const __vite__mapDeps = (
    i,
    m = __vite__mapDeps,
    d = m.f ||
        (m.f = [
            'assets/index-YUhooQEv.js',
            'assets/index-Du4onkjd.js',
            'assets/lottie-4koyQiv_.js',
            'assets/index-DISLUmAd.js',
            'assets/Cube-found-ChOUz20m.js',
            'assets/index-CuHcGG1j.js',
        ])
) => i.map((i) => d[i]);
(function () {
    const e = document.createElement('link').relList;
    if (e && e.supports && e.supports('modulepreload')) return;
    for (const r of document.querySelectorAll('link[rel="modulepreload"]'))
        n(r);
    new MutationObserver((r) => {
        for (const s of r)
            if (s.type === 'childList')
                for (const a of s.addedNodes)
                    a.tagName === 'LINK' && a.rel === 'modulepreload' && n(a);
    }).observe(document, { childList: !0, subtree: !0 });
    function t(r) {
        const s = {};
        return (
            r.integrity && (s.integrity = r.integrity),
            r.referrerPolicy && (s.referrerPolicy = r.referrerPolicy),
            r.crossOrigin === 'use-credentials'
                ? (s.credentials = 'include')
                : r.crossOrigin === 'anonymous'
                  ? (s.credentials = 'omit')
                  : (s.credentials = 'same-origin'),
            s
        );
    }
    function n(r) {
        if (r.ep) return;
        r.ep = !0;
        const s = t(r);
        fetch(r.href, s);
    }
})();
var $W =
    typeof globalThis < 'u'
        ? globalThis
        : typeof window < 'u'
          ? window
          : typeof global < 'u'
            ? global
            : typeof self < 'u'
              ? self
              : {};
function k_(i) {
    return i &&
        i.__esModule &&
        Object.prototype.hasOwnProperty.call(i, 'default')
        ? i.default
        : i;
}
var S0 = { exports: {} },
    Md = {},
    w0 = { exports: {} },
    Jt = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Qw;
function CL() {
    if (Qw) return Jt;
    Qw = 1;
    var i = Symbol.for('react.element'),
        e = Symbol.for('react.portal'),
        t = Symbol.for('react.fragment'),
        n = Symbol.for('react.strict_mode'),
        r = Symbol.for('react.profiler'),
        s = Symbol.for('react.provider'),
        a = Symbol.for('react.context'),
        l = Symbol.for('react.forward_ref'),
        c = Symbol.for('react.suspense'),
        d = Symbol.for('react.memo'),
        p = Symbol.for('react.lazy'),
        g = Symbol.iterator;
    function y(G) {
        return G === null || typeof G != 'object'
            ? null
            : ((G = (g && G[g]) || G['@@iterator']),
              typeof G == 'function' ? G : null);
    }
    var v = {
            isMounted: function () {
                return !1;
            },
            enqueueForceUpdate: function () {},
            enqueueReplaceState: function () {},
            enqueueSetState: function () {},
        },
        S = Object.assign,
        T = {};
    function M(G, ae, Oe) {
        (this.props = G),
            (this.context = ae),
            (this.refs = T),
            (this.updater = Oe || v);
    }
    (M.prototype.isReactComponent = {}),
        (M.prototype.setState = function (G, ae) {
            if (typeof G != 'object' && typeof G != 'function' && G != null)
                throw Error(
                    'setState(...): takes an object of state variables to update or a function which returns an object of state variables.'
                );
            this.updater.enqueueSetState(this, G, ae, 'setState');
        }),
        (M.prototype.forceUpdate = function (G) {
            this.updater.enqueueForceUpdate(this, G, 'forceUpdate');
        });
    function w() {}
    w.prototype = M.prototype;
    function b(G, ae, Oe) {
        (this.props = G),
            (this.context = ae),
            (this.refs = T),
            (this.updater = Oe || v);
    }
    var C = (b.prototype = new w());
    (C.constructor = b), S(C, M.prototype), (C.isPureReactComponent = !0);
    var L = Array.isArray,
        F = Object.prototype.hasOwnProperty,
        N = { current: null },
        B = { key: !0, ref: !0, __self: !0, __source: !0 };
    function z(G, ae, Oe) {
        var fe,
            we = {},
            Pe = null,
            Re = null;
        if (ae != null)
            for (fe in (ae.ref !== void 0 && (Re = ae.ref),
            ae.key !== void 0 && (Pe = '' + ae.key),
            ae))
                F.call(ae, fe) && !B.hasOwnProperty(fe) && (we[fe] = ae[fe]);
        var Ye = arguments.length - 2;
        if (Ye === 1) we.children = Oe;
        else if (1 < Ye) {
            for (var lt = Array(Ye), dt = 0; dt < Ye; dt++)
                lt[dt] = arguments[dt + 2];
            we.children = lt;
        }
        if (G && G.defaultProps)
            for (fe in ((Ye = G.defaultProps), Ye))
                we[fe] === void 0 && (we[fe] = Ye[fe]);
        return {
            $$typeof: i,
            type: G,
            key: Pe,
            ref: Re,
            props: we,
            _owner: N.current,
        };
    }
    function U(G, ae) {
        return {
            $$typeof: i,
            type: G.type,
            key: ae,
            ref: G.ref,
            props: G.props,
            _owner: G._owner,
        };
    }
    function D(G) {
        return typeof G == 'object' && G !== null && G.$$typeof === i;
    }
    function H(G) {
        var ae = { '=': '=0', ':': '=2' };
        return (
            '$' +
            G.replace(/[=:]/g, function (Oe) {
                return ae[Oe];
            })
        );
    }
    var ie = /\/+/g;
    function ee(G, ae) {
        return typeof G == 'object' && G !== null && G.key != null
            ? H('' + G.key)
            : ae.toString(36);
    }
    function ue(G, ae, Oe, fe, we) {
        var Pe = typeof G;
        (Pe === 'undefined' || Pe === 'boolean') && (G = null);
        var Re = !1;
        if (G === null) Re = !0;
        else
            switch (Pe) {
                case 'string':
                case 'number':
                    Re = !0;
                    break;
                case 'object':
                    switch (G.$$typeof) {
                        case i:
                        case e:
                            Re = !0;
                    }
            }
        if (Re)
            return (
                (Re = G),
                (we = we(Re)),
                (G = fe === '' ? '.' + ee(Re, 0) : fe),
                L(we)
                    ? ((Oe = ''),
                      G != null && (Oe = G.replace(ie, '$&/') + '/'),
                      ue(we, ae, Oe, '', function (dt) {
                          return dt;
                      }))
                    : we != null &&
                      (D(we) &&
                          (we = U(
                              we,
                              Oe +
                                  (!we.key || (Re && Re.key === we.key)
                                      ? ''
                                      : ('' + we.key).replace(ie, '$&/') +
                                        '/') +
                                  G
                          )),
                      ae.push(we)),
                1
            );
        if (((Re = 0), (fe = fe === '' ? '.' : fe + ':'), L(G)))
            for (var Ye = 0; Ye < G.length; Ye++) {
                Pe = G[Ye];
                var lt = fe + ee(Pe, Ye);
                Re += ue(Pe, ae, Oe, lt, we);
            }
        else if (((lt = y(G)), typeof lt == 'function'))
            for (G = lt.call(G), Ye = 0; !(Pe = G.next()).done; )
                (Pe = Pe.value),
                    (lt = fe + ee(Pe, Ye++)),
                    (Re += ue(Pe, ae, Oe, lt, we));
        else if (Pe === 'object')
            throw (
                ((ae = String(G)),
                Error(
                    'Objects are not valid as a React child (found: ' +
                        (ae === '[object Object]'
                            ? 'object with keys {' +
                              Object.keys(G).join(', ') +
                              '}'
                            : ae) +
                        '). If you meant to render a collection of children, use an array instead.'
                ))
            );
        return Re;
    }
    function Se(G, ae, Oe) {
        if (G == null) return G;
        var fe = [],
            we = 0;
        return (
            ue(G, fe, '', '', function (Pe) {
                return ae.call(Oe, Pe, we++);
            }),
            fe
        );
    }
    function ce(G) {
        if (G._status === -1) {
            var ae = G._result;
            (ae = ae()),
                ae.then(
                    function (Oe) {
                        (G._status === 0 || G._status === -1) &&
                            ((G._status = 1), (G._result = Oe));
                    },
                    function (Oe) {
                        (G._status === 0 || G._status === -1) &&
                            ((G._status = 2), (G._result = Oe));
                    }
                ),
                G._status === -1 && ((G._status = 0), (G._result = ae));
        }
        if (G._status === 1) return G._result.default;
        throw G._result;
    }
    var me = { current: null },
        X = { transition: null },
        oe = {
            ReactCurrentDispatcher: me,
            ReactCurrentBatchConfig: X,
            ReactCurrentOwner: N,
        };
    function Q() {
        throw Error('act(...) is not supported in production builds of React.');
    }
    return (
        (Jt.Children = {
            map: Se,
            forEach: function (G, ae, Oe) {
                Se(
                    G,
                    function () {
                        ae.apply(this, arguments);
                    },
                    Oe
                );
            },
            count: function (G) {
                var ae = 0;
                return (
                    Se(G, function () {
                        ae++;
                    }),
                    ae
                );
            },
            toArray: function (G) {
                return (
                    Se(G, function (ae) {
                        return ae;
                    }) || []
                );
            },
            only: function (G) {
                if (!D(G))
                    throw Error(
                        'React.Children.only expected to receive a single React element child.'
                    );
                return G;
            },
        }),
        (Jt.Component = M),
        (Jt.Fragment = t),
        (Jt.Profiler = r),
        (Jt.PureComponent = b),
        (Jt.StrictMode = n),
        (Jt.Suspense = c),
        (Jt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = oe),
        (Jt.act = Q),
        (Jt.cloneElement = function (G, ae, Oe) {
            if (G == null)
                throw Error(
                    'React.cloneElement(...): The argument must be a React element, but you passed ' +
                        G +
                        '.'
                );
            var fe = S({}, G.props),
                we = G.key,
                Pe = G.ref,
                Re = G._owner;
            if (ae != null) {
                if (
                    (ae.ref !== void 0 && ((Pe = ae.ref), (Re = N.current)),
                    ae.key !== void 0 && (we = '' + ae.key),
                    G.type && G.type.defaultProps)
                )
                    var Ye = G.type.defaultProps;
                for (lt in ae)
                    F.call(ae, lt) &&
                        !B.hasOwnProperty(lt) &&
                        (fe[lt] =
                            ae[lt] === void 0 && Ye !== void 0
                                ? Ye[lt]
                                : ae[lt]);
            }
            var lt = arguments.length - 2;
            if (lt === 1) fe.children = Oe;
            else if (1 < lt) {
                Ye = Array(lt);
                for (var dt = 0; dt < lt; dt++) Ye[dt] = arguments[dt + 2];
                fe.children = Ye;
            }
            return {
                $$typeof: i,
                type: G.type,
                key: we,
                ref: Pe,
                props: fe,
                _owner: Re,
            };
        }),
        (Jt.createContext = function (G) {
            return (
                (G = {
                    $$typeof: a,
                    _currentValue: G,
                    _currentValue2: G,
                    _threadCount: 0,
                    Provider: null,
                    Consumer: null,
                    _defaultValue: null,
                    _globalName: null,
                }),
                (G.Provider = { $$typeof: s, _context: G }),
                (G.Consumer = G)
            );
        }),
        (Jt.createElement = z),
        (Jt.createFactory = function (G) {
            var ae = z.bind(null, G);
            return (ae.type = G), ae;
        }),
        (Jt.createRef = function () {
            return { current: null };
        }),
        (Jt.forwardRef = function (G) {
            return { $$typeof: l, render: G };
        }),
        (Jt.isValidElement = D),
        (Jt.lazy = function (G) {
            return {
                $$typeof: p,
                _payload: { _status: -1, _result: G },
                _init: ce,
            };
        }),
        (Jt.memo = function (G, ae) {
            return { $$typeof: d, type: G, compare: ae === void 0 ? null : ae };
        }),
        (Jt.startTransition = function (G) {
            var ae = X.transition;
            X.transition = {};
            try {
                G();
            } finally {
                X.transition = ae;
            }
        }),
        (Jt.unstable_act = Q),
        (Jt.useCallback = function (G, ae) {
            return me.current.useCallback(G, ae);
        }),
        (Jt.useContext = function (G) {
            return me.current.useContext(G);
        }),
        (Jt.useDebugValue = function () {}),
        (Jt.useDeferredValue = function (G) {
            return me.current.useDeferredValue(G);
        }),
        (Jt.useEffect = function (G, ae) {
            return me.current.useEffect(G, ae);
        }),
        (Jt.useId = function () {
            return me.current.useId();
        }),
        (Jt.useImperativeHandle = function (G, ae, Oe) {
            return me.current.useImperativeHandle(G, ae, Oe);
        }),
        (Jt.useInsertionEffect = function (G, ae) {
            return me.current.useInsertionEffect(G, ae);
        }),
        (Jt.useLayoutEffect = function (G, ae) {
            return me.current.useLayoutEffect(G, ae);
        }),
        (Jt.useMemo = function (G, ae) {
            return me.current.useMemo(G, ae);
        }),
        (Jt.useReducer = function (G, ae, Oe) {
            return me.current.useReducer(G, ae, Oe);
        }),
        (Jt.useRef = function (G) {
            return me.current.useRef(G);
        }),
        (Jt.useState = function (G) {
            return me.current.useState(G);
        }),
        (Jt.useSyncExternalStore = function (G, ae, Oe) {
            return me.current.useSyncExternalStore(G, ae, Oe);
        }),
        (Jt.useTransition = function () {
            return me.current.useTransition();
        }),
        (Jt.version = '18.3.1'),
        Jt
    );
}
var eM;
function Qy() {
    return eM || ((eM = 1), (w0.exports = CL())), w0.exports;
}
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var tM;
function RL() {
    if (tM) return Md;
    tM = 1;
    var i = Qy(),
        e = Symbol.for('react.element'),
        t = Symbol.for('react.fragment'),
        n = Object.prototype.hasOwnProperty,
        r =
            i.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
                .ReactCurrentOwner,
        s = { key: !0, ref: !0, __self: !0, __source: !0 };
    function a(l, c, d) {
        var p,
            g = {},
            y = null,
            v = null;
        d !== void 0 && (y = '' + d),
            c.key !== void 0 && (y = '' + c.key),
            c.ref !== void 0 && (v = c.ref);
        for (p in c) n.call(c, p) && !s.hasOwnProperty(p) && (g[p] = c[p]);
        if (l && l.defaultProps)
            for (p in ((c = l.defaultProps), c))
                g[p] === void 0 && (g[p] = c[p]);
        return {
            $$typeof: e,
            type: l,
            key: y,
            ref: v,
            props: g,
            _owner: r.current,
        };
    }
    return (Md.Fragment = t), (Md.jsx = a), (Md.jsxs = a), Md;
}
var nM;
function bL() {
    return nM || ((nM = 1), (S0.exports = RL())), S0.exports;
}
var rt = bL(),
    K = Qy();
const YW = k_(K);
var Jm = {},
    M0 = { exports: {} },
    Fr = {},
    E0 = { exports: {} },
    T0 = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var iM;
function PL() {
    return (
        iM ||
            ((iM = 1),
            (function (i) {
                function e(X, oe) {
                    var Q = X.length;
                    X.push(oe);
                    e: for (; 0 < Q; ) {
                        var G = (Q - 1) >>> 1,
                            ae = X[G];
                        if (0 < r(ae, oe)) (X[G] = oe), (X[Q] = ae), (Q = G);
                        else break e;
                    }
                }
                function t(X) {
                    return X.length === 0 ? null : X[0];
                }
                function n(X) {
                    if (X.length === 0) return null;
                    var oe = X[0],
                        Q = X.pop();
                    if (Q !== oe) {
                        X[0] = Q;
                        e: for (
                            var G = 0, ae = X.length, Oe = ae >>> 1;
                            G < Oe;

                        ) {
                            var fe = 2 * (G + 1) - 1,
                                we = X[fe],
                                Pe = fe + 1,
                                Re = X[Pe];
                            if (0 > r(we, Q))
                                Pe < ae && 0 > r(Re, we)
                                    ? ((X[G] = Re), (X[Pe] = Q), (G = Pe))
                                    : ((X[G] = we), (X[fe] = Q), (G = fe));
                            else if (Pe < ae && 0 > r(Re, Q))
                                (X[G] = Re), (X[Pe] = Q), (G = Pe);
                            else break e;
                        }
                    }
                    return oe;
                }
                function r(X, oe) {
                    var Q = X.sortIndex - oe.sortIndex;
                    return Q !== 0 ? Q : X.id - oe.id;
                }
                if (
                    typeof performance == 'object' &&
                    typeof performance.now == 'function'
                ) {
                    var s = performance;
                    i.unstable_now = function () {
                        return s.now();
                    };
                } else {
                    var a = Date,
                        l = a.now();
                    i.unstable_now = function () {
                        return a.now() - l;
                    };
                }
                var c = [],
                    d = [],
                    p = 1,
                    g = null,
                    y = 3,
                    v = !1,
                    S = !1,
                    T = !1,
                    M = typeof setTimeout == 'function' ? setTimeout : null,
                    w = typeof clearTimeout == 'function' ? clearTimeout : null,
                    b = typeof setImmediate < 'u' ? setImmediate : null;
                typeof navigator < 'u' &&
                    navigator.scheduling !== void 0 &&
                    navigator.scheduling.isInputPending !== void 0 &&
                    navigator.scheduling.isInputPending.bind(
                        navigator.scheduling
                    );
                function C(X) {
                    for (var oe = t(d); oe !== null; ) {
                        if (oe.callback === null) n(d);
                        else if (oe.startTime <= X)
                            n(d), (oe.sortIndex = oe.expirationTime), e(c, oe);
                        else break;
                        oe = t(d);
                    }
                }
                function L(X) {
                    if (((T = !1), C(X), !S))
                        if (t(c) !== null) (S = !0), ce(F);
                        else {
                            var oe = t(d);
                            oe !== null && me(L, oe.startTime - X);
                        }
                }
                function F(X, oe) {
                    (S = !1), T && ((T = !1), w(z), (z = -1)), (v = !0);
                    var Q = y;
                    try {
                        for (
                            C(oe), g = t(c);
                            g !== null &&
                            (!(g.expirationTime > oe) || (X && !H()));

                        ) {
                            var G = g.callback;
                            if (typeof G == 'function') {
                                (g.callback = null), (y = g.priorityLevel);
                                var ae = G(g.expirationTime <= oe);
                                (oe = i.unstable_now()),
                                    typeof ae == 'function'
                                        ? (g.callback = ae)
                                        : g === t(c) && n(c),
                                    C(oe);
                            } else n(c);
                            g = t(c);
                        }
                        if (g !== null) var Oe = !0;
                        else {
                            var fe = t(d);
                            fe !== null && me(L, fe.startTime - oe), (Oe = !1);
                        }
                        return Oe;
                    } finally {
                        (g = null), (y = Q), (v = !1);
                    }
                }
                var N = !1,
                    B = null,
                    z = -1,
                    U = 5,
                    D = -1;
                function H() {
                    return !(i.unstable_now() - D < U);
                }
                function ie() {
                    if (B !== null) {
                        var X = i.unstable_now();
                        D = X;
                        var oe = !0;
                        try {
                            oe = B(!0, X);
                        } finally {
                            oe ? ee() : ((N = !1), (B = null));
                        }
                    } else N = !1;
                }
                var ee;
                if (typeof b == 'function')
                    ee = function () {
                        b(ie);
                    };
                else if (typeof MessageChannel < 'u') {
                    var ue = new MessageChannel(),
                        Se = ue.port2;
                    (ue.port1.onmessage = ie),
                        (ee = function () {
                            Se.postMessage(null);
                        });
                } else
                    ee = function () {
                        M(ie, 0);
                    };
                function ce(X) {
                    (B = X), N || ((N = !0), ee());
                }
                function me(X, oe) {
                    z = M(function () {
                        X(i.unstable_now());
                    }, oe);
                }
                (i.unstable_IdlePriority = 5),
                    (i.unstable_ImmediatePriority = 1),
                    (i.unstable_LowPriority = 4),
                    (i.unstable_NormalPriority = 3),
                    (i.unstable_Profiling = null),
                    (i.unstable_UserBlockingPriority = 2),
                    (i.unstable_cancelCallback = function (X) {
                        X.callback = null;
                    }),
                    (i.unstable_continueExecution = function () {
                        S || v || ((S = !0), ce(F));
                    }),
                    (i.unstable_forceFrameRate = function (X) {
                        0 > X || 125 < X
                            ? console.error(
                                  'forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported'
                              )
                            : (U = 0 < X ? Math.floor(1e3 / X) : 5);
                    }),
                    (i.unstable_getCurrentPriorityLevel = function () {
                        return y;
                    }),
                    (i.unstable_getFirstCallbackNode = function () {
                        return t(c);
                    }),
                    (i.unstable_next = function (X) {
                        switch (y) {
                            case 1:
                            case 2:
                            case 3:
                                var oe = 3;
                                break;
                            default:
                                oe = y;
                        }
                        var Q = y;
                        y = oe;
                        try {
                            return X();
                        } finally {
                            y = Q;
                        }
                    }),
                    (i.unstable_pauseExecution = function () {}),
                    (i.unstable_requestPaint = function () {}),
                    (i.unstable_runWithPriority = function (X, oe) {
                        switch (X) {
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                                break;
                            default:
                                X = 3;
                        }
                        var Q = y;
                        y = X;
                        try {
                            return oe();
                        } finally {
                            y = Q;
                        }
                    }),
                    (i.unstable_scheduleCallback = function (X, oe, Q) {
                        var G = i.unstable_now();
                        switch (
                            (typeof Q == 'object' && Q !== null
                                ? ((Q = Q.delay),
                                  (Q =
                                      typeof Q == 'number' && 0 < Q
                                          ? G + Q
                                          : G))
                                : (Q = G),
                            X)
                        ) {
                            case 1:
                                var ae = -1;
                                break;
                            case 2:
                                ae = 250;
                                break;
                            case 5:
                                ae = 1073741823;
                                break;
                            case 4:
                                ae = 1e4;
                                break;
                            default:
                                ae = 5e3;
                        }
                        return (
                            (ae = Q + ae),
                            (X = {
                                id: p++,
                                callback: oe,
                                priorityLevel: X,
                                startTime: Q,
                                expirationTime: ae,
                                sortIndex: -1,
                            }),
                            Q > G
                                ? ((X.sortIndex = Q),
                                  e(d, X),
                                  t(c) === null &&
                                      X === t(d) &&
                                      (T ? (w(z), (z = -1)) : (T = !0),
                                      me(L, Q - G)))
                                : ((X.sortIndex = ae),
                                  e(c, X),
                                  S || v || ((S = !0), ce(F))),
                            X
                        );
                    }),
                    (i.unstable_shouldYield = H),
                    (i.unstable_wrapCallback = function (X) {
                        var oe = y;
                        return function () {
                            var Q = y;
                            y = oe;
                            try {
                                return X.apply(this, arguments);
                            } finally {
                                y = Q;
                            }
                        };
                    });
            })(T0)),
        T0
    );
}
var rM;
function LL() {
    return rM || ((rM = 1), (E0.exports = PL())), E0.exports;
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var sM;
function IL() {
    if (sM) return Fr;
    sM = 1;
    var i = Qy(),
        e = LL();
    function t(o) {
        for (
            var u =
                    'https://reactjs.org/docs/error-decoder.html?invariant=' +
                    o,
                m = 1;
            m < arguments.length;
            m++
        )
            u += '&args[]=' + encodeURIComponent(arguments[m]);
        return (
            'Minified React error #' +
            o +
            '; visit ' +
            u +
            ' for the full message or use the non-minified dev environment for full errors and additional helpful warnings.'
        );
    }
    var n = new Set(),
        r = {};
    function s(o, u) {
        a(o, u), a(o + 'Capture', u);
    }
    function a(o, u) {
        for (r[o] = u, o = 0; o < u.length; o++) n.add(u[o]);
    }
    var l = !(
            typeof window > 'u' ||
            typeof window.document > 'u' ||
            typeof window.document.createElement > 'u'
        ),
        c = Object.prototype.hasOwnProperty,
        d =
            /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
        p = {},
        g = {};
    function y(o) {
        return c.call(g, o)
            ? !0
            : c.call(p, o)
              ? !1
              : d.test(o)
                ? (g[o] = !0)
                : ((p[o] = !0), !1);
    }
    function v(o, u, m, _) {
        if (m !== null && m.type === 0) return !1;
        switch (typeof u) {
            case 'function':
            case 'symbol':
                return !0;
            case 'boolean':
                return _
                    ? !1
                    : m !== null
                      ? !m.acceptsBooleans
                      : ((o = o.toLowerCase().slice(0, 5)),
                        o !== 'data-' && o !== 'aria-');
            default:
                return !1;
        }
    }
    function S(o, u, m, _) {
        if (u === null || typeof u > 'u' || v(o, u, m, _)) return !0;
        if (_) return !1;
        if (m !== null)
            switch (m.type) {
                case 3:
                    return !u;
                case 4:
                    return u === !1;
                case 5:
                    return isNaN(u);
                case 6:
                    return isNaN(u) || 1 > u;
            }
        return !1;
    }
    function T(o, u, m, _, A, P, O) {
        (this.acceptsBooleans = u === 2 || u === 3 || u === 4),
            (this.attributeName = _),
            (this.attributeNamespace = A),
            (this.mustUseProperty = m),
            (this.propertyName = o),
            (this.type = u),
            (this.sanitizeURL = P),
            (this.removeEmptyString = O);
    }
    var M = {};
    'children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style'
        .split(' ')
        .forEach(function (o) {
            M[o] = new T(o, 0, !1, o, null, !1, !1);
        }),
        [
            ['acceptCharset', 'accept-charset'],
            ['className', 'class'],
            ['htmlFor', 'for'],
            ['httpEquiv', 'http-equiv'],
        ].forEach(function (o) {
            var u = o[0];
            M[u] = new T(u, 1, !1, o[1], null, !1, !1);
        }),
        ['contentEditable', 'draggable', 'spellCheck', 'value'].forEach(
            function (o) {
                M[o] = new T(o, 2, !1, o.toLowerCase(), null, !1, !1);
            }
        ),
        [
            'autoReverse',
            'externalResourcesRequired',
            'focusable',
            'preserveAlpha',
        ].forEach(function (o) {
            M[o] = new T(o, 2, !1, o, null, !1, !1);
        }),
        'allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope'
            .split(' ')
            .forEach(function (o) {
                M[o] = new T(o, 3, !1, o.toLowerCase(), null, !1, !1);
            }),
        ['checked', 'multiple', 'muted', 'selected'].forEach(function (o) {
            M[o] = new T(o, 3, !0, o, null, !1, !1);
        }),
        ['capture', 'download'].forEach(function (o) {
            M[o] = new T(o, 4, !1, o, null, !1, !1);
        }),
        ['cols', 'rows', 'size', 'span'].forEach(function (o) {
            M[o] = new T(o, 6, !1, o, null, !1, !1);
        }),
        ['rowSpan', 'start'].forEach(function (o) {
            M[o] = new T(o, 5, !1, o.toLowerCase(), null, !1, !1);
        });
    var w = /[\-:]([a-z])/g;
    function b(o) {
        return o[1].toUpperCase();
    }
    'accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height'
        .split(' ')
        .forEach(function (o) {
            var u = o.replace(w, b);
            M[u] = new T(u, 1, !1, o, null, !1, !1);
        }),
        'xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type'
            .split(' ')
            .forEach(function (o) {
                var u = o.replace(w, b);
                M[u] = new T(
                    u,
                    1,
                    !1,
                    o,
                    'http://www.w3.org/1999/xlink',
                    !1,
                    !1
                );
            }),
        ['xml:base', 'xml:lang', 'xml:space'].forEach(function (o) {
            var u = o.replace(w, b);
            M[u] = new T(
                u,
                1,
                !1,
                o,
                'http://www.w3.org/XML/1998/namespace',
                !1,
                !1
            );
        }),
        ['tabIndex', 'crossOrigin'].forEach(function (o) {
            M[o] = new T(o, 1, !1, o.toLowerCase(), null, !1, !1);
        }),
        (M.xlinkHref = new T(
            'xlinkHref',
            1,
            !1,
            'xlink:href',
            'http://www.w3.org/1999/xlink',
            !0,
            !1
        )),
        ['src', 'href', 'action', 'formAction'].forEach(function (o) {
            M[o] = new T(o, 1, !1, o.toLowerCase(), null, !0, !0);
        });
    function C(o, u, m, _) {
        var A = M.hasOwnProperty(u) ? M[u] : null;
        (A !== null
            ? A.type !== 0
            : _ ||
              !(2 < u.length) ||
              (u[0] !== 'o' && u[0] !== 'O') ||
              (u[1] !== 'n' && u[1] !== 'N')) &&
            (S(u, m, A, _) && (m = null),
            _ || A === null
                ? y(u) &&
                  (m === null
                      ? o.removeAttribute(u)
                      : o.setAttribute(u, '' + m))
                : A.mustUseProperty
                  ? (o[A.propertyName] =
                        m === null ? (A.type === 3 ? !1 : '') : m)
                  : ((u = A.attributeName),
                    (_ = A.attributeNamespace),
                    m === null
                        ? o.removeAttribute(u)
                        : ((A = A.type),
                          (m = A === 3 || (A === 4 && m === !0) ? '' : '' + m),
                          _
                              ? o.setAttributeNS(_, u, m)
                              : o.setAttribute(u, m))));
    }
    var L = i.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
        F = Symbol.for('react.element'),
        N = Symbol.for('react.portal'),
        B = Symbol.for('react.fragment'),
        z = Symbol.for('react.strict_mode'),
        U = Symbol.for('react.profiler'),
        D = Symbol.for('react.provider'),
        H = Symbol.for('react.context'),
        ie = Symbol.for('react.forward_ref'),
        ee = Symbol.for('react.suspense'),
        ue = Symbol.for('react.suspense_list'),
        Se = Symbol.for('react.memo'),
        ce = Symbol.for('react.lazy'),
        me = Symbol.for('react.offscreen'),
        X = Symbol.iterator;
    function oe(o) {
        return o === null || typeof o != 'object'
            ? null
            : ((o = (X && o[X]) || o['@@iterator']),
              typeof o == 'function' ? o : null);
    }
    var Q = Object.assign,
        G;
    function ae(o) {
        if (G === void 0)
            try {
                throw Error();
            } catch (m) {
                var u = m.stack.trim().match(/\n( *(at )?)/);
                G = (u && u[1]) || '';
            }
        return (
            `
` +
            G +
            o
        );
    }
    var Oe = !1;
    function fe(o, u) {
        if (!o || Oe) return '';
        Oe = !0;
        var m = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
            if (u)
                if (
                    ((u = function () {
                        throw Error();
                    }),
                    Object.defineProperty(u.prototype, 'props', {
                        set: function () {
                            throw Error();
                        },
                    }),
                    typeof Reflect == 'object' && Reflect.construct)
                ) {
                    try {
                        Reflect.construct(u, []);
                    } catch (xe) {
                        var _ = xe;
                    }
                    Reflect.construct(o, [], u);
                } else {
                    try {
                        u.call();
                    } catch (xe) {
                        _ = xe;
                    }
                    o.call(u.prototype);
                }
            else {
                try {
                    throw Error();
                } catch (xe) {
                    _ = xe;
                }
                o();
            }
        } catch (xe) {
            if (xe && _ && typeof xe.stack == 'string') {
                for (
                    var A = xe.stack.split(`
`),
                        P = _.stack.split(`
`),
                        O = A.length - 1,
                        Y = P.length - 1;
                    1 <= O && 0 <= Y && A[O] !== P[Y];

                )
                    Y--;
                for (; 1 <= O && 0 <= Y; O--, Y--)
                    if (A[O] !== P[Y]) {
                        if (O !== 1 || Y !== 1)
                            do
                                if ((O--, Y--, 0 > Y || A[O] !== P[Y])) {
                                    var Z =
                                        `
` + A[O].replace(' at new ', ' at ');
                                    return (
                                        o.displayName &&
                                            Z.includes('<anonymous>') &&
                                            (Z = Z.replace(
                                                '<anonymous>',
                                                o.displayName
                                            )),
                                        Z
                                    );
                                }
                            while (1 <= O && 0 <= Y);
                        break;
                    }
            }
        } finally {
            (Oe = !1), (Error.prepareStackTrace = m);
        }
        return (o = o ? o.displayName || o.name : '') ? ae(o) : '';
    }
    function we(o) {
        switch (o.tag) {
            case 5:
                return ae(o.type);
            case 16:
                return ae('Lazy');
            case 13:
                return ae('Suspense');
            case 19:
                return ae('SuspenseList');
            case 0:
            case 2:
            case 15:
                return (o = fe(o.type, !1)), o;
            case 11:
                return (o = fe(o.type.render, !1)), o;
            case 1:
                return (o = fe(o.type, !0)), o;
            default:
                return '';
        }
    }
    function Pe(o) {
        if (o == null) return null;
        if (typeof o == 'function') return o.displayName || o.name || null;
        if (typeof o == 'string') return o;
        switch (o) {
            case B:
                return 'Fragment';
            case N:
                return 'Portal';
            case U:
                return 'Profiler';
            case z:
                return 'StrictMode';
            case ee:
                return 'Suspense';
            case ue:
                return 'SuspenseList';
        }
        if (typeof o == 'object')
            switch (o.$$typeof) {
                case H:
                    return (o.displayName || 'Context') + '.Consumer';
                case D:
                    return (o._context.displayName || 'Context') + '.Provider';
                case ie:
                    var u = o.render;
                    return (
                        (o = o.displayName),
                        o ||
                            ((o = u.displayName || u.name || ''),
                            (o =
                                o !== ''
                                    ? 'ForwardRef(' + o + ')'
                                    : 'ForwardRef')),
                        o
                    );
                case Se:
                    return (
                        (u = o.displayName || null),
                        u !== null ? u : Pe(o.type) || 'Memo'
                    );
                case ce:
                    (u = o._payload), (o = o._init);
                    try {
                        return Pe(o(u));
                    } catch {}
            }
        return null;
    }
    function Re(o) {
        var u = o.type;
        switch (o.tag) {
            case 24:
                return 'Cache';
            case 9:
                return (u.displayName || 'Context') + '.Consumer';
            case 10:
                return (u._context.displayName || 'Context') + '.Provider';
            case 18:
                return 'DehydratedFragment';
            case 11:
                return (
                    (o = u.render),
                    (o = o.displayName || o.name || ''),
                    u.displayName ||
                        (o !== '' ? 'ForwardRef(' + o + ')' : 'ForwardRef')
                );
            case 7:
                return 'Fragment';
            case 5:
                return u;
            case 4:
                return 'Portal';
            case 3:
                return 'Root';
            case 6:
                return 'Text';
            case 16:
                return Pe(u);
            case 8:
                return u === z ? 'StrictMode' : 'Mode';
            case 22:
                return 'Offscreen';
            case 12:
                return 'Profiler';
            case 21:
                return 'Scope';
            case 13:
                return 'Suspense';
            case 19:
                return 'SuspenseList';
            case 25:
                return 'TracingMarker';
            case 1:
            case 0:
            case 17:
            case 2:
            case 14:
            case 15:
                if (typeof u == 'function')
                    return u.displayName || u.name || null;
                if (typeof u == 'string') return u;
        }
        return null;
    }
    function Ye(o) {
        switch (typeof o) {
            case 'boolean':
            case 'number':
            case 'string':
            case 'undefined':
                return o;
            case 'object':
                return o;
            default:
                return '';
        }
    }
    function lt(o) {
        var u = o.type;
        return (
            (o = o.nodeName) &&
            o.toLowerCase() === 'input' &&
            (u === 'checkbox' || u === 'radio')
        );
    }
    function dt(o) {
        var u = lt(o) ? 'checked' : 'value',
            m = Object.getOwnPropertyDescriptor(o.constructor.prototype, u),
            _ = '' + o[u];
        if (
            !o.hasOwnProperty(u) &&
            typeof m < 'u' &&
            typeof m.get == 'function' &&
            typeof m.set == 'function'
        ) {
            var A = m.get,
                P = m.set;
            return (
                Object.defineProperty(o, u, {
                    configurable: !0,
                    get: function () {
                        return A.call(this);
                    },
                    set: function (O) {
                        (_ = '' + O), P.call(this, O);
                    },
                }),
                Object.defineProperty(o, u, { enumerable: m.enumerable }),
                {
                    getValue: function () {
                        return _;
                    },
                    setValue: function (O) {
                        _ = '' + O;
                    },
                    stopTracking: function () {
                        (o._valueTracker = null), delete o[u];
                    },
                }
            );
        }
    }
    function Lt(o) {
        o._valueTracker || (o._valueTracker = dt(o));
    }
    function W(o) {
        if (!o) return !1;
        var u = o._valueTracker;
        if (!u) return !0;
        var m = u.getValue(),
            _ = '';
        return (
            o && (_ = lt(o) ? (o.checked ? 'true' : 'false') : o.value),
            (o = _),
            o !== m ? (u.setValue(o), !0) : !1
        );
    }
    function Ie(o) {
        if (
            ((o = o || (typeof document < 'u' ? document : void 0)),
            typeof o > 'u')
        )
            return null;
        try {
            return o.activeElement || o.body;
        } catch {
            return o.body;
        }
    }
    function ke(o, u) {
        var m = u.checked;
        return Q({}, u, {
            defaultChecked: void 0,
            defaultValue: void 0,
            value: void 0,
            checked: m ?? o._wrapperState.initialChecked,
        });
    }
    function Ke(o, u) {
        var m = u.defaultValue == null ? '' : u.defaultValue,
            _ = u.checked != null ? u.checked : u.defaultChecked;
        (m = Ye(u.value != null ? u.value : m)),
            (o._wrapperState = {
                initialChecked: _,
                initialValue: m,
                controlled:
                    u.type === 'checkbox' || u.type === 'radio'
                        ? u.checked != null
                        : u.value != null,
            });
    }
    function Ee(o, u) {
        (u = u.checked), u != null && C(o, 'checked', u, !1);
    }
    function St(o, u) {
        Ee(o, u);
        var m = Ye(u.value),
            _ = u.type;
        if (m != null)
            _ === 'number'
                ? ((m === 0 && o.value === '') || o.value != m) &&
                  (o.value = '' + m)
                : o.value !== '' + m && (o.value = '' + m);
        else if (_ === 'submit' || _ === 'reset') {
            o.removeAttribute('value');
            return;
        }
        u.hasOwnProperty('value')
            ? ot(o, u.type, m)
            : u.hasOwnProperty('defaultValue') &&
              ot(o, u.type, Ye(u.defaultValue)),
            u.checked == null &&
                u.defaultChecked != null &&
                (o.defaultChecked = !!u.defaultChecked);
    }
    function Ze(o, u, m) {
        if (u.hasOwnProperty('value') || u.hasOwnProperty('defaultValue')) {
            var _ = u.type;
            if (
                !(
                    (_ !== 'submit' && _ !== 'reset') ||
                    (u.value !== void 0 && u.value !== null)
                )
            )
                return;
            (u = '' + o._wrapperState.initialValue),
                m || u === o.value || (o.value = u),
                (o.defaultValue = u);
        }
        (m = o.name),
            m !== '' && (o.name = ''),
            (o.defaultChecked = !!o._wrapperState.initialChecked),
            m !== '' && (o.name = m);
    }
    function ot(o, u, m) {
        (u !== 'number' || Ie(o.ownerDocument) !== o) &&
            (m == null
                ? (o.defaultValue = '' + o._wrapperState.initialValue)
                : o.defaultValue !== '' + m && (o.defaultValue = '' + m));
    }
    var $ = Array.isArray;
    function k(o, u, m, _) {
        if (((o = o.options), u)) {
            u = {};
            for (var A = 0; A < m.length; A++) u['$' + m[A]] = !0;
            for (m = 0; m < o.length; m++)
                (A = u.hasOwnProperty('$' + o[m].value)),
                    o[m].selected !== A && (o[m].selected = A),
                    A && _ && (o[m].defaultSelected = !0);
        } else {
            for (m = '' + Ye(m), u = null, A = 0; A < o.length; A++) {
                if (o[A].value === m) {
                    (o[A].selected = !0), _ && (o[A].defaultSelected = !0);
                    return;
                }
                u !== null || o[A].disabled || (u = o[A]);
            }
            u !== null && (u.selected = !0);
        }
    }
    function ge(o, u) {
        if (u.dangerouslySetInnerHTML != null) throw Error(t(91));
        return Q({}, u, {
            value: void 0,
            defaultValue: void 0,
            children: '' + o._wrapperState.initialValue,
        });
    }
    function De(o, u) {
        var m = u.value;
        if (m == null) {
            if (((m = u.children), (u = u.defaultValue), m != null)) {
                if (u != null) throw Error(t(92));
                if ($(m)) {
                    if (1 < m.length) throw Error(t(93));
                    m = m[0];
                }
                u = m;
            }
            u == null && (u = ''), (m = u);
        }
        o._wrapperState = { initialValue: Ye(m) };
    }
    function be(o, u) {
        var m = Ye(u.value),
            _ = Ye(u.defaultValue);
        m != null &&
            ((m = '' + m),
            m !== o.value && (o.value = m),
            u.defaultValue == null &&
                o.defaultValue !== m &&
                (o.defaultValue = m)),
            _ != null && (o.defaultValue = '' + _);
    }
    function Le(o) {
        var u = o.textContent;
        u === o._wrapperState.initialValue &&
            u !== '' &&
            u !== null &&
            (o.value = u);
    }
    function _t(o) {
        switch (o) {
            case 'svg':
                return 'http://www.w3.org/2000/svg';
            case 'math':
                return 'http://www.w3.org/1998/Math/MathML';
            default:
                return 'http://www.w3.org/1999/xhtml';
        }
    }
    function $e(o, u) {
        return o == null || o === 'http://www.w3.org/1999/xhtml'
            ? _t(u)
            : o === 'http://www.w3.org/2000/svg' && u === 'foreignObject'
              ? 'http://www.w3.org/1999/xhtml'
              : o;
    }
    var tt,
        Nt = (function (o) {
            return typeof MSApp < 'u' && MSApp.execUnsafeLocalFunction
                ? function (u, m, _, A) {
                      MSApp.execUnsafeLocalFunction(function () {
                          return o(u, m, _, A);
                      });
                  }
                : o;
        })(function (o, u) {
            if (
                o.namespaceURI !== 'http://www.w3.org/2000/svg' ||
                'innerHTML' in o
            )
                o.innerHTML = u;
            else {
                for (
                    tt = tt || document.createElement('div'),
                        tt.innerHTML =
                            '<svg>' + u.valueOf().toString() + '</svg>',
                        u = tt.firstChild;
                    o.firstChild;

                )
                    o.removeChild(o.firstChild);
                for (; u.firstChild; ) o.appendChild(u.firstChild);
            }
        });
    function Be(o, u) {
        if (u) {
            var m = o.firstChild;
            if (m && m === o.lastChild && m.nodeType === 3) {
                m.nodeValue = u;
                return;
            }
        }
        o.textContent = u;
    }
    var Je = {
            animationIterationCount: !0,
            aspectRatio: !0,
            borderImageOutset: !0,
            borderImageSlice: !0,
            borderImageWidth: !0,
            boxFlex: !0,
            boxFlexGroup: !0,
            boxOrdinalGroup: !0,
            columnCount: !0,
            columns: !0,
            flex: !0,
            flexGrow: !0,
            flexPositive: !0,
            flexShrink: !0,
            flexNegative: !0,
            flexOrder: !0,
            gridArea: !0,
            gridRow: !0,
            gridRowEnd: !0,
            gridRowSpan: !0,
            gridRowStart: !0,
            gridColumn: !0,
            gridColumnEnd: !0,
            gridColumnSpan: !0,
            gridColumnStart: !0,
            fontWeight: !0,
            lineClamp: !0,
            lineHeight: !0,
            opacity: !0,
            order: !0,
            orphans: !0,
            tabSize: !0,
            widows: !0,
            zIndex: !0,
            zoom: !0,
            fillOpacity: !0,
            floodOpacity: !0,
            stopOpacity: !0,
            strokeDasharray: !0,
            strokeDashoffset: !0,
            strokeMiterlimit: !0,
            strokeOpacity: !0,
            strokeWidth: !0,
        },
        Kt = ['Webkit', 'ms', 'Moz', 'O'];
    Object.keys(Je).forEach(function (o) {
        Kt.forEach(function (u) {
            (u = u + o.charAt(0).toUpperCase() + o.substring(1)),
                (Je[u] = Je[o]);
        });
    });
    function bt(o, u, m) {
        return u == null || typeof u == 'boolean' || u === ''
            ? ''
            : m ||
                typeof u != 'number' ||
                u === 0 ||
                (Je.hasOwnProperty(o) && Je[o])
              ? ('' + u).trim()
              : u + 'px';
    }
    function ut(o, u) {
        o = o.style;
        for (var m in u)
            if (u.hasOwnProperty(m)) {
                var _ = m.indexOf('--') === 0,
                    A = bt(m, u[m], _);
                m === 'float' && (m = 'cssFloat'),
                    _ ? o.setProperty(m, A) : (o[m] = A);
            }
    }
    var Ut = Q(
        { menuitem: !0 },
        {
            area: !0,
            base: !0,
            br: !0,
            col: !0,
            embed: !0,
            hr: !0,
            img: !0,
            input: !0,
            keygen: !0,
            link: !0,
            meta: !0,
            param: !0,
            source: !0,
            track: !0,
            wbr: !0,
        }
    );
    function zt(o, u) {
        if (u) {
            if (
                Ut[o] &&
                (u.children != null || u.dangerouslySetInnerHTML != null)
            )
                throw Error(t(137, o));
            if (u.dangerouslySetInnerHTML != null) {
                if (u.children != null) throw Error(t(60));
                if (
                    typeof u.dangerouslySetInnerHTML != 'object' ||
                    !('__html' in u.dangerouslySetInnerHTML)
                )
                    throw Error(t(61));
            }
            if (u.style != null && typeof u.style != 'object')
                throw Error(t(62));
        }
    }
    function dn(o, u) {
        if (o.indexOf('-') === -1) return typeof u.is == 'string';
        switch (o) {
            case 'annotation-xml':
            case 'color-profile':
            case 'font-face':
            case 'font-face-src':
            case 'font-face-uri':
            case 'font-face-format':
            case 'font-face-name':
            case 'missing-glyph':
                return !1;
            default:
                return !0;
        }
    }
    var ne = null;
    function Ve(o) {
        return (
            (o = o.target || o.srcElement || window),
            o.correspondingUseElement && (o = o.correspondingUseElement),
            o.nodeType === 3 ? o.parentNode : o
        );
    }
    var Te = null,
        Ae = null,
        Ge = null;
    function At(o) {
        if ((o = Fs(o))) {
            if (typeof Te != 'function') throw Error(t(280));
            var u = o.stateNode;
            u && ((u = Zc(u)), Te(o.stateNode, o.type, u));
        }
    }
    function Yt(o) {
        Ae ? (Ge ? Ge.push(o) : (Ge = [o])) : (Ae = o);
    }
    function Cn() {
        if (Ae) {
            var o = Ae,
                u = Ge;
            if (((Ge = Ae = null), At(o), u))
                for (o = 0; o < u.length; o++) At(u[o]);
        }
    }
    function jn(o, u) {
        return o(u);
    }
    function en() {}
    var Hi = !1;
    function Gi(o, u, m) {
        if (Hi) return o(u, m);
        Hi = !0;
        try {
            return jn(o, u, m);
        } finally {
            (Hi = !1), (Ae !== null || Ge !== null) && (en(), Cn());
        }
    }
    function mo(o, u) {
        var m = o.stateNode;
        if (m === null) return null;
        var _ = Zc(m);
        if (_ === null) return null;
        m = _[u];
        e: switch (u) {
            case 'onClick':
            case 'onClickCapture':
            case 'onDoubleClick':
            case 'onDoubleClickCapture':
            case 'onMouseDown':
            case 'onMouseDownCapture':
            case 'onMouseMove':
            case 'onMouseMoveCapture':
            case 'onMouseUp':
            case 'onMouseUpCapture':
            case 'onMouseEnter':
                (_ = !_.disabled) ||
                    ((o = o.type),
                    (_ = !(
                        o === 'button' ||
                        o === 'input' ||
                        o === 'select' ||
                        o === 'textarea'
                    ))),
                    (o = !_);
                break e;
            default:
                o = !1;
        }
        if (o) return null;
        if (m && typeof m != 'function') throw Error(t(231, u, typeof m));
        return m;
    }
    var Wr = !1;
    if (l)
        try {
            var Cs = {};
            Object.defineProperty(Cs, 'passive', {
                get: function () {
                    Wr = !0;
                },
            }),
                window.addEventListener('test', Cs, Cs),
                window.removeEventListener('test', Cs, Cs);
        } catch {
            Wr = !1;
        }
    function Gl(o, u, m, _, A, P, O, Y, Z) {
        var xe = Array.prototype.slice.call(arguments, 3);
        try {
            u.apply(m, xe);
        } catch (Ue) {
            this.onError(Ue);
        }
    }
    var ls = !1,
        Rs = null,
        Xr = !1,
        go = null,
        gc = {
            onError: function (o) {
                (ls = !0), (Rs = o);
            },
        };
    function yc(o, u, m, _, A, P, O, Y, Z) {
        (ls = !1), (Rs = null), Gl.apply(gc, arguments);
    }
    function Rh(o, u, m, _, A, P, O, Y, Z) {
        if ((yc.apply(this, arguments), ls)) {
            if (ls) {
                var xe = Rs;
                (ls = !1), (Rs = null);
            } else throw Error(t(198));
            Xr || ((Xr = !0), (go = xe));
        }
    }
    function bs(o) {
        var u = o,
            m = o;
        if (o.alternate) for (; u.return; ) u = u.return;
        else {
            o = u;
            do
                (u = o),
                    (u.flags & 4098) !== 0 && (m = u.return),
                    (o = u.return);
            while (o);
        }
        return u.tag === 3 ? m : null;
    }
    function vc(o) {
        if (o.tag === 13) {
            var u = o.memoizedState;
            if (
                (u === null &&
                    ((o = o.alternate), o !== null && (u = o.memoizedState)),
                u !== null)
            )
                return u.dehydrated;
        }
        return null;
    }
    function V(o) {
        if (bs(o) !== o) throw Error(t(188));
    }
    function re(o) {
        var u = o.alternate;
        if (!u) {
            if (((u = bs(o)), u === null)) throw Error(t(188));
            return u !== o ? null : o;
        }
        for (var m = o, _ = u; ; ) {
            var A = m.return;
            if (A === null) break;
            var P = A.alternate;
            if (P === null) {
                if (((_ = A.return), _ !== null)) {
                    m = _;
                    continue;
                }
                break;
            }
            if (A.child === P.child) {
                for (P = A.child; P; ) {
                    if (P === m) return V(A), o;
                    if (P === _) return V(A), u;
                    P = P.sibling;
                }
                throw Error(t(188));
            }
            if (m.return !== _.return) (m = A), (_ = P);
            else {
                for (var O = !1, Y = A.child; Y; ) {
                    if (Y === m) {
                        (O = !0), (m = A), (_ = P);
                        break;
                    }
                    if (Y === _) {
                        (O = !0), (_ = A), (m = P);
                        break;
                    }
                    Y = Y.sibling;
                }
                if (!O) {
                    for (Y = P.child; Y; ) {
                        if (Y === m) {
                            (O = !0), (m = P), (_ = A);
                            break;
                        }
                        if (Y === _) {
                            (O = !0), (_ = P), (m = A);
                            break;
                        }
                        Y = Y.sibling;
                    }
                    if (!O) throw Error(t(189));
                }
            }
            if (m.alternate !== _) throw Error(t(190));
        }
        if (m.tag !== 3) throw Error(t(188));
        return m.stateNode.current === m ? o : u;
    }
    function ye(o) {
        return (o = re(o)), o !== null ? ve(o) : null;
    }
    function ve(o) {
        if (o.tag === 5 || o.tag === 6) return o;
        for (o = o.child; o !== null; ) {
            var u = ve(o);
            if (u !== null) return u;
            o = o.sibling;
        }
        return null;
    }
    var le = e.unstable_scheduleCallback,
        We = e.unstable_cancelCallback,
        nt = e.unstable_shouldYield,
        pt = e.unstable_requestPaint,
        Xe = e.unstable_now,
        Mt = e.unstable_getCurrentPriorityLevel,
        Et = e.unstable_ImmediatePriority,
        wt = e.unstable_UserBlockingPriority,
        Qt = e.unstable_NormalPriority,
        vn = e.unstable_LowPriority,
        un = e.unstable_IdlePriority,
        En = null,
        ft = null;
    function je(o) {
        if (ft && typeof ft.onCommitFiberRoot == 'function')
            try {
                ft.onCommitFiberRoot(
                    En,
                    o,
                    void 0,
                    (o.current.flags & 128) === 128
                );
            } catch {}
    }
    var Zt = Math.clz32 ? Math.clz32 : Wi,
        It = Math.log,
        xn = Math.LN2;
    function Wi(o) {
        return (o >>>= 0), o === 0 ? 32 : (31 - ((It(o) / xn) | 0)) | 0;
    }
    var Dn = 64,
        zn = 4194304;
    function fn(o) {
        switch (o & -o) {
            case 1:
                return 1;
            case 2:
                return 2;
            case 4:
                return 4;
            case 8:
                return 8;
            case 16:
                return 16;
            case 32:
                return 32;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
                return o & 4194240;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
                return o & 130023424;
            case 134217728:
                return 134217728;
            case 268435456:
                return 268435456;
            case 536870912:
                return 536870912;
            case 1073741824:
                return 1073741824;
            default:
                return o;
        }
    }
    function Xi(o, u) {
        var m = o.pendingLanes;
        if (m === 0) return 0;
        var _ = 0,
            A = o.suspendedLanes,
            P = o.pingedLanes,
            O = m & 268435455;
        if (O !== 0) {
            var Y = O & ~A;
            Y !== 0 ? (_ = fn(Y)) : ((P &= O), P !== 0 && (_ = fn(P)));
        } else (O = m & ~A), O !== 0 ? (_ = fn(O)) : P !== 0 && (_ = fn(P));
        if (_ === 0) return 0;
        if (
            u !== 0 &&
            u !== _ &&
            (u & A) === 0 &&
            ((A = _ & -_),
            (P = u & -u),
            A >= P || (A === 16 && (P & 4194240) !== 0))
        )
            return u;
        if (((_ & 4) !== 0 && (_ |= m & 16), (u = o.entangledLanes), u !== 0))
            for (o = o.entanglements, u &= _; 0 < u; )
                (m = 31 - Zt(u)), (A = 1 << m), (_ |= o[m]), (u &= ~A);
        return _;
    }
    function za(o, u) {
        switch (o) {
            case 1:
            case 2:
            case 4:
                return u + 250;
            case 8:
            case 16:
            case 32:
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
                return u + 5e3;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
                return -1;
            case 134217728:
            case 268435456:
            case 536870912:
            case 1073741824:
                return -1;
            default:
                return -1;
        }
    }
    function pi(o, u) {
        for (
            var m = o.suspendedLanes,
                _ = o.pingedLanes,
                A = o.expirationTimes,
                P = o.pendingLanes;
            0 < P;

        ) {
            var O = 31 - Zt(P),
                Y = 1 << O,
                Z = A[O];
            Z === -1
                ? ((Y & m) === 0 || (Y & _) !== 0) && (A[O] = za(Y, u))
                : Z <= u && (o.expiredLanes |= Y),
                (P &= ~Y);
        }
    }
    function yo(o) {
        return (
            (o = o.pendingLanes & -1073741825),
            o !== 0 ? o : o & 1073741824 ? 1073741824 : 0
        );
    }
    function ji() {
        var o = Dn;
        return (Dn <<= 1), (Dn & 4194240) === 0 && (Dn = 64), o;
    }
    function Va(o) {
        for (var u = [], m = 0; 31 > m; m++) u.push(o);
        return u;
    }
    function Wl(o, u, m) {
        (o.pendingLanes |= u),
            u !== 536870912 && ((o.suspendedLanes = 0), (o.pingedLanes = 0)),
            (o = o.eventTimes),
            (u = 31 - Zt(u)),
            (o[u] = m);
    }
    function Xv(o, u) {
        var m = o.pendingLanes & ~u;
        (o.pendingLanes = u),
            (o.suspendedLanes = 0),
            (o.pingedLanes = 0),
            (o.expiredLanes &= u),
            (o.mutableReadLanes &= u),
            (o.entangledLanes &= u),
            (u = o.entanglements);
        var _ = o.eventTimes;
        for (o = o.expirationTimes; 0 < m; ) {
            var A = 31 - Zt(m),
                P = 1 << A;
            (u[A] = 0), (_[A] = -1), (o[A] = -1), (m &= ~P);
        }
    }
    function Ha(o, u) {
        var m = (o.entangledLanes |= u);
        for (o = o.entanglements; m; ) {
            var _ = 31 - Zt(m),
                A = 1 << _;
            (A & u) | (o[_] & u) && (o[_] |= u), (m &= ~A);
        }
    }
    var rn = 0;
    function Ga(o) {
        return (
            (o &= -o),
            1 < o ? (4 < o ? ((o & 268435455) !== 0 ? 16 : 536870912) : 4) : 1
        );
    }
    var Xl,
        bh,
        om,
        xc,
        _c,
        Ho = !1,
        Sc = [],
        us = null,
        jt = null,
        Ps = null,
        Go = new Map(),
        Wa = new Map(),
        vo = [],
        jv =
            'mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit'.split(
                ' '
            );
    function ei(o, u) {
        switch (o) {
            case 'focusin':
            case 'focusout':
                us = null;
                break;
            case 'dragenter':
            case 'dragleave':
                jt = null;
                break;
            case 'mouseover':
            case 'mouseout':
                Ps = null;
                break;
            case 'pointerover':
            case 'pointerout':
                Go.delete(u.pointerId);
                break;
            case 'gotpointercapture':
            case 'lostpointercapture':
                Wa.delete(u.pointerId);
        }
    }
    function Wo(o, u, m, _, A, P) {
        return o === null || o.nativeEvent !== P
            ? ((o = {
                  blockedOn: u,
                  domEventName: m,
                  eventSystemFlags: _,
                  nativeEvent: P,
                  targetContainers: [A],
              }),
              u !== null && ((u = Fs(u)), u !== null && bh(u)),
              o)
            : ((o.eventSystemFlags |= _),
              (u = o.targetContainers),
              A !== null && u.indexOf(A) === -1 && u.push(A),
              o);
    }
    function qv(o, u, m, _, A) {
        switch (u) {
            case 'focusin':
                return (us = Wo(us, o, u, m, _, A)), !0;
            case 'dragenter':
                return (jt = Wo(jt, o, u, m, _, A)), !0;
            case 'mouseover':
                return (Ps = Wo(Ps, o, u, m, _, A)), !0;
            case 'pointerover':
                var P = A.pointerId;
                return Go.set(P, Wo(Go.get(P) || null, o, u, m, _, A)), !0;
            case 'gotpointercapture':
                return (
                    (P = A.pointerId),
                    Wa.set(P, Wo(Wa.get(P) || null, o, u, m, _, A)),
                    !0
                );
        }
        return !1;
    }
    function wc(o) {
        var u = To(o.target);
        if (u !== null) {
            var m = bs(u);
            if (m !== null) {
                if (((u = m.tag), u === 13)) {
                    if (((u = vc(m)), u !== null)) {
                        (o.blockedOn = u),
                            _c(o.priority, function () {
                                om(m);
                            });
                        return;
                    }
                } else if (
                    u === 3 &&
                    m.stateNode.current.memoizedState.isDehydrated
                ) {
                    o.blockedOn =
                        m.tag === 3 ? m.stateNode.containerInfo : null;
                    return;
                }
            }
        }
        o.blockedOn = null;
    }
    function Mc(o) {
        if (o.blockedOn !== null) return !1;
        for (var u = o.targetContainers; 0 < u.length; ) {
            var m = Rr(o.domEventName, o.eventSystemFlags, u[0], o.nativeEvent);
            if (m === null) {
                m = o.nativeEvent;
                var _ = new m.constructor(m.type, m);
                (ne = _), m.target.dispatchEvent(_), (ne = null);
            } else
                return (u = Fs(m)), u !== null && bh(u), (o.blockedOn = m), !1;
            u.shift();
        }
        return !0;
    }
    function jl(o, u, m) {
        Mc(o) && m.delete(u);
    }
    function cs() {
        (Ho = !1),
            us !== null && Mc(us) && (us = null),
            jt !== null && Mc(jt) && (jt = null),
            Ps !== null && Mc(Ps) && (Ps = null),
            Go.forEach(jl),
            Wa.forEach(jl);
    }
    function ql(o, u) {
        o.blockedOn === u &&
            ((o.blockedOn = null),
            Ho ||
                ((Ho = !0),
                e.unstable_scheduleCallback(e.unstable_NormalPriority, cs)));
    }
    function $l(o) {
        function u(A) {
            return ql(A, o);
        }
        if (0 < Sc.length) {
            ql(Sc[0], o);
            for (var m = 1; m < Sc.length; m++) {
                var _ = Sc[m];
                _.blockedOn === o && (_.blockedOn = null);
            }
        }
        for (
            us !== null && ql(us, o),
                jt !== null && ql(jt, o),
                Ps !== null && ql(Ps, o),
                Go.forEach(u),
                Wa.forEach(u),
                m = 0;
            m < vo.length;
            m++
        )
            (_ = vo[m]), _.blockedOn === o && (_.blockedOn = null);
        for (; 0 < vo.length && ((m = vo[0]), m.blockedOn === null); )
            wc(m), m.blockedOn === null && vo.shift();
    }
    var Ii = L.ReactCurrentBatchConfig,
        Cr = !0;
    function Ec(o, u, m, _) {
        var A = rn,
            P = Ii.transition;
        Ii.transition = null;
        try {
            (rn = 1), Tc(o, u, m, _);
        } finally {
            (rn = A), (Ii.transition = P);
        }
    }
    function Ph(o, u, m, _) {
        var A = rn,
            P = Ii.transition;
        Ii.transition = null;
        try {
            (rn = 4), Tc(o, u, m, _);
        } finally {
            (rn = A), (Ii.transition = P);
        }
    }
    function Tc(o, u, m, _) {
        if (Cr) {
            var A = Rr(o, u, m, _);
            if (A === null) Xc(o, u, _, Ac, m), ei(o, _);
            else if (qv(A, o, u, m, _)) _.stopPropagation();
            else if ((ei(o, _), u & 4 && -1 < jv.indexOf(o))) {
                for (; A !== null; ) {
                    var P = Fs(A);
                    if (
                        (P !== null && Xl(P),
                        (P = Rr(o, u, m, _)),
                        P === null && Xc(o, u, _, Ac, m),
                        P === A)
                    )
                        break;
                    A = P;
                }
                A !== null && _.stopPropagation();
            } else Xc(o, u, _, null, m);
        }
    }
    var Ac = null;
    function Rr(o, u, m, _) {
        if (((Ac = null), (o = Ve(_)), (o = To(o)), o !== null))
            if (((u = bs(o)), u === null)) o = null;
            else if (((m = u.tag), m === 13)) {
                if (((o = vc(u)), o !== null)) return o;
                o = null;
            } else if (m === 3) {
                if (u.stateNode.current.memoizedState.isDehydrated)
                    return u.tag === 3 ? u.stateNode.containerInfo : null;
                o = null;
            } else u !== o && (o = null);
        return (Ac = o), null;
    }
    function am(o) {
        switch (o) {
            case 'cancel':
            case 'click':
            case 'close':
            case 'contextmenu':
            case 'copy':
            case 'cut':
            case 'auxclick':
            case 'dblclick':
            case 'dragend':
            case 'dragstart':
            case 'drop':
            case 'focusin':
            case 'focusout':
            case 'input':
            case 'invalid':
            case 'keydown':
            case 'keypress':
            case 'keyup':
            case 'mousedown':
            case 'mouseup':
            case 'paste':
            case 'pause':
            case 'play':
            case 'pointercancel':
            case 'pointerdown':
            case 'pointerup':
            case 'ratechange':
            case 'reset':
            case 'resize':
            case 'seeked':
            case 'submit':
            case 'touchcancel':
            case 'touchend':
            case 'touchstart':
            case 'volumechange':
            case 'change':
            case 'selectionchange':
            case 'textInput':
            case 'compositionstart':
            case 'compositionend':
            case 'compositionupdate':
            case 'beforeblur':
            case 'afterblur':
            case 'beforeinput':
            case 'blur':
            case 'fullscreenchange':
            case 'focus':
            case 'hashchange':
            case 'popstate':
            case 'select':
            case 'selectstart':
                return 1;
            case 'drag':
            case 'dragenter':
            case 'dragexit':
            case 'dragleave':
            case 'dragover':
            case 'mousemove':
            case 'mouseout':
            case 'mouseover':
            case 'pointermove':
            case 'pointerout':
            case 'pointerover':
            case 'scroll':
            case 'toggle':
            case 'touchmove':
            case 'wheel':
            case 'mouseenter':
            case 'mouseleave':
            case 'pointerenter':
            case 'pointerleave':
                return 4;
            case 'message':
                switch (Mt()) {
                    case Et:
                        return 1;
                    case wt:
                        return 4;
                    case Qt:
                    case vn:
                        return 16;
                    case un:
                        return 536870912;
                    default:
                        return 16;
                }
            default:
                return 16;
        }
    }
    var jr = null,
        Lh = null,
        qi = null;
    function Yl() {
        if (qi) return qi;
        var o,
            u = Lh,
            m = u.length,
            _,
            A = 'value' in jr ? jr.value : jr.textContent,
            P = A.length;
        for (o = 0; o < m && u[o] === A[o]; o++);
        var O = m - o;
        for (_ = 1; _ <= O && u[m - _] === A[P - _]; _++);
        return (qi = A.slice(o, 1 < _ ? 1 - _ : void 0));
    }
    function Xo(o) {
        var u = o.keyCode;
        return (
            'charCode' in o
                ? ((o = o.charCode), o === 0 && u === 13 && (o = 13))
                : (o = u),
            o === 10 && (o = 13),
            32 <= o || o === 13 ? o : 0
        );
    }
    function Ls() {
        return !0;
    }
    function Cc() {
        return !1;
    }
    function Di(o) {
        function u(m, _, A, P, O) {
            (this._reactName = m),
                (this._targetInst = A),
                (this.type = _),
                (this.nativeEvent = P),
                (this.target = O),
                (this.currentTarget = null);
            for (var Y in o)
                o.hasOwnProperty(Y) &&
                    ((m = o[Y]), (this[Y] = m ? m(P) : P[Y]));
            return (
                (this.isDefaultPrevented = (
                    P.defaultPrevented != null
                        ? P.defaultPrevented
                        : P.returnValue === !1
                )
                    ? Ls
                    : Cc),
                (this.isPropagationStopped = Cc),
                this
            );
        }
        return (
            Q(u.prototype, {
                preventDefault: function () {
                    this.defaultPrevented = !0;
                    var m = this.nativeEvent;
                    m &&
                        (m.preventDefault
                            ? m.preventDefault()
                            : typeof m.returnValue != 'unknown' &&
                              (m.returnValue = !1),
                        (this.isDefaultPrevented = Ls));
                },
                stopPropagation: function () {
                    var m = this.nativeEvent;
                    m &&
                        (m.stopPropagation
                            ? m.stopPropagation()
                            : typeof m.cancelBubble != 'unknown' &&
                              (m.cancelBubble = !0),
                        (this.isPropagationStopped = Ls));
                },
                persist: function () {},
                isPersistent: Ls,
            }),
            u
        );
    }
    var jo = {
            eventPhase: 0,
            bubbles: 0,
            cancelable: 0,
            timeStamp: function (o) {
                return o.timeStamp || Date.now();
            },
            defaultPrevented: 0,
            isTrusted: 0,
        },
        Kl = Di(jo),
        qo = Q({}, jo, { view: 0, detail: 0 }),
        Xa = Di(qo),
        $i,
        br,
        Pr,
        ja = Q({}, qo, {
            screenX: 0,
            screenY: 0,
            clientX: 0,
            clientY: 0,
            pageX: 0,
            pageY: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            getModifierState: _o,
            button: 0,
            buttons: 0,
            relatedTarget: function (o) {
                return o.relatedTarget === void 0
                    ? o.fromElement === o.srcElement
                        ? o.toElement
                        : o.fromElement
                    : o.relatedTarget;
            },
            movementX: function (o) {
                return 'movementX' in o
                    ? o.movementX
                    : (o !== Pr &&
                          (Pr && o.type === 'mousemove'
                              ? (($i = o.screenX - Pr.screenX),
                                (br = o.screenY - Pr.screenY))
                              : (br = $i = 0),
                          (Pr = o)),
                      $i);
            },
            movementY: function (o) {
                return 'movementY' in o ? o.movementY : br;
            },
        }),
        Ih = Di(ja),
        Is = Q({}, ja, { dataTransfer: 0 }),
        xo = Di(Is),
        Rc = Q({}, qo, { relatedTarget: 0 }),
        bc = Di(Rc),
        Pc = Q({}, jo, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
        lm = Di(Pc),
        um = Q({}, jo, {
            clipboardData: function (o) {
                return 'clipboardData' in o
                    ? o.clipboardData
                    : window.clipboardData;
            },
        }),
        Dh = Di(um),
        Lc = Q({}, jo, { data: 0 }),
        Nh = Di(Lc),
        cm = {
            Esc: 'Escape',
            Spacebar: ' ',
            Left: 'ArrowLeft',
            Up: 'ArrowUp',
            Right: 'ArrowRight',
            Down: 'ArrowDown',
            Del: 'Delete',
            Win: 'OS',
            Menu: 'ContextMenu',
            Apps: 'ContextMenu',
            Scroll: 'ScrollLock',
            MozPrintableKey: 'Unidentified',
        },
        fm = {
            8: 'Backspace',
            9: 'Tab',
            12: 'Clear',
            13: 'Enter',
            16: 'Shift',
            17: 'Control',
            18: 'Alt',
            19: 'Pause',
            20: 'CapsLock',
            27: 'Escape',
            32: ' ',
            33: 'PageUp',
            34: 'PageDown',
            35: 'End',
            36: 'Home',
            37: 'ArrowLeft',
            38: 'ArrowUp',
            39: 'ArrowRight',
            40: 'ArrowDown',
            45: 'Insert',
            46: 'Delete',
            112: 'F1',
            113: 'F2',
            114: 'F3',
            115: 'F4',
            116: 'F5',
            117: 'F6',
            118: 'F7',
            119: 'F8',
            120: 'F9',
            121: 'F10',
            122: 'F11',
            123: 'F12',
            144: 'NumLock',
            145: 'ScrollLock',
            224: 'Meta',
        },
        Uh = {
            Alt: 'altKey',
            Control: 'ctrlKey',
            Meta: 'metaKey',
            Shift: 'shiftKey',
        };
    function qa(o) {
        var u = this.nativeEvent;
        return u.getModifierState
            ? u.getModifierState(o)
            : (o = Uh[o])
              ? !!u[o]
              : !1;
    }
    function _o() {
        return qa;
    }
    var Ic = Q({}, qo, {
            key: function (o) {
                if (o.key) {
                    var u = cm[o.key] || o.key;
                    if (u !== 'Unidentified') return u;
                }
                return o.type === 'keypress'
                    ? ((o = Xo(o)), o === 13 ? 'Enter' : String.fromCharCode(o))
                    : o.type === 'keydown' || o.type === 'keyup'
                      ? fm[o.keyCode] || 'Unidentified'
                      : '';
            },
            code: 0,
            location: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            repeat: 0,
            locale: 0,
            getModifierState: _o,
            charCode: function (o) {
                return o.type === 'keypress' ? Xo(o) : 0;
            },
            keyCode: function (o) {
                return o.type === 'keydown' || o.type === 'keyup'
                    ? o.keyCode
                    : 0;
            },
            which: function (o) {
                return o.type === 'keypress'
                    ? Xo(o)
                    : o.type === 'keydown' || o.type === 'keyup'
                      ? o.keyCode
                      : 0;
            },
        }),
        Dc = Di(Ic),
        Lr = Q({}, ja, {
            pointerId: 0,
            width: 0,
            height: 0,
            pressure: 0,
            tangentialPressure: 0,
            tiltX: 0,
            tiltY: 0,
            twist: 0,
            pointerType: 0,
            isPrimary: 0,
        }),
        cr = Di(Lr),
        $o = Q({}, qo, {
            touches: 0,
            targetTouches: 0,
            changedTouches: 0,
            altKey: 0,
            metaKey: 0,
            ctrlKey: 0,
            shiftKey: 0,
            getModifierState: _o,
        }),
        Ds = Di($o),
        Ns = Q({}, jo, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
        Yo = Di(Ns),
        hm = Q({}, ja, {
            deltaX: function (o) {
                return 'deltaX' in o
                    ? o.deltaX
                    : 'wheelDeltaX' in o
                      ? -o.wheelDeltaX
                      : 0;
            },
            deltaY: function (o) {
                return 'deltaY' in o
                    ? o.deltaY
                    : 'wheelDeltaY' in o
                      ? -o.wheelDeltaY
                      : 'wheelDelta' in o
                        ? -o.wheelDelta
                        : 0;
            },
            deltaZ: 0,
            deltaMode: 0,
        }),
        Oh = Di(hm),
        kh = [9, 13, 27, 32],
        Ni = l && 'CompositionEvent' in window,
        mi = null;
    l && 'documentMode' in document && (mi = document.documentMode);
    var Rn = l && 'TextEvent' in window && !mi,
        $a = l && (!Ni || (mi && 8 < mi && 11 >= mi)),
        Ir = ' ',
        Fh = !1;
    function Bh(o, u) {
        switch (o) {
            case 'keyup':
                return kh.indexOf(u.keyCode) !== -1;
            case 'keydown':
                return u.keyCode !== 229;
            case 'keypress':
            case 'mousedown':
            case 'focusout':
                return !0;
            default:
                return !1;
        }
    }
    function Nc(o) {
        return (
            (o = o.detail), typeof o == 'object' && 'data' in o ? o.data : null
        );
    }
    var So = !1;
    function dm(o, u) {
        switch (o) {
            case 'compositionend':
                return Nc(u);
            case 'keypress':
                return u.which !== 32 ? null : ((Fh = !0), Ir);
            case 'textInput':
                return (o = u.data), o === Ir && Fh ? null : o;
            default:
                return null;
        }
    }
    function Zl(o, u) {
        if (So)
            return o === 'compositionend' || (!Ni && Bh(o, u))
                ? ((o = Yl()), (qi = Lh = jr = null), (So = !1), o)
                : null;
        switch (o) {
            case 'paste':
                return null;
            case 'keypress':
                if (
                    !(u.ctrlKey || u.altKey || u.metaKey) ||
                    (u.ctrlKey && u.altKey)
                ) {
                    if (u.char && 1 < u.char.length) return u.char;
                    if (u.which) return String.fromCharCode(u.which);
                }
                return null;
            case 'compositionend':
                return $a && u.locale !== 'ko' ? null : u.data;
            default:
                return null;
        }
    }
    var Ya = {
        color: !0,
        date: !0,
        datetime: !0,
        'datetime-local': !0,
        email: !0,
        month: !0,
        number: !0,
        password: !0,
        range: !0,
        search: !0,
        tel: !0,
        text: !0,
        time: !0,
        url: !0,
        week: !0,
    };
    function Uc(o) {
        var u = o && o.nodeName && o.nodeName.toLowerCase();
        return u === 'input' ? !!Ya[o.type] : u === 'textarea';
    }
    function Ka(o, u, m, _) {
        Yt(_),
            (u = jc(u, 'onChange')),
            0 < u.length &&
                ((m = new Kl('onChange', 'change', null, m, _)),
                o.push({ event: m, listeners: u }));
    }
    var wo = null,
        Za = null;
    function pm(o) {
        tl(o, 0);
    }
    function Us(o) {
        var u = Vn(o);
        if (W(u)) return o;
    }
    function mm(o, u) {
        if (o === 'change') return u;
    }
    var Ja = !1;
    if (l) {
        var Yi;
        if (l) {
            var Ko = 'oninput' in document;
            if (!Ko) {
                var Zo = document.createElement('div');
                Zo.setAttribute('oninput', 'return;'),
                    (Ko = typeof Zo.oninput == 'function');
            }
            Yi = Ko;
        } else Yi = !1;
        Ja = Yi && (!document.documentMode || 9 < document.documentMode);
    }
    function qr() {
        wo && (wo.detachEvent('onpropertychange', Oc), (Za = wo = null));
    }
    function Oc(o) {
        if (o.propertyName === 'value' && Us(Za)) {
            var u = [];
            Ka(u, Za, o, Ve(o)), Gi(pm, u);
        }
    }
    function Qa(o, u, m) {
        o === 'focusin'
            ? (qr(), (wo = u), (Za = m), wo.attachEvent('onpropertychange', Oc))
            : o === 'focusout' && qr();
    }
    function gm(o) {
        if (o === 'selectionchange' || o === 'keyup' || o === 'keydown')
            return Us(Za);
    }
    function zh(o, u) {
        if (o === 'click') return Us(u);
    }
    function Nn(o, u) {
        if (o === 'input' || o === 'change') return Us(u);
    }
    function kc(o, u) {
        return (
            (o === u && (o !== 0 || 1 / o === 1 / u)) || (o !== o && u !== u)
        );
    }
    var fr = typeof Object.is == 'function' ? Object.is : kc;
    function Jo(o, u) {
        if (fr(o, u)) return !0;
        if (
            typeof o != 'object' ||
            o === null ||
            typeof u != 'object' ||
            u === null
        )
            return !1;
        var m = Object.keys(o),
            _ = Object.keys(u);
        if (m.length !== _.length) return !1;
        for (_ = 0; _ < m.length; _++) {
            var A = m[_];
            if (!c.call(u, A) || !fr(o[A], u[A])) return !1;
        }
        return !0;
    }
    function Jl(o) {
        for (; o && o.firstChild; ) o = o.firstChild;
        return o;
    }
    function hr(o, u) {
        var m = Jl(o);
        o = 0;
        for (var _; m; ) {
            if (m.nodeType === 3) {
                if (((_ = o + m.textContent.length), o <= u && _ >= u))
                    return { node: m, offset: u - o };
                o = _;
            }
            e: {
                for (; m; ) {
                    if (m.nextSibling) {
                        m = m.nextSibling;
                        break e;
                    }
                    m = m.parentNode;
                }
                m = void 0;
            }
            m = Jl(m);
        }
    }
    function Qo(o, u) {
        return o && u
            ? o === u
                ? !0
                : o && o.nodeType === 3
                  ? !1
                  : u && u.nodeType === 3
                    ? Qo(o, u.parentNode)
                    : 'contains' in o
                      ? o.contains(u)
                      : o.compareDocumentPosition
                        ? !!(o.compareDocumentPosition(u) & 16)
                        : !1
            : !1;
    }
    function Un() {
        for (var o = window, u = Ie(); u instanceof o.HTMLIFrameElement; ) {
            try {
                var m = typeof u.contentWindow.location.href == 'string';
            } catch {
                m = !1;
            }
            if (m) o = u.contentWindow;
            else break;
            u = Ie(o.document);
        }
        return u;
    }
    function si(o) {
        var u = o && o.nodeName && o.nodeName.toLowerCase();
        return (
            u &&
            ((u === 'input' &&
                (o.type === 'text' ||
                    o.type === 'search' ||
                    o.type === 'tel' ||
                    o.type === 'url' ||
                    o.type === 'password')) ||
                u === 'textarea' ||
                o.contentEditable === 'true')
        );
    }
    function oi(o) {
        var u = Un(),
            m = o.focusedElem,
            _ = o.selectionRange;
        if (
            u !== m &&
            m &&
            m.ownerDocument &&
            Qo(m.ownerDocument.documentElement, m)
        ) {
            if (_ !== null && si(m)) {
                if (
                    ((u = _.start),
                    (o = _.end),
                    o === void 0 && (o = u),
                    'selectionStart' in m)
                )
                    (m.selectionStart = u),
                        (m.selectionEnd = Math.min(o, m.value.length));
                else if (
                    ((o =
                        ((u = m.ownerDocument || document) && u.defaultView) ||
                        window),
                    o.getSelection)
                ) {
                    o = o.getSelection();
                    var A = m.textContent.length,
                        P = Math.min(_.start, A);
                    (_ = _.end === void 0 ? P : Math.min(_.end, A)),
                        !o.extend && P > _ && ((A = _), (_ = P), (P = A)),
                        (A = hr(m, P));
                    var O = hr(m, _);
                    A &&
                        O &&
                        (o.rangeCount !== 1 ||
                            o.anchorNode !== A.node ||
                            o.anchorOffset !== A.offset ||
                            o.focusNode !== O.node ||
                            o.focusOffset !== O.offset) &&
                        ((u = u.createRange()),
                        u.setStart(A.node, A.offset),
                        o.removeAllRanges(),
                        P > _
                            ? (o.addRange(u), o.extend(O.node, O.offset))
                            : (u.setEnd(O.node, O.offset), o.addRange(u)));
                }
            }
            for (u = [], o = m; (o = o.parentNode); )
                o.nodeType === 1 &&
                    u.push({
                        element: o,
                        left: o.scrollLeft,
                        top: o.scrollTop,
                    });
            for (
                typeof m.focus == 'function' && m.focus(), m = 0;
                m < u.length;
                m++
            )
                (o = u[m]),
                    (o.element.scrollLeft = o.left),
                    (o.element.scrollTop = o.top);
        }
    }
    var Fc = l && 'documentMode' in document && 11 >= document.documentMode,
        fs = null,
        ea = null,
        Ql = null,
        ai = !1;
    function Bc(o, u, m) {
        var _ =
            m.window === m
                ? m.document
                : m.nodeType === 9
                  ? m
                  : m.ownerDocument;
        ai ||
            fs == null ||
            fs !== Ie(_) ||
            ((_ = fs),
            'selectionStart' in _ && si(_)
                ? (_ = { start: _.selectionStart, end: _.selectionEnd })
                : ((_ = (
                      (_.ownerDocument && _.ownerDocument.defaultView) ||
                      window
                  ).getSelection()),
                  (_ = {
                      anchorNode: _.anchorNode,
                      anchorOffset: _.anchorOffset,
                      focusNode: _.focusNode,
                      focusOffset: _.focusOffset,
                  })),
            (Ql && Jo(Ql, _)) ||
                ((Ql = _),
                (_ = jc(ea, 'onSelect')),
                0 < _.length &&
                    ((u = new Kl('onSelect', 'select', null, u, m)),
                    o.push({ event: u, listeners: _ }),
                    (u.target = fs))));
    }
    function el(o, u) {
        var m = {};
        return (
            (m[o.toLowerCase()] = u.toLowerCase()),
            (m['Webkit' + o] = 'webkit' + u),
            (m['Moz' + o] = 'moz' + u),
            m
        );
    }
    var Mo = {
            animationend: el('Animation', 'AnimationEnd'),
            animationiteration: el('Animation', 'AnimationIteration'),
            animationstart: el('Animation', 'AnimationStart'),
            transitionend: el('Transition', 'TransitionEnd'),
        },
        $r = {},
        Yr = {};
    l &&
        ((Yr = document.createElement('div').style),
        'AnimationEvent' in window ||
            (delete Mo.animationend.animation,
            delete Mo.animationiteration.animation,
            delete Mo.animationstart.animation),
        'TransitionEvent' in window || delete Mo.transitionend.transition);
    function hs(o) {
        if ($r[o]) return $r[o];
        if (!Mo[o]) return o;
        var u = Mo[o],
            m;
        for (m in u) if (u.hasOwnProperty(m) && m in Yr) return ($r[o] = u[m]);
        return o;
    }
    var eu = hs('animationend'),
        tu = hs('animationiteration'),
        Vh = hs('animationstart'),
        Hh = hs('transitionend'),
        Gh = new Map(),
        Wh =
            'abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel'.split(
                ' '
            );
    function Os(o, u) {
        Gh.set(o, u), s(u, [o]);
    }
    for (var zc = 0; zc < Wh.length; zc++) {
        var nu = Wh[zc],
            iu = nu.toLowerCase(),
            ym = nu[0].toUpperCase() + nu.slice(1);
        Os(iu, 'on' + ym);
    }
    Os(eu, 'onAnimationEnd'),
        Os(tu, 'onAnimationIteration'),
        Os(Vh, 'onAnimationStart'),
        Os('dblclick', 'onDoubleClick'),
        Os('focusin', 'onFocus'),
        Os('focusout', 'onBlur'),
        Os(Hh, 'onTransitionEnd'),
        a('onMouseEnter', ['mouseout', 'mouseover']),
        a('onMouseLeave', ['mouseout', 'mouseover']),
        a('onPointerEnter', ['pointerout', 'pointerover']),
        a('onPointerLeave', ['pointerout', 'pointerover']),
        s(
            'onChange',
            'change click focusin focusout input keydown keyup selectionchange'.split(
                ' '
            )
        ),
        s(
            'onSelect',
            'focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange'.split(
                ' '
            )
        ),
        s('onBeforeInput', [
            'compositionend',
            'keypress',
            'textInput',
            'paste',
        ]),
        s(
            'onCompositionEnd',
            'compositionend focusout keydown keypress keyup mousedown'.split(
                ' '
            )
        ),
        s(
            'onCompositionStart',
            'compositionstart focusout keydown keypress keyup mousedown'.split(
                ' '
            )
        ),
        s(
            'onCompositionUpdate',
            'compositionupdate focusout keydown keypress keyup mousedown'.split(
                ' '
            )
        );
    var Eo =
            'abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting'.split(
                ' '
            ),
        Vc = new Set(
            'cancel close invalid load scroll toggle'.split(' ').concat(Eo)
        );
    function Hc(o, u, m) {
        var _ = o.type || 'unknown-event';
        (o.currentTarget = m), Rh(_, u, void 0, o), (o.currentTarget = null);
    }
    function tl(o, u) {
        u = (u & 4) !== 0;
        for (var m = 0; m < o.length; m++) {
            var _ = o[m],
                A = _.event;
            _ = _.listeners;
            e: {
                var P = void 0;
                if (u)
                    for (var O = _.length - 1; 0 <= O; O--) {
                        var Y = _[O],
                            Z = Y.instance,
                            xe = Y.currentTarget;
                        if (
                            ((Y = Y.listener),
                            Z !== P && A.isPropagationStopped())
                        )
                            break e;
                        Hc(A, Y, xe), (P = Z);
                    }
                else
                    for (O = 0; O < _.length; O++) {
                        if (
                            ((Y = _[O]),
                            (Z = Y.instance),
                            (xe = Y.currentTarget),
                            (Y = Y.listener),
                            Z !== P && A.isPropagationStopped())
                        )
                            break e;
                        Hc(A, Y, xe), (P = Z);
                    }
            }
        }
        if (Xr) throw ((o = go), (Xr = !1), (go = null), o);
    }
    function _n(o, u) {
        var m = u[ia];
        m === void 0 && (m = u[ia] = new Set());
        var _ = o + '__bubble';
        m.has(_) || (Wc(u, o, 2, !1), m.add(_));
    }
    function Gc(o, u, m) {
        var _ = 0;
        u && (_ |= 4), Wc(m, o, _, u);
    }
    var ru = '_reactListening' + Math.random().toString(36).slice(2);
    function nl(o) {
        if (!o[ru]) {
            (o[ru] = !0),
                n.forEach(function (m) {
                    m !== 'selectionchange' &&
                        (Vc.has(m) || Gc(m, !1, o), Gc(m, !0, o));
                });
            var u = o.nodeType === 9 ? o : o.ownerDocument;
            u === null || u[ru] || ((u[ru] = !0), Gc('selectionchange', !1, u));
        }
    }
    function Wc(o, u, m, _) {
        switch (am(u)) {
            case 1:
                var A = Ec;
                break;
            case 4:
                A = Ph;
                break;
            default:
                A = Tc;
        }
        (m = A.bind(null, u, m, o)),
            (A = void 0),
            !Wr ||
                (u !== 'touchstart' && u !== 'touchmove' && u !== 'wheel') ||
                (A = !0),
            _
                ? A !== void 0
                    ? o.addEventListener(u, m, { capture: !0, passive: A })
                    : o.addEventListener(u, m, !0)
                : A !== void 0
                  ? o.addEventListener(u, m, { passive: A })
                  : o.addEventListener(u, m, !1);
    }
    function Xc(o, u, m, _, A) {
        var P = _;
        if ((u & 1) === 0 && (u & 2) === 0 && _ !== null)
            e: for (;;) {
                if (_ === null) return;
                var O = _.tag;
                if (O === 3 || O === 4) {
                    var Y = _.stateNode.containerInfo;
                    if (Y === A || (Y.nodeType === 8 && Y.parentNode === A))
                        break;
                    if (O === 4)
                        for (O = _.return; O !== null; ) {
                            var Z = O.tag;
                            if (
                                (Z === 3 || Z === 4) &&
                                ((Z = O.stateNode.containerInfo),
                                Z === A ||
                                    (Z.nodeType === 8 && Z.parentNode === A))
                            )
                                return;
                            O = O.return;
                        }
                    for (; Y !== null; ) {
                        if (((O = To(Y)), O === null)) return;
                        if (((Z = O.tag), Z === 5 || Z === 6)) {
                            _ = P = O;
                            continue e;
                        }
                        Y = Y.parentNode;
                    }
                }
                _ = _.return;
            }
        Gi(function () {
            var xe = P,
                Ue = Ve(m),
                Fe = [];
            e: {
                var Ne = Gh.get(o);
                if (Ne !== void 0) {
                    var at = Kl,
                        mt = o;
                    switch (o) {
                        case 'keypress':
                            if (Xo(m) === 0) break e;
                        case 'keydown':
                        case 'keyup':
                            at = Dc;
                            break;
                        case 'focusin':
                            (mt = 'focus'), (at = bc);
                            break;
                        case 'focusout':
                            (mt = 'blur'), (at = bc);
                            break;
                        case 'beforeblur':
                        case 'afterblur':
                            at = bc;
                            break;
                        case 'click':
                            if (m.button === 2) break e;
                        case 'auxclick':
                        case 'dblclick':
                        case 'mousedown':
                        case 'mousemove':
                        case 'mouseup':
                        case 'mouseout':
                        case 'mouseover':
                        case 'contextmenu':
                            at = Ih;
                            break;
                        case 'drag':
                        case 'dragend':
                        case 'dragenter':
                        case 'dragexit':
                        case 'dragleave':
                        case 'dragover':
                        case 'dragstart':
                        case 'drop':
                            at = xo;
                            break;
                        case 'touchcancel':
                        case 'touchend':
                        case 'touchmove':
                        case 'touchstart':
                            at = Ds;
                            break;
                        case eu:
                        case tu:
                        case Vh:
                            at = lm;
                            break;
                        case Hh:
                            at = Yo;
                            break;
                        case 'scroll':
                            at = Xa;
                            break;
                        case 'wheel':
                            at = Oh;
                            break;
                        case 'copy':
                        case 'cut':
                        case 'paste':
                            at = Dh;
                            break;
                        case 'gotpointercapture':
                        case 'lostpointercapture':
                        case 'pointercancel':
                        case 'pointerdown':
                        case 'pointermove':
                        case 'pointerout':
                        case 'pointerover':
                        case 'pointerup':
                            at = cr;
                    }
                    var gt = (u & 4) !== 0,
                        ni = !gt && o === 'scroll',
                        he = gt ? (Ne !== null ? Ne + 'Capture' : null) : Ne;
                    gt = [];
                    for (var J = xe, de; J !== null; ) {
                        de = J;
                        var He = de.stateNode;
                        if (
                            (de.tag === 5 &&
                                He !== null &&
                                ((de = He),
                                he !== null &&
                                    ((He = mo(J, he)),
                                    He != null && gt.push(il(J, He, de)))),
                            ni)
                        )
                            break;
                        J = J.return;
                    }
                    0 < gt.length &&
                        ((Ne = new at(Ne, mt, null, m, Ue)),
                        Fe.push({ event: Ne, listeners: gt }));
                }
            }
            if ((u & 7) === 0) {
                e: {
                    if (
                        ((Ne = o === 'mouseover' || o === 'pointerover'),
                        (at = o === 'mouseout' || o === 'pointerout'),
                        Ne &&
                            m !== ne &&
                            (mt = m.relatedTarget || m.fromElement) &&
                            (To(mt) || mt[dr]))
                    )
                        break e;
                    if (
                        (at || Ne) &&
                        ((Ne =
                            Ue.window === Ue
                                ? Ue
                                : (Ne = Ue.ownerDocument)
                                  ? Ne.defaultView || Ne.parentWindow
                                  : window),
                        at
                            ? ((mt = m.relatedTarget || m.toElement),
                              (at = xe),
                              (mt = mt ? To(mt) : null),
                              mt !== null &&
                                  ((ni = bs(mt)),
                                  mt !== ni ||
                                      (mt.tag !== 5 && mt.tag !== 6)) &&
                                  (mt = null))
                            : ((at = null), (mt = xe)),
                        at !== mt)
                    ) {
                        if (
                            ((gt = Ih),
                            (He = 'onMouseLeave'),
                            (he = 'onMouseEnter'),
                            (J = 'mouse'),
                            (o === 'pointerout' || o === 'pointerover') &&
                                ((gt = cr),
                                (He = 'onPointerLeave'),
                                (he = 'onPointerEnter'),
                                (J = 'pointer')),
                            (ni = at == null ? Ne : Vn(at)),
                            (de = mt == null ? Ne : Vn(mt)),
                            (Ne = new gt(He, J + 'leave', at, m, Ue)),
                            (Ne.target = ni),
                            (Ne.relatedTarget = de),
                            (He = null),
                            To(Ue) === xe &&
                                ((gt = new gt(he, J + 'enter', mt, m, Ue)),
                                (gt.target = de),
                                (gt.relatedTarget = ni),
                                (He = gt)),
                            (ni = He),
                            at && mt)
                        )
                            t: {
                                for (
                                    gt = at, he = mt, J = 0, de = gt;
                                    de;
                                    de = ta(de)
                                )
                                    J++;
                                for (de = 0, He = he; He; He = ta(He)) de++;
                                for (; 0 < J - de; ) (gt = ta(gt)), J--;
                                for (; 0 < de - J; ) (he = ta(he)), de--;
                                for (; J--; ) {
                                    if (
                                        gt === he ||
                                        (he !== null && gt === he.alternate)
                                    )
                                        break t;
                                    (gt = ta(gt)), (he = ta(he));
                                }
                                gt = null;
                            }
                        else gt = null;
                        at !== null && vm(Fe, Ne, at, gt, !1),
                            mt !== null &&
                                ni !== null &&
                                vm(Fe, ni, mt, gt, !0);
                    }
                }
                e: {
                    if (
                        ((Ne = xe ? Vn(xe) : window),
                        (at = Ne.nodeName && Ne.nodeName.toLowerCase()),
                        at === 'select' ||
                            (at === 'input' && Ne.type === 'file'))
                    )
                        var xt = mm;
                    else if (Uc(Ne))
                        if (Ja) xt = Nn;
                        else {
                            xt = gm;
                            var Ct = Qa;
                        }
                    else
                        (at = Ne.nodeName) &&
                            at.toLowerCase() === 'input' &&
                            (Ne.type === 'checkbox' || Ne.type === 'radio') &&
                            (xt = zh);
                    if (xt && (xt = xt(o, xe))) {
                        Ka(Fe, xt, m, Ue);
                        break e;
                    }
                    Ct && Ct(o, Ne, xe),
                        o === 'focusout' &&
                            (Ct = Ne._wrapperState) &&
                            Ct.controlled &&
                            Ne.type === 'number' &&
                            ot(Ne, 'number', Ne.value);
                }
                switch (((Ct = xe ? Vn(xe) : window), o)) {
                    case 'focusin':
                        (Uc(Ct) || Ct.contentEditable === 'true') &&
                            ((fs = Ct), (ea = xe), (Ql = null));
                        break;
                    case 'focusout':
                        Ql = ea = fs = null;
                        break;
                    case 'mousedown':
                        ai = !0;
                        break;
                    case 'contextmenu':
                    case 'mouseup':
                    case 'dragend':
                        (ai = !1), Bc(Fe, m, Ue);
                        break;
                    case 'selectionchange':
                        if (Fc) break;
                    case 'keydown':
                    case 'keyup':
                        Bc(Fe, m, Ue);
                }
                var Rt;
                if (Ni)
                    e: {
                        switch (o) {
                            case 'compositionstart':
                                var Ot = 'onCompositionStart';
                                break e;
                            case 'compositionend':
                                Ot = 'onCompositionEnd';
                                break e;
                            case 'compositionupdate':
                                Ot = 'onCompositionUpdate';
                                break e;
                        }
                        Ot = void 0;
                    }
                else
                    So
                        ? Bh(o, m) && (Ot = 'onCompositionEnd')
                        : o === 'keydown' &&
                          m.keyCode === 229 &&
                          (Ot = 'onCompositionStart');
                Ot &&
                    ($a &&
                        m.locale !== 'ko' &&
                        (So || Ot !== 'onCompositionStart'
                            ? Ot === 'onCompositionEnd' && So && (Rt = Yl())
                            : ((jr = Ue),
                              (Lh = 'value' in jr ? jr.value : jr.textContent),
                              (So = !0))),
                    (Ct = jc(xe, Ot)),
                    0 < Ct.length &&
                        ((Ot = new Nh(Ot, o, null, m, Ue)),
                        Fe.push({ event: Ot, listeners: Ct }),
                        Rt
                            ? (Ot.data = Rt)
                            : ((Rt = Nc(m)), Rt !== null && (Ot.data = Rt)))),
                    (Rt = Rn ? dm(o, m) : Zl(o, m)) &&
                        ((xe = jc(xe, 'onBeforeInput')),
                        0 < xe.length &&
                            ((Ue = new Nh(
                                'onBeforeInput',
                                'beforeinput',
                                null,
                                m,
                                Ue
                            )),
                            Fe.push({ event: Ue, listeners: xe }),
                            (Ue.data = Rt)));
            }
            tl(Fe, u);
        });
    }
    function il(o, u, m) {
        return { instance: o, listener: u, currentTarget: m };
    }
    function jc(o, u) {
        for (var m = u + 'Capture', _ = []; o !== null; ) {
            var A = o,
                P = A.stateNode;
            A.tag === 5 &&
                P !== null &&
                ((A = P),
                (P = mo(o, m)),
                P != null && _.unshift(il(o, P, A)),
                (P = mo(o, u)),
                P != null && _.push(il(o, P, A))),
                (o = o.return);
        }
        return _;
    }
    function ta(o) {
        if (o === null) return null;
        do o = o.return;
        while (o && o.tag !== 5);
        return o || null;
    }
    function vm(o, u, m, _, A) {
        for (var P = u._reactName, O = []; m !== null && m !== _; ) {
            var Y = m,
                Z = Y.alternate,
                xe = Y.stateNode;
            if (Z !== null && Z === _) break;
            Y.tag === 5 &&
                xe !== null &&
                ((Y = xe),
                A
                    ? ((Z = mo(m, P)), Z != null && O.unshift(il(m, Z, Y)))
                    : A || ((Z = mo(m, P)), Z != null && O.push(il(m, Z, Y)))),
                (m = m.return);
        }
        O.length !== 0 && o.push({ event: u, listeners: O });
    }
    var $v = /\r\n?/g,
        xm = /\u0000|\uFFFD/g;
    function Xh(o) {
        return (typeof o == 'string' ? o : '' + o)
            .replace(
                $v,
                `
`
            )
            .replace(xm, '');
    }
    function su(o, u, m) {
        if (((u = Xh(u)), Xh(o) !== u && m)) throw Error(t(425));
    }
    function ou() {}
    var rl = null,
        jh = null;
    function qh(o, u) {
        return (
            o === 'textarea' ||
            o === 'noscript' ||
            typeof u.children == 'string' ||
            typeof u.children == 'number' ||
            (typeof u.dangerouslySetInnerHTML == 'object' &&
                u.dangerouslySetInnerHTML !== null &&
                u.dangerouslySetInnerHTML.__html != null)
        );
    }
    var $h = typeof setTimeout == 'function' ? setTimeout : void 0,
        Yh = typeof clearTimeout == 'function' ? clearTimeout : void 0,
        qc = typeof Promise == 'function' ? Promise : void 0,
        Yv =
            typeof queueMicrotask == 'function'
                ? queueMicrotask
                : typeof qc < 'u'
                  ? function (o) {
                        return qc.resolve(null).then(o).catch(_m);
                    }
                  : $h;
    function _m(o) {
        setTimeout(function () {
            throw o;
        });
    }
    function $c(o, u) {
        var m = u,
            _ = 0;
        do {
            var A = m.nextSibling;
            if ((o.removeChild(m), A && A.nodeType === 8))
                if (((m = A.data), m === '/$')) {
                    if (_ === 0) {
                        o.removeChild(A), $l(u);
                        return;
                    }
                    _--;
                } else (m !== '$' && m !== '$?' && m !== '$!') || _++;
            m = A;
        } while (m);
        $l(u);
    }
    function ks(o) {
        for (; o != null; o = o.nextSibling) {
            var u = o.nodeType;
            if (u === 1 || u === 3) break;
            if (u === 8) {
                if (((u = o.data), u === '$' || u === '$!' || u === '$?'))
                    break;
                if (u === '/$') return null;
            }
        }
        return o;
    }
    function Kh(o) {
        o = o.previousSibling;
        for (var u = 0; o; ) {
            if (o.nodeType === 8) {
                var m = o.data;
                if (m === '$' || m === '$!' || m === '$?') {
                    if (u === 0) return o;
                    u--;
                } else m === '/$' && u++;
            }
            o = o.previousSibling;
        }
        return null;
    }
    var na = Math.random().toString(36).slice(2),
        ti = '__reactFiber$' + na,
        sl = '__reactProps$' + na,
        dr = '__reactContainer$' + na,
        ia = '__reactEvents$' + na,
        Yc = '__reactListeners$' + na,
        Kc = '__reactHandles$' + na;
    function To(o) {
        var u = o[ti];
        if (u) return u;
        for (var m = o.parentNode; m; ) {
            if ((u = m[dr] || m[ti])) {
                if (
                    ((m = u.alternate),
                    u.child !== null || (m !== null && m.child !== null))
                )
                    for (o = Kh(o); o !== null; ) {
                        if ((m = o[ti])) return m;
                        o = Kh(o);
                    }
                return u;
            }
            (o = m), (m = o.parentNode);
        }
        return null;
    }
    function Fs(o) {
        return (
            (o = o[ti] || o[dr]),
            !o || (o.tag !== 5 && o.tag !== 6 && o.tag !== 13 && o.tag !== 3)
                ? null
                : o
        );
    }
    function Vn(o) {
        if (o.tag === 5 || o.tag === 6) return o.stateNode;
        throw Error(t(33));
    }
    function Zc(o) {
        return o[sl] || null;
    }
    var Zh = [],
        li = -1;
    function On(o) {
        return { current: o };
    }
    function Sn(o) {
        0 > li || ((o.current = Zh[li]), (Zh[li] = null), li--);
    }
    function yn(o, u) {
        li++, (Zh[li] = o.current), (o.current = u);
    }
    var Bs = {},
        gi = On(Bs),
        Ui = On(!1),
        zs = Bs;
    function ra(o, u) {
        var m = o.type.contextTypes;
        if (!m) return Bs;
        var _ = o.stateNode;
        if (_ && _.__reactInternalMemoizedUnmaskedChildContext === u)
            return _.__reactInternalMemoizedMaskedChildContext;
        var A = {},
            P;
        for (P in m) A[P] = u[P];
        return (
            _ &&
                ((o = o.stateNode),
                (o.__reactInternalMemoizedUnmaskedChildContext = u),
                (o.__reactInternalMemoizedMaskedChildContext = A)),
            A
        );
    }
    function Ei(o) {
        return (o = o.childContextTypes), o != null;
    }
    function au() {
        Sn(Ui), Sn(gi);
    }
    function Jh(o, u, m) {
        if (gi.current !== Bs) throw Error(t(168));
        yn(gi, u), yn(Ui, m);
    }
    function lu(o, u, m) {
        var _ = o.stateNode;
        if (((u = u.childContextTypes), typeof _.getChildContext != 'function'))
            return m;
        _ = _.getChildContext();
        for (var A in _)
            if (!(A in u)) throw Error(t(108, Re(o) || 'Unknown', A));
        return Q({}, m, _);
    }
    function sa(o) {
        return (
            (o =
                ((o = o.stateNode) &&
                    o.__reactInternalMemoizedMergedChildContext) ||
                Bs),
            (zs = gi.current),
            yn(gi, o),
            yn(Ui, Ui.current),
            !0
        );
    }
    function Qh(o, u, m) {
        var _ = o.stateNode;
        if (!_) throw Error(t(169));
        m
            ? ((o = lu(o, u, zs)),
              (_.__reactInternalMemoizedMergedChildContext = o),
              Sn(Ui),
              Sn(gi),
              yn(gi, o))
            : Sn(Ui),
            yn(Ui, m);
    }
    var Kr = null,
        uu = !1,
        Jc = !1;
    function cu(o) {
        Kr === null ? (Kr = [o]) : Kr.push(o);
    }
    function Sm(o) {
        (uu = !0), cu(o);
    }
    function ds() {
        if (!Jc && Kr !== null) {
            Jc = !0;
            var o = 0,
                u = rn;
            try {
                var m = Kr;
                for (rn = 1; o < m.length; o++) {
                    var _ = m[o];
                    do _ = _(!0);
                    while (_ !== null);
                }
                (Kr = null), (uu = !1);
            } catch (A) {
                throw (Kr !== null && (Kr = Kr.slice(o + 1)), le(Et, ds), A);
            } finally {
                (rn = u), (Jc = !1);
            }
        }
        return null;
    }
    var oa = [],
        Ki = 0,
        Qc = null,
        ef = 0,
        Oi = [],
        ui = 0,
        aa = null,
        qe = 1,
        Dr = '';
    function Vs(o, u) {
        (oa[Ki++] = ef), (oa[Ki++] = Qc), (Qc = o), (ef = u);
    }
    function ed(o, u, m) {
        (Oi[ui++] = qe), (Oi[ui++] = Dr), (Oi[ui++] = aa), (aa = o);
        var _ = qe;
        o = Dr;
        var A = 32 - Zt(_) - 1;
        (_ &= ~(1 << A)), (m += 1);
        var P = 32 - Zt(u) + A;
        if (30 < P) {
            var O = A - (A % 5);
            (P = (_ & ((1 << O) - 1)).toString(32)),
                (_ >>= O),
                (A -= O),
                (qe = (1 << (32 - Zt(u) + A)) | (m << A) | _),
                (Dr = P + o);
        } else (qe = (1 << P) | (m << A) | _), (Dr = o);
    }
    function td(o) {
        o.return !== null && (Vs(o, 1), ed(o, 1, 0));
    }
    function Hs(o) {
        for (; o === Qc; )
            (Qc = oa[--Ki]), (oa[Ki] = null), (ef = oa[--Ki]), (oa[Ki] = null);
        for (; o === aa; )
            (aa = Oi[--ui]),
                (Oi[ui] = null),
                (Dr = Oi[--ui]),
                (Oi[ui] = null),
                (qe = Oi[--ui]),
                (Oi[ui] = null);
    }
    var yi = null,
        ki = null,
        Tn = !1,
        Nr = null;
    function nd(o, u) {
        var m = vs(5, null, null, 0);
        (m.elementType = 'DELETED'),
            (m.stateNode = u),
            (m.return = o),
            (u = o.deletions),
            u === null ? ((o.deletions = [m]), (o.flags |= 16)) : u.push(m);
    }
    function id(o, u) {
        switch (o.tag) {
            case 5:
                var m = o.type;
                return (
                    (u =
                        u.nodeType !== 1 ||
                        m.toLowerCase() !== u.nodeName.toLowerCase()
                            ? null
                            : u),
                    u !== null
                        ? ((o.stateNode = u),
                          (yi = o),
                          (ki = ks(u.firstChild)),
                          !0)
                        : !1
                );
            case 6:
                return (
                    (u = o.pendingProps === '' || u.nodeType !== 3 ? null : u),
                    u !== null
                        ? ((o.stateNode = u), (yi = o), (ki = null), !0)
                        : !1
                );
            case 13:
                return (
                    (u = u.nodeType !== 8 ? null : u),
                    u !== null
                        ? ((m = aa !== null ? { id: qe, overflow: Dr } : null),
                          (o.memoizedState = {
                              dehydrated: u,
                              treeContext: m,
                              retryLane: 1073741824,
                          }),
                          (m = vs(18, null, null, 0)),
                          (m.stateNode = u),
                          (m.return = o),
                          (o.child = m),
                          (yi = o),
                          (ki = null),
                          !0)
                        : !1
                );
            default:
                return !1;
        }
    }
    function tf(o) {
        return (o.mode & 1) !== 0 && (o.flags & 128) === 0;
    }
    function nf(o) {
        if (Tn) {
            var u = ki;
            if (u) {
                var m = u;
                if (!id(o, u)) {
                    if (tf(o)) throw Error(t(418));
                    u = ks(m.nextSibling);
                    var _ = yi;
                    u && id(o, u)
                        ? nd(_, m)
                        : ((o.flags = (o.flags & -4097) | 2),
                          (Tn = !1),
                          (yi = o));
                }
            } else {
                if (tf(o)) throw Error(t(418));
                (o.flags = (o.flags & -4097) | 2), (Tn = !1), (yi = o);
            }
        }
    }
    function rf(o) {
        for (
            o = o.return;
            o !== null && o.tag !== 5 && o.tag !== 3 && o.tag !== 13;

        )
            o = o.return;
        yi = o;
    }
    function ol(o) {
        if (o !== yi) return !1;
        if (!Tn) return rf(o), (Tn = !0), !1;
        var u;
        if (
            ((u = o.tag !== 3) &&
                !(u = o.tag !== 5) &&
                ((u = o.type),
                (u =
                    u !== 'head' &&
                    u !== 'body' &&
                    !qh(o.type, o.memoizedProps))),
            u && (u = ki))
        ) {
            if (tf(o)) throw (rd(), Error(t(418)));
            for (; u; ) nd(o, u), (u = ks(u.nextSibling));
        }
        if ((rf(o), o.tag === 13)) {
            if (
                ((o = o.memoizedState),
                (o = o !== null ? o.dehydrated : null),
                !o)
            )
                throw Error(t(317));
            e: {
                for (o = o.nextSibling, u = 0; o; ) {
                    if (o.nodeType === 8) {
                        var m = o.data;
                        if (m === '/$') {
                            if (u === 0) {
                                ki = ks(o.nextSibling);
                                break e;
                            }
                            u--;
                        } else (m !== '$' && m !== '$!' && m !== '$?') || u++;
                    }
                    o = o.nextSibling;
                }
                ki = null;
            }
        } else ki = yi ? ks(o.stateNode.nextSibling) : null;
        return !0;
    }
    function rd() {
        for (var o = ki; o; ) o = ks(o.nextSibling);
    }
    function Ao() {
        (ki = yi = null), (Tn = !1);
    }
    function al(o) {
        Nr === null ? (Nr = [o]) : Nr.push(o);
    }
    var Kv = L.ReactCurrentBatchConfig;
    function fu(o, u, m) {
        if (
            ((o = m.ref),
            o !== null && typeof o != 'function' && typeof o != 'object')
        ) {
            if (m._owner) {
                if (((m = m._owner), m)) {
                    if (m.tag !== 1) throw Error(t(309));
                    var _ = m.stateNode;
                }
                if (!_) throw Error(t(147, o));
                var A = _,
                    P = '' + o;
                return u !== null &&
                    u.ref !== null &&
                    typeof u.ref == 'function' &&
                    u.ref._stringRef === P
                    ? u.ref
                    : ((u = function (O) {
                          var Y = A.refs;
                          O === null ? delete Y[P] : (Y[P] = O);
                      }),
                      (u._stringRef = P),
                      u);
            }
            if (typeof o != 'string') throw Error(t(284));
            if (!m._owner) throw Error(t(290, o));
        }
        return o;
    }
    function hu(o, u) {
        throw (
            ((o = Object.prototype.toString.call(u)),
            Error(
                t(
                    31,
                    o === '[object Object]'
                        ? 'object with keys {' + Object.keys(u).join(', ') + '}'
                        : o
                )
            ))
        );
    }
    function sd(o) {
        var u = o._init;
        return u(o._payload);
    }
    function od(o) {
        function u(he, J) {
            if (o) {
                var de = he.deletions;
                de === null
                    ? ((he.deletions = [J]), (he.flags |= 16))
                    : de.push(J);
            }
        }
        function m(he, J) {
            if (!o) return null;
            for (; J !== null; ) u(he, J), (J = J.sibling);
            return null;
        }
        function _(he, J) {
            for (he = new Map(); J !== null; )
                J.key !== null ? he.set(J.key, J) : he.set(J.index, J),
                    (J = J.sibling);
            return he;
        }
        function A(he, J) {
            return (he = vl(he, J)), (he.index = 0), (he.sibling = null), he;
        }
        function P(he, J, de) {
            return (
                (he.index = de),
                o
                    ? ((de = he.alternate),
                      de !== null
                          ? ((de = de.index),
                            de < J ? ((he.flags |= 2), J) : de)
                          : ((he.flags |= 2), J))
                    : ((he.flags |= 1048576), J)
            );
        }
        function O(he) {
            return o && he.alternate === null && (he.flags |= 2), he;
        }
        function Y(he, J, de, He) {
            return J === null || J.tag !== 6
                ? ((J = m0(de, he.mode, He)), (J.return = he), J)
                : ((J = A(J, de)), (J.return = he), J);
        }
        function Z(he, J, de, He) {
            var xt = de.type;
            return xt === B
                ? Ue(he, J, de.props.children, He, de.key)
                : J !== null &&
                    (J.elementType === xt ||
                        (typeof xt == 'object' &&
                            xt !== null &&
                            xt.$$typeof === ce &&
                            sd(xt) === J.type))
                  ? ((He = A(J, de.props)),
                    (He.ref = fu(he, J, de)),
                    (He.return = he),
                    He)
                  : ((He = Wm(de.type, de.key, de.props, null, he.mode, He)),
                    (He.ref = fu(he, J, de)),
                    (He.return = he),
                    He);
        }
        function xe(he, J, de, He) {
            return J === null ||
                J.tag !== 4 ||
                J.stateNode.containerInfo !== de.containerInfo ||
                J.stateNode.implementation !== de.implementation
                ? ((J = g0(de, he.mode, He)), (J.return = he), J)
                : ((J = A(J, de.children || [])), (J.return = he), J);
        }
        function Ue(he, J, de, He, xt) {
            return J === null || J.tag !== 7
                ? ((J = bu(de, he.mode, He, xt)), (J.return = he), J)
                : ((J = A(J, de)), (J.return = he), J);
        }
        function Fe(he, J, de) {
            if ((typeof J == 'string' && J !== '') || typeof J == 'number')
                return (J = m0('' + J, he.mode, de)), (J.return = he), J;
            if (typeof J == 'object' && J !== null) {
                switch (J.$$typeof) {
                    case F:
                        return (
                            (de = Wm(
                                J.type,
                                J.key,
                                J.props,
                                null,
                                he.mode,
                                de
                            )),
                            (de.ref = fu(he, null, J)),
                            (de.return = he),
                            de
                        );
                    case N:
                        return (J = g0(J, he.mode, de)), (J.return = he), J;
                    case ce:
                        var He = J._init;
                        return Fe(he, He(J._payload), de);
                }
                if ($(J) || oe(J))
                    return (J = bu(J, he.mode, de, null)), (J.return = he), J;
                hu(he, J);
            }
            return null;
        }
        function Ne(he, J, de, He) {
            var xt = J !== null ? J.key : null;
            if ((typeof de == 'string' && de !== '') || typeof de == 'number')
                return xt !== null ? null : Y(he, J, '' + de, He);
            if (typeof de == 'object' && de !== null) {
                switch (de.$$typeof) {
                    case F:
                        return de.key === xt ? Z(he, J, de, He) : null;
                    case N:
                        return de.key === xt ? xe(he, J, de, He) : null;
                    case ce:
                        return (xt = de._init), Ne(he, J, xt(de._payload), He);
                }
                if ($(de) || oe(de))
                    return xt !== null ? null : Ue(he, J, de, He, null);
                hu(he, de);
            }
            return null;
        }
        function at(he, J, de, He, xt) {
            if ((typeof He == 'string' && He !== '') || typeof He == 'number')
                return (he = he.get(de) || null), Y(J, he, '' + He, xt);
            if (typeof He == 'object' && He !== null) {
                switch (He.$$typeof) {
                    case F:
                        return (
                            (he =
                                he.get(He.key === null ? de : He.key) || null),
                            Z(J, he, He, xt)
                        );
                    case N:
                        return (
                            (he =
                                he.get(He.key === null ? de : He.key) || null),
                            xe(J, he, He, xt)
                        );
                    case ce:
                        var Ct = He._init;
                        return at(he, J, de, Ct(He._payload), xt);
                }
                if ($(He) || oe(He))
                    return (he = he.get(de) || null), Ue(J, he, He, xt, null);
                hu(J, He);
            }
            return null;
        }
        function mt(he, J, de, He) {
            for (
                var xt = null, Ct = null, Rt = J, Ot = (J = 0), Ri = null;
                Rt !== null && Ot < de.length;
                Ot++
            ) {
                Rt.index > Ot ? ((Ri = Rt), (Rt = null)) : (Ri = Rt.sibling);
                var cn = Ne(he, Rt, de[Ot], He);
                if (cn === null) {
                    Rt === null && (Rt = Ri);
                    break;
                }
                o && Rt && cn.alternate === null && u(he, Rt),
                    (J = P(cn, J, Ot)),
                    Ct === null ? (xt = cn) : (Ct.sibling = cn),
                    (Ct = cn),
                    (Rt = Ri);
            }
            if (Ot === de.length) return m(he, Rt), Tn && Vs(he, Ot), xt;
            if (Rt === null) {
                for (; Ot < de.length; Ot++)
                    (Rt = Fe(he, de[Ot], He)),
                        Rt !== null &&
                            ((J = P(Rt, J, Ot)),
                            Ct === null ? (xt = Rt) : (Ct.sibling = Rt),
                            (Ct = Rt));
                return Tn && Vs(he, Ot), xt;
            }
            for (Rt = _(he, Rt); Ot < de.length; Ot++)
                (Ri = at(Rt, he, Ot, de[Ot], He)),
                    Ri !== null &&
                        (o &&
                            Ri.alternate !== null &&
                            Rt.delete(Ri.key === null ? Ot : Ri.key),
                        (J = P(Ri, J, Ot)),
                        Ct === null ? (xt = Ri) : (Ct.sibling = Ri),
                        (Ct = Ri));
            return (
                o &&
                    Rt.forEach(function (xl) {
                        return u(he, xl);
                    }),
                Tn && Vs(he, Ot),
                xt
            );
        }
        function gt(he, J, de, He) {
            var xt = oe(de);
            if (typeof xt != 'function') throw Error(t(150));
            if (((de = xt.call(de)), de == null)) throw Error(t(151));
            for (
                var Ct = (xt = null),
                    Rt = J,
                    Ot = (J = 0),
                    Ri = null,
                    cn = de.next();
                Rt !== null && !cn.done;
                Ot++, cn = de.next()
            ) {
                Rt.index > Ot ? ((Ri = Rt), (Rt = null)) : (Ri = Rt.sibling);
                var xl = Ne(he, Rt, cn.value, He);
                if (xl === null) {
                    Rt === null && (Rt = Ri);
                    break;
                }
                o && Rt && xl.alternate === null && u(he, Rt),
                    (J = P(xl, J, Ot)),
                    Ct === null ? (xt = xl) : (Ct.sibling = xl),
                    (Ct = xl),
                    (Rt = Ri);
            }
            if (cn.done) return m(he, Rt), Tn && Vs(he, Ot), xt;
            if (Rt === null) {
                for (; !cn.done; Ot++, cn = de.next())
                    (cn = Fe(he, cn.value, He)),
                        cn !== null &&
                            ((J = P(cn, J, Ot)),
                            Ct === null ? (xt = cn) : (Ct.sibling = cn),
                            (Ct = cn));
                return Tn && Vs(he, Ot), xt;
            }
            for (Rt = _(he, Rt); !cn.done; Ot++, cn = de.next())
                (cn = at(Rt, he, Ot, cn.value, He)),
                    cn !== null &&
                        (o &&
                            cn.alternate !== null &&
                            Rt.delete(cn.key === null ? Ot : cn.key),
                        (J = P(cn, J, Ot)),
                        Ct === null ? (xt = cn) : (Ct.sibling = cn),
                        (Ct = cn));
            return (
                o &&
                    Rt.forEach(function (AL) {
                        return u(he, AL);
                    }),
                Tn && Vs(he, Ot),
                xt
            );
        }
        function ni(he, J, de, He) {
            if (
                (typeof de == 'object' &&
                    de !== null &&
                    de.type === B &&
                    de.key === null &&
                    (de = de.props.children),
                typeof de == 'object' && de !== null)
            ) {
                switch (de.$$typeof) {
                    case F:
                        e: {
                            for (var xt = de.key, Ct = J; Ct !== null; ) {
                                if (Ct.key === xt) {
                                    if (((xt = de.type), xt === B)) {
                                        if (Ct.tag === 7) {
                                            m(he, Ct.sibling),
                                                (J = A(Ct, de.props.children)),
                                                (J.return = he),
                                                (he = J);
                                            break e;
                                        }
                                    } else if (
                                        Ct.elementType === xt ||
                                        (typeof xt == 'object' &&
                                            xt !== null &&
                                            xt.$$typeof === ce &&
                                            sd(xt) === Ct.type)
                                    ) {
                                        m(he, Ct.sibling),
                                            (J = A(Ct, de.props)),
                                            (J.ref = fu(he, Ct, de)),
                                            (J.return = he),
                                            (he = J);
                                        break e;
                                    }
                                    m(he, Ct);
                                    break;
                                } else u(he, Ct);
                                Ct = Ct.sibling;
                            }
                            de.type === B
                                ? ((J = bu(
                                      de.props.children,
                                      he.mode,
                                      He,
                                      de.key
                                  )),
                                  (J.return = he),
                                  (he = J))
                                : ((He = Wm(
                                      de.type,
                                      de.key,
                                      de.props,
                                      null,
                                      he.mode,
                                      He
                                  )),
                                  (He.ref = fu(he, J, de)),
                                  (He.return = he),
                                  (he = He));
                        }
                        return O(he);
                    case N:
                        e: {
                            for (Ct = de.key; J !== null; ) {
                                if (J.key === Ct)
                                    if (
                                        J.tag === 4 &&
                                        J.stateNode.containerInfo ===
                                            de.containerInfo &&
                                        J.stateNode.implementation ===
                                            de.implementation
                                    ) {
                                        m(he, J.sibling),
                                            (J = A(J, de.children || [])),
                                            (J.return = he),
                                            (he = J);
                                        break e;
                                    } else {
                                        m(he, J);
                                        break;
                                    }
                                else u(he, J);
                                J = J.sibling;
                            }
                            (J = g0(de, he.mode, He)),
                                (J.return = he),
                                (he = J);
                        }
                        return O(he);
                    case ce:
                        return (Ct = de._init), ni(he, J, Ct(de._payload), He);
                }
                if ($(de)) return mt(he, J, de, He);
                if (oe(de)) return gt(he, J, de, He);
                hu(he, de);
            }
            return (typeof de == 'string' && de !== '') || typeof de == 'number'
                ? ((de = '' + de),
                  J !== null && J.tag === 6
                      ? (m(he, J.sibling),
                        (J = A(J, de)),
                        (J.return = he),
                        (he = J))
                      : (m(he, J),
                        (J = m0(de, he.mode, He)),
                        (J.return = he),
                        (he = J)),
                  O(he))
                : m(he, J);
        }
        return ni;
    }
    var la = od(!0),
        du = od(!1),
        ua = On(null),
        ca = null,
        Gs = null,
        ll = null;
    function fa() {
        ll = Gs = ca = null;
    }
    function pu(o) {
        var u = ua.current;
        Sn(ua), (o._currentValue = u);
    }
    function mu(o, u, m) {
        for (; o !== null; ) {
            var _ = o.alternate;
            if (
                ((o.childLanes & u) !== u
                    ? ((o.childLanes |= u), _ !== null && (_.childLanes |= u))
                    : _ !== null &&
                      (_.childLanes & u) !== u &&
                      (_.childLanes |= u),
                o === m)
            )
                break;
            o = o.return;
        }
    }
    function Co(o, u) {
        (ca = o),
            (ll = Gs = null),
            (o = o.dependencies),
            o !== null &&
                o.firstContext !== null &&
                ((o.lanes & u) !== 0 && (Gt = !0), (o.firstContext = null));
    }
    function pr(o) {
        var u = o._currentValue;
        if (ll !== o)
            if (
                ((o = { context: o, memoizedValue: u, next: null }),
                Gs === null)
            ) {
                if (ca === null) throw Error(t(308));
                (Gs = o), (ca.dependencies = { lanes: 0, firstContext: o });
            } else Gs = Gs.next = o;
        return u;
    }
    var Ws = null;
    function ad(o) {
        Ws === null ? (Ws = [o]) : Ws.push(o);
    }
    function gu(o, u, m, _) {
        var A = u.interleaved;
        return (
            A === null
                ? ((m.next = m), ad(u))
                : ((m.next = A.next), (A.next = m)),
            (u.interleaved = m),
            Zr(o, _)
        );
    }
    function Zr(o, u) {
        o.lanes |= u;
        var m = o.alternate;
        for (m !== null && (m.lanes |= u), m = o, o = o.return; o !== null; )
            (o.childLanes |= u),
                (m = o.alternate),
                m !== null && (m.childLanes |= u),
                (m = o),
                (o = o.return);
        return m.tag === 3 ? m.stateNode : null;
    }
    var pn = !1;
    function Ht(o) {
        o.updateQueue = {
            baseState: o.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: { pending: null, interleaved: null, lanes: 0 },
            effects: null,
        };
    }
    function Hn(o, u) {
        (o = o.updateQueue),
            u.updateQueue === o &&
                (u.updateQueue = {
                    baseState: o.baseState,
                    firstBaseUpdate: o.firstBaseUpdate,
                    lastBaseUpdate: o.lastBaseUpdate,
                    shared: o.shared,
                    effects: o.effects,
                });
    }
    function mn(o, u) {
        return {
            eventTime: o,
            lane: u,
            tag: 0,
            payload: null,
            callback: null,
            next: null,
        };
    }
    function bn(o, u, m) {
        var _ = o.updateQueue;
        if (_ === null) return null;
        if (((_ = _.shared), (on & 2) !== 0)) {
            var A = _.pending;
            return (
                A === null ? (u.next = u) : ((u.next = A.next), (A.next = u)),
                (_.pending = u),
                Zr(o, m)
            );
        }
        return (
            (A = _.interleaved),
            A === null
                ? ((u.next = u), ad(_))
                : ((u.next = A.next), (A.next = u)),
            (_.interleaved = u),
            Zr(o, m)
        );
    }
    function Ti(o, u, m) {
        if (
            ((u = u.updateQueue),
            u !== null && ((u = u.shared), (m & 4194240) !== 0))
        ) {
            var _ = u.lanes;
            (_ &= o.pendingLanes), (m |= _), (u.lanes = m), Ha(o, m);
        }
    }
    function ha(o, u) {
        var m = o.updateQueue,
            _ = o.alternate;
        if (_ !== null && ((_ = _.updateQueue), m === _)) {
            var A = null,
                P = null;
            if (((m = m.firstBaseUpdate), m !== null)) {
                do {
                    var O = {
                        eventTime: m.eventTime,
                        lane: m.lane,
                        tag: m.tag,
                        payload: m.payload,
                        callback: m.callback,
                        next: null,
                    };
                    P === null ? (A = P = O) : (P = P.next = O), (m = m.next);
                } while (m !== null);
                P === null ? (A = P = u) : (P = P.next = u);
            } else A = P = u;
            (m = {
                baseState: _.baseState,
                firstBaseUpdate: A,
                lastBaseUpdate: P,
                shared: _.shared,
                effects: _.effects,
            }),
                (o.updateQueue = m);
            return;
        }
        (o = m.lastBaseUpdate),
            o === null ? (m.firstBaseUpdate = u) : (o.next = u),
            (m.lastBaseUpdate = u);
    }
    function kn(o, u, m, _) {
        var A = o.updateQueue;
        pn = !1;
        var P = A.firstBaseUpdate,
            O = A.lastBaseUpdate,
            Y = A.shared.pending;
        if (Y !== null) {
            A.shared.pending = null;
            var Z = Y,
                xe = Z.next;
            (Z.next = null), O === null ? (P = xe) : (O.next = xe), (O = Z);
            var Ue = o.alternate;
            Ue !== null &&
                ((Ue = Ue.updateQueue),
                (Y = Ue.lastBaseUpdate),
                Y !== O &&
                    (Y === null ? (Ue.firstBaseUpdate = xe) : (Y.next = xe),
                    (Ue.lastBaseUpdate = Z)));
        }
        if (P !== null) {
            var Fe = A.baseState;
            (O = 0), (Ue = xe = Z = null), (Y = P);
            do {
                var Ne = Y.lane,
                    at = Y.eventTime;
                if ((_ & Ne) === Ne) {
                    Ue !== null &&
                        (Ue = Ue.next =
                            {
                                eventTime: at,
                                lane: 0,
                                tag: Y.tag,
                                payload: Y.payload,
                                callback: Y.callback,
                                next: null,
                            });
                    e: {
                        var mt = o,
                            gt = Y;
                        switch (((Ne = u), (at = m), gt.tag)) {
                            case 1:
                                if (
                                    ((mt = gt.payload), typeof mt == 'function')
                                ) {
                                    Fe = mt.call(at, Fe, Ne);
                                    break e;
                                }
                                Fe = mt;
                                break e;
                            case 3:
                                mt.flags = (mt.flags & -65537) | 128;
                            case 0:
                                if (
                                    ((mt = gt.payload),
                                    (Ne =
                                        typeof mt == 'function'
                                            ? mt.call(at, Fe, Ne)
                                            : mt),
                                    Ne == null)
                                )
                                    break e;
                                Fe = Q({}, Fe, Ne);
                                break e;
                            case 2:
                                pn = !0;
                        }
                    }
                    Y.callback !== null &&
                        Y.lane !== 0 &&
                        ((o.flags |= 64),
                        (Ne = A.effects),
                        Ne === null ? (A.effects = [Y]) : Ne.push(Y));
                } else
                    (at = {
                        eventTime: at,
                        lane: Ne,
                        tag: Y.tag,
                        payload: Y.payload,
                        callback: Y.callback,
                        next: null,
                    }),
                        Ue === null
                            ? ((xe = Ue = at), (Z = Fe))
                            : (Ue = Ue.next = at),
                        (O |= Ne);
                if (((Y = Y.next), Y === null)) {
                    if (((Y = A.shared.pending), Y === null)) break;
                    (Ne = Y),
                        (Y = Ne.next),
                        (Ne.next = null),
                        (A.lastBaseUpdate = Ne),
                        (A.shared.pending = null);
                }
            } while (!0);
            if (
                (Ue === null && (Z = Fe),
                (A.baseState = Z),
                (A.firstBaseUpdate = xe),
                (A.lastBaseUpdate = Ue),
                (u = A.shared.interleaved),
                u !== null)
            ) {
                A = u;
                do (O |= A.lane), (A = A.next);
                while (A !== u);
            } else P === null && (A.shared.lanes = 0);
            (Tu |= O), (o.lanes = O), (o.memoizedState = Fe);
        }
    }
    function ul(o, u, m) {
        if (((o = u.effects), (u.effects = null), o !== null))
            for (u = 0; u < o.length; u++) {
                var _ = o[u],
                    A = _.callback;
                if (A !== null) {
                    if (((_.callback = null), (_ = m), typeof A != 'function'))
                        throw Error(t(191, A));
                    A.call(_);
                }
            }
    }
    var ps = {},
        mr = On(ps),
        da = On(ps),
        Xs = On(ps);
    function qn(o) {
        if (o === ps) throw Error(t(174));
        return o;
    }
    function yu(o, u) {
        switch ((yn(Xs, u), yn(da, o), yn(mr, ps), (o = u.nodeType), o)) {
            case 9:
            case 11:
                u = (u = u.documentElement) ? u.namespaceURI : $e(null, '');
                break;
            default:
                (o = o === 8 ? u.parentNode : u),
                    (u = o.namespaceURI || null),
                    (o = o.tagName),
                    (u = $e(u, o));
        }
        Sn(mr), yn(mr, u);
    }
    function Ro() {
        Sn(mr), Sn(da), Sn(Xs);
    }
    function pa(o) {
        qn(Xs.current);
        var u = qn(mr.current),
            m = $e(u, o.type);
        u !== m && (yn(da, o), yn(mr, m));
    }
    function cl(o) {
        da.current === o && (Sn(mr), Sn(da));
    }
    var An = On(0);
    function Jr(o) {
        for (var u = o; u !== null; ) {
            if (u.tag === 13) {
                var m = u.memoizedState;
                if (
                    m !== null &&
                    ((m = m.dehydrated),
                    m === null || m.data === '$?' || m.data === '$!')
                )
                    return u;
            } else if (u.tag === 19 && u.memoizedProps.revealOrder !== void 0) {
                if ((u.flags & 128) !== 0) return u;
            } else if (u.child !== null) {
                (u.child.return = u), (u = u.child);
                continue;
            }
            if (u === o) break;
            for (; u.sibling === null; ) {
                if (u.return === null || u.return === o) return null;
                u = u.return;
            }
            (u.sibling.return = u.return), (u = u.sibling);
        }
        return null;
    }
    var fl = [];
    function ms() {
        for (var o = 0; o < fl.length; o++)
            fl[o]._workInProgressVersionPrimary = null;
        fl.length = 0;
    }
    var ma = L.ReactCurrentDispatcher,
        ga = L.ReactCurrentBatchConfig,
        js = 0,
        wn = null,
        Fn = null,
        sn = null,
        Qr = !1,
        Ai = !1,
        bo = 0,
        Zi = 0;
    function vi() {
        throw Error(t(321));
    }
    function vu(o, u) {
        if (u === null) return !1;
        for (var m = 0; m < u.length && m < o.length; m++)
            if (!fr(o[m], u[m])) return !1;
        return !0;
    }
    function xu(o, u, m, _, A, P) {
        if (
            ((js = P),
            (wn = u),
            (u.memoizedState = null),
            (u.updateQueue = null),
            (u.lanes = 0),
            (ma.current = o === null || o.memoizedState === null ? Rm : bm),
            (o = m(_, A)),
            Ai)
        ) {
            P = 0;
            do {
                if (((Ai = !1), (bo = 0), 25 <= P)) throw Error(t(301));
                (P += 1),
                    (sn = Fn = null),
                    (u.updateQueue = null),
                    (ma.current = Pm),
                    (o = m(_, A));
            } while (Ai);
        }
        if (
            ((ma.current = ff),
            (u = Fn !== null && Fn.next !== null),
            (js = 0),
            (sn = Fn = wn = null),
            (Qr = !1),
            u)
        )
            throw Error(t(300));
        return o;
    }
    function ld() {
        var o = bo !== 0;
        return (bo = 0), o;
    }
    function xi() {
        var o = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null,
        };
        return (
            sn === null ? (wn.memoizedState = sn = o) : (sn = sn.next = o), sn
        );
    }
    function gr() {
        if (Fn === null) {
            var o = wn.alternate;
            o = o !== null ? o.memoizedState : null;
        } else o = Fn.next;
        var u = sn === null ? wn.memoizedState : sn.next;
        if (u !== null) (sn = u), (Fn = o);
        else {
            if (o === null) throw Error(t(310));
            (Fn = o),
                (o = {
                    memoizedState: Fn.memoizedState,
                    baseState: Fn.baseState,
                    baseQueue: Fn.baseQueue,
                    queue: Fn.queue,
                    next: null,
                }),
                sn === null ? (wn.memoizedState = sn = o) : (sn = sn.next = o);
        }
        return sn;
    }
    function hl(o, u) {
        return typeof u == 'function' ? u(o) : u;
    }
    function _u(o) {
        var u = gr(),
            m = u.queue;
        if (m === null) throw Error(t(311));
        m.lastRenderedReducer = o;
        var _ = Fn,
            A = _.baseQueue,
            P = m.pending;
        if (P !== null) {
            if (A !== null) {
                var O = A.next;
                (A.next = P.next), (P.next = O);
            }
            (_.baseQueue = A = P), (m.pending = null);
        }
        if (A !== null) {
            (P = A.next), (_ = _.baseState);
            var Y = (O = null),
                Z = null,
                xe = P;
            do {
                var Ue = xe.lane;
                if ((js & Ue) === Ue)
                    Z !== null &&
                        (Z = Z.next =
                            {
                                lane: 0,
                                action: xe.action,
                                hasEagerState: xe.hasEagerState,
                                eagerState: xe.eagerState,
                                next: null,
                            }),
                        (_ = xe.hasEagerState
                            ? xe.eagerState
                            : o(_, xe.action));
                else {
                    var Fe = {
                        lane: Ue,
                        action: xe.action,
                        hasEagerState: xe.hasEagerState,
                        eagerState: xe.eagerState,
                        next: null,
                    };
                    Z === null ? ((Y = Z = Fe), (O = _)) : (Z = Z.next = Fe),
                        (wn.lanes |= Ue),
                        (Tu |= Ue);
                }
                xe = xe.next;
            } while (xe !== null && xe !== P);
            Z === null ? (O = _) : (Z.next = Y),
                fr(_, u.memoizedState) || (Gt = !0),
                (u.memoizedState = _),
                (u.baseState = O),
                (u.baseQueue = Z),
                (m.lastRenderedState = _);
        }
        if (((o = m.interleaved), o !== null)) {
            A = o;
            do (P = A.lane), (wn.lanes |= P), (Tu |= P), (A = A.next);
            while (A !== o);
        } else A === null && (m.lanes = 0);
        return [u.memoizedState, m.dispatch];
    }
    function qs(o) {
        var u = gr(),
            m = u.queue;
        if (m === null) throw Error(t(311));
        m.lastRenderedReducer = o;
        var _ = m.dispatch,
            A = m.pending,
            P = u.memoizedState;
        if (A !== null) {
            m.pending = null;
            var O = (A = A.next);
            do (P = o(P, O.action)), (O = O.next);
            while (O !== A);
            fr(P, u.memoizedState) || (Gt = !0),
                (u.memoizedState = P),
                u.baseQueue === null && (u.baseState = P),
                (m.lastRenderedState = P);
        }
        return [P, _];
    }
    function ud() {}
    function cd(o, u) {
        var m = wn,
            _ = gr(),
            A = u(),
            P = !fr(_.memoizedState, A);
        if (
            (P && ((_.memoizedState = A), (Gt = !0)),
            (_ = _.queue),
            dd(wm.bind(null, m, _, o), [o]),
            _.getSnapshot !== u ||
                P ||
                (sn !== null && sn.memoizedState.tag & 1))
        ) {
            if (
                ((m.flags |= 2048),
                es(9, Su.bind(null, m, _, A, u), void 0, null),
                Ci === null)
            )
                throw Error(t(349));
            (js & 30) !== 0 || sf(m, u, A);
        }
        return A;
    }
    function sf(o, u, m) {
        (o.flags |= 16384),
            (o = { getSnapshot: u, value: m }),
            (u = wn.updateQueue),
            u === null
                ? ((u = { lastEffect: null, stores: null }),
                  (wn.updateQueue = u),
                  (u.stores = [o]))
                : ((m = u.stores), m === null ? (u.stores = [o]) : m.push(o));
    }
    function Su(o, u, m, _) {
        (u.value = m), (u.getSnapshot = _), Mm(u) && fd(o);
    }
    function wm(o, u, m) {
        return m(function () {
            Mm(u) && fd(o);
        });
    }
    function Mm(o) {
        var u = o.getSnapshot;
        o = o.value;
        try {
            var m = u();
            return !fr(o, m);
        } catch {
            return !0;
        }
    }
    function fd(o) {
        var u = Zr(o, 1);
        u !== null && Js(u, o, 1, -1);
    }
    function hd(o) {
        var u = xi();
        return (
            typeof o == 'function' && (o = o()),
            (u.memoizedState = u.baseState = o),
            (o = {
                pending: null,
                interleaved: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: hl,
                lastRenderedState: o,
            }),
            (u.queue = o),
            (o = o.dispatch = ya.bind(null, wn, o)),
            [u.memoizedState, o]
        );
    }
    function es(o, u, m, _) {
        return (
            (o = { tag: o, create: u, destroy: m, deps: _, next: null }),
            (u = wn.updateQueue),
            u === null
                ? ((u = { lastEffect: null, stores: null }),
                  (wn.updateQueue = u),
                  (u.lastEffect = o.next = o))
                : ((m = u.lastEffect),
                  m === null
                      ? (u.lastEffect = o.next = o)
                      : ((_ = m.next),
                        (m.next = o),
                        (o.next = _),
                        (u.lastEffect = o))),
            o
        );
    }
    function Em() {
        return gr().memoizedState;
    }
    function gs(o, u, m, _) {
        var A = xi();
        (wn.flags |= o),
            (A.memoizedState = es(1 | u, m, void 0, _ === void 0 ? null : _));
    }
    function wu(o, u, m, _) {
        var A = gr();
        _ = _ === void 0 ? null : _;
        var P = void 0;
        if (Fn !== null) {
            var O = Fn.memoizedState;
            if (((P = O.destroy), _ !== null && vu(_, O.deps))) {
                A.memoizedState = es(u, m, P, _);
                return;
            }
        }
        (wn.flags |= o), (A.memoizedState = es(1 | u, m, P, _));
    }
    function Fi(o, u) {
        return gs(8390656, 8, o, u);
    }
    function dd(o, u) {
        return wu(2048, 8, o, u);
    }
    function pd(o, u) {
        return wu(4, 2, o, u);
    }
    function Tm(o, u) {
        return wu(4, 4, o, u);
    }
    function Am(o, u) {
        if (typeof u == 'function')
            return (
                (o = o()),
                u(o),
                function () {
                    u(null);
                }
            );
        if (u != null)
            return (
                (o = o()),
                (u.current = o),
                function () {
                    u.current = null;
                }
            );
    }
    function md(o, u, m) {
        return (
            (m = m != null ? m.concat([o]) : null),
            wu(4, 4, Am.bind(null, u, o), m)
        );
    }
    function of() {}
    function Cm(o, u) {
        var m = gr();
        u = u === void 0 ? null : u;
        var _ = m.memoizedState;
        return _ !== null && u !== null && vu(u, _[1])
            ? _[0]
            : ((m.memoizedState = [o, u]), o);
    }
    function yr(o, u) {
        var m = gr();
        u = u === void 0 ? null : u;
        var _ = m.memoizedState;
        return _ !== null && u !== null && vu(u, _[1])
            ? _[0]
            : ((o = o()), (m.memoizedState = [o, u]), o);
    }
    function af(o, u, m) {
        return (js & 21) === 0
            ? (o.baseState && ((o.baseState = !1), (Gt = !0)),
              (o.memoizedState = m))
            : (fr(m, u) ||
                  ((m = ji()), (wn.lanes |= m), (Tu |= m), (o.baseState = !0)),
              u);
    }
    function Zv(o, u) {
        var m = rn;
        (rn = m !== 0 && 4 > m ? m : 4), o(!0);
        var _ = ga.transition;
        ga.transition = {};
        try {
            o(!1), u();
        } finally {
            (rn = m), (ga.transition = _);
        }
    }
    function $s() {
        return gr().memoizedState;
    }
    function lf(o, u, m) {
        var _ = gl(o);
        if (
            ((m = {
                lane: _,
                action: m,
                hasEagerState: !1,
                eagerState: null,
                next: null,
            }),
            Mu(o))
        )
            uf(u, m);
        else if (((m = gu(o, u, m, _)), m !== null)) {
            var A = xr();
            Js(m, o, _, A), cf(m, u, _);
        }
    }
    function ya(o, u, m) {
        var _ = gl(o),
            A = {
                lane: _,
                action: m,
                hasEagerState: !1,
                eagerState: null,
                next: null,
            };
        if (Mu(o)) uf(u, A);
        else {
            var P = o.alternate;
            if (
                o.lanes === 0 &&
                (P === null || P.lanes === 0) &&
                ((P = u.lastRenderedReducer), P !== null)
            )
                try {
                    var O = u.lastRenderedState,
                        Y = P(O, m);
                    if (
                        ((A.hasEagerState = !0), (A.eagerState = Y), fr(Y, O))
                    ) {
                        var Z = u.interleaved;
                        Z === null
                            ? ((A.next = A), ad(u))
                            : ((A.next = Z.next), (Z.next = A)),
                            (u.interleaved = A);
                        return;
                    }
                } catch {
                } finally {
                }
            (m = gu(o, u, A, _)),
                m !== null && ((A = xr()), Js(m, o, _, A), cf(m, u, _));
        }
    }
    function Mu(o) {
        var u = o.alternate;
        return o === wn || (u !== null && u === wn);
    }
    function uf(o, u) {
        Ai = Qr = !0;
        var m = o.pending;
        m === null ? (u.next = u) : ((u.next = m.next), (m.next = u)),
            (o.pending = u);
    }
    function cf(o, u, m) {
        if ((m & 4194240) !== 0) {
            var _ = u.lanes;
            (_ &= o.pendingLanes), (m |= _), (u.lanes = m), Ha(o, m);
        }
    }
    var ff = {
            readContext: pr,
            useCallback: vi,
            useContext: vi,
            useEffect: vi,
            useImperativeHandle: vi,
            useInsertionEffect: vi,
            useLayoutEffect: vi,
            useMemo: vi,
            useReducer: vi,
            useRef: vi,
            useState: vi,
            useDebugValue: vi,
            useDeferredValue: vi,
            useTransition: vi,
            useMutableSource: vi,
            useSyncExternalStore: vi,
            useId: vi,
            unstable_isNewReconciler: !1,
        },
        Rm = {
            readContext: pr,
            useCallback: function (o, u) {
                return (xi().memoizedState = [o, u === void 0 ? null : u]), o;
            },
            useContext: pr,
            useEffect: Fi,
            useImperativeHandle: function (o, u, m) {
                return (
                    (m = m != null ? m.concat([o]) : null),
                    gs(4194308, 4, Am.bind(null, u, o), m)
                );
            },
            useLayoutEffect: function (o, u) {
                return gs(4194308, 4, o, u);
            },
            useInsertionEffect: function (o, u) {
                return gs(4, 2, o, u);
            },
            useMemo: function (o, u) {
                var m = xi();
                return (
                    (u = u === void 0 ? null : u),
                    (o = o()),
                    (m.memoizedState = [o, u]),
                    o
                );
            },
            useReducer: function (o, u, m) {
                var _ = xi();
                return (
                    (u = m !== void 0 ? m(u) : u),
                    (_.memoizedState = _.baseState = u),
                    (o = {
                        pending: null,
                        interleaved: null,
                        lanes: 0,
                        dispatch: null,
                        lastRenderedReducer: o,
                        lastRenderedState: u,
                    }),
                    (_.queue = o),
                    (o = o.dispatch = lf.bind(null, wn, o)),
                    [_.memoizedState, o]
                );
            },
            useRef: function (o) {
                var u = xi();
                return (o = { current: o }), (u.memoizedState = o);
            },
            useState: hd,
            useDebugValue: of,
            useDeferredValue: function (o) {
                return (xi().memoizedState = o);
            },
            useTransition: function () {
                var o = hd(!1),
                    u = o[0];
                return (
                    (o = Zv.bind(null, o[1])), (xi().memoizedState = o), [u, o]
                );
            },
            useMutableSource: function () {},
            useSyncExternalStore: function (o, u, m) {
                var _ = wn,
                    A = xi();
                if (Tn) {
                    if (m === void 0) throw Error(t(407));
                    m = m();
                } else {
                    if (((m = u()), Ci === null)) throw Error(t(349));
                    (js & 30) !== 0 || sf(_, u, m);
                }
                A.memoizedState = m;
                var P = { value: m, getSnapshot: u };
                return (
                    (A.queue = P),
                    Fi(wm.bind(null, _, P, o), [o]),
                    (_.flags |= 2048),
                    es(9, Su.bind(null, _, P, m, u), void 0, null),
                    m
                );
            },
            useId: function () {
                var o = xi(),
                    u = Ci.identifierPrefix;
                if (Tn) {
                    var m = Dr,
                        _ = qe;
                    (m = (_ & ~(1 << (32 - Zt(_) - 1))).toString(32) + m),
                        (u = ':' + u + 'R' + m),
                        (m = bo++),
                        0 < m && (u += 'H' + m.toString(32)),
                        (u += ':');
                } else (m = Zi++), (u = ':' + u + 'r' + m.toString(32) + ':');
                return (o.memoizedState = u);
            },
            unstable_isNewReconciler: !1,
        },
        bm = {
            readContext: pr,
            useCallback: Cm,
            useContext: pr,
            useEffect: dd,
            useImperativeHandle: md,
            useInsertionEffect: pd,
            useLayoutEffect: Tm,
            useMemo: yr,
            useReducer: _u,
            useRef: Em,
            useState: function () {
                return _u(hl);
            },
            useDebugValue: of,
            useDeferredValue: function (o) {
                var u = gr();
                return af(u, Fn.memoizedState, o);
            },
            useTransition: function () {
                var o = _u(hl)[0],
                    u = gr().memoizedState;
                return [o, u];
            },
            useMutableSource: ud,
            useSyncExternalStore: cd,
            useId: $s,
            unstable_isNewReconciler: !1,
        },
        Pm = {
            readContext: pr,
            useCallback: Cm,
            useContext: pr,
            useEffect: dd,
            useImperativeHandle: md,
            useInsertionEffect: pd,
            useLayoutEffect: Tm,
            useMemo: yr,
            useReducer: qs,
            useRef: Em,
            useState: function () {
                return qs(hl);
            },
            useDebugValue: of,
            useDeferredValue: function (o) {
                var u = gr();
                return Fn === null
                    ? (u.memoizedState = o)
                    : af(u, Fn.memoizedState, o);
            },
            useTransition: function () {
                var o = qs(hl)[0],
                    u = gr().memoizedState;
                return [o, u];
            },
            useMutableSource: ud,
            useSyncExternalStore: cd,
            useId: $s,
            unstable_isNewReconciler: !1,
        };
    function Ur(o, u) {
        if (o && o.defaultProps) {
            (u = Q({}, u)), (o = o.defaultProps);
            for (var m in o) u[m] === void 0 && (u[m] = o[m]);
            return u;
        }
        return u;
    }
    function Eu(o, u, m, _) {
        (u = o.memoizedState),
            (m = m(_, u)),
            (m = m == null ? u : Q({}, u, m)),
            (o.memoizedState = m),
            o.lanes === 0 && (o.updateQueue.baseState = m);
    }
    var hf = {
        isMounted: function (o) {
            return (o = o._reactInternals) ? bs(o) === o : !1;
        },
        enqueueSetState: function (o, u, m) {
            o = o._reactInternals;
            var _ = xr(),
                A = gl(o),
                P = mn(_, A);
            (P.payload = u),
                m != null && (P.callback = m),
                (u = bn(o, P, A)),
                u !== null && (Js(u, o, A, _), Ti(u, o, A));
        },
        enqueueReplaceState: function (o, u, m) {
            o = o._reactInternals;
            var _ = xr(),
                A = gl(o),
                P = mn(_, A);
            (P.tag = 1),
                (P.payload = u),
                m != null && (P.callback = m),
                (u = bn(o, P, A)),
                u !== null && (Js(u, o, A, _), Ti(u, o, A));
        },
        enqueueForceUpdate: function (o, u) {
            o = o._reactInternals;
            var m = xr(),
                _ = gl(o),
                A = mn(m, _);
            (A.tag = 2),
                u != null && (A.callback = u),
                (u = bn(o, A, _)),
                u !== null && (Js(u, o, _, m), Ti(u, o, _));
        },
    };
    function Lm(o, u, m, _, A, P, O) {
        return (
            (o = o.stateNode),
            typeof o.shouldComponentUpdate == 'function'
                ? o.shouldComponentUpdate(_, P, O)
                : u.prototype && u.prototype.isPureReactComponent
                  ? !Jo(m, _) || !Jo(A, P)
                  : !0
        );
    }
    function f(o, u, m) {
        var _ = !1,
            A = Bs,
            P = u.contextType;
        return (
            typeof P == 'object' && P !== null
                ? (P = pr(P))
                : ((A = Ei(u) ? zs : gi.current),
                  (_ = u.contextTypes),
                  (P = (_ = _ != null) ? ra(o, A) : Bs)),
            (u = new u(m, P)),
            (o.memoizedState =
                u.state !== null && u.state !== void 0 ? u.state : null),
            (u.updater = hf),
            (o.stateNode = u),
            (u._reactInternals = o),
            _ &&
                ((o = o.stateNode),
                (o.__reactInternalMemoizedUnmaskedChildContext = A),
                (o.__reactInternalMemoizedMaskedChildContext = P)),
            u
        );
    }
    function h(o, u, m, _) {
        (o = u.state),
            typeof u.componentWillReceiveProps == 'function' &&
                u.componentWillReceiveProps(m, _),
            typeof u.UNSAFE_componentWillReceiveProps == 'function' &&
                u.UNSAFE_componentWillReceiveProps(m, _),
            u.state !== o && hf.enqueueReplaceState(u, u.state, null);
    }
    function x(o, u, m, _) {
        var A = o.stateNode;
        (A.props = m), (A.state = o.memoizedState), (A.refs = {}), Ht(o);
        var P = u.contextType;
        typeof P == 'object' && P !== null
            ? (A.context = pr(P))
            : ((P = Ei(u) ? zs : gi.current), (A.context = ra(o, P))),
            (A.state = o.memoizedState),
            (P = u.getDerivedStateFromProps),
            typeof P == 'function' &&
                (Eu(o, u, P, m), (A.state = o.memoizedState)),
            typeof u.getDerivedStateFromProps == 'function' ||
                typeof A.getSnapshotBeforeUpdate == 'function' ||
                (typeof A.UNSAFE_componentWillMount != 'function' &&
                    typeof A.componentWillMount != 'function') ||
                ((u = A.state),
                typeof A.componentWillMount == 'function' &&
                    A.componentWillMount(),
                typeof A.UNSAFE_componentWillMount == 'function' &&
                    A.UNSAFE_componentWillMount(),
                u !== A.state && hf.enqueueReplaceState(A, A.state, null),
                kn(o, m, A, _),
                (A.state = o.memoizedState)),
            typeof A.componentDidMount == 'function' && (o.flags |= 4194308);
    }
    function E(o, u) {
        try {
            var m = '',
                _ = u;
            do (m += we(_)), (_ = _.return);
            while (_);
            var A = m;
        } catch (P) {
            A =
                `
Error generating stack: ` +
                P.message +
                `
` +
                P.stack;
        }
        return { value: o, source: u, stack: A, digest: null };
    }
    function R(o, u, m) {
        return { value: o, source: null, stack: m ?? null, digest: u ?? null };
    }
    function I(o, u) {
        try {
            console.error(u.value);
        } catch (m) {
            setTimeout(function () {
                throw m;
            });
        }
    }
    var q = typeof WeakMap == 'function' ? WeakMap : Map;
    function te(o, u, m) {
        (m = mn(-1, m)), (m.tag = 3), (m.payload = { element: null });
        var _ = u.value;
        return (
            (m.callback = function () {
                Fm || ((Fm = !0), (a0 = _)), I(o, u);
            }),
            m
        );
    }
    function Me(o, u, m) {
        (m = mn(-1, m)), (m.tag = 3);
        var _ = o.type.getDerivedStateFromError;
        if (typeof _ == 'function') {
            var A = u.value;
            (m.payload = function () {
                return _(A);
            }),
                (m.callback = function () {
                    I(o, u);
                });
        }
        var P = o.stateNode;
        return (
            P !== null &&
                typeof P.componentDidCatch == 'function' &&
                (m.callback = function () {
                    I(o, u),
                        typeof _ != 'function' &&
                            (pl === null
                                ? (pl = new Set([this]))
                                : pl.add(this));
                    var O = u.stack;
                    this.componentDidCatch(u.value, {
                        componentStack: O !== null ? O : '',
                    });
                }),
            m
        );
    }
    function ze(o, u, m) {
        var _ = o.pingCache;
        if (_ === null) {
            _ = o.pingCache = new q();
            var A = new Set();
            _.set(u, A);
        } else (A = _.get(u)), A === void 0 && ((A = new Set()), _.set(u, A));
        A.has(m) || (A.add(m), (o = mL.bind(null, o, u, m)), u.then(o, o));
    }
    function ct(o) {
        do {
            var u;
            if (
                ((u = o.tag === 13) &&
                    ((u = o.memoizedState),
                    (u = u !== null ? u.dehydrated !== null : !0)),
                u)
            )
                return o;
            o = o.return;
        } while (o !== null);
        return null;
    }
    function kt(o, u, m, _, A) {
        return (o.mode & 1) === 0
            ? (o === u
                  ? (o.flags |= 65536)
                  : ((o.flags |= 128),
                    (m.flags |= 131072),
                    (m.flags &= -52805),
                    m.tag === 1 &&
                        (m.alternate === null
                            ? (m.tag = 17)
                            : ((u = mn(-1, 1)), (u.tag = 2), bn(m, u, 1))),
                    (m.lanes |= 1)),
              o)
            : ((o.flags |= 65536), (o.lanes = A), o);
    }
    var Tt = L.ReactCurrentOwner,
        Gt = !1;
    function it(o, u, m, _) {
        u.child = o === null ? du(u, null, m, _) : la(u, o.child, m, _);
    }
    function _i(o, u, m, _, A) {
        m = m.render;
        var P = u.ref;
        return (
            Co(u, A),
            (_ = xu(o, u, m, _, P, A)),
            (m = ld()),
            o !== null && !Gt
                ? ((u.updateQueue = o.updateQueue),
                  (u.flags &= -2053),
                  (o.lanes &= ~A),
                  va(o, u, A))
                : (Tn && m && td(u), (u.flags |= 1), it(o, u, _, A), u.child)
        );
    }
    function vr(o, u, m, _, A) {
        if (o === null) {
            var P = m.type;
            return typeof P == 'function' &&
                !p0(P) &&
                P.defaultProps === void 0 &&
                m.compare === null &&
                m.defaultProps === void 0
                ? ((u.tag = 15), (u.type = P), pe(o, u, P, _, A))
                : ((o = Wm(m.type, null, _, u, u.mode, A)),
                  (o.ref = u.ref),
                  (o.return = u),
                  (u.child = o));
        }
        if (((P = o.child), (o.lanes & A) === 0)) {
            var O = P.memoizedProps;
            if (
                ((m = m.compare),
                (m = m !== null ? m : Jo),
                m(O, _) && o.ref === u.ref)
            )
                return va(o, u, A);
        }
        return (
            (u.flags |= 1),
            (o = vl(P, _)),
            (o.ref = u.ref),
            (o.return = u),
            (u.child = o)
        );
    }
    function pe(o, u, m, _, A) {
        if (o !== null) {
            var P = o.memoizedProps;
            if (Jo(P, _) && o.ref === u.ref)
                if (((Gt = !1), (u.pendingProps = _ = P), (o.lanes & A) !== 0))
                    (o.flags & 131072) !== 0 && (Gt = !0);
                else return (u.lanes = o.lanes), va(o, u, A);
        }
        return Qe(o, u, m, _, A);
    }
    function se(o, u, m) {
        var _ = u.pendingProps,
            A = _.children,
            P = o !== null ? o.memoizedState : null;
        if (_.mode === 'hidden')
            if ((u.mode & 1) === 0)
                (u.memoizedState = {
                    baseLanes: 0,
                    cachePool: null,
                    transitions: null,
                }),
                    yn(pf, ts),
                    (ts |= m);
            else {
                if ((m & 1073741824) === 0)
                    return (
                        (o = P !== null ? P.baseLanes | m : m),
                        (u.lanes = u.childLanes = 1073741824),
                        (u.memoizedState = {
                            baseLanes: o,
                            cachePool: null,
                            transitions: null,
                        }),
                        (u.updateQueue = null),
                        yn(pf, ts),
                        (ts |= o),
                        null
                    );
                (u.memoizedState = {
                    baseLanes: 0,
                    cachePool: null,
                    transitions: null,
                }),
                    (_ = P !== null ? P.baseLanes : m),
                    yn(pf, ts),
                    (ts |= _);
            }
        else
            P !== null
                ? ((_ = P.baseLanes | m), (u.memoizedState = null))
                : (_ = m),
                yn(pf, ts),
                (ts |= _);
        return it(o, u, A, m), u.child;
    }
    function _e(o, u) {
        var m = u.ref;
        ((o === null && m !== null) || (o !== null && o.ref !== m)) &&
            ((u.flags |= 512), (u.flags |= 2097152));
    }
    function Qe(o, u, m, _, A) {
        var P = Ei(m) ? zs : gi.current;
        return (
            (P = ra(u, P)),
            Co(u, A),
            (m = xu(o, u, m, _, P, A)),
            (_ = ld()),
            o !== null && !Gt
                ? ((u.updateQueue = o.updateQueue),
                  (u.flags &= -2053),
                  (o.lanes &= ~A),
                  va(o, u, A))
                : (Tn && _ && td(u), (u.flags |= 1), it(o, u, m, A), u.child)
        );
    }
    function yt(o, u, m, _, A) {
        if (Ei(m)) {
            var P = !0;
            sa(u);
        } else P = !1;
        if ((Co(u, A), u.stateNode === null))
            Dm(o, u), f(u, m, _), x(u, m, _, A), (_ = !0);
        else if (o === null) {
            var O = u.stateNode,
                Y = u.memoizedProps;
            O.props = Y;
            var Z = O.context,
                xe = m.contextType;
            typeof xe == 'object' && xe !== null
                ? (xe = pr(xe))
                : ((xe = Ei(m) ? zs : gi.current), (xe = ra(u, xe)));
            var Ue = m.getDerivedStateFromProps,
                Fe =
                    typeof Ue == 'function' ||
                    typeof O.getSnapshotBeforeUpdate == 'function';
            Fe ||
                (typeof O.UNSAFE_componentWillReceiveProps != 'function' &&
                    typeof O.componentWillReceiveProps != 'function') ||
                ((Y !== _ || Z !== xe) && h(u, O, _, xe)),
                (pn = !1);
            var Ne = u.memoizedState;
            (O.state = Ne),
                kn(u, _, O, A),
                (Z = u.memoizedState),
                Y !== _ || Ne !== Z || Ui.current || pn
                    ? (typeof Ue == 'function' &&
                          (Eu(u, m, Ue, _), (Z = u.memoizedState)),
                      (Y = pn || Lm(u, m, Y, _, Ne, Z, xe))
                          ? (Fe ||
                                (typeof O.UNSAFE_componentWillMount !=
                                    'function' &&
                                    typeof O.componentWillMount !=
                                        'function') ||
                                (typeof O.componentWillMount == 'function' &&
                                    O.componentWillMount(),
                                typeof O.UNSAFE_componentWillMount ==
                                    'function' &&
                                    O.UNSAFE_componentWillMount()),
                            typeof O.componentDidMount == 'function' &&
                                (u.flags |= 4194308))
                          : (typeof O.componentDidMount == 'function' &&
                                (u.flags |= 4194308),
                            (u.memoizedProps = _),
                            (u.memoizedState = Z)),
                      (O.props = _),
                      (O.state = Z),
                      (O.context = xe),
                      (_ = Y))
                    : (typeof O.componentDidMount == 'function' &&
                          (u.flags |= 4194308),
                      (_ = !1));
        } else {
            (O = u.stateNode),
                Hn(o, u),
                (Y = u.memoizedProps),
                (xe = u.type === u.elementType ? Y : Ur(u.type, Y)),
                (O.props = xe),
                (Fe = u.pendingProps),
                (Ne = O.context),
                (Z = m.contextType),
                typeof Z == 'object' && Z !== null
                    ? (Z = pr(Z))
                    : ((Z = Ei(m) ? zs : gi.current), (Z = ra(u, Z)));
            var at = m.getDerivedStateFromProps;
            (Ue =
                typeof at == 'function' ||
                typeof O.getSnapshotBeforeUpdate == 'function') ||
                (typeof O.UNSAFE_componentWillReceiveProps != 'function' &&
                    typeof O.componentWillReceiveProps != 'function') ||
                ((Y !== Fe || Ne !== Z) && h(u, O, _, Z)),
                (pn = !1),
                (Ne = u.memoizedState),
                (O.state = Ne),
                kn(u, _, O, A);
            var mt = u.memoizedState;
            Y !== Fe || Ne !== mt || Ui.current || pn
                ? (typeof at == 'function' &&
                      (Eu(u, m, at, _), (mt = u.memoizedState)),
                  (xe = pn || Lm(u, m, xe, _, Ne, mt, Z) || !1)
                      ? (Ue ||
                            (typeof O.UNSAFE_componentWillUpdate !=
                                'function' &&
                                typeof O.componentWillUpdate != 'function') ||
                            (typeof O.componentWillUpdate == 'function' &&
                                O.componentWillUpdate(_, mt, Z),
                            typeof O.UNSAFE_componentWillUpdate == 'function' &&
                                O.UNSAFE_componentWillUpdate(_, mt, Z)),
                        typeof O.componentDidUpdate == 'function' &&
                            (u.flags |= 4),
                        typeof O.getSnapshotBeforeUpdate == 'function' &&
                            (u.flags |= 1024))
                      : (typeof O.componentDidUpdate != 'function' ||
                            (Y === o.memoizedProps && Ne === o.memoizedState) ||
                            (u.flags |= 4),
                        typeof O.getSnapshotBeforeUpdate != 'function' ||
                            (Y === o.memoizedProps && Ne === o.memoizedState) ||
                            (u.flags |= 1024),
                        (u.memoizedProps = _),
                        (u.memoizedState = mt)),
                  (O.props = _),
                  (O.state = mt),
                  (O.context = Z),
                  (_ = xe))
                : (typeof O.componentDidUpdate != 'function' ||
                      (Y === o.memoizedProps && Ne === o.memoizedState) ||
                      (u.flags |= 4),
                  typeof O.getSnapshotBeforeUpdate != 'function' ||
                      (Y === o.memoizedProps && Ne === o.memoizedState) ||
                      (u.flags |= 1024),
                  (_ = !1));
        }
        return Vt(o, u, m, _, P, A);
    }
    function Vt(o, u, m, _, A, P) {
        _e(o, u);
        var O = (u.flags & 128) !== 0;
        if (!_ && !O) return A && Qh(u, m, !1), va(o, u, P);
        (_ = u.stateNode), (Tt.current = u);
        var Y =
            O && typeof m.getDerivedStateFromError != 'function'
                ? null
                : _.render();
        return (
            (u.flags |= 1),
            o !== null && O
                ? ((u.child = la(u, o.child, null, P)),
                  (u.child = la(u, null, Y, P)))
                : it(o, u, Y, P),
            (u.memoizedState = _.state),
            A && Qh(u, m, !0),
            u.child
        );
    }
    function Ft(o) {
        var u = o.stateNode;
        u.pendingContext
            ? Jh(o, u.pendingContext, u.pendingContext !== u.context)
            : u.context && Jh(o, u.context, !1),
            yu(o, u.containerInfo);
    }
    function nn(o, u, m, _, A) {
        return Ao(), al(A), (u.flags |= 256), it(o, u, m, _), u.child;
    }
    var $n = { dehydrated: null, treeContext: null, retryLane: 0 };
    function tn(o) {
        return { baseLanes: o, cachePool: null, transitions: null };
    }
    function Ys(o, u, m) {
        var _ = u.pendingProps,
            A = An.current,
            P = !1,
            O = (u.flags & 128) !== 0,
            Y;
        if (
            ((Y = O) ||
                (Y =
                    o !== null && o.memoizedState === null
                        ? !1
                        : (A & 2) !== 0),
            Y
                ? ((P = !0), (u.flags &= -129))
                : (o === null || o.memoizedState !== null) && (A |= 1),
            yn(An, A & 1),
            o === null)
        )
            return (
                nf(u),
                (o = u.memoizedState),
                o !== null && ((o = o.dehydrated), o !== null)
                    ? ((u.mode & 1) === 0
                          ? (u.lanes = 1)
                          : o.data === '$!'
                            ? (u.lanes = 8)
                            : (u.lanes = 1073741824),
                      null)
                    : ((O = _.children),
                      (o = _.fallback),
                      P
                          ? ((_ = u.mode),
                            (P = u.child),
                            (O = { mode: 'hidden', children: O }),
                            (_ & 1) === 0 && P !== null
                                ? ((P.childLanes = 0), (P.pendingProps = O))
                                : (P = Xm(O, _, 0, null)),
                            (o = bu(o, _, m, null)),
                            (P.return = u),
                            (o.return = u),
                            (P.sibling = o),
                            (u.child = P),
                            (u.child.memoizedState = tn(m)),
                            (u.memoizedState = $n),
                            o)
                          : gd(u, O))
            );
        if (
            ((A = o.memoizedState),
            A !== null && ((Y = A.dehydrated), Y !== null))
        )
            return iL(o, u, O, _, Y, A, m);
        if (P) {
            (P = _.fallback), (O = u.mode), (A = o.child), (Y = A.sibling);
            var Z = { mode: 'hidden', children: _.children };
            return (
                (O & 1) === 0 && u.child !== A
                    ? ((_ = u.child),
                      (_.childLanes = 0),
                      (_.pendingProps = Z),
                      (u.deletions = null))
                    : ((_ = vl(A, Z)),
                      (_.subtreeFlags = A.subtreeFlags & 14680064)),
                Y !== null
                    ? (P = vl(Y, P))
                    : ((P = bu(P, O, m, null)), (P.flags |= 2)),
                (P.return = u),
                (_.return = u),
                (_.sibling = P),
                (u.child = _),
                (_ = P),
                (P = u.child),
                (O = o.child.memoizedState),
                (O =
                    O === null
                        ? tn(m)
                        : {
                              baseLanes: O.baseLanes | m,
                              cachePool: null,
                              transitions: O.transitions,
                          }),
                (P.memoizedState = O),
                (P.childLanes = o.childLanes & ~m),
                (u.memoizedState = $n),
                _
            );
        }
        return (
            (P = o.child),
            (o = P.sibling),
            (_ = vl(P, { mode: 'visible', children: _.children })),
            (u.mode & 1) === 0 && (_.lanes = m),
            (_.return = u),
            (_.sibling = null),
            o !== null &&
                ((m = u.deletions),
                m === null
                    ? ((u.deletions = [o]), (u.flags |= 16))
                    : m.push(o)),
            (u.child = _),
            (u.memoizedState = null),
            _
        );
    }
    function gd(o, u) {
        return (
            (u = Xm({ mode: 'visible', children: u }, o.mode, 0, null)),
            (u.return = o),
            (o.child = u)
        );
    }
    function Im(o, u, m, _) {
        return (
            _ !== null && al(_),
            la(u, o.child, null, m),
            (o = gd(u, u.pendingProps.children)),
            (o.flags |= 2),
            (u.memoizedState = null),
            o
        );
    }
    function iL(o, u, m, _, A, P, O) {
        if (m)
            return u.flags & 256
                ? ((u.flags &= -257), (_ = R(Error(t(422)))), Im(o, u, O, _))
                : u.memoizedState !== null
                  ? ((u.child = o.child), (u.flags |= 128), null)
                  : ((P = _.fallback),
                    (A = u.mode),
                    (_ = Xm(
                        { mode: 'visible', children: _.children },
                        A,
                        0,
                        null
                    )),
                    (P = bu(P, A, O, null)),
                    (P.flags |= 2),
                    (_.return = u),
                    (P.return = u),
                    (_.sibling = P),
                    (u.child = _),
                    (u.mode & 1) !== 0 && la(u, o.child, null, O),
                    (u.child.memoizedState = tn(O)),
                    (u.memoizedState = $n),
                    P);
        if ((u.mode & 1) === 0) return Im(o, u, O, null);
        if (A.data === '$!') {
            if (((_ = A.nextSibling && A.nextSibling.dataset), _))
                var Y = _.dgst;
            return (
                (_ = Y),
                (P = Error(t(419))),
                (_ = R(P, _, void 0)),
                Im(o, u, O, _)
            );
        }
        if (((Y = (O & o.childLanes) !== 0), Gt || Y)) {
            if (((_ = Ci), _ !== null)) {
                switch (O & -O) {
                    case 4:
                        A = 2;
                        break;
                    case 16:
                        A = 8;
                        break;
                    case 64:
                    case 128:
                    case 256:
                    case 512:
                    case 1024:
                    case 2048:
                    case 4096:
                    case 8192:
                    case 16384:
                    case 32768:
                    case 65536:
                    case 131072:
                    case 262144:
                    case 524288:
                    case 1048576:
                    case 2097152:
                    case 4194304:
                    case 8388608:
                    case 16777216:
                    case 33554432:
                    case 67108864:
                        A = 32;
                        break;
                    case 536870912:
                        A = 268435456;
                        break;
                    default:
                        A = 0;
                }
                (A = (A & (_.suspendedLanes | O)) !== 0 ? 0 : A),
                    A !== 0 &&
                        A !== P.retryLane &&
                        ((P.retryLane = A), Zr(o, A), Js(_, o, A, -1));
            }
            return d0(), (_ = R(Error(t(421)))), Im(o, u, O, _);
        }
        return A.data === '$?'
            ? ((u.flags |= 128),
              (u.child = o.child),
              (u = gL.bind(null, o)),
              (A._reactRetry = u),
              null)
            : ((o = P.treeContext),
              (ki = ks(A.nextSibling)),
              (yi = u),
              (Tn = !0),
              (Nr = null),
              o !== null &&
                  ((Oi[ui++] = qe),
                  (Oi[ui++] = Dr),
                  (Oi[ui++] = aa),
                  (qe = o.id),
                  (Dr = o.overflow),
                  (aa = u)),
              (u = gd(u, _.children)),
              (u.flags |= 4096),
              u);
    }
    function ww(o, u, m) {
        o.lanes |= u;
        var _ = o.alternate;
        _ !== null && (_.lanes |= u), mu(o.return, u, m);
    }
    function Jv(o, u, m, _, A) {
        var P = o.memoizedState;
        P === null
            ? (o.memoizedState = {
                  isBackwards: u,
                  rendering: null,
                  renderingStartTime: 0,
                  last: _,
                  tail: m,
                  tailMode: A,
              })
            : ((P.isBackwards = u),
              (P.rendering = null),
              (P.renderingStartTime = 0),
              (P.last = _),
              (P.tail = m),
              (P.tailMode = A));
    }
    function Mw(o, u, m) {
        var _ = u.pendingProps,
            A = _.revealOrder,
            P = _.tail;
        if ((it(o, u, _.children, m), (_ = An.current), (_ & 2) !== 0))
            (_ = (_ & 1) | 2), (u.flags |= 128);
        else {
            if (o !== null && (o.flags & 128) !== 0)
                e: for (o = u.child; o !== null; ) {
                    if (o.tag === 13) o.memoizedState !== null && ww(o, m, u);
                    else if (o.tag === 19) ww(o, m, u);
                    else if (o.child !== null) {
                        (o.child.return = o), (o = o.child);
                        continue;
                    }
                    if (o === u) break e;
                    for (; o.sibling === null; ) {
                        if (o.return === null || o.return === u) break e;
                        o = o.return;
                    }
                    (o.sibling.return = o.return), (o = o.sibling);
                }
            _ &= 1;
        }
        if ((yn(An, _), (u.mode & 1) === 0)) u.memoizedState = null;
        else
            switch (A) {
                case 'forwards':
                    for (m = u.child, A = null; m !== null; )
                        (o = m.alternate),
                            o !== null && Jr(o) === null && (A = m),
                            (m = m.sibling);
                    (m = A),
                        m === null
                            ? ((A = u.child), (u.child = null))
                            : ((A = m.sibling), (m.sibling = null)),
                        Jv(u, !1, A, m, P);
                    break;
                case 'backwards':
                    for (m = null, A = u.child, u.child = null; A !== null; ) {
                        if (((o = A.alternate), o !== null && Jr(o) === null)) {
                            u.child = A;
                            break;
                        }
                        (o = A.sibling), (A.sibling = m), (m = A), (A = o);
                    }
                    Jv(u, !0, m, null, P);
                    break;
                case 'together':
                    Jv(u, !1, null, null, void 0);
                    break;
                default:
                    u.memoizedState = null;
            }
        return u.child;
    }
    function Dm(o, u) {
        (u.mode & 1) === 0 &&
            o !== null &&
            ((o.alternate = null), (u.alternate = null), (u.flags |= 2));
    }
    function va(o, u, m) {
        if (
            (o !== null && (u.dependencies = o.dependencies),
            (Tu |= u.lanes),
            (m & u.childLanes) === 0)
        )
            return null;
        if (o !== null && u.child !== o.child) throw Error(t(153));
        if (u.child !== null) {
            for (
                o = u.child,
                    m = vl(o, o.pendingProps),
                    u.child = m,
                    m.return = u;
                o.sibling !== null;

            )
                (o = o.sibling),
                    (m = m.sibling = vl(o, o.pendingProps)),
                    (m.return = u);
            m.sibling = null;
        }
        return u.child;
    }
    function rL(o, u, m) {
        switch (u.tag) {
            case 3:
                Ft(u), Ao();
                break;
            case 5:
                pa(u);
                break;
            case 1:
                Ei(u.type) && sa(u);
                break;
            case 4:
                yu(u, u.stateNode.containerInfo);
                break;
            case 10:
                var _ = u.type._context,
                    A = u.memoizedProps.value;
                yn(ua, _._currentValue), (_._currentValue = A);
                break;
            case 13:
                if (((_ = u.memoizedState), _ !== null))
                    return _.dehydrated !== null
                        ? (yn(An, An.current & 1), (u.flags |= 128), null)
                        : (m & u.child.childLanes) !== 0
                          ? Ys(o, u, m)
                          : (yn(An, An.current & 1),
                            (o = va(o, u, m)),
                            o !== null ? o.sibling : null);
                yn(An, An.current & 1);
                break;
            case 19:
                if (((_ = (m & u.childLanes) !== 0), (o.flags & 128) !== 0)) {
                    if (_) return Mw(o, u, m);
                    u.flags |= 128;
                }
                if (
                    ((A = u.memoizedState),
                    A !== null &&
                        ((A.rendering = null),
                        (A.tail = null),
                        (A.lastEffect = null)),
                    yn(An, An.current),
                    _)
                )
                    break;
                return null;
            case 22:
            case 23:
                return (u.lanes = 0), se(o, u, m);
        }
        return va(o, u, m);
    }
    var Ew, Qv, Tw, Aw;
    (Ew = function (o, u) {
        for (var m = u.child; m !== null; ) {
            if (m.tag === 5 || m.tag === 6) o.appendChild(m.stateNode);
            else if (m.tag !== 4 && m.child !== null) {
                (m.child.return = m), (m = m.child);
                continue;
            }
            if (m === u) break;
            for (; m.sibling === null; ) {
                if (m.return === null || m.return === u) return;
                m = m.return;
            }
            (m.sibling.return = m.return), (m = m.sibling);
        }
    }),
        (Qv = function () {}),
        (Tw = function (o, u, m, _) {
            var A = o.memoizedProps;
            if (A !== _) {
                (o = u.stateNode), qn(mr.current);
                var P = null;
                switch (m) {
                    case 'input':
                        (A = ke(o, A)), (_ = ke(o, _)), (P = []);
                        break;
                    case 'select':
                        (A = Q({}, A, { value: void 0 })),
                            (_ = Q({}, _, { value: void 0 })),
                            (P = []);
                        break;
                    case 'textarea':
                        (A = ge(o, A)), (_ = ge(o, _)), (P = []);
                        break;
                    default:
                        typeof A.onClick != 'function' &&
                            typeof _.onClick == 'function' &&
                            (o.onclick = ou);
                }
                zt(m, _);
                var O;
                m = null;
                for (xe in A)
                    if (
                        !_.hasOwnProperty(xe) &&
                        A.hasOwnProperty(xe) &&
                        A[xe] != null
                    )
                        if (xe === 'style') {
                            var Y = A[xe];
                            for (O in Y)
                                Y.hasOwnProperty(O) &&
                                    (m || (m = {}), (m[O] = ''));
                        } else
                            xe !== 'dangerouslySetInnerHTML' &&
                                xe !== 'children' &&
                                xe !== 'suppressContentEditableWarning' &&
                                xe !== 'suppressHydrationWarning' &&
                                xe !== 'autoFocus' &&
                                (r.hasOwnProperty(xe)
                                    ? P || (P = [])
                                    : (P = P || []).push(xe, null));
                for (xe in _) {
                    var Z = _[xe];
                    if (
                        ((Y = A != null ? A[xe] : void 0),
                        _.hasOwnProperty(xe) &&
                            Z !== Y &&
                            (Z != null || Y != null))
                    )
                        if (xe === 'style')
                            if (Y) {
                                for (O in Y)
                                    !Y.hasOwnProperty(O) ||
                                        (Z && Z.hasOwnProperty(O)) ||
                                        (m || (m = {}), (m[O] = ''));
                                for (O in Z)
                                    Z.hasOwnProperty(O) &&
                                        Y[O] !== Z[O] &&
                                        (m || (m = {}), (m[O] = Z[O]));
                            } else m || (P || (P = []), P.push(xe, m)), (m = Z);
                        else
                            xe === 'dangerouslySetInnerHTML'
                                ? ((Z = Z ? Z.__html : void 0),
                                  (Y = Y ? Y.__html : void 0),
                                  Z != null &&
                                      Y !== Z &&
                                      (P = P || []).push(xe, Z))
                                : xe === 'children'
                                  ? (typeof Z != 'string' &&
                                        typeof Z != 'number') ||
                                    (P = P || []).push(xe, '' + Z)
                                  : xe !== 'suppressContentEditableWarning' &&
                                    xe !== 'suppressHydrationWarning' &&
                                    (r.hasOwnProperty(xe)
                                        ? (Z != null &&
                                              xe === 'onScroll' &&
                                              _n('scroll', o),
                                          P || Y === Z || (P = []))
                                        : (P = P || []).push(xe, Z));
                }
                m && (P = P || []).push('style', m);
                var xe = P;
                (u.updateQueue = xe) && (u.flags |= 4);
            }
        }),
        (Aw = function (o, u, m, _) {
            m !== _ && (u.flags |= 4);
        });
    function yd(o, u) {
        if (!Tn)
            switch (o.tailMode) {
                case 'hidden':
                    u = o.tail;
                    for (var m = null; u !== null; )
                        u.alternate !== null && (m = u), (u = u.sibling);
                    m === null ? (o.tail = null) : (m.sibling = null);
                    break;
                case 'collapsed':
                    m = o.tail;
                    for (var _ = null; m !== null; )
                        m.alternate !== null && (_ = m), (m = m.sibling);
                    _ === null
                        ? u || o.tail === null
                            ? (o.tail = null)
                            : (o.tail.sibling = null)
                        : (_.sibling = null);
            }
    }
    function Ji(o) {
        var u = o.alternate !== null && o.alternate.child === o.child,
            m = 0,
            _ = 0;
        if (u)
            for (var A = o.child; A !== null; )
                (m |= A.lanes | A.childLanes),
                    (_ |= A.subtreeFlags & 14680064),
                    (_ |= A.flags & 14680064),
                    (A.return = o),
                    (A = A.sibling);
        else
            for (A = o.child; A !== null; )
                (m |= A.lanes | A.childLanes),
                    (_ |= A.subtreeFlags),
                    (_ |= A.flags),
                    (A.return = o),
                    (A = A.sibling);
        return (o.subtreeFlags |= _), (o.childLanes = m), u;
    }
    function sL(o, u, m) {
        var _ = u.pendingProps;
        switch ((Hs(u), u.tag)) {
            case 2:
            case 16:
            case 15:
            case 0:
            case 11:
            case 7:
            case 8:
            case 12:
            case 9:
            case 14:
                return Ji(u), null;
            case 1:
                return Ei(u.type) && au(), Ji(u), null;
            case 3:
                return (
                    (_ = u.stateNode),
                    Ro(),
                    Sn(Ui),
                    Sn(gi),
                    ms(),
                    _.pendingContext &&
                        ((_.context = _.pendingContext),
                        (_.pendingContext = null)),
                    (o === null || o.child === null) &&
                        (ol(u)
                            ? (u.flags |= 4)
                            : o === null ||
                              (o.memoizedState.isDehydrated &&
                                  (u.flags & 256) === 0) ||
                              ((u.flags |= 1024),
                              Nr !== null && (c0(Nr), (Nr = null)))),
                    Qv(o, u),
                    Ji(u),
                    null
                );
            case 5:
                cl(u);
                var A = qn(Xs.current);
                if (((m = u.type), o !== null && u.stateNode != null))
                    Tw(o, u, m, _, A),
                        o.ref !== u.ref &&
                            ((u.flags |= 512), (u.flags |= 2097152));
                else {
                    if (!_) {
                        if (u.stateNode === null) throw Error(t(166));
                        return Ji(u), null;
                    }
                    if (((o = qn(mr.current)), ol(u))) {
                        (_ = u.stateNode), (m = u.type);
                        var P = u.memoizedProps;
                        switch (
                            ((_[ti] = u),
                            (_[sl] = P),
                            (o = (u.mode & 1) !== 0),
                            m)
                        ) {
                            case 'dialog':
                                _n('cancel', _), _n('close', _);
                                break;
                            case 'iframe':
                            case 'object':
                            case 'embed':
                                _n('load', _);
                                break;
                            case 'video':
                            case 'audio':
                                for (A = 0; A < Eo.length; A++) _n(Eo[A], _);
                                break;
                            case 'source':
                                _n('error', _);
                                break;
                            case 'img':
                            case 'image':
                            case 'link':
                                _n('error', _), _n('load', _);
                                break;
                            case 'details':
                                _n('toggle', _);
                                break;
                            case 'input':
                                Ke(_, P), _n('invalid', _);
                                break;
                            case 'select':
                                (_._wrapperState = {
                                    wasMultiple: !!P.multiple,
                                }),
                                    _n('invalid', _);
                                break;
                            case 'textarea':
                                De(_, P), _n('invalid', _);
                        }
                        zt(m, P), (A = null);
                        for (var O in P)
                            if (P.hasOwnProperty(O)) {
                                var Y = P[O];
                                O === 'children'
                                    ? typeof Y == 'string'
                                        ? _.textContent !== Y &&
                                          (P.suppressHydrationWarning !== !0 &&
                                              su(_.textContent, Y, o),
                                          (A = ['children', Y]))
                                        : typeof Y == 'number' &&
                                          _.textContent !== '' + Y &&
                                          (P.suppressHydrationWarning !== !0 &&
                                              su(_.textContent, Y, o),
                                          (A = ['children', '' + Y]))
                                    : r.hasOwnProperty(O) &&
                                      Y != null &&
                                      O === 'onScroll' &&
                                      _n('scroll', _);
                            }
                        switch (m) {
                            case 'input':
                                Lt(_), Ze(_, P, !0);
                                break;
                            case 'textarea':
                                Lt(_), Le(_);
                                break;
                            case 'select':
                            case 'option':
                                break;
                            default:
                                typeof P.onClick == 'function' &&
                                    (_.onclick = ou);
                        }
                        (_ = A),
                            (u.updateQueue = _),
                            _ !== null && (u.flags |= 4);
                    } else {
                        (O = A.nodeType === 9 ? A : A.ownerDocument),
                            o === 'http://www.w3.org/1999/xhtml' && (o = _t(m)),
                            o === 'http://www.w3.org/1999/xhtml'
                                ? m === 'script'
                                    ? ((o = O.createElement('div')),
                                      (o.innerHTML = '<script><\/script>'),
                                      (o = o.removeChild(o.firstChild)))
                                    : typeof _.is == 'string'
                                      ? (o = O.createElement(m, { is: _.is }))
                                      : ((o = O.createElement(m)),
                                        m === 'select' &&
                                            ((O = o),
                                            _.multiple
                                                ? (O.multiple = !0)
                                                : _.size && (O.size = _.size)))
                                : (o = O.createElementNS(o, m)),
                            (o[ti] = u),
                            (o[sl] = _),
                            Ew(o, u, !1, !1),
                            (u.stateNode = o);
                        e: {
                            switch (((O = dn(m, _)), m)) {
                                case 'dialog':
                                    _n('cancel', o), _n('close', o), (A = _);
                                    break;
                                case 'iframe':
                                case 'object':
                                case 'embed':
                                    _n('load', o), (A = _);
                                    break;
                                case 'video':
                                case 'audio':
                                    for (A = 0; A < Eo.length; A++)
                                        _n(Eo[A], o);
                                    A = _;
                                    break;
                                case 'source':
                                    _n('error', o), (A = _);
                                    break;
                                case 'img':
                                case 'image':
                                case 'link':
                                    _n('error', o), _n('load', o), (A = _);
                                    break;
                                case 'details':
                                    _n('toggle', o), (A = _);
                                    break;
                                case 'input':
                                    Ke(o, _), (A = ke(o, _)), _n('invalid', o);
                                    break;
                                case 'option':
                                    A = _;
                                    break;
                                case 'select':
                                    (o._wrapperState = {
                                        wasMultiple: !!_.multiple,
                                    }),
                                        (A = Q({}, _, { value: void 0 })),
                                        _n('invalid', o);
                                    break;
                                case 'textarea':
                                    De(o, _), (A = ge(o, _)), _n('invalid', o);
                                    break;
                                default:
                                    A = _;
                            }
                            zt(m, A), (Y = A);
                            for (P in Y)
                                if (Y.hasOwnProperty(P)) {
                                    var Z = Y[P];
                                    P === 'style'
                                        ? ut(o, Z)
                                        : P === 'dangerouslySetInnerHTML'
                                          ? ((Z = Z ? Z.__html : void 0),
                                            Z != null && Nt(o, Z))
                                          : P === 'children'
                                            ? typeof Z == 'string'
                                                ? (m !== 'textarea' ||
                                                      Z !== '') &&
                                                  Be(o, Z)
                                                : typeof Z == 'number' &&
                                                  Be(o, '' + Z)
                                            : P !==
                                                  'suppressContentEditableWarning' &&
                                              P !==
                                                  'suppressHydrationWarning' &&
                                              P !== 'autoFocus' &&
                                              (r.hasOwnProperty(P)
                                                  ? Z != null &&
                                                    P === 'onScroll' &&
                                                    _n('scroll', o)
                                                  : Z != null && C(o, P, Z, O));
                                }
                            switch (m) {
                                case 'input':
                                    Lt(o), Ze(o, _, !1);
                                    break;
                                case 'textarea':
                                    Lt(o), Le(o);
                                    break;
                                case 'option':
                                    _.value != null &&
                                        o.setAttribute(
                                            'value',
                                            '' + Ye(_.value)
                                        );
                                    break;
                                case 'select':
                                    (o.multiple = !!_.multiple),
                                        (P = _.value),
                                        P != null
                                            ? k(o, !!_.multiple, P, !1)
                                            : _.defaultValue != null &&
                                              k(
                                                  o,
                                                  !!_.multiple,
                                                  _.defaultValue,
                                                  !0
                                              );
                                    break;
                                default:
                                    typeof A.onClick == 'function' &&
                                        (o.onclick = ou);
                            }
                            switch (m) {
                                case 'button':
                                case 'input':
                                case 'select':
                                case 'textarea':
                                    _ = !!_.autoFocus;
                                    break e;
                                case 'img':
                                    _ = !0;
                                    break e;
                                default:
                                    _ = !1;
                            }
                        }
                        _ && (u.flags |= 4);
                    }
                    u.ref !== null && ((u.flags |= 512), (u.flags |= 2097152));
                }
                return Ji(u), null;
            case 6:
                if (o && u.stateNode != null) Aw(o, u, o.memoizedProps, _);
                else {
                    if (typeof _ != 'string' && u.stateNode === null)
                        throw Error(t(166));
                    if (((m = qn(Xs.current)), qn(mr.current), ol(u))) {
                        if (
                            ((_ = u.stateNode),
                            (m = u.memoizedProps),
                            (_[ti] = u),
                            (P = _.nodeValue !== m) && ((o = yi), o !== null))
                        )
                            switch (o.tag) {
                                case 3:
                                    su(_.nodeValue, m, (o.mode & 1) !== 0);
                                    break;
                                case 5:
                                    o.memoizedProps.suppressHydrationWarning !==
                                        !0 &&
                                        su(_.nodeValue, m, (o.mode & 1) !== 0);
                            }
                        P && (u.flags |= 4);
                    } else
                        (_ = (
                            m.nodeType === 9 ? m : m.ownerDocument
                        ).createTextNode(_)),
                            (_[ti] = u),
                            (u.stateNode = _);
                }
                return Ji(u), null;
            case 13:
                if (
                    (Sn(An),
                    (_ = u.memoizedState),
                    o === null ||
                        (o.memoizedState !== null &&
                            o.memoizedState.dehydrated !== null))
                ) {
                    if (
                        Tn &&
                        ki !== null &&
                        (u.mode & 1) !== 0 &&
                        (u.flags & 128) === 0
                    )
                        rd(), Ao(), (u.flags |= 98560), (P = !1);
                    else if (
                        ((P = ol(u)), _ !== null && _.dehydrated !== null)
                    ) {
                        if (o === null) {
                            if (!P) throw Error(t(318));
                            if (
                                ((P = u.memoizedState),
                                (P = P !== null ? P.dehydrated : null),
                                !P)
                            )
                                throw Error(t(317));
                            P[ti] = u;
                        } else
                            Ao(),
                                (u.flags & 128) === 0 &&
                                    (u.memoizedState = null),
                                (u.flags |= 4);
                        Ji(u), (P = !1);
                    } else Nr !== null && (c0(Nr), (Nr = null)), (P = !0);
                    if (!P) return u.flags & 65536 ? u : null;
                }
                return (u.flags & 128) !== 0
                    ? ((u.lanes = m), u)
                    : ((_ = _ !== null),
                      _ !== (o !== null && o.memoizedState !== null) &&
                          _ &&
                          ((u.child.flags |= 8192),
                          (u.mode & 1) !== 0 &&
                              (o === null || (An.current & 1) !== 0
                                  ? Si === 0 && (Si = 3)
                                  : d0())),
                      u.updateQueue !== null && (u.flags |= 4),
                      Ji(u),
                      null);
            case 4:
                return (
                    Ro(),
                    Qv(o, u),
                    o === null && nl(u.stateNode.containerInfo),
                    Ji(u),
                    null
                );
            case 10:
                return pu(u.type._context), Ji(u), null;
            case 17:
                return Ei(u.type) && au(), Ji(u), null;
            case 19:
                if ((Sn(An), (P = u.memoizedState), P === null))
                    return Ji(u), null;
                if (
                    ((_ = (u.flags & 128) !== 0), (O = P.rendering), O === null)
                )
                    if (_) yd(P, !1);
                    else {
                        if (Si !== 0 || (o !== null && (o.flags & 128) !== 0))
                            for (o = u.child; o !== null; ) {
                                if (((O = Jr(o)), O !== null)) {
                                    for (
                                        u.flags |= 128,
                                            yd(P, !1),
                                            _ = O.updateQueue,
                                            _ !== null &&
                                                ((u.updateQueue = _),
                                                (u.flags |= 4)),
                                            u.subtreeFlags = 0,
                                            _ = m,
                                            m = u.child;
                                        m !== null;

                                    )
                                        (P = m),
                                            (o = _),
                                            (P.flags &= 14680066),
                                            (O = P.alternate),
                                            O === null
                                                ? ((P.childLanes = 0),
                                                  (P.lanes = o),
                                                  (P.child = null),
                                                  (P.subtreeFlags = 0),
                                                  (P.memoizedProps = null),
                                                  (P.memoizedState = null),
                                                  (P.updateQueue = null),
                                                  (P.dependencies = null),
                                                  (P.stateNode = null))
                                                : ((P.childLanes =
                                                      O.childLanes),
                                                  (P.lanes = O.lanes),
                                                  (P.child = O.child),
                                                  (P.subtreeFlags = 0),
                                                  (P.deletions = null),
                                                  (P.memoizedProps =
                                                      O.memoizedProps),
                                                  (P.memoizedState =
                                                      O.memoizedState),
                                                  (P.updateQueue =
                                                      O.updateQueue),
                                                  (P.type = O.type),
                                                  (o = O.dependencies),
                                                  (P.dependencies =
                                                      o === null
                                                          ? null
                                                          : {
                                                                lanes: o.lanes,
                                                                firstContext:
                                                                    o.firstContext,
                                                            })),
                                            (m = m.sibling);
                                    return (
                                        yn(An, (An.current & 1) | 2), u.child
                                    );
                                }
                                o = o.sibling;
                            }
                        P.tail !== null &&
                            Xe() > mf &&
                            ((u.flags |= 128),
                            (_ = !0),
                            yd(P, !1),
                            (u.lanes = 4194304));
                    }
                else {
                    if (!_)
                        if (((o = Jr(O)), o !== null)) {
                            if (
                                ((u.flags |= 128),
                                (_ = !0),
                                (m = o.updateQueue),
                                m !== null &&
                                    ((u.updateQueue = m), (u.flags |= 4)),
                                yd(P, !0),
                                P.tail === null &&
                                    P.tailMode === 'hidden' &&
                                    !O.alternate &&
                                    !Tn)
                            )
                                return Ji(u), null;
                        } else
                            2 * Xe() - P.renderingStartTime > mf &&
                                m !== 1073741824 &&
                                ((u.flags |= 128),
                                (_ = !0),
                                yd(P, !1),
                                (u.lanes = 4194304));
                    P.isBackwards
                        ? ((O.sibling = u.child), (u.child = O))
                        : ((m = P.last),
                          m !== null ? (m.sibling = O) : (u.child = O),
                          (P.last = O));
                }
                return P.tail !== null
                    ? ((u = P.tail),
                      (P.rendering = u),
                      (P.tail = u.sibling),
                      (P.renderingStartTime = Xe()),
                      (u.sibling = null),
                      (m = An.current),
                      yn(An, _ ? (m & 1) | 2 : m & 1),
                      u)
                    : (Ji(u), null);
            case 22:
            case 23:
                return (
                    h0(),
                    (_ = u.memoizedState !== null),
                    o !== null &&
                        (o.memoizedState !== null) !== _ &&
                        (u.flags |= 8192),
                    _ && (u.mode & 1) !== 0
                        ? (ts & 1073741824) !== 0 &&
                          (Ji(u), u.subtreeFlags & 6 && (u.flags |= 8192))
                        : Ji(u),
                    null
                );
            case 24:
                return null;
            case 25:
                return null;
        }
        throw Error(t(156, u.tag));
    }
    function oL(o, u) {
        switch ((Hs(u), u.tag)) {
            case 1:
                return (
                    Ei(u.type) && au(),
                    (o = u.flags),
                    o & 65536 ? ((u.flags = (o & -65537) | 128), u) : null
                );
            case 3:
                return (
                    Ro(),
                    Sn(Ui),
                    Sn(gi),
                    ms(),
                    (o = u.flags),
                    (o & 65536) !== 0 && (o & 128) === 0
                        ? ((u.flags = (o & -65537) | 128), u)
                        : null
                );
            case 5:
                return cl(u), null;
            case 13:
                if (
                    (Sn(An),
                    (o = u.memoizedState),
                    o !== null && o.dehydrated !== null)
                ) {
                    if (u.alternate === null) throw Error(t(340));
                    Ao();
                }
                return (
                    (o = u.flags),
                    o & 65536 ? ((u.flags = (o & -65537) | 128), u) : null
                );
            case 19:
                return Sn(An), null;
            case 4:
                return Ro(), null;
            case 10:
                return pu(u.type._context), null;
            case 22:
            case 23:
                return h0(), null;
            case 24:
                return null;
            default:
                return null;
        }
    }
    var Nm = !1,
        Qi = !1,
        aL = typeof WeakSet == 'function' ? WeakSet : Set,
        ht = null;
    function df(o, u) {
        var m = o.ref;
        if (m !== null)
            if (typeof m == 'function')
                try {
                    m(null);
                } catch (_) {
                    Yn(o, u, _);
                }
            else m.current = null;
    }
    function e0(o, u, m) {
        try {
            m();
        } catch (_) {
            Yn(o, u, _);
        }
    }
    var Cw = !1;
    function lL(o, u) {
        if (((rl = Cr), (o = Un()), si(o))) {
            if ('selectionStart' in o)
                var m = { start: o.selectionStart, end: o.selectionEnd };
            else
                e: {
                    m = ((m = o.ownerDocument) && m.defaultView) || window;
                    var _ = m.getSelection && m.getSelection();
                    if (_ && _.rangeCount !== 0) {
                        m = _.anchorNode;
                        var A = _.anchorOffset,
                            P = _.focusNode;
                        _ = _.focusOffset;
                        try {
                            m.nodeType, P.nodeType;
                        } catch {
                            m = null;
                            break e;
                        }
                        var O = 0,
                            Y = -1,
                            Z = -1,
                            xe = 0,
                            Ue = 0,
                            Fe = o,
                            Ne = null;
                        t: for (;;) {
                            for (
                                var at;
                                Fe !== m ||
                                    (A !== 0 && Fe.nodeType !== 3) ||
                                    (Y = O + A),
                                    Fe !== P ||
                                        (_ !== 0 && Fe.nodeType !== 3) ||
                                        (Z = O + _),
                                    Fe.nodeType === 3 &&
                                        (O += Fe.nodeValue.length),
                                    (at = Fe.firstChild) !== null;

                            )
                                (Ne = Fe), (Fe = at);
                            for (;;) {
                                if (Fe === o) break t;
                                if (
                                    (Ne === m && ++xe === A && (Y = O),
                                    Ne === P && ++Ue === _ && (Z = O),
                                    (at = Fe.nextSibling) !== null)
                                )
                                    break;
                                (Fe = Ne), (Ne = Fe.parentNode);
                            }
                            Fe = at;
                        }
                        m = Y === -1 || Z === -1 ? null : { start: Y, end: Z };
                    } else m = null;
                }
            m = m || { start: 0, end: 0 };
        } else m = null;
        for (
            jh = { focusedElem: o, selectionRange: m }, Cr = !1, ht = u;
            ht !== null;

        )
            if (
                ((u = ht),
                (o = u.child),
                (u.subtreeFlags & 1028) !== 0 && o !== null)
            )
                (o.return = u), (ht = o);
            else
                for (; ht !== null; ) {
                    u = ht;
                    try {
                        var mt = u.alternate;
                        if ((u.flags & 1024) !== 0)
                            switch (u.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    break;
                                case 1:
                                    if (mt !== null) {
                                        var gt = mt.memoizedProps,
                                            ni = mt.memoizedState,
                                            he = u.stateNode,
                                            J = he.getSnapshotBeforeUpdate(
                                                u.elementType === u.type
                                                    ? gt
                                                    : Ur(u.type, gt),
                                                ni
                                            );
                                        he.__reactInternalSnapshotBeforeUpdate =
                                            J;
                                    }
                                    break;
                                case 3:
                                    var de = u.stateNode.containerInfo;
                                    de.nodeType === 1
                                        ? (de.textContent = '')
                                        : de.nodeType === 9 &&
                                          de.documentElement &&
                                          de.removeChild(de.documentElement);
                                    break;
                                case 5:
                                case 6:
                                case 4:
                                case 17:
                                    break;
                                default:
                                    throw Error(t(163));
                            }
                    } catch (He) {
                        Yn(u, u.return, He);
                    }
                    if (((o = u.sibling), o !== null)) {
                        (o.return = u.return), (ht = o);
                        break;
                    }
                    ht = u.return;
                }
        return (mt = Cw), (Cw = !1), mt;
    }
    function vd(o, u, m) {
        var _ = u.updateQueue;
        if (((_ = _ !== null ? _.lastEffect : null), _ !== null)) {
            var A = (_ = _.next);
            do {
                if ((A.tag & o) === o) {
                    var P = A.destroy;
                    (A.destroy = void 0), P !== void 0 && e0(u, m, P);
                }
                A = A.next;
            } while (A !== _);
        }
    }
    function Um(o, u) {
        if (
            ((u = u.updateQueue),
            (u = u !== null ? u.lastEffect : null),
            u !== null)
        ) {
            var m = (u = u.next);
            do {
                if ((m.tag & o) === o) {
                    var _ = m.create;
                    m.destroy = _();
                }
                m = m.next;
            } while (m !== u);
        }
    }
    function t0(o) {
        var u = o.ref;
        if (u !== null) {
            var m = o.stateNode;
            switch (o.tag) {
                case 5:
                    o = m;
                    break;
                default:
                    o = m;
            }
            typeof u == 'function' ? u(o) : (u.current = o);
        }
    }
    function Rw(o) {
        var u = o.alternate;
        u !== null && ((o.alternate = null), Rw(u)),
            (o.child = null),
            (o.deletions = null),
            (o.sibling = null),
            o.tag === 5 &&
                ((u = o.stateNode),
                u !== null &&
                    (delete u[ti],
                    delete u[sl],
                    delete u[ia],
                    delete u[Yc],
                    delete u[Kc])),
            (o.stateNode = null),
            (o.return = null),
            (o.dependencies = null),
            (o.memoizedProps = null),
            (o.memoizedState = null),
            (o.pendingProps = null),
            (o.stateNode = null),
            (o.updateQueue = null);
    }
    function bw(o) {
        return o.tag === 5 || o.tag === 3 || o.tag === 4;
    }
    function Pw(o) {
        e: for (;;) {
            for (; o.sibling === null; ) {
                if (o.return === null || bw(o.return)) return null;
                o = o.return;
            }
            for (
                o.sibling.return = o.return, o = o.sibling;
                o.tag !== 5 && o.tag !== 6 && o.tag !== 18;

            ) {
                if (o.flags & 2 || o.child === null || o.tag === 4) continue e;
                (o.child.return = o), (o = o.child);
            }
            if (!(o.flags & 2)) return o.stateNode;
        }
    }
    function n0(o, u, m) {
        var _ = o.tag;
        if (_ === 5 || _ === 6)
            (o = o.stateNode),
                u
                    ? m.nodeType === 8
                        ? m.parentNode.insertBefore(o, u)
                        : m.insertBefore(o, u)
                    : (m.nodeType === 8
                          ? ((u = m.parentNode), u.insertBefore(o, m))
                          : ((u = m), u.appendChild(o)),
                      (m = m._reactRootContainer),
                      m != null || u.onclick !== null || (u.onclick = ou));
        else if (_ !== 4 && ((o = o.child), o !== null))
            for (n0(o, u, m), o = o.sibling; o !== null; )
                n0(o, u, m), (o = o.sibling);
    }
    function i0(o, u, m) {
        var _ = o.tag;
        if (_ === 5 || _ === 6)
            (o = o.stateNode), u ? m.insertBefore(o, u) : m.appendChild(o);
        else if (_ !== 4 && ((o = o.child), o !== null))
            for (i0(o, u, m), o = o.sibling; o !== null; )
                i0(o, u, m), (o = o.sibling);
    }
    var Bi = null,
        Ks = !1;
    function dl(o, u, m) {
        for (m = m.child; m !== null; ) Lw(o, u, m), (m = m.sibling);
    }
    function Lw(o, u, m) {
        if (ft && typeof ft.onCommitFiberUnmount == 'function')
            try {
                ft.onCommitFiberUnmount(En, m);
            } catch {}
        switch (m.tag) {
            case 5:
                Qi || df(m, u);
            case 6:
                var _ = Bi,
                    A = Ks;
                (Bi = null),
                    dl(o, u, m),
                    (Bi = _),
                    (Ks = A),
                    Bi !== null &&
                        (Ks
                            ? ((o = Bi),
                              (m = m.stateNode),
                              o.nodeType === 8
                                  ? o.parentNode.removeChild(m)
                                  : o.removeChild(m))
                            : Bi.removeChild(m.stateNode));
                break;
            case 18:
                Bi !== null &&
                    (Ks
                        ? ((o = Bi),
                          (m = m.stateNode),
                          o.nodeType === 8
                              ? $c(o.parentNode, m)
                              : o.nodeType === 1 && $c(o, m),
                          $l(o))
                        : $c(Bi, m.stateNode));
                break;
            case 4:
                (_ = Bi),
                    (A = Ks),
                    (Bi = m.stateNode.containerInfo),
                    (Ks = !0),
                    dl(o, u, m),
                    (Bi = _),
                    (Ks = A);
                break;
            case 0:
            case 11:
            case 14:
            case 15:
                if (
                    !Qi &&
                    ((_ = m.updateQueue),
                    _ !== null && ((_ = _.lastEffect), _ !== null))
                ) {
                    A = _ = _.next;
                    do {
                        var P = A,
                            O = P.destroy;
                        (P = P.tag),
                            O !== void 0 &&
                                ((P & 2) !== 0 || (P & 4) !== 0) &&
                                e0(m, u, O),
                            (A = A.next);
                    } while (A !== _);
                }
                dl(o, u, m);
                break;
            case 1:
                if (
                    !Qi &&
                    (df(m, u),
                    (_ = m.stateNode),
                    typeof _.componentWillUnmount == 'function')
                )
                    try {
                        (_.props = m.memoizedProps),
                            (_.state = m.memoizedState),
                            _.componentWillUnmount();
                    } catch (Y) {
                        Yn(m, u, Y);
                    }
                dl(o, u, m);
                break;
            case 21:
                dl(o, u, m);
                break;
            case 22:
                m.mode & 1
                    ? ((Qi = (_ = Qi) || m.memoizedState !== null),
                      dl(o, u, m),
                      (Qi = _))
                    : dl(o, u, m);
                break;
            default:
                dl(o, u, m);
        }
    }
    function Iw(o) {
        var u = o.updateQueue;
        if (u !== null) {
            o.updateQueue = null;
            var m = o.stateNode;
            m === null && (m = o.stateNode = new aL()),
                u.forEach(function (_) {
                    var A = yL.bind(null, o, _);
                    m.has(_) || (m.add(_), _.then(A, A));
                });
        }
    }
    function Zs(o, u) {
        var m = u.deletions;
        if (m !== null)
            for (var _ = 0; _ < m.length; _++) {
                var A = m[_];
                try {
                    var P = o,
                        O = u,
                        Y = O;
                    e: for (; Y !== null; ) {
                        switch (Y.tag) {
                            case 5:
                                (Bi = Y.stateNode), (Ks = !1);
                                break e;
                            case 3:
                                (Bi = Y.stateNode.containerInfo), (Ks = !0);
                                break e;
                            case 4:
                                (Bi = Y.stateNode.containerInfo), (Ks = !0);
                                break e;
                        }
                        Y = Y.return;
                    }
                    if (Bi === null) throw Error(t(160));
                    Lw(P, O, A), (Bi = null), (Ks = !1);
                    var Z = A.alternate;
                    Z !== null && (Z.return = null), (A.return = null);
                } catch (xe) {
                    Yn(A, u, xe);
                }
            }
        if (u.subtreeFlags & 12854)
            for (u = u.child; u !== null; ) Dw(u, o), (u = u.sibling);
    }
    function Dw(o, u) {
        var m = o.alternate,
            _ = o.flags;
        switch (o.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
                if ((Zs(u, o), Po(o), _ & 4)) {
                    try {
                        vd(3, o, o.return), Um(3, o);
                    } catch (gt) {
                        Yn(o, o.return, gt);
                    }
                    try {
                        vd(5, o, o.return);
                    } catch (gt) {
                        Yn(o, o.return, gt);
                    }
                }
                break;
            case 1:
                Zs(u, o), Po(o), _ & 512 && m !== null && df(m, m.return);
                break;
            case 5:
                if (
                    (Zs(u, o),
                    Po(o),
                    _ & 512 && m !== null && df(m, m.return),
                    o.flags & 32)
                ) {
                    var A = o.stateNode;
                    try {
                        Be(A, '');
                    } catch (gt) {
                        Yn(o, o.return, gt);
                    }
                }
                if (_ & 4 && ((A = o.stateNode), A != null)) {
                    var P = o.memoizedProps,
                        O = m !== null ? m.memoizedProps : P,
                        Y = o.type,
                        Z = o.updateQueue;
                    if (((o.updateQueue = null), Z !== null))
                        try {
                            Y === 'input' &&
                                P.type === 'radio' &&
                                P.name != null &&
                                Ee(A, P),
                                dn(Y, O);
                            var xe = dn(Y, P);
                            for (O = 0; O < Z.length; O += 2) {
                                var Ue = Z[O],
                                    Fe = Z[O + 1];
                                Ue === 'style'
                                    ? ut(A, Fe)
                                    : Ue === 'dangerouslySetInnerHTML'
                                      ? Nt(A, Fe)
                                      : Ue === 'children'
                                        ? Be(A, Fe)
                                        : C(A, Ue, Fe, xe);
                            }
                            switch (Y) {
                                case 'input':
                                    St(A, P);
                                    break;
                                case 'textarea':
                                    be(A, P);
                                    break;
                                case 'select':
                                    var Ne = A._wrapperState.wasMultiple;
                                    A._wrapperState.wasMultiple = !!P.multiple;
                                    var at = P.value;
                                    at != null
                                        ? k(A, !!P.multiple, at, !1)
                                        : Ne !== !!P.multiple &&
                                          (P.defaultValue != null
                                              ? k(
                                                    A,
                                                    !!P.multiple,
                                                    P.defaultValue,
                                                    !0
                                                )
                                              : k(
                                                    A,
                                                    !!P.multiple,
                                                    P.multiple ? [] : '',
                                                    !1
                                                ));
                            }
                            A[sl] = P;
                        } catch (gt) {
                            Yn(o, o.return, gt);
                        }
                }
                break;
            case 6:
                if ((Zs(u, o), Po(o), _ & 4)) {
                    if (o.stateNode === null) throw Error(t(162));
                    (A = o.stateNode), (P = o.memoizedProps);
                    try {
                        A.nodeValue = P;
                    } catch (gt) {
                        Yn(o, o.return, gt);
                    }
                }
                break;
            case 3:
                if (
                    (Zs(u, o),
                    Po(o),
                    _ & 4 && m !== null && m.memoizedState.isDehydrated)
                )
                    try {
                        $l(u.containerInfo);
                    } catch (gt) {
                        Yn(o, o.return, gt);
                    }
                break;
            case 4:
                Zs(u, o), Po(o);
                break;
            case 13:
                Zs(u, o),
                    Po(o),
                    (A = o.child),
                    A.flags & 8192 &&
                        ((P = A.memoizedState !== null),
                        (A.stateNode.isHidden = P),
                        !P ||
                            (A.alternate !== null &&
                                A.alternate.memoizedState !== null) ||
                            (o0 = Xe())),
                    _ & 4 && Iw(o);
                break;
            case 22:
                if (
                    ((Ue = m !== null && m.memoizedState !== null),
                    o.mode & 1
                        ? ((Qi = (xe = Qi) || Ue), Zs(u, o), (Qi = xe))
                        : Zs(u, o),
                    Po(o),
                    _ & 8192)
                ) {
                    if (
                        ((xe = o.memoizedState !== null),
                        (o.stateNode.isHidden = xe) &&
                            !Ue &&
                            (o.mode & 1) !== 0)
                    )
                        for (ht = o, Ue = o.child; Ue !== null; ) {
                            for (Fe = ht = Ue; ht !== null; ) {
                                switch (((Ne = ht), (at = Ne.child), Ne.tag)) {
                                    case 0:
                                    case 11:
                                    case 14:
                                    case 15:
                                        vd(4, Ne, Ne.return);
                                        break;
                                    case 1:
                                        df(Ne, Ne.return);
                                        var mt = Ne.stateNode;
                                        if (
                                            typeof mt.componentWillUnmount ==
                                            'function'
                                        ) {
                                            (_ = Ne), (m = Ne.return);
                                            try {
                                                (u = _),
                                                    (mt.props =
                                                        u.memoizedProps),
                                                    (mt.state =
                                                        u.memoizedState),
                                                    mt.componentWillUnmount();
                                            } catch (gt) {
                                                Yn(_, m, gt);
                                            }
                                        }
                                        break;
                                    case 5:
                                        df(Ne, Ne.return);
                                        break;
                                    case 22:
                                        if (Ne.memoizedState !== null) {
                                            Ow(Fe);
                                            continue;
                                        }
                                }
                                at !== null
                                    ? ((at.return = Ne), (ht = at))
                                    : Ow(Fe);
                            }
                            Ue = Ue.sibling;
                        }
                    e: for (Ue = null, Fe = o; ; ) {
                        if (Fe.tag === 5) {
                            if (Ue === null) {
                                Ue = Fe;
                                try {
                                    (A = Fe.stateNode),
                                        xe
                                            ? ((P = A.style),
                                              typeof P.setProperty == 'function'
                                                  ? P.setProperty(
                                                        'display',
                                                        'none',
                                                        'important'
                                                    )
                                                  : (P.display = 'none'))
                                            : ((Y = Fe.stateNode),
                                              (Z = Fe.memoizedProps.style),
                                              (O =
                                                  Z != null &&
                                                  Z.hasOwnProperty('display')
                                                      ? Z.display
                                                      : null),
                                              (Y.style.display = bt(
                                                  'display',
                                                  O
                                              )));
                                } catch (gt) {
                                    Yn(o, o.return, gt);
                                }
                            }
                        } else if (Fe.tag === 6) {
                            if (Ue === null)
                                try {
                                    Fe.stateNode.nodeValue = xe
                                        ? ''
                                        : Fe.memoizedProps;
                                } catch (gt) {
                                    Yn(o, o.return, gt);
                                }
                        } else if (
                            ((Fe.tag !== 22 && Fe.tag !== 23) ||
                                Fe.memoizedState === null ||
                                Fe === o) &&
                            Fe.child !== null
                        ) {
                            (Fe.child.return = Fe), (Fe = Fe.child);
                            continue;
                        }
                        if (Fe === o) break e;
                        for (; Fe.sibling === null; ) {
                            if (Fe.return === null || Fe.return === o) break e;
                            Ue === Fe && (Ue = null), (Fe = Fe.return);
                        }
                        Ue === Fe && (Ue = null),
                            (Fe.sibling.return = Fe.return),
                            (Fe = Fe.sibling);
                    }
                }
                break;
            case 19:
                Zs(u, o), Po(o), _ & 4 && Iw(o);
                break;
            case 21:
                break;
            default:
                Zs(u, o), Po(o);
        }
    }
    function Po(o) {
        var u = o.flags;
        if (u & 2) {
            try {
                e: {
                    for (var m = o.return; m !== null; ) {
                        if (bw(m)) {
                            var _ = m;
                            break e;
                        }
                        m = m.return;
                    }
                    throw Error(t(160));
                }
                switch (_.tag) {
                    case 5:
                        var A = _.stateNode;
                        _.flags & 32 && (Be(A, ''), (_.flags &= -33));
                        var P = Pw(o);
                        i0(o, P, A);
                        break;
                    case 3:
                    case 4:
                        var O = _.stateNode.containerInfo,
                            Y = Pw(o);
                        n0(o, Y, O);
                        break;
                    default:
                        throw Error(t(161));
                }
            } catch (Z) {
                Yn(o, o.return, Z);
            }
            o.flags &= -3;
        }
        u & 4096 && (o.flags &= -4097);
    }
    function uL(o, u, m) {
        (ht = o), Nw(o);
    }
    function Nw(o, u, m) {
        for (var _ = (o.mode & 1) !== 0; ht !== null; ) {
            var A = ht,
                P = A.child;
            if (A.tag === 22 && _) {
                var O = A.memoizedState !== null || Nm;
                if (!O) {
                    var Y = A.alternate,
                        Z = (Y !== null && Y.memoizedState !== null) || Qi;
                    Y = Nm;
                    var xe = Qi;
                    if (((Nm = O), (Qi = Z) && !xe))
                        for (ht = A; ht !== null; )
                            (O = ht),
                                (Z = O.child),
                                O.tag === 22 && O.memoizedState !== null
                                    ? kw(A)
                                    : Z !== null
                                      ? ((Z.return = O), (ht = Z))
                                      : kw(A);
                    for (; P !== null; ) (ht = P), Nw(P), (P = P.sibling);
                    (ht = A), (Nm = Y), (Qi = xe);
                }
                Uw(o);
            } else
                (A.subtreeFlags & 8772) !== 0 && P !== null
                    ? ((P.return = A), (ht = P))
                    : Uw(o);
        }
    }
    function Uw(o) {
        for (; ht !== null; ) {
            var u = ht;
            if ((u.flags & 8772) !== 0) {
                var m = u.alternate;
                try {
                    if ((u.flags & 8772) !== 0)
                        switch (u.tag) {
                            case 0:
                            case 11:
                            case 15:
                                Qi || Um(5, u);
                                break;
                            case 1:
                                var _ = u.stateNode;
                                if (u.flags & 4 && !Qi)
                                    if (m === null) _.componentDidMount();
                                    else {
                                        var A =
                                            u.elementType === u.type
                                                ? m.memoizedProps
                                                : Ur(u.type, m.memoizedProps);
                                        _.componentDidUpdate(
                                            A,
                                            m.memoizedState,
                                            _.__reactInternalSnapshotBeforeUpdate
                                        );
                                    }
                                var P = u.updateQueue;
                                P !== null && ul(u, P, _);
                                break;
                            case 3:
                                var O = u.updateQueue;
                                if (O !== null) {
                                    if (((m = null), u.child !== null))
                                        switch (u.child.tag) {
                                            case 5:
                                                m = u.child.stateNode;
                                                break;
                                            case 1:
                                                m = u.child.stateNode;
                                        }
                                    ul(u, O, m);
                                }
                                break;
                            case 5:
                                var Y = u.stateNode;
                                if (m === null && u.flags & 4) {
                                    m = Y;
                                    var Z = u.memoizedProps;
                                    switch (u.type) {
                                        case 'button':
                                        case 'input':
                                        case 'select':
                                        case 'textarea':
                                            Z.autoFocus && m.focus();
                                            break;
                                        case 'img':
                                            Z.src && (m.src = Z.src);
                                    }
                                }
                                break;
                            case 6:
                                break;
                            case 4:
                                break;
                            case 12:
                                break;
                            case 13:
                                if (u.memoizedState === null) {
                                    var xe = u.alternate;
                                    if (xe !== null) {
                                        var Ue = xe.memoizedState;
                                        if (Ue !== null) {
                                            var Fe = Ue.dehydrated;
                                            Fe !== null && $l(Fe);
                                        }
                                    }
                                }
                                break;
                            case 19:
                            case 17:
                            case 21:
                            case 22:
                            case 23:
                            case 25:
                                break;
                            default:
                                throw Error(t(163));
                        }
                    Qi || (u.flags & 512 && t0(u));
                } catch (Ne) {
                    Yn(u, u.return, Ne);
                }
            }
            if (u === o) {
                ht = null;
                break;
            }
            if (((m = u.sibling), m !== null)) {
                (m.return = u.return), (ht = m);
                break;
            }
            ht = u.return;
        }
    }
    function Ow(o) {
        for (; ht !== null; ) {
            var u = ht;
            if (u === o) {
                ht = null;
                break;
            }
            var m = u.sibling;
            if (m !== null) {
                (m.return = u.return), (ht = m);
                break;
            }
            ht = u.return;
        }
    }
    function kw(o) {
        for (; ht !== null; ) {
            var u = ht;
            try {
                switch (u.tag) {
                    case 0:
                    case 11:
                    case 15:
                        var m = u.return;
                        try {
                            Um(4, u);
                        } catch (Z) {
                            Yn(u, m, Z);
                        }
                        break;
                    case 1:
                        var _ = u.stateNode;
                        if (typeof _.componentDidMount == 'function') {
                            var A = u.return;
                            try {
                                _.componentDidMount();
                            } catch (Z) {
                                Yn(u, A, Z);
                            }
                        }
                        var P = u.return;
                        try {
                            t0(u);
                        } catch (Z) {
                            Yn(u, P, Z);
                        }
                        break;
                    case 5:
                        var O = u.return;
                        try {
                            t0(u);
                        } catch (Z) {
                            Yn(u, O, Z);
                        }
                }
            } catch (Z) {
                Yn(u, u.return, Z);
            }
            if (u === o) {
                ht = null;
                break;
            }
            var Y = u.sibling;
            if (Y !== null) {
                (Y.return = u.return), (ht = Y);
                break;
            }
            ht = u.return;
        }
    }
    var cL = Math.ceil,
        Om = L.ReactCurrentDispatcher,
        r0 = L.ReactCurrentOwner,
        ys = L.ReactCurrentBatchConfig,
        on = 0,
        Ci = null,
        ci = null,
        zi = 0,
        ts = 0,
        pf = On(0),
        Si = 0,
        xd = null,
        Tu = 0,
        km = 0,
        s0 = 0,
        _d = null,
        Or = null,
        o0 = 0,
        mf = 1 / 0,
        xa = null,
        Fm = !1,
        a0 = null,
        pl = null,
        Bm = !1,
        ml = null,
        zm = 0,
        Sd = 0,
        l0 = null,
        Vm = -1,
        Hm = 0;
    function xr() {
        return (on & 6) !== 0 ? Xe() : Vm !== -1 ? Vm : (Vm = Xe());
    }
    function gl(o) {
        return (o.mode & 1) === 0
            ? 1
            : (on & 2) !== 0 && zi !== 0
              ? zi & -zi
              : Kv.transition !== null
                ? (Hm === 0 && (Hm = ji()), Hm)
                : ((o = rn),
                  o !== 0 ||
                      ((o = window.event),
                      (o = o === void 0 ? 16 : am(o.type))),
                  o);
    }
    function Js(o, u, m, _) {
        if (50 < Sd) throw ((Sd = 0), (l0 = null), Error(t(185)));
        Wl(o, m, _),
            ((on & 2) === 0 || o !== Ci) &&
                (o === Ci &&
                    ((on & 2) === 0 && (km |= m), Si === 4 && yl(o, zi)),
                kr(o, _),
                m === 1 &&
                    on === 0 &&
                    (u.mode & 1) === 0 &&
                    ((mf = Xe() + 500), uu && ds()));
    }
    function kr(o, u) {
        var m = o.callbackNode;
        pi(o, u);
        var _ = Xi(o, o === Ci ? zi : 0);
        if (_ === 0)
            m !== null && We(m),
                (o.callbackNode = null),
                (o.callbackPriority = 0);
        else if (((u = _ & -_), o.callbackPriority !== u)) {
            if ((m != null && We(m), u === 1))
                o.tag === 0 ? Sm(Bw.bind(null, o)) : cu(Bw.bind(null, o)),
                    Yv(function () {
                        (on & 6) === 0 && ds();
                    }),
                    (m = null);
            else {
                switch (Ga(_)) {
                    case 1:
                        m = Et;
                        break;
                    case 4:
                        m = wt;
                        break;
                    case 16:
                        m = Qt;
                        break;
                    case 536870912:
                        m = un;
                        break;
                    default:
                        m = Qt;
                }
                m = qw(m, Fw.bind(null, o));
            }
            (o.callbackPriority = u), (o.callbackNode = m);
        }
    }
    function Fw(o, u) {
        if (((Vm = -1), (Hm = 0), (on & 6) !== 0)) throw Error(t(327));
        var m = o.callbackNode;
        if (gf() && o.callbackNode !== m) return null;
        var _ = Xi(o, o === Ci ? zi : 0);
        if (_ === 0) return null;
        if ((_ & 30) !== 0 || (_ & o.expiredLanes) !== 0 || u) u = Gm(o, _);
        else {
            u = _;
            var A = on;
            on |= 2;
            var P = Vw();
            (Ci !== o || zi !== u) &&
                ((xa = null), (mf = Xe() + 500), Cu(o, u));
            do
                try {
                    dL();
                    break;
                } catch (Y) {
                    zw(o, Y);
                }
            while (!0);
            fa(),
                (Om.current = P),
                (on = A),
                ci !== null ? (u = 0) : ((Ci = null), (zi = 0), (u = Si));
        }
        if (u !== 0) {
            if (
                (u === 2 && ((A = yo(o)), A !== 0 && ((_ = A), (u = u0(o, A)))),
                u === 1)
            )
                throw ((m = xd), Cu(o, 0), yl(o, _), kr(o, Xe()), m);
            if (u === 6) yl(o, _);
            else {
                if (
                    ((A = o.current.alternate),
                    (_ & 30) === 0 &&
                        !fL(A) &&
                        ((u = Gm(o, _)),
                        u === 2 &&
                            ((P = yo(o)), P !== 0 && ((_ = P), (u = u0(o, P)))),
                        u === 1))
                )
                    throw ((m = xd), Cu(o, 0), yl(o, _), kr(o, Xe()), m);
                switch (((o.finishedWork = A), (o.finishedLanes = _), u)) {
                    case 0:
                    case 1:
                        throw Error(t(345));
                    case 2:
                        Ru(o, Or, xa);
                        break;
                    case 3:
                        if (
                            (yl(o, _),
                            (_ & 130023424) === _ &&
                                ((u = o0 + 500 - Xe()), 10 < u))
                        ) {
                            if (Xi(o, 0) !== 0) break;
                            if (((A = o.suspendedLanes), (A & _) !== _)) {
                                xr(), (o.pingedLanes |= o.suspendedLanes & A);
                                break;
                            }
                            o.timeoutHandle = $h(Ru.bind(null, o, Or, xa), u);
                            break;
                        }
                        Ru(o, Or, xa);
                        break;
                    case 4:
                        if ((yl(o, _), (_ & 4194240) === _)) break;
                        for (u = o.eventTimes, A = -1; 0 < _; ) {
                            var O = 31 - Zt(_);
                            (P = 1 << O),
                                (O = u[O]),
                                O > A && (A = O),
                                (_ &= ~P);
                        }
                        if (
                            ((_ = A),
                            (_ = Xe() - _),
                            (_ =
                                (120 > _
                                    ? 120
                                    : 480 > _
                                      ? 480
                                      : 1080 > _
                                        ? 1080
                                        : 1920 > _
                                          ? 1920
                                          : 3e3 > _
                                            ? 3e3
                                            : 4320 > _
                                              ? 4320
                                              : 1960 * cL(_ / 1960)) - _),
                            10 < _)
                        ) {
                            o.timeoutHandle = $h(Ru.bind(null, o, Or, xa), _);
                            break;
                        }
                        Ru(o, Or, xa);
                        break;
                    case 5:
                        Ru(o, Or, xa);
                        break;
                    default:
                        throw Error(t(329));
                }
            }
        }
        return kr(o, Xe()), o.callbackNode === m ? Fw.bind(null, o) : null;
    }
    function u0(o, u) {
        var m = _d;
        return (
            o.current.memoizedState.isDehydrated && (Cu(o, u).flags |= 256),
            (o = Gm(o, u)),
            o !== 2 && ((u = Or), (Or = m), u !== null && c0(u)),
            o
        );
    }
    function c0(o) {
        Or === null ? (Or = o) : Or.push.apply(Or, o);
    }
    function fL(o) {
        for (var u = o; ; ) {
            if (u.flags & 16384) {
                var m = u.updateQueue;
                if (m !== null && ((m = m.stores), m !== null))
                    for (var _ = 0; _ < m.length; _++) {
                        var A = m[_],
                            P = A.getSnapshot;
                        A = A.value;
                        try {
                            if (!fr(P(), A)) return !1;
                        } catch {
                            return !1;
                        }
                    }
            }
            if (((m = u.child), u.subtreeFlags & 16384 && m !== null))
                (m.return = u), (u = m);
            else {
                if (u === o) break;
                for (; u.sibling === null; ) {
                    if (u.return === null || u.return === o) return !0;
                    u = u.return;
                }
                (u.sibling.return = u.return), (u = u.sibling);
            }
        }
        return !0;
    }
    function yl(o, u) {
        for (
            u &= ~s0,
                u &= ~km,
                o.suspendedLanes |= u,
                o.pingedLanes &= ~u,
                o = o.expirationTimes;
            0 < u;

        ) {
            var m = 31 - Zt(u),
                _ = 1 << m;
            (o[m] = -1), (u &= ~_);
        }
    }
    function Bw(o) {
        if ((on & 6) !== 0) throw Error(t(327));
        gf();
        var u = Xi(o, 0);
        if ((u & 1) === 0) return kr(o, Xe()), null;
        var m = Gm(o, u);
        if (o.tag !== 0 && m === 2) {
            var _ = yo(o);
            _ !== 0 && ((u = _), (m = u0(o, _)));
        }
        if (m === 1) throw ((m = xd), Cu(o, 0), yl(o, u), kr(o, Xe()), m);
        if (m === 6) throw Error(t(345));
        return (
            (o.finishedWork = o.current.alternate),
            (o.finishedLanes = u),
            Ru(o, Or, xa),
            kr(o, Xe()),
            null
        );
    }
    function f0(o, u) {
        var m = on;
        on |= 1;
        try {
            return o(u);
        } finally {
            (on = m), on === 0 && ((mf = Xe() + 500), uu && ds());
        }
    }
    function Au(o) {
        ml !== null && ml.tag === 0 && (on & 6) === 0 && gf();
        var u = on;
        on |= 1;
        var m = ys.transition,
            _ = rn;
        try {
            if (((ys.transition = null), (rn = 1), o)) return o();
        } finally {
            (rn = _), (ys.transition = m), (on = u), (on & 6) === 0 && ds();
        }
    }
    function h0() {
        (ts = pf.current), Sn(pf);
    }
    function Cu(o, u) {
        (o.finishedWork = null), (o.finishedLanes = 0);
        var m = o.timeoutHandle;
        if ((m !== -1 && ((o.timeoutHandle = -1), Yh(m)), ci !== null))
            for (m = ci.return; m !== null; ) {
                var _ = m;
                switch ((Hs(_), _.tag)) {
                    case 1:
                        (_ = _.type.childContextTypes), _ != null && au();
                        break;
                    case 3:
                        Ro(), Sn(Ui), Sn(gi), ms();
                        break;
                    case 5:
                        cl(_);
                        break;
                    case 4:
                        Ro();
                        break;
                    case 13:
                        Sn(An);
                        break;
                    case 19:
                        Sn(An);
                        break;
                    case 10:
                        pu(_.type._context);
                        break;
                    case 22:
                    case 23:
                        h0();
                }
                m = m.return;
            }
        if (
            ((Ci = o),
            (ci = o = vl(o.current, null)),
            (zi = ts = u),
            (Si = 0),
            (xd = null),
            (s0 = km = Tu = 0),
            (Or = _d = null),
            Ws !== null)
        ) {
            for (u = 0; u < Ws.length; u++)
                if (((m = Ws[u]), (_ = m.interleaved), _ !== null)) {
                    m.interleaved = null;
                    var A = _.next,
                        P = m.pending;
                    if (P !== null) {
                        var O = P.next;
                        (P.next = A), (_.next = O);
                    }
                    m.pending = _;
                }
            Ws = null;
        }
        return o;
    }
    function zw(o, u) {
        do {
            var m = ci;
            try {
                if ((fa(), (ma.current = ff), Qr)) {
                    for (var _ = wn.memoizedState; _ !== null; ) {
                        var A = _.queue;
                        A !== null && (A.pending = null), (_ = _.next);
                    }
                    Qr = !1;
                }
                if (
                    ((js = 0),
                    (sn = Fn = wn = null),
                    (Ai = !1),
                    (bo = 0),
                    (r0.current = null),
                    m === null || m.return === null)
                ) {
                    (Si = 1), (xd = u), (ci = null);
                    break;
                }
                e: {
                    var P = o,
                        O = m.return,
                        Y = m,
                        Z = u;
                    if (
                        ((u = zi),
                        (Y.flags |= 32768),
                        Z !== null &&
                            typeof Z == 'object' &&
                            typeof Z.then == 'function')
                    ) {
                        var xe = Z,
                            Ue = Y,
                            Fe = Ue.tag;
                        if (
                            (Ue.mode & 1) === 0 &&
                            (Fe === 0 || Fe === 11 || Fe === 15)
                        ) {
                            var Ne = Ue.alternate;
                            Ne
                                ? ((Ue.updateQueue = Ne.updateQueue),
                                  (Ue.memoizedState = Ne.memoizedState),
                                  (Ue.lanes = Ne.lanes))
                                : ((Ue.updateQueue = null),
                                  (Ue.memoizedState = null));
                        }
                        var at = ct(O);
                        if (at !== null) {
                            (at.flags &= -257),
                                kt(at, O, Y, P, u),
                                at.mode & 1 && ze(P, xe, u),
                                (u = at),
                                (Z = xe);
                            var mt = u.updateQueue;
                            if (mt === null) {
                                var gt = new Set();
                                gt.add(Z), (u.updateQueue = gt);
                            } else mt.add(Z);
                            break e;
                        } else {
                            if ((u & 1) === 0) {
                                ze(P, xe, u), d0();
                                break e;
                            }
                            Z = Error(t(426));
                        }
                    } else if (Tn && Y.mode & 1) {
                        var ni = ct(O);
                        if (ni !== null) {
                            (ni.flags & 65536) === 0 && (ni.flags |= 256),
                                kt(ni, O, Y, P, u),
                                al(E(Z, Y));
                            break e;
                        }
                    }
                    (P = Z = E(Z, Y)),
                        Si !== 4 && (Si = 2),
                        _d === null ? (_d = [P]) : _d.push(P),
                        (P = O);
                    do {
                        switch (P.tag) {
                            case 3:
                                (P.flags |= 65536), (u &= -u), (P.lanes |= u);
                                var he = te(P, Z, u);
                                ha(P, he);
                                break e;
                            case 1:
                                Y = Z;
                                var J = P.type,
                                    de = P.stateNode;
                                if (
                                    (P.flags & 128) === 0 &&
                                    (typeof J.getDerivedStateFromError ==
                                        'function' ||
                                        (de !== null &&
                                            typeof de.componentDidCatch ==
                                                'function' &&
                                            (pl === null || !pl.has(de))))
                                ) {
                                    (P.flags |= 65536),
                                        (u &= -u),
                                        (P.lanes |= u);
                                    var He = Me(P, Y, u);
                                    ha(P, He);
                                    break e;
                                }
                        }
                        P = P.return;
                    } while (P !== null);
                }
                Gw(m);
            } catch (xt) {
                (u = xt), ci === m && m !== null && (ci = m = m.return);
                continue;
            }
            break;
        } while (!0);
    }
    function Vw() {
        var o = Om.current;
        return (Om.current = ff), o === null ? ff : o;
    }
    function d0() {
        (Si === 0 || Si === 3 || Si === 2) && (Si = 4),
            Ci === null ||
                ((Tu & 268435455) === 0 && (km & 268435455) === 0) ||
                yl(Ci, zi);
    }
    function Gm(o, u) {
        var m = on;
        on |= 2;
        var _ = Vw();
        (Ci !== o || zi !== u) && ((xa = null), Cu(o, u));
        do
            try {
                hL();
                break;
            } catch (A) {
                zw(o, A);
            }
        while (!0);
        if ((fa(), (on = m), (Om.current = _), ci !== null))
            throw Error(t(261));
        return (Ci = null), (zi = 0), Si;
    }
    function hL() {
        for (; ci !== null; ) Hw(ci);
    }
    function dL() {
        for (; ci !== null && !nt(); ) Hw(ci);
    }
    function Hw(o) {
        var u = jw(o.alternate, o, ts);
        (o.memoizedProps = o.pendingProps),
            u === null ? Gw(o) : (ci = u),
            (r0.current = null);
    }
    function Gw(o) {
        var u = o;
        do {
            var m = u.alternate;
            if (((o = u.return), (u.flags & 32768) === 0)) {
                if (((m = sL(m, u, ts)), m !== null)) {
                    ci = m;
                    return;
                }
            } else {
                if (((m = oL(m, u)), m !== null)) {
                    (m.flags &= 32767), (ci = m);
                    return;
                }
                if (o !== null)
                    (o.flags |= 32768),
                        (o.subtreeFlags = 0),
                        (o.deletions = null);
                else {
                    (Si = 6), (ci = null);
                    return;
                }
            }
            if (((u = u.sibling), u !== null)) {
                ci = u;
                return;
            }
            ci = u = o;
        } while (u !== null);
        Si === 0 && (Si = 5);
    }
    function Ru(o, u, m) {
        var _ = rn,
            A = ys.transition;
        try {
            (ys.transition = null), (rn = 1), pL(o, u, m, _);
        } finally {
            (ys.transition = A), (rn = _);
        }
        return null;
    }
    function pL(o, u, m, _) {
        do gf();
        while (ml !== null);
        if ((on & 6) !== 0) throw Error(t(327));
        m = o.finishedWork;
        var A = o.finishedLanes;
        if (m === null) return null;
        if (((o.finishedWork = null), (o.finishedLanes = 0), m === o.current))
            throw Error(t(177));
        (o.callbackNode = null), (o.callbackPriority = 0);
        var P = m.lanes | m.childLanes;
        if (
            (Xv(o, P),
            o === Ci && ((ci = Ci = null), (zi = 0)),
            ((m.subtreeFlags & 2064) === 0 && (m.flags & 2064) === 0) ||
                Bm ||
                ((Bm = !0),
                qw(Qt, function () {
                    return gf(), null;
                })),
            (P = (m.flags & 15990) !== 0),
            (m.subtreeFlags & 15990) !== 0 || P)
        ) {
            (P = ys.transition), (ys.transition = null);
            var O = rn;
            rn = 1;
            var Y = on;
            (on |= 4),
                (r0.current = null),
                lL(o, m),
                Dw(m, o),
                oi(jh),
                (Cr = !!rl),
                (jh = rl = null),
                (o.current = m),
                uL(m),
                pt(),
                (on = Y),
                (rn = O),
                (ys.transition = P);
        } else o.current = m;
        if (
            (Bm && ((Bm = !1), (ml = o), (zm = A)),
            (P = o.pendingLanes),
            P === 0 && (pl = null),
            je(m.stateNode),
            kr(o, Xe()),
            u !== null)
        )
            for (_ = o.onRecoverableError, m = 0; m < u.length; m++)
                (A = u[m]),
                    _(A.value, { componentStack: A.stack, digest: A.digest });
        if (Fm) throw ((Fm = !1), (o = a0), (a0 = null), o);
        return (
            (zm & 1) !== 0 && o.tag !== 0 && gf(),
            (P = o.pendingLanes),
            (P & 1) !== 0 ? (o === l0 ? Sd++ : ((Sd = 0), (l0 = o))) : (Sd = 0),
            ds(),
            null
        );
    }
    function gf() {
        if (ml !== null) {
            var o = Ga(zm),
                u = ys.transition,
                m = rn;
            try {
                if (
                    ((ys.transition = null),
                    (rn = 16 > o ? 16 : o),
                    ml === null)
                )
                    var _ = !1;
                else {
                    if (((o = ml), (ml = null), (zm = 0), (on & 6) !== 0))
                        throw Error(t(331));
                    var A = on;
                    for (on |= 4, ht = o.current; ht !== null; ) {
                        var P = ht,
                            O = P.child;
                        if ((ht.flags & 16) !== 0) {
                            var Y = P.deletions;
                            if (Y !== null) {
                                for (var Z = 0; Z < Y.length; Z++) {
                                    var xe = Y[Z];
                                    for (ht = xe; ht !== null; ) {
                                        var Ue = ht;
                                        switch (Ue.tag) {
                                            case 0:
                                            case 11:
                                            case 15:
                                                vd(8, Ue, P);
                                        }
                                        var Fe = Ue.child;
                                        if (Fe !== null)
                                            (Fe.return = Ue), (ht = Fe);
                                        else
                                            for (; ht !== null; ) {
                                                Ue = ht;
                                                var Ne = Ue.sibling,
                                                    at = Ue.return;
                                                if ((Rw(Ue), Ue === xe)) {
                                                    ht = null;
                                                    break;
                                                }
                                                if (Ne !== null) {
                                                    (Ne.return = at), (ht = Ne);
                                                    break;
                                                }
                                                ht = at;
                                            }
                                    }
                                }
                                var mt = P.alternate;
                                if (mt !== null) {
                                    var gt = mt.child;
                                    if (gt !== null) {
                                        mt.child = null;
                                        do {
                                            var ni = gt.sibling;
                                            (gt.sibling = null), (gt = ni);
                                        } while (gt !== null);
                                    }
                                }
                                ht = P;
                            }
                        }
                        if ((P.subtreeFlags & 2064) !== 0 && O !== null)
                            (O.return = P), (ht = O);
                        else
                            e: for (; ht !== null; ) {
                                if (((P = ht), (P.flags & 2048) !== 0))
                                    switch (P.tag) {
                                        case 0:
                                        case 11:
                                        case 15:
                                            vd(9, P, P.return);
                                    }
                                var he = P.sibling;
                                if (he !== null) {
                                    (he.return = P.return), (ht = he);
                                    break e;
                                }
                                ht = P.return;
                            }
                    }
                    var J = o.current;
                    for (ht = J; ht !== null; ) {
                        O = ht;
                        var de = O.child;
                        if ((O.subtreeFlags & 2064) !== 0 && de !== null)
                            (de.return = O), (ht = de);
                        else
                            e: for (O = J; ht !== null; ) {
                                if (((Y = ht), (Y.flags & 2048) !== 0))
                                    try {
                                        switch (Y.tag) {
                                            case 0:
                                            case 11:
                                            case 15:
                                                Um(9, Y);
                                        }
                                    } catch (xt) {
                                        Yn(Y, Y.return, xt);
                                    }
                                if (Y === O) {
                                    ht = null;
                                    break e;
                                }
                                var He = Y.sibling;
                                if (He !== null) {
                                    (He.return = Y.return), (ht = He);
                                    break e;
                                }
                                ht = Y.return;
                            }
                    }
                    if (
                        ((on = A),
                        ds(),
                        ft && typeof ft.onPostCommitFiberRoot == 'function')
                    )
                        try {
                            ft.onPostCommitFiberRoot(En, o);
                        } catch {}
                    _ = !0;
                }
                return _;
            } finally {
                (rn = m), (ys.transition = u);
            }
        }
        return !1;
    }
    function Ww(o, u, m) {
        (u = E(m, u)),
            (u = te(o, u, 1)),
            (o = bn(o, u, 1)),
            (u = xr()),
            o !== null && (Wl(o, 1, u), kr(o, u));
    }
    function Yn(o, u, m) {
        if (o.tag === 3) Ww(o, o, m);
        else
            for (; u !== null; ) {
                if (u.tag === 3) {
                    Ww(u, o, m);
                    break;
                } else if (u.tag === 1) {
                    var _ = u.stateNode;
                    if (
                        typeof u.type.getDerivedStateFromError == 'function' ||
                        (typeof _.componentDidCatch == 'function' &&
                            (pl === null || !pl.has(_)))
                    ) {
                        (o = E(m, o)),
                            (o = Me(u, o, 1)),
                            (u = bn(u, o, 1)),
                            (o = xr()),
                            u !== null && (Wl(u, 1, o), kr(u, o));
                        break;
                    }
                }
                u = u.return;
            }
    }
    function mL(o, u, m) {
        var _ = o.pingCache;
        _ !== null && _.delete(u),
            (u = xr()),
            (o.pingedLanes |= o.suspendedLanes & m),
            Ci === o &&
                (zi & m) === m &&
                (Si === 4 ||
                (Si === 3 && (zi & 130023424) === zi && 500 > Xe() - o0)
                    ? Cu(o, 0)
                    : (s0 |= m)),
            kr(o, u);
    }
    function Xw(o, u) {
        u === 0 &&
            ((o.mode & 1) === 0
                ? (u = 1)
                : ((u = zn),
                  (zn <<= 1),
                  (zn & 130023424) === 0 && (zn = 4194304)));
        var m = xr();
        (o = Zr(o, u)), o !== null && (Wl(o, u, m), kr(o, m));
    }
    function gL(o) {
        var u = o.memoizedState,
            m = 0;
        u !== null && (m = u.retryLane), Xw(o, m);
    }
    function yL(o, u) {
        var m = 0;
        switch (o.tag) {
            case 13:
                var _ = o.stateNode,
                    A = o.memoizedState;
                A !== null && (m = A.retryLane);
                break;
            case 19:
                _ = o.stateNode;
                break;
            default:
                throw Error(t(314));
        }
        _ !== null && _.delete(u), Xw(o, m);
    }
    var jw;
    jw = function (o, u, m) {
        if (o !== null)
            if (o.memoizedProps !== u.pendingProps || Ui.current) Gt = !0;
            else {
                if ((o.lanes & m) === 0 && (u.flags & 128) === 0)
                    return (Gt = !1), rL(o, u, m);
                Gt = (o.flags & 131072) !== 0;
            }
        else (Gt = !1), Tn && (u.flags & 1048576) !== 0 && ed(u, ef, u.index);
        switch (((u.lanes = 0), u.tag)) {
            case 2:
                var _ = u.type;
                Dm(o, u), (o = u.pendingProps);
                var A = ra(u, gi.current);
                Co(u, m), (A = xu(null, u, _, o, A, m));
                var P = ld();
                return (
                    (u.flags |= 1),
                    typeof A == 'object' &&
                    A !== null &&
                    typeof A.render == 'function' &&
                    A.$$typeof === void 0
                        ? ((u.tag = 1),
                          (u.memoizedState = null),
                          (u.updateQueue = null),
                          Ei(_) ? ((P = !0), sa(u)) : (P = !1),
                          (u.memoizedState =
                              A.state !== null && A.state !== void 0
                                  ? A.state
                                  : null),
                          Ht(u),
                          (A.updater = hf),
                          (u.stateNode = A),
                          (A._reactInternals = u),
                          x(u, _, o, m),
                          (u = Vt(null, u, _, !0, P, m)))
                        : ((u.tag = 0),
                          Tn && P && td(u),
                          it(null, u, A, m),
                          (u = u.child)),
                    u
                );
            case 16:
                _ = u.elementType;
                e: {
                    switch (
                        (Dm(o, u),
                        (o = u.pendingProps),
                        (A = _._init),
                        (_ = A(_._payload)),
                        (u.type = _),
                        (A = u.tag = xL(_)),
                        (o = Ur(_, o)),
                        A)
                    ) {
                        case 0:
                            u = Qe(null, u, _, o, m);
                            break e;
                        case 1:
                            u = yt(null, u, _, o, m);
                            break e;
                        case 11:
                            u = _i(null, u, _, o, m);
                            break e;
                        case 14:
                            u = vr(null, u, _, Ur(_.type, o), m);
                            break e;
                    }
                    throw Error(t(306, _, ''));
                }
                return u;
            case 0:
                return (
                    (_ = u.type),
                    (A = u.pendingProps),
                    (A = u.elementType === _ ? A : Ur(_, A)),
                    Qe(o, u, _, A, m)
                );
            case 1:
                return (
                    (_ = u.type),
                    (A = u.pendingProps),
                    (A = u.elementType === _ ? A : Ur(_, A)),
                    yt(o, u, _, A, m)
                );
            case 3:
                e: {
                    if ((Ft(u), o === null)) throw Error(t(387));
                    (_ = u.pendingProps),
                        (P = u.memoizedState),
                        (A = P.element),
                        Hn(o, u),
                        kn(u, _, null, m);
                    var O = u.memoizedState;
                    if (((_ = O.element), P.isDehydrated))
                        if (
                            ((P = {
                                element: _,
                                isDehydrated: !1,
                                cache: O.cache,
                                pendingSuspenseBoundaries:
                                    O.pendingSuspenseBoundaries,
                                transitions: O.transitions,
                            }),
                            (u.updateQueue.baseState = P),
                            (u.memoizedState = P),
                            u.flags & 256)
                        ) {
                            (A = E(Error(t(423)), u)), (u = nn(o, u, _, m, A));
                            break e;
                        } else if (_ !== A) {
                            (A = E(Error(t(424)), u)), (u = nn(o, u, _, m, A));
                            break e;
                        } else
                            for (
                                ki = ks(u.stateNode.containerInfo.firstChild),
                                    yi = u,
                                    Tn = !0,
                                    Nr = null,
                                    m = du(u, null, _, m),
                                    u.child = m;
                                m;

                            )
                                (m.flags = (m.flags & -3) | 4096),
                                    (m = m.sibling);
                    else {
                        if ((Ao(), _ === A)) {
                            u = va(o, u, m);
                            break e;
                        }
                        it(o, u, _, m);
                    }
                    u = u.child;
                }
                return u;
            case 5:
                return (
                    pa(u),
                    o === null && nf(u),
                    (_ = u.type),
                    (A = u.pendingProps),
                    (P = o !== null ? o.memoizedProps : null),
                    (O = A.children),
                    qh(_, A)
                        ? (O = null)
                        : P !== null && qh(_, P) && (u.flags |= 32),
                    _e(o, u),
                    it(o, u, O, m),
                    u.child
                );
            case 6:
                return o === null && nf(u), null;
            case 13:
                return Ys(o, u, m);
            case 4:
                return (
                    yu(u, u.stateNode.containerInfo),
                    (_ = u.pendingProps),
                    o === null ? (u.child = la(u, null, _, m)) : it(o, u, _, m),
                    u.child
                );
            case 11:
                return (
                    (_ = u.type),
                    (A = u.pendingProps),
                    (A = u.elementType === _ ? A : Ur(_, A)),
                    _i(o, u, _, A, m)
                );
            case 7:
                return it(o, u, u.pendingProps, m), u.child;
            case 8:
                return it(o, u, u.pendingProps.children, m), u.child;
            case 12:
                return it(o, u, u.pendingProps.children, m), u.child;
            case 10:
                e: {
                    if (
                        ((_ = u.type._context),
                        (A = u.pendingProps),
                        (P = u.memoizedProps),
                        (O = A.value),
                        yn(ua, _._currentValue),
                        (_._currentValue = O),
                        P !== null)
                    )
                        if (fr(P.value, O)) {
                            if (P.children === A.children && !Ui.current) {
                                u = va(o, u, m);
                                break e;
                            }
                        } else
                            for (
                                P = u.child, P !== null && (P.return = u);
                                P !== null;

                            ) {
                                var Y = P.dependencies;
                                if (Y !== null) {
                                    O = P.child;
                                    for (var Z = Y.firstContext; Z !== null; ) {
                                        if (Z.context === _) {
                                            if (P.tag === 1) {
                                                (Z = mn(-1, m & -m)),
                                                    (Z.tag = 2);
                                                var xe = P.updateQueue;
                                                if (xe !== null) {
                                                    xe = xe.shared;
                                                    var Ue = xe.pending;
                                                    Ue === null
                                                        ? (Z.next = Z)
                                                        : ((Z.next = Ue.next),
                                                          (Ue.next = Z)),
                                                        (xe.pending = Z);
                                                }
                                            }
                                            (P.lanes |= m),
                                                (Z = P.alternate),
                                                Z !== null && (Z.lanes |= m),
                                                mu(P.return, m, u),
                                                (Y.lanes |= m);
                                            break;
                                        }
                                        Z = Z.next;
                                    }
                                } else if (P.tag === 10)
                                    O = P.type === u.type ? null : P.child;
                                else if (P.tag === 18) {
                                    if (((O = P.return), O === null))
                                        throw Error(t(341));
                                    (O.lanes |= m),
                                        (Y = O.alternate),
                                        Y !== null && (Y.lanes |= m),
                                        mu(O, m, u),
                                        (O = P.sibling);
                                } else O = P.child;
                                if (O !== null) O.return = P;
                                else
                                    for (O = P; O !== null; ) {
                                        if (O === u) {
                                            O = null;
                                            break;
                                        }
                                        if (((P = O.sibling), P !== null)) {
                                            (P.return = O.return), (O = P);
                                            break;
                                        }
                                        O = O.return;
                                    }
                                P = O;
                            }
                    it(o, u, A.children, m), (u = u.child);
                }
                return u;
            case 9:
                return (
                    (A = u.type),
                    (_ = u.pendingProps.children),
                    Co(u, m),
                    (A = pr(A)),
                    (_ = _(A)),
                    (u.flags |= 1),
                    it(o, u, _, m),
                    u.child
                );
            case 14:
                return (
                    (_ = u.type),
                    (A = Ur(_, u.pendingProps)),
                    (A = Ur(_.type, A)),
                    vr(o, u, _, A, m)
                );
            case 15:
                return pe(o, u, u.type, u.pendingProps, m);
            case 17:
                return (
                    (_ = u.type),
                    (A = u.pendingProps),
                    (A = u.elementType === _ ? A : Ur(_, A)),
                    Dm(o, u),
                    (u.tag = 1),
                    Ei(_) ? ((o = !0), sa(u)) : (o = !1),
                    Co(u, m),
                    f(u, _, A),
                    x(u, _, A, m),
                    Vt(null, u, _, !0, o, m)
                );
            case 19:
                return Mw(o, u, m);
            case 22:
                return se(o, u, m);
        }
        throw Error(t(156, u.tag));
    };
    function qw(o, u) {
        return le(o, u);
    }
    function vL(o, u, m, _) {
        (this.tag = o),
            (this.key = m),
            (this.sibling =
                this.child =
                this.return =
                this.stateNode =
                this.type =
                this.elementType =
                    null),
            (this.index = 0),
            (this.ref = null),
            (this.pendingProps = u),
            (this.dependencies =
                this.memoizedState =
                this.updateQueue =
                this.memoizedProps =
                    null),
            (this.mode = _),
            (this.subtreeFlags = this.flags = 0),
            (this.deletions = null),
            (this.childLanes = this.lanes = 0),
            (this.alternate = null);
    }
    function vs(o, u, m, _) {
        return new vL(o, u, m, _);
    }
    function p0(o) {
        return (o = o.prototype), !(!o || !o.isReactComponent);
    }
    function xL(o) {
        if (typeof o == 'function') return p0(o) ? 1 : 0;
        if (o != null) {
            if (((o = o.$$typeof), o === ie)) return 11;
            if (o === Se) return 14;
        }
        return 2;
    }
    function vl(o, u) {
        var m = o.alternate;
        return (
            m === null
                ? ((m = vs(o.tag, u, o.key, o.mode)),
                  (m.elementType = o.elementType),
                  (m.type = o.type),
                  (m.stateNode = o.stateNode),
                  (m.alternate = o),
                  (o.alternate = m))
                : ((m.pendingProps = u),
                  (m.type = o.type),
                  (m.flags = 0),
                  (m.subtreeFlags = 0),
                  (m.deletions = null)),
            (m.flags = o.flags & 14680064),
            (m.childLanes = o.childLanes),
            (m.lanes = o.lanes),
            (m.child = o.child),
            (m.memoizedProps = o.memoizedProps),
            (m.memoizedState = o.memoizedState),
            (m.updateQueue = o.updateQueue),
            (u = o.dependencies),
            (m.dependencies =
                u === null
                    ? null
                    : { lanes: u.lanes, firstContext: u.firstContext }),
            (m.sibling = o.sibling),
            (m.index = o.index),
            (m.ref = o.ref),
            m
        );
    }
    function Wm(o, u, m, _, A, P) {
        var O = 2;
        if (((_ = o), typeof o == 'function')) p0(o) && (O = 1);
        else if (typeof o == 'string') O = 5;
        else
            e: switch (o) {
                case B:
                    return bu(m.children, A, P, u);
                case z:
                    (O = 8), (A |= 8);
                    break;
                case U:
                    return (
                        (o = vs(12, m, u, A | 2)),
                        (o.elementType = U),
                        (o.lanes = P),
                        o
                    );
                case ee:
                    return (
                        (o = vs(13, m, u, A)),
                        (o.elementType = ee),
                        (o.lanes = P),
                        o
                    );
                case ue:
                    return (
                        (o = vs(19, m, u, A)),
                        (o.elementType = ue),
                        (o.lanes = P),
                        o
                    );
                case me:
                    return Xm(m, A, P, u);
                default:
                    if (typeof o == 'object' && o !== null)
                        switch (o.$$typeof) {
                            case D:
                                O = 10;
                                break e;
                            case H:
                                O = 9;
                                break e;
                            case ie:
                                O = 11;
                                break e;
                            case Se:
                                O = 14;
                                break e;
                            case ce:
                                (O = 16), (_ = null);
                                break e;
                        }
                    throw Error(t(130, o == null ? o : typeof o, ''));
            }
        return (
            (u = vs(O, m, u, A)),
            (u.elementType = o),
            (u.type = _),
            (u.lanes = P),
            u
        );
    }
    function bu(o, u, m, _) {
        return (o = vs(7, o, _, u)), (o.lanes = m), o;
    }
    function Xm(o, u, m, _) {
        return (
            (o = vs(22, o, _, u)),
            (o.elementType = me),
            (o.lanes = m),
            (o.stateNode = { isHidden: !1 }),
            o
        );
    }
    function m0(o, u, m) {
        return (o = vs(6, o, null, u)), (o.lanes = m), o;
    }
    function g0(o, u, m) {
        return (
            (u = vs(4, o.children !== null ? o.children : [], o.key, u)),
            (u.lanes = m),
            (u.stateNode = {
                containerInfo: o.containerInfo,
                pendingChildren: null,
                implementation: o.implementation,
            }),
            u
        );
    }
    function _L(o, u, m, _, A) {
        (this.tag = u),
            (this.containerInfo = o),
            (this.finishedWork =
                this.pingCache =
                this.current =
                this.pendingChildren =
                    null),
            (this.timeoutHandle = -1),
            (this.callbackNode = this.pendingContext = this.context = null),
            (this.callbackPriority = 0),
            (this.eventTimes = Va(0)),
            (this.expirationTimes = Va(-1)),
            (this.entangledLanes =
                this.finishedLanes =
                this.mutableReadLanes =
                this.expiredLanes =
                this.pingedLanes =
                this.suspendedLanes =
                this.pendingLanes =
                    0),
            (this.entanglements = Va(0)),
            (this.identifierPrefix = _),
            (this.onRecoverableError = A),
            (this.mutableSourceEagerHydrationData = null);
    }
    function y0(o, u, m, _, A, P, O, Y, Z) {
        return (
            (o = new _L(o, u, m, Y, Z)),
            u === 1 ? ((u = 1), P === !0 && (u |= 8)) : (u = 0),
            (P = vs(3, null, null, u)),
            (o.current = P),
            (P.stateNode = o),
            (P.memoizedState = {
                element: _,
                isDehydrated: m,
                cache: null,
                transitions: null,
                pendingSuspenseBoundaries: null,
            }),
            Ht(P),
            o
        );
    }
    function SL(o, u, m) {
        var _ =
            3 < arguments.length && arguments[3] !== void 0
                ? arguments[3]
                : null;
        return {
            $$typeof: N,
            key: _ == null ? null : '' + _,
            children: o,
            containerInfo: u,
            implementation: m,
        };
    }
    function $w(o) {
        if (!o) return Bs;
        o = o._reactInternals;
        e: {
            if (bs(o) !== o || o.tag !== 1) throw Error(t(170));
            var u = o;
            do {
                switch (u.tag) {
                    case 3:
                        u = u.stateNode.context;
                        break e;
                    case 1:
                        if (Ei(u.type)) {
                            u =
                                u.stateNode
                                    .__reactInternalMemoizedMergedChildContext;
                            break e;
                        }
                }
                u = u.return;
            } while (u !== null);
            throw Error(t(171));
        }
        if (o.tag === 1) {
            var m = o.type;
            if (Ei(m)) return lu(o, m, u);
        }
        return u;
    }
    function Yw(o, u, m, _, A, P, O, Y, Z) {
        return (
            (o = y0(m, _, !0, o, A, P, O, Y, Z)),
            (o.context = $w(null)),
            (m = o.current),
            (_ = xr()),
            (A = gl(m)),
            (P = mn(_, A)),
            (P.callback = u ?? null),
            bn(m, P, A),
            (o.current.lanes = A),
            Wl(o, A, _),
            kr(o, _),
            o
        );
    }
    function jm(o, u, m, _) {
        var A = u.current,
            P = xr(),
            O = gl(A);
        return (
            (m = $w(m)),
            u.context === null ? (u.context = m) : (u.pendingContext = m),
            (u = mn(P, O)),
            (u.payload = { element: o }),
            (_ = _ === void 0 ? null : _),
            _ !== null && (u.callback = _),
            (o = bn(A, u, O)),
            o !== null && (Js(o, A, O, P), Ti(o, A, O)),
            O
        );
    }
    function qm(o) {
        if (((o = o.current), !o.child)) return null;
        switch (o.child.tag) {
            case 5:
                return o.child.stateNode;
            default:
                return o.child.stateNode;
        }
    }
    function Kw(o, u) {
        if (((o = o.memoizedState), o !== null && o.dehydrated !== null)) {
            var m = o.retryLane;
            o.retryLane = m !== 0 && m < u ? m : u;
        }
    }
    function v0(o, u) {
        Kw(o, u), (o = o.alternate) && Kw(o, u);
    }
    function wL() {
        return null;
    }
    var Zw =
        typeof reportError == 'function'
            ? reportError
            : function (o) {
                  console.error(o);
              };
    function x0(o) {
        this._internalRoot = o;
    }
    ($m.prototype.render = x0.prototype.render =
        function (o) {
            var u = this._internalRoot;
            if (u === null) throw Error(t(409));
            jm(o, u, null, null);
        }),
        ($m.prototype.unmount = x0.prototype.unmount =
            function () {
                var o = this._internalRoot;
                if (o !== null) {
                    this._internalRoot = null;
                    var u = o.containerInfo;
                    Au(function () {
                        jm(null, o, null, null);
                    }),
                        (u[dr] = null);
                }
            });
    function $m(o) {
        this._internalRoot = o;
    }
    $m.prototype.unstable_scheduleHydration = function (o) {
        if (o) {
            var u = xc();
            o = { blockedOn: null, target: o, priority: u };
            for (
                var m = 0;
                m < vo.length && u !== 0 && u < vo[m].priority;
                m++
            );
            vo.splice(m, 0, o), m === 0 && wc(o);
        }
    };
    function _0(o) {
        return !(
            !o ||
            (o.nodeType !== 1 && o.nodeType !== 9 && o.nodeType !== 11)
        );
    }
    function Ym(o) {
        return !(
            !o ||
            (o.nodeType !== 1 &&
                o.nodeType !== 9 &&
                o.nodeType !== 11 &&
                (o.nodeType !== 8 ||
                    o.nodeValue !== ' react-mount-point-unstable '))
        );
    }
    function Jw() {}
    function ML(o, u, m, _, A) {
        if (A) {
            if (typeof _ == 'function') {
                var P = _;
                _ = function () {
                    var xe = qm(O);
                    P.call(xe);
                };
            }
            var O = Yw(u, _, o, 0, null, !1, !1, '', Jw);
            return (
                (o._reactRootContainer = O),
                (o[dr] = O.current),
                nl(o.nodeType === 8 ? o.parentNode : o),
                Au(),
                O
            );
        }
        for (; (A = o.lastChild); ) o.removeChild(A);
        if (typeof _ == 'function') {
            var Y = _;
            _ = function () {
                var xe = qm(Z);
                Y.call(xe);
            };
        }
        var Z = y0(o, 0, !1, null, null, !1, !1, '', Jw);
        return (
            (o._reactRootContainer = Z),
            (o[dr] = Z.current),
            nl(o.nodeType === 8 ? o.parentNode : o),
            Au(function () {
                jm(u, Z, m, _);
            }),
            Z
        );
    }
    function Km(o, u, m, _, A) {
        var P = m._reactRootContainer;
        if (P) {
            var O = P;
            if (typeof A == 'function') {
                var Y = A;
                A = function () {
                    var Z = qm(O);
                    Y.call(Z);
                };
            }
            jm(u, O, o, A);
        } else O = ML(m, u, o, A, _);
        return qm(O);
    }
    (Xl = function (o) {
        switch (o.tag) {
            case 3:
                var u = o.stateNode;
                if (u.current.memoizedState.isDehydrated) {
                    var m = fn(u.pendingLanes);
                    m !== 0 &&
                        (Ha(u, m | 1),
                        kr(u, Xe()),
                        (on & 6) === 0 && ((mf = Xe() + 500), ds()));
                }
                break;
            case 13:
                Au(function () {
                    var _ = Zr(o, 1);
                    if (_ !== null) {
                        var A = xr();
                        Js(_, o, 1, A);
                    }
                }),
                    v0(o, 1);
        }
    }),
        (bh = function (o) {
            if (o.tag === 13) {
                var u = Zr(o, 134217728);
                if (u !== null) {
                    var m = xr();
                    Js(u, o, 134217728, m);
                }
                v0(o, 134217728);
            }
        }),
        (om = function (o) {
            if (o.tag === 13) {
                var u = gl(o),
                    m = Zr(o, u);
                if (m !== null) {
                    var _ = xr();
                    Js(m, o, u, _);
                }
                v0(o, u);
            }
        }),
        (xc = function () {
            return rn;
        }),
        (_c = function (o, u) {
            var m = rn;
            try {
                return (rn = o), u();
            } finally {
                rn = m;
            }
        }),
        (Te = function (o, u, m) {
            switch (u) {
                case 'input':
                    if (
                        (St(o, m),
                        (u = m.name),
                        m.type === 'radio' && u != null)
                    ) {
                        for (m = o; m.parentNode; ) m = m.parentNode;
                        for (
                            m = m.querySelectorAll(
                                'input[name=' +
                                    JSON.stringify('' + u) +
                                    '][type="radio"]'
                            ),
                                u = 0;
                            u < m.length;
                            u++
                        ) {
                            var _ = m[u];
                            if (_ !== o && _.form === o.form) {
                                var A = Zc(_);
                                if (!A) throw Error(t(90));
                                W(_), St(_, A);
                            }
                        }
                    }
                    break;
                case 'textarea':
                    be(o, m);
                    break;
                case 'select':
                    (u = m.value), u != null && k(o, !!m.multiple, u, !1);
            }
        }),
        (jn = f0),
        (en = Au);
    var EL = { usingClientEntryPoint: !1, Events: [Fs, Vn, Zc, Yt, Cn, f0] },
        wd = {
            findFiberByHostInstance: To,
            bundleType: 0,
            version: '18.3.1',
            rendererPackageName: 'react-dom',
        },
        TL = {
            bundleType: wd.bundleType,
            version: wd.version,
            rendererPackageName: wd.rendererPackageName,
            rendererConfig: wd.rendererConfig,
            overrideHookState: null,
            overrideHookStateDeletePath: null,
            overrideHookStateRenamePath: null,
            overrideProps: null,
            overridePropsDeletePath: null,
            overridePropsRenamePath: null,
            setErrorHandler: null,
            setSuspenseHandler: null,
            scheduleUpdate: null,
            currentDispatcherRef: L.ReactCurrentDispatcher,
            findHostInstanceByFiber: function (o) {
                return (o = ye(o)), o === null ? null : o.stateNode;
            },
            findFiberByHostInstance: wd.findFiberByHostInstance || wL,
            findHostInstancesForRefresh: null,
            scheduleRefresh: null,
            scheduleRoot: null,
            setRefreshHandler: null,
            getCurrentFiber: null,
            reconcilerVersion: '18.3.1-next-f1338f8080-20240426',
        };
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < 'u') {
        var Zm = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (!Zm.isDisabled && Zm.supportsFiber)
            try {
                (En = Zm.inject(TL)), (ft = Zm);
            } catch {}
    }
    return (
        (Fr.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = EL),
        (Fr.createPortal = function (o, u) {
            var m =
                2 < arguments.length && arguments[2] !== void 0
                    ? arguments[2]
                    : null;
            if (!_0(u)) throw Error(t(200));
            return SL(o, u, null, m);
        }),
        (Fr.createRoot = function (o, u) {
            if (!_0(o)) throw Error(t(299));
            var m = !1,
                _ = '',
                A = Zw;
            return (
                u != null &&
                    (u.unstable_strictMode === !0 && (m = !0),
                    u.identifierPrefix !== void 0 && (_ = u.identifierPrefix),
                    u.onRecoverableError !== void 0 &&
                        (A = u.onRecoverableError)),
                (u = y0(o, 1, !1, null, null, m, !1, _, A)),
                (o[dr] = u.current),
                nl(o.nodeType === 8 ? o.parentNode : o),
                new x0(u)
            );
        }),
        (Fr.findDOMNode = function (o) {
            if (o == null) return null;
            if (o.nodeType === 1) return o;
            var u = o._reactInternals;
            if (u === void 0)
                throw typeof o.render == 'function'
                    ? Error(t(188))
                    : ((o = Object.keys(o).join(',')), Error(t(268, o)));
            return (o = ye(u)), (o = o === null ? null : o.stateNode), o;
        }),
        (Fr.flushSync = function (o) {
            return Au(o);
        }),
        (Fr.hydrate = function (o, u, m) {
            if (!Ym(u)) throw Error(t(200));
            return Km(null, o, u, !0, m);
        }),
        (Fr.hydrateRoot = function (o, u, m) {
            if (!_0(o)) throw Error(t(405));
            var _ = (m != null && m.hydratedSources) || null,
                A = !1,
                P = '',
                O = Zw;
            if (
                (m != null &&
                    (m.unstable_strictMode === !0 && (A = !0),
                    m.identifierPrefix !== void 0 && (P = m.identifierPrefix),
                    m.onRecoverableError !== void 0 &&
                        (O = m.onRecoverableError)),
                (u = Yw(u, null, o, 1, m ?? null, A, !1, P, O)),
                (o[dr] = u.current),
                nl(o),
                _)
            )
                for (o = 0; o < _.length; o++)
                    (m = _[o]),
                        (A = m._getVersion),
                        (A = A(m._source)),
                        u.mutableSourceEagerHydrationData == null
                            ? (u.mutableSourceEagerHydrationData = [m, A])
                            : u.mutableSourceEagerHydrationData.push(m, A);
            return new $m(u);
        }),
        (Fr.render = function (o, u, m) {
            if (!Ym(u)) throw Error(t(200));
            return Km(null, o, u, !1, m);
        }),
        (Fr.unmountComponentAtNode = function (o) {
            if (!Ym(o)) throw Error(t(40));
            return o._reactRootContainer
                ? (Au(function () {
                      Km(null, null, o, !1, function () {
                          (o._reactRootContainer = null), (o[dr] = null);
                      });
                  }),
                  !0)
                : !1;
        }),
        (Fr.unstable_batchedUpdates = f0),
        (Fr.unstable_renderSubtreeIntoContainer = function (o, u, m, _) {
            if (!Ym(m)) throw Error(t(200));
            if (o == null || o._reactInternals === void 0) throw Error(t(38));
            return Km(o, u, m, !1, _);
        }),
        (Fr.version = '18.3.1-next-f1338f8080-20240426'),
        Fr
    );
}
var oM;
function DL() {
    if (oM) return M0.exports;
    oM = 1;
    function i() {
        if (
            !(
                typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > 'u' ||
                typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != 'function'
            )
        )
            try {
                __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(i);
            } catch (e) {
                console.error(e);
            }
    }
    return i(), (M0.exports = IL()), M0.exports;
}
var aM;
function NL() {
    if (aM) return Jm;
    aM = 1;
    var i = DL();
    return (Jm.createRoot = i.createRoot), (Jm.hydrateRoot = i.hydrateRoot), Jm;
}
var UL = NL();
const OL = k_(UL),
    kL = 'modulepreload',
    FL = function (i) {
        return '/' + i;
    },
    lM = {},
    uo = function (e, t, n) {
        let r = Promise.resolve();
        if (t && t.length > 0) {
            let a = function (d) {
                return Promise.all(
                    d.map((p) =>
                        Promise.resolve(p).then(
                            (g) => ({ status: 'fulfilled', value: g }),
                            (g) => ({ status: 'rejected', reason: g })
                        )
                    )
                );
            };
            document.getElementsByTagName('link');
            const l = document.querySelector('meta[property=csp-nonce]'),
                c =
                    (l == null ? void 0 : l.nonce) ||
                    (l == null ? void 0 : l.getAttribute('nonce'));
            r = a(
                t.map((d) => {
                    if (((d = FL(d)), d in lM)) return;
                    lM[d] = !0;
                    const p = d.endsWith('.css'),
                        g = p ? '[rel="stylesheet"]' : '';
                    if (document.querySelector(`link[href="${d}"]${g}`)) return;
                    const y = document.createElement('link');
                    if (
                        ((y.rel = p ? 'stylesheet' : kL),
                        p || (y.as = 'script'),
                        (y.crossOrigin = ''),
                        (y.href = d),
                        c && y.setAttribute('nonce', c),
                        document.head.appendChild(y),
                        p)
                    )
                        return new Promise((v, S) => {
                            y.addEventListener('load', v),
                                y.addEventListener('error', () =>
                                    S(
                                        new Error(
                                            `Unable to preload CSS for ${d}`
                                        )
                                    )
                                );
                        });
                })
            );
        }
        function s(a) {
            const l = new Event('vite:preloadError', { cancelable: !0 });
            if (((l.payload = a), window.dispatchEvent(l), !l.defaultPrevented))
                throw a;
        }
        return r.then((a) => {
            for (const l of a || []) l.status === 'rejected' && s(l.reason);
            return e().catch(s);
        });
    },
    BL = () => {
        const i = localStorage.getItem('abm-mytick-theme') === 'dark';
        return (
            i
                ? document.documentElement.classList.add('dark')
                : document.documentElement.classList.remove('dark'),
            i
        );
    },
    F_ = K.createContext({});
function B_(i) {
    const e = K.useRef(null);
    return e.current === null && (e.current = i()), e.current;
}
const z_ = typeof window < 'u',
    eA = z_ ? K.useLayoutEffect : K.useEffect,
    ev = K.createContext(null);
function V_(i, e) {
    i.indexOf(e) === -1 && i.push(e);
}
function H_(i, e) {
    const t = i.indexOf(e);
    t > -1 && i.splice(t, 1);
}
const La = (i, e, t) => (t > e ? e : t < i ? i : t);
let G_ = () => {};
const Ia = {},
    tA = (i) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(i);
function nA(i) {
    return typeof i == 'object' && i !== null;
}
const iA = (i) => /^0[^.\s]+$/u.test(i);
function W_(i) {
    let e;
    return () => (e === void 0 && (e = i()), e);
}
const Es = (i) => i,
    zL = (i, e) => (t) => e(i(t)),
    Vp = (...i) => i.reduce(zL),
    up = (i, e, t) => {
        const n = e - i;
        return n === 0 ? 1 : (t - i) / n;
    };
class X_ {
    constructor() {
        this.subscriptions = [];
    }
    add(e) {
        return V_(this.subscriptions, e), () => H_(this.subscriptions, e);
    }
    notify(e, t, n) {
        const r = this.subscriptions.length;
        if (r)
            if (r === 1) this.subscriptions[0](e, t, n);
            else
                for (let s = 0; s < r; s++) {
                    const a = this.subscriptions[s];
                    a && a(e, t, n);
                }
    }
    getSize() {
        return this.subscriptions.length;
    }
    clear() {
        this.subscriptions.length = 0;
    }
}
const Uo = (i) => i * 1e3,
    Oo = (i) => i / 1e3;
function rA(i, e) {
    return e ? i * (1e3 / e) : 0;
}
const sA = (i, e, t) =>
        (((1 - 3 * t + 3 * e) * i + (3 * t - 6 * e)) * i + 3 * e) * i,
    VL = 1e-7,
    HL = 12;
function GL(i, e, t, n, r) {
    let s,
        a,
        l = 0;
    do (a = e + (t - e) / 2), (s = sA(a, n, r) - i), s > 0 ? (t = a) : (e = a);
    while (Math.abs(s) > VL && ++l < HL);
    return a;
}
function Hp(i, e, t, n) {
    if (i === e && t === n) return Es;
    const r = (s) => GL(s, 0, 1, i, t);
    return (s) => (s === 0 || s === 1 ? s : sA(r(s), e, n));
}
const oA = (i) => (e) => (e <= 0.5 ? i(2 * e) / 2 : (2 - i(2 * (1 - e))) / 2),
    aA = (i) => (e) => 1 - i(1 - e),
    lA = Hp(0.33, 1.53, 0.69, 0.99),
    j_ = aA(lA),
    uA = oA(j_),
    cA = (i) =>
        (i *= 2) < 1 ? 0.5 * j_(i) : 0.5 * (2 - Math.pow(2, -10 * (i - 1))),
    q_ = (i) => 1 - Math.sin(Math.acos(i)),
    fA = aA(q_),
    hA = oA(q_),
    WL = Hp(0.42, 0, 1, 1),
    XL = Hp(0, 0, 0.58, 1),
    dA = Hp(0.42, 0, 0.58, 1),
    jL = (i) => Array.isArray(i) && typeof i[0] != 'number',
    pA = (i) => Array.isArray(i) && typeof i[0] == 'number',
    qL = {
        linear: Es,
        easeIn: WL,
        easeInOut: dA,
        easeOut: XL,
        circIn: q_,
        circInOut: hA,
        circOut: fA,
        backIn: j_,
        backInOut: uA,
        backOut: lA,
        anticipate: cA,
    },
    $L = (i) => typeof i == 'string',
    uM = (i) => {
        if (pA(i)) {
            G_(i.length === 4);
            const [e, t, n, r] = i;
            return Hp(e, t, n, r);
        } else if ($L(i)) return qL[i];
        return i;
    },
    Qm = [
        'setup',
        'read',
        'resolveKeyframes',
        'preUpdate',
        'update',
        'preRender',
        'render',
        'postRender',
    ];
function YL(i, e) {
    let t = new Set(),
        n = new Set(),
        r = !1,
        s = !1;
    const a = new WeakSet();
    let l = { delta: 0, timestamp: 0, isProcessing: !1 };
    function c(p) {
        a.has(p) && (d.schedule(p), i()), p(l);
    }
    const d = {
        schedule: (p, g = !1, y = !1) => {
            const S = y && r ? t : n;
            return g && a.add(p), S.has(p) || S.add(p), p;
        },
        cancel: (p) => {
            n.delete(p), a.delete(p);
        },
        process: (p) => {
            if (((l = p), r)) {
                s = !0;
                return;
            }
            (r = !0),
                ([t, n] = [n, t]),
                t.forEach(c),
                t.clear(),
                (r = !1),
                s && ((s = !1), d.process(p));
        },
    };
    return d;
}
const KL = 40;
function mA(i, e) {
    let t = !1,
        n = !0;
    const r = { delta: 0, timestamp: 0, isProcessing: !1 },
        s = () => (t = !0),
        a = Qm.reduce((C, L) => ((C[L] = YL(s)), C), {}),
        {
            setup: l,
            read: c,
            resolveKeyframes: d,
            preUpdate: p,
            update: g,
            preRender: y,
            render: v,
            postRender: S,
        } = a,
        T = () => {
            const C = Ia.useManualTiming ? r.timestamp : performance.now();
            (t = !1),
                Ia.useManualTiming ||
                    (r.delta = n
                        ? 1e3 / 60
                        : Math.max(Math.min(C - r.timestamp, KL), 1)),
                (r.timestamp = C),
                (r.isProcessing = !0),
                l.process(r),
                c.process(r),
                d.process(r),
                p.process(r),
                g.process(r),
                y.process(r),
                v.process(r),
                S.process(r),
                (r.isProcessing = !1),
                t && e && ((n = !1), i(T));
        },
        M = () => {
            (t = !0), (n = !0), r.isProcessing || i(T);
        };
    return {
        schedule: Qm.reduce((C, L) => {
            const F = a[L];
            return (
                (C[L] = (N, B = !1, z = !1) => (t || M(), F.schedule(N, B, z))),
                C
            );
        }, {}),
        cancel: (C) => {
            for (let L = 0; L < Qm.length; L++) a[Qm[L]].cancel(C);
        },
        state: r,
        steps: a,
    };
}
const {
    schedule: Xn,
    cancel: Il,
    state: Vi,
    steps: A0,
} = mA(typeof requestAnimationFrame < 'u' ? requestAnimationFrame : Es, !0);
let ey;
function ZL() {
    ey = void 0;
}
const zr = {
        now: () => (
            ey === void 0 &&
                zr.set(
                    Vi.isProcessing || Ia.useManualTiming
                        ? Vi.timestamp
                        : performance.now()
                ),
            ey
        ),
        set: (i) => {
            (ey = i), queueMicrotask(ZL);
        },
    },
    gA = (i) => (e) => typeof e == 'string' && e.startsWith(i),
    $_ = gA('--'),
    JL = gA('var(--'),
    Y_ = (i) => (JL(i) ? QL.test(i.split('/*')[0].trim()) : !1),
    QL =
        /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu,
    gh = {
        test: (i) => typeof i == 'number',
        parse: parseFloat,
        transform: (i) => i,
    },
    cp = { ...gh, transform: (i) => La(0, 1, i) },
    eg = { ...gh, default: 1 },
    jd = (i) => Math.round(i * 1e5) / 1e5,
    K_ = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
function e2(i) {
    return i == null;
}
const t2 =
        /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu,
    Z_ = (i, e) => (t) =>
        !!(
            (typeof t == 'string' && t2.test(t) && t.startsWith(i)) ||
            (e && !e2(t) && Object.prototype.hasOwnProperty.call(t, e))
        ),
    yA = (i, e, t) => (n) => {
        if (typeof n != 'string') return n;
        const [r, s, a, l] = n.match(K_);
        return {
            [i]: parseFloat(r),
            [e]: parseFloat(s),
            [t]: parseFloat(a),
            alpha: l !== void 0 ? parseFloat(l) : 1,
        };
    },
    n2 = (i) => La(0, 255, i),
    C0 = { ...gh, transform: (i) => Math.round(n2(i)) },
    qu = {
        test: Z_('rgb', 'red'),
        parse: yA('red', 'green', 'blue'),
        transform: ({ red: i, green: e, blue: t, alpha: n = 1 }) =>
            'rgba(' +
            C0.transform(i) +
            ', ' +
            C0.transform(e) +
            ', ' +
            C0.transform(t) +
            ', ' +
            jd(cp.transform(n)) +
            ')',
    };
function i2(i) {
    let e = '',
        t = '',
        n = '',
        r = '';
    return (
        i.length > 5
            ? ((e = i.substring(1, 3)),
              (t = i.substring(3, 5)),
              (n = i.substring(5, 7)),
              (r = i.substring(7, 9)))
            : ((e = i.substring(1, 2)),
              (t = i.substring(2, 3)),
              (n = i.substring(3, 4)),
              (r = i.substring(4, 5)),
              (e += e),
              (t += t),
              (n += n),
              (r += r)),
        {
            red: parseInt(e, 16),
            green: parseInt(t, 16),
            blue: parseInt(n, 16),
            alpha: r ? parseInt(r, 16) / 255 : 1,
        }
    );
}
const Gx = { test: Z_('#'), parse: i2, transform: qu.transform },
    Gp = (i) => ({
        test: (e) =>
            typeof e == 'string' && e.endsWith(i) && e.split(' ').length === 1,
        parse: parseFloat,
        transform: (e) => `${e}${i}`,
    }),
    bl = Gp('deg'),
    ko = Gp('%'),
    Dt = Gp('px'),
    r2 = Gp('vh'),
    s2 = Gp('vw'),
    cM = {
        ...ko,
        parse: (i) => ko.parse(i) / 100,
        transform: (i) => ko.transform(i * 100),
    },
    qf = {
        test: Z_('hsl', 'hue'),
        parse: yA('hue', 'saturation', 'lightness'),
        transform: ({ hue: i, saturation: e, lightness: t, alpha: n = 1 }) =>
            'hsla(' +
            Math.round(i) +
            ', ' +
            ko.transform(jd(e)) +
            ', ' +
            ko.transform(jd(t)) +
            ', ' +
            jd(cp.transform(n)) +
            ')',
    },
    ir = {
        test: (i) => qu.test(i) || Gx.test(i) || qf.test(i),
        parse: (i) =>
            qu.test(i) ? qu.parse(i) : qf.test(i) ? qf.parse(i) : Gx.parse(i),
        transform: (i) =>
            typeof i == 'string'
                ? i
                : i.hasOwnProperty('red')
                  ? qu.transform(i)
                  : qf.transform(i),
    },
    o2 =
        /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
function a2(i) {
    var e, t;
    return (
        isNaN(i) &&
        typeof i == 'string' &&
        (((e = i.match(K_)) == null ? void 0 : e.length) || 0) +
            (((t = i.match(o2)) == null ? void 0 : t.length) || 0) >
            0
    );
}
const vA = 'number',
    xA = 'color',
    l2 = 'var',
    u2 = 'var(',
    fM = '${}',
    c2 =
        /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function fp(i) {
    const e = i.toString(),
        t = [],
        n = { color: [], number: [], var: [] },
        r = [];
    let s = 0;
    const l = e
        .replace(
            c2,
            (c) => (
                ir.test(c)
                    ? (n.color.push(s), r.push(xA), t.push(ir.parse(c)))
                    : c.startsWith(u2)
                      ? (n.var.push(s), r.push(l2), t.push(c))
                      : (n.number.push(s), r.push(vA), t.push(parseFloat(c))),
                ++s,
                fM
            )
        )
        .split(fM);
    return { values: t, split: l, indexes: n, types: r };
}
function _A(i) {
    return fp(i).values;
}
function SA(i) {
    const { split: e, types: t } = fp(i),
        n = e.length;
    return (r) => {
        let s = '';
        for (let a = 0; a < n; a++)
            if (((s += e[a]), r[a] !== void 0)) {
                const l = t[a];
                l === vA
                    ? (s += jd(r[a]))
                    : l === xA
                      ? (s += ir.transform(r[a]))
                      : (s += r[a]);
            }
        return s;
    };
}
const f2 = (i) => (typeof i == 'number' ? 0 : i);
function h2(i) {
    const e = _A(i);
    return SA(i)(e.map(f2));
}
const Dl = {
    test: a2,
    parse: _A,
    createTransformer: SA,
    getAnimatableNone: h2,
};
function R0(i, e, t) {
    return (
        t < 0 && (t += 1),
        t > 1 && (t -= 1),
        t < 1 / 6
            ? i + (e - i) * 6 * t
            : t < 1 / 2
              ? e
              : t < 2 / 3
                ? i + (e - i) * (2 / 3 - t) * 6
                : i
    );
}
function d2({ hue: i, saturation: e, lightness: t, alpha: n }) {
    (i /= 360), (e /= 100), (t /= 100);
    let r = 0,
        s = 0,
        a = 0;
    if (!e) r = s = a = t;
    else {
        const l = t < 0.5 ? t * (1 + e) : t + e - t * e,
            c = 2 * t - l;
        (r = R0(c, l, i + 1 / 3)), (s = R0(c, l, i)), (a = R0(c, l, i - 1 / 3));
    }
    return {
        red: Math.round(r * 255),
        green: Math.round(s * 255),
        blue: Math.round(a * 255),
        alpha: n,
    };
}
function uy(i, e) {
    return (t) => (t > 0 ? e : i);
}
const Gn = (i, e, t) => i + (e - i) * t,
    b0 = (i, e, t) => {
        const n = i * i,
            r = t * (e * e - n) + n;
        return r < 0 ? 0 : Math.sqrt(r);
    },
    p2 = [Gx, qu, qf],
    m2 = (i) => p2.find((e) => e.test(i));
function hM(i) {
    const e = m2(i);
    if (!e) return !1;
    let t = e.parse(i);
    return e === qf && (t = d2(t)), t;
}
const dM = (i, e) => {
        const t = hM(i),
            n = hM(e);
        if (!t || !n) return uy(i, e);
        const r = { ...t };
        return (s) => (
            (r.red = b0(t.red, n.red, s)),
            (r.green = b0(t.green, n.green, s)),
            (r.blue = b0(t.blue, n.blue, s)),
            (r.alpha = Gn(t.alpha, n.alpha, s)),
            qu.transform(r)
        );
    },
    Wx = new Set(['none', 'hidden']);
function g2(i, e) {
    return Wx.has(i) ? (t) => (t <= 0 ? i : e) : (t) => (t >= 1 ? e : i);
}
function y2(i, e) {
    return (t) => Gn(i, e, t);
}
function J_(i) {
    return typeof i == 'number'
        ? y2
        : typeof i == 'string'
          ? Y_(i)
              ? uy
              : ir.test(i)
                ? dM
                : _2
          : Array.isArray(i)
            ? wA
            : typeof i == 'object'
              ? ir.test(i)
                  ? dM
                  : v2
              : uy;
}
function wA(i, e) {
    const t = [...i],
        n = t.length,
        r = i.map((s, a) => J_(s)(s, e[a]));
    return (s) => {
        for (let a = 0; a < n; a++) t[a] = r[a](s);
        return t;
    };
}
function v2(i, e) {
    const t = { ...i, ...e },
        n = {};
    for (const r in t)
        i[r] !== void 0 && e[r] !== void 0 && (n[r] = J_(i[r])(i[r], e[r]));
    return (r) => {
        for (const s in n) t[s] = n[s](r);
        return t;
    };
}
function x2(i, e) {
    const t = [],
        n = { color: 0, var: 0, number: 0 };
    for (let r = 0; r < e.values.length; r++) {
        const s = e.types[r],
            a = i.indexes[s][n[s]],
            l = i.values[a] ?? 0;
        (t[r] = l), n[s]++;
    }
    return t;
}
const _2 = (i, e) => {
    const t = Dl.createTransformer(e),
        n = fp(i),
        r = fp(e);
    return n.indexes.var.length === r.indexes.var.length &&
        n.indexes.color.length === r.indexes.color.length &&
        n.indexes.number.length >= r.indexes.number.length
        ? (Wx.has(i) && !r.values.length) || (Wx.has(e) && !n.values.length)
            ? g2(i, e)
            : Vp(wA(x2(n, r), r.values), t)
        : uy(i, e);
};
function MA(i, e, t) {
    return typeof i == 'number' && typeof e == 'number' && typeof t == 'number'
        ? Gn(i, e, t)
        : J_(i)(i, e);
}
const S2 = (i) => {
        const e = ({ timestamp: t }) => i(t);
        return {
            start: (t = !0) => Xn.update(e, t),
            stop: () => Il(e),
            now: () => (Vi.isProcessing ? Vi.timestamp : zr.now()),
        };
    },
    EA = (i, e, t = 10) => {
        let n = '';
        const r = Math.max(Math.round(e / t), 2);
        for (let s = 0; s < r; s++) n += i(s / (r - 1)) + ', ';
        return `linear(${n.substring(0, n.length - 2)})`;
    },
    cy = 2e4;
function Q_(i) {
    let e = 0;
    const t = 50;
    let n = i.next(e);
    for (; !n.done && e < cy; ) (e += t), (n = i.next(e));
    return e >= cy ? 1 / 0 : e;
}
function w2(i, e = 100, t) {
    const n = t({ ...i, keyframes: [0, e] }),
        r = Math.min(Q_(n), cy);
    return {
        type: 'keyframes',
        ease: (s) => n.next(r * s).value / e,
        duration: Oo(r),
    };
}
const M2 = 5;
function TA(i, e, t) {
    const n = Math.max(e - M2, 0);
    return rA(t - i(n), e - n);
}
const Zn = {
        stiffness: 100,
        damping: 10,
        mass: 1,
        velocity: 0,
        duration: 800,
        bounce: 0.3,
        visualDuration: 0.3,
        restSpeed: { granular: 0.01, default: 2 },
        restDelta: { granular: 0.005, default: 0.5 },
        minDuration: 0.01,
        maxDuration: 10,
        minDamping: 0.05,
        maxDamping: 1,
    },
    pM = 0.001;
function E2({
    duration: i = Zn.duration,
    bounce: e = Zn.bounce,
    velocity: t = Zn.velocity,
    mass: n = Zn.mass,
}) {
    let r,
        s,
        a = 1 - e;
    (a = La(Zn.minDamping, Zn.maxDamping, a)),
        (i = La(Zn.minDuration, Zn.maxDuration, Oo(i))),
        a < 1
            ? ((r = (d) => {
                  const p = d * a,
                      g = p * i,
                      y = p - t,
                      v = Xx(d, a),
                      S = Math.exp(-g);
                  return pM - (y / v) * S;
              }),
              (s = (d) => {
                  const g = d * a * i,
                      y = g * t + t,
                      v = Math.pow(a, 2) * Math.pow(d, 2) * i,
                      S = Math.exp(-g),
                      T = Xx(Math.pow(d, 2), a);
                  return ((-r(d) + pM > 0 ? -1 : 1) * ((y - v) * S)) / T;
              }))
            : ((r = (d) => {
                  const p = Math.exp(-d * i),
                      g = (d - t) * i + 1;
                  return -0.001 + p * g;
              }),
              (s = (d) => {
                  const p = Math.exp(-d * i),
                      g = (t - d) * (i * i);
                  return p * g;
              }));
    const l = 5 / i,
        c = A2(r, s, l);
    if (((i = Uo(i)), isNaN(c)))
        return { stiffness: Zn.stiffness, damping: Zn.damping, duration: i };
    {
        const d = Math.pow(c, 2) * n;
        return { stiffness: d, damping: a * 2 * Math.sqrt(n * d), duration: i };
    }
}
const T2 = 12;
function A2(i, e, t) {
    let n = t;
    for (let r = 1; r < T2; r++) n = n - i(n) / e(n);
    return n;
}
function Xx(i, e) {
    return i * Math.sqrt(1 - e * e);
}
const C2 = ['duration', 'bounce'],
    R2 = ['stiffness', 'damping', 'mass'];
function mM(i, e) {
    return e.some((t) => i[t] !== void 0);
}
function b2(i) {
    let e = {
        velocity: Zn.velocity,
        stiffness: Zn.stiffness,
        damping: Zn.damping,
        mass: Zn.mass,
        isResolvedFromDuration: !1,
        ...i,
    };
    if (!mM(i, R2) && mM(i, C2))
        if (i.visualDuration) {
            const t = i.visualDuration,
                n = (2 * Math.PI) / (t * 1.2),
                r = n * n,
                s = 2 * La(0.05, 1, 1 - (i.bounce || 0)) * Math.sqrt(r);
            e = { ...e, mass: Zn.mass, stiffness: r, damping: s };
        } else {
            const t = E2(i);
            (e = { ...e, ...t, mass: Zn.mass }),
                (e.isResolvedFromDuration = !0);
        }
    return e;
}
function fy(i = Zn.visualDuration, e = Zn.bounce) {
    const t =
        typeof i != 'object'
            ? { visualDuration: i, keyframes: [0, 1], bounce: e }
            : i;
    let { restSpeed: n, restDelta: r } = t;
    const s = t.keyframes[0],
        a = t.keyframes[t.keyframes.length - 1],
        l = { done: !1, value: s },
        {
            stiffness: c,
            damping: d,
            mass: p,
            duration: g,
            velocity: y,
            isResolvedFromDuration: v,
        } = b2({ ...t, velocity: -Oo(t.velocity || 0) }),
        S = y || 0,
        T = d / (2 * Math.sqrt(c * p)),
        M = a - s,
        w = Oo(Math.sqrt(c / p)),
        b = Math.abs(M) < 5;
    n || (n = b ? Zn.restSpeed.granular : Zn.restSpeed.default),
        r || (r = b ? Zn.restDelta.granular : Zn.restDelta.default);
    let C;
    if (T < 1) {
        const F = Xx(w, T);
        C = (N) => {
            const B = Math.exp(-T * w * N);
            return (
                a -
                B *
                    (((S + T * w * M) / F) * Math.sin(F * N) +
                        M * Math.cos(F * N))
            );
        };
    } else if (T === 1) C = (F) => a - Math.exp(-w * F) * (M + (S + w * M) * F);
    else {
        const F = w * Math.sqrt(T * T - 1);
        C = (N) => {
            const B = Math.exp(-T * w * N),
                z = Math.min(F * N, 300);
            return (
                a -
                (B * ((S + T * w * M) * Math.sinh(z) + F * M * Math.cosh(z))) /
                    F
            );
        };
    }
    const L = {
        calculatedDuration: (v && g) || null,
        next: (F) => {
            const N = C(F);
            if (v) l.done = F >= g;
            else {
                let B = F === 0 ? S : 0;
                T < 1 && (B = F === 0 ? Uo(S) : TA(C, F, N));
                const z = Math.abs(B) <= n,
                    U = Math.abs(a - N) <= r;
                l.done = z && U;
            }
            return (l.value = l.done ? a : N), l;
        },
        toString: () => {
            const F = Math.min(Q_(L), cy),
                N = EA((B) => L.next(F * B).value, F, 30);
            return F + 'ms ' + N;
        },
        toTransition: () => {},
    };
    return L;
}
fy.applyToOptions = (i) => {
    const e = w2(i, 100, fy);
    return (
        (i.ease = e.ease),
        (i.duration = Uo(e.duration)),
        (i.type = 'keyframes'),
        i
    );
};
function jx({
    keyframes: i,
    velocity: e = 0,
    power: t = 0.8,
    timeConstant: n = 325,
    bounceDamping: r = 10,
    bounceStiffness: s = 500,
    modifyTarget: a,
    min: l,
    max: c,
    restDelta: d = 0.5,
    restSpeed: p,
}) {
    const g = i[0],
        y = { done: !1, value: g },
        v = (z) => (l !== void 0 && z < l) || (c !== void 0 && z > c),
        S = (z) =>
            l === void 0
                ? c
                : c === void 0 || Math.abs(l - z) < Math.abs(c - z)
                  ? l
                  : c;
    let T = t * e;
    const M = g + T,
        w = a === void 0 ? M : a(M);
    w !== M && (T = w - g);
    const b = (z) => -T * Math.exp(-z / n),
        C = (z) => w + b(z),
        L = (z) => {
            const U = b(z),
                D = C(z);
            (y.done = Math.abs(U) <= d), (y.value = y.done ? w : D);
        };
    let F, N;
    const B = (z) => {
        v(y.value) &&
            ((F = z),
            (N = fy({
                keyframes: [y.value, S(y.value)],
                velocity: TA(C, z, y.value),
                damping: r,
                stiffness: s,
                restDelta: d,
                restSpeed: p,
            })));
    };
    return (
        B(0),
        {
            calculatedDuration: null,
            next: (z) => {
                let U = !1;
                return (
                    !N && F === void 0 && ((U = !0), L(z), B(z)),
                    F !== void 0 && z >= F ? N.next(z - F) : (!U && L(z), y)
                );
            },
        }
    );
}
function P2(i, e, t) {
    const n = [],
        r = t || Ia.mix || MA,
        s = i.length - 1;
    for (let a = 0; a < s; a++) {
        let l = r(i[a], i[a + 1]);
        if (e) {
            const c = Array.isArray(e) ? e[a] || Es : e;
            l = Vp(c, l);
        }
        n.push(l);
    }
    return n;
}
function L2(i, e, { clamp: t = !0, ease: n, mixer: r } = {}) {
    const s = i.length;
    if ((G_(s === e.length), s === 1)) return () => e[0];
    if (s === 2 && e[0] === e[1]) return () => e[1];
    const a = i[0] === i[1];
    i[0] > i[s - 1] && ((i = [...i].reverse()), (e = [...e].reverse()));
    const l = P2(e, n, r),
        c = l.length,
        d = (p) => {
            if (a && p < i[0]) return e[0];
            let g = 0;
            if (c > 1) for (; g < i.length - 2 && !(p < i[g + 1]); g++);
            const y = up(i[g], i[g + 1], p);
            return l[g](y);
        };
    return t ? (p) => d(La(i[0], i[s - 1], p)) : d;
}
function I2(i, e) {
    const t = i[i.length - 1];
    for (let n = 1; n <= e; n++) {
        const r = up(0, e, n);
        i.push(Gn(t, 1, r));
    }
}
function D2(i) {
    const e = [0];
    return I2(e, i.length - 1), e;
}
function N2(i, e) {
    return i.map((t) => t * e);
}
function U2(i, e) {
    return i.map(() => e || dA).splice(0, i.length - 1);
}
function qd({
    duration: i = 300,
    keyframes: e,
    times: t,
    ease: n = 'easeInOut',
}) {
    const r = jL(n) ? n.map(uM) : uM(n),
        s = { done: !1, value: e[0] },
        a = N2(t && t.length === e.length ? t : D2(e), i),
        l = L2(a, e, { ease: Array.isArray(r) ? r : U2(e, r) });
    return {
        calculatedDuration: i,
        next: (c) => ((s.value = l(c)), (s.done = c >= i), s),
    };
}
const O2 = (i) => i !== null;
function eS(i, { repeat: e, repeatType: t = 'loop' }, n, r = 1) {
    const s = i.filter(O2),
        l = r < 0 || (e && t !== 'loop' && e % 2 === 1) ? 0 : s.length - 1;
    return !l || n === void 0 ? s[l] : n;
}
const k2 = { decay: jx, inertia: jx, tween: qd, keyframes: qd, spring: fy };
function AA(i) {
    typeof i.type == 'string' && (i.type = k2[i.type]);
}
class tS {
    constructor() {
        this.updateFinished();
    }
    get finished() {
        return this._finished;
    }
    updateFinished() {
        this._finished = new Promise((e) => {
            this.resolve = e;
        });
    }
    notifyFinished() {
        this.resolve();
    }
    then(e, t) {
        return this.finished.then(e, t);
    }
}
const F2 = (i) => i / 100;
class nS extends tS {
    constructor(e) {
        super(),
            (this.state = 'idle'),
            (this.startTime = null),
            (this.isStopped = !1),
            (this.currentTime = 0),
            (this.holdTime = null),
            (this.playbackSpeed = 1),
            (this.stop = (t = !0) => {
                var n, r;
                if (t) {
                    const { motionValue: s } = this.options;
                    s && s.updatedAt !== zr.now() && this.tick(zr.now());
                }
                (this.isStopped = !0),
                    this.state !== 'idle' &&
                        (this.teardown(),
                        (r = (n = this.options).onStop) == null || r.call(n));
            }),
            (this.options = e),
            this.initAnimation(),
            this.play(),
            e.autoplay === !1 && this.pause();
    }
    initAnimation() {
        const { options: e } = this;
        AA(e);
        const {
            type: t = qd,
            repeat: n = 0,
            repeatDelay: r = 0,
            repeatType: s,
            velocity: a = 0,
        } = e;
        let { keyframes: l } = e;
        const c = t || qd;
        c !== qd &&
            typeof l[0] != 'number' &&
            ((this.mixKeyframes = Vp(F2, MA(l[0], l[1]))), (l = [0, 100]));
        const d = c({ ...e, keyframes: l });
        s === 'mirror' &&
            (this.mirroredGenerator = c({
                ...e,
                keyframes: [...l].reverse(),
                velocity: -a,
            })),
            d.calculatedDuration === null && (d.calculatedDuration = Q_(d));
        const { calculatedDuration: p } = d;
        (this.calculatedDuration = p),
            (this.resolvedDuration = p + r),
            (this.totalDuration = this.resolvedDuration * (n + 1) - r),
            (this.generator = d);
    }
    updateTime(e) {
        const t = Math.round(e - this.startTime) * this.playbackSpeed;
        this.holdTime !== null
            ? (this.currentTime = this.holdTime)
            : (this.currentTime = t);
    }
    tick(e, t = !1) {
        const {
            generator: n,
            totalDuration: r,
            mixKeyframes: s,
            mirroredGenerator: a,
            resolvedDuration: l,
            calculatedDuration: c,
        } = this;
        if (this.startTime === null) return n.next(0);
        const {
            delay: d = 0,
            keyframes: p,
            repeat: g,
            repeatType: y,
            repeatDelay: v,
            type: S,
            onUpdate: T,
            finalKeyframe: M,
        } = this.options;
        this.speed > 0
            ? (this.startTime = Math.min(this.startTime, e))
            : this.speed < 0 &&
              (this.startTime = Math.min(e - r / this.speed, this.startTime)),
            t ? (this.currentTime = e) : this.updateTime(e);
        const w = this.currentTime - d * (this.playbackSpeed >= 0 ? 1 : -1),
            b = this.playbackSpeed >= 0 ? w < 0 : w > r;
        (this.currentTime = Math.max(w, 0)),
            this.state === 'finished' &&
                this.holdTime === null &&
                (this.currentTime = r);
        let C = this.currentTime,
            L = n;
        if (g) {
            const z = Math.min(this.currentTime, r) / l;
            let U = Math.floor(z),
                D = z % 1;
            !D && z >= 1 && (D = 1),
                D === 1 && U--,
                (U = Math.min(U, g + 1)),
                !!(U % 2) &&
                    (y === 'reverse'
                        ? ((D = 1 - D), v && (D -= v / l))
                        : y === 'mirror' && (L = a)),
                (C = La(0, 1, D) * l);
        }
        const F = b ? { done: !1, value: p[0] } : L.next(C);
        s && (F.value = s(F.value));
        let { done: N } = F;
        !b &&
            c !== null &&
            (N =
                this.playbackSpeed >= 0
                    ? this.currentTime >= r
                    : this.currentTime <= 0);
        const B =
            this.holdTime === null &&
            (this.state === 'finished' || (this.state === 'running' && N));
        return (
            B && S !== jx && (F.value = eS(p, this.options, M, this.speed)),
            T && T(F.value),
            B && this.finish(),
            F
        );
    }
    then(e, t) {
        return this.finished.then(e, t);
    }
    get duration() {
        return Oo(this.calculatedDuration);
    }
    get time() {
        return Oo(this.currentTime);
    }
    set time(e) {
        var t;
        (e = Uo(e)),
            (this.currentTime = e),
            this.startTime === null ||
            this.holdTime !== null ||
            this.playbackSpeed === 0
                ? (this.holdTime = e)
                : this.driver &&
                  (this.startTime = this.driver.now() - e / this.playbackSpeed),
            (t = this.driver) == null || t.start(!1);
    }
    get speed() {
        return this.playbackSpeed;
    }
    set speed(e) {
        this.updateTime(zr.now());
        const t = this.playbackSpeed !== e;
        (this.playbackSpeed = e), t && (this.time = Oo(this.currentTime));
    }
    play() {
        var r, s;
        if (this.isStopped) return;
        const { driver: e = S2, startTime: t } = this.options;
        this.driver || (this.driver = e((a) => this.tick(a))),
            (s = (r = this.options).onPlay) == null || s.call(r);
        const n = this.driver.now();
        this.state === 'finished'
            ? (this.updateFinished(), (this.startTime = n))
            : this.holdTime !== null
              ? (this.startTime = n - this.holdTime)
              : this.startTime || (this.startTime = t ?? n),
            this.state === 'finished' &&
                this.speed < 0 &&
                (this.startTime += this.calculatedDuration),
            (this.holdTime = null),
            (this.state = 'running'),
            this.driver.start();
    }
    pause() {
        (this.state = 'paused'),
            this.updateTime(zr.now()),
            (this.holdTime = this.currentTime);
    }
    complete() {
        this.state !== 'running' && this.play(),
            (this.state = 'finished'),
            (this.holdTime = null);
    }
    finish() {
        var e, t;
        this.notifyFinished(),
            this.teardown(),
            (this.state = 'finished'),
            (t = (e = this.options).onComplete) == null || t.call(e);
    }
    cancel() {
        var e, t;
        (this.holdTime = null),
            (this.startTime = 0),
            this.tick(0),
            this.teardown(),
            (t = (e = this.options).onCancel) == null || t.call(e);
    }
    teardown() {
        (this.state = 'idle'),
            this.stopDriver(),
            (this.startTime = this.holdTime = null);
    }
    stopDriver() {
        this.driver && (this.driver.stop(), (this.driver = void 0));
    }
    sample(e) {
        return (this.startTime = 0), this.tick(e, !0);
    }
    attachTimeline(e) {
        var t;
        return (
            this.options.allowFlatten &&
                ((this.options.type = 'keyframes'),
                (this.options.ease = 'linear'),
                this.initAnimation()),
            (t = this.driver) == null || t.stop(),
            e.observe(this)
        );
    }
}
function B2(i) {
    for (let e = 1; e < i.length; e++) i[e] ?? (i[e] = i[e - 1]);
}
const $u = (i) => (i * 180) / Math.PI,
    qx = (i) => {
        const e = $u(Math.atan2(i[1], i[0]));
        return $x(e);
    },
    z2 = {
        x: 4,
        y: 5,
        translateX: 4,
        translateY: 5,
        scaleX: 0,
        scaleY: 3,
        scale: (i) => (Math.abs(i[0]) + Math.abs(i[3])) / 2,
        rotate: qx,
        rotateZ: qx,
        skewX: (i) => $u(Math.atan(i[1])),
        skewY: (i) => $u(Math.atan(i[2])),
        skew: (i) => (Math.abs(i[1]) + Math.abs(i[2])) / 2,
    },
    $x = (i) => ((i = i % 360), i < 0 && (i += 360), i),
    gM = qx,
    yM = (i) => Math.sqrt(i[0] * i[0] + i[1] * i[1]),
    vM = (i) => Math.sqrt(i[4] * i[4] + i[5] * i[5]),
    V2 = {
        x: 12,
        y: 13,
        z: 14,
        translateX: 12,
        translateY: 13,
        translateZ: 14,
        scaleX: yM,
        scaleY: vM,
        scale: (i) => (yM(i) + vM(i)) / 2,
        rotateX: (i) => $x($u(Math.atan2(i[6], i[5]))),
        rotateY: (i) => $x($u(Math.atan2(-i[2], i[0]))),
        rotateZ: gM,
        rotate: gM,
        skewX: (i) => $u(Math.atan(i[4])),
        skewY: (i) => $u(Math.atan(i[1])),
        skew: (i) => (Math.abs(i[1]) + Math.abs(i[4])) / 2,
    };
function Yx(i) {
    return i.includes('scale') ? 1 : 0;
}
function Kx(i, e) {
    if (!i || i === 'none') return Yx(e);
    const t = i.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);
    let n, r;
    if (t) (n = V2), (r = t);
    else {
        const l = i.match(/^matrix\(([-\d.e\s,]+)\)$/u);
        (n = z2), (r = l);
    }
    if (!r) return Yx(e);
    const s = n[e],
        a = r[1].split(',').map(G2);
    return typeof s == 'function' ? s(a) : a[s];
}
const H2 = (i, e) => {
    const { transform: t = 'none' } = getComputedStyle(i);
    return Kx(t, e);
};
function G2(i) {
    return parseFloat(i.trim());
}
const yh = [
        'transformPerspective',
        'x',
        'y',
        'z',
        'translateX',
        'translateY',
        'translateZ',
        'scale',
        'scaleX',
        'scaleY',
        'rotate',
        'rotateX',
        'rotateY',
        'rotateZ',
        'skew',
        'skewX',
        'skewY',
    ],
    vh = new Set(yh),
    xM = (i) => i === gh || i === Dt,
    W2 = new Set(['x', 'y', 'z']),
    X2 = yh.filter((i) => !W2.has(i));
function j2(i) {
    const e = [];
    return (
        X2.forEach((t) => {
            const n = i.getValue(t);
            n !== void 0 &&
                (e.push([t, n.get()]), n.set(t.startsWith('scale') ? 1 : 0));
        }),
        e
    );
}
const ec = {
    width: ({ x: i }, { paddingLeft: e = '0', paddingRight: t = '0' }) =>
        i.max - i.min - parseFloat(e) - parseFloat(t),
    height: ({ y: i }, { paddingTop: e = '0', paddingBottom: t = '0' }) =>
        i.max - i.min - parseFloat(e) - parseFloat(t),
    top: (i, { top: e }) => parseFloat(e),
    left: (i, { left: e }) => parseFloat(e),
    bottom: ({ y: i }, { top: e }) => parseFloat(e) + (i.max - i.min),
    right: ({ x: i }, { left: e }) => parseFloat(e) + (i.max - i.min),
    x: (i, { transform: e }) => Kx(e, 'x'),
    y: (i, { transform: e }) => Kx(e, 'y'),
};
ec.translateX = ec.x;
ec.translateY = ec.y;
const tc = new Set();
let Zx = !1,
    Jx = !1,
    Qx = !1;
function CA() {
    if (Jx) {
        const i = Array.from(tc).filter((n) => n.needsMeasurement),
            e = new Set(i.map((n) => n.element)),
            t = new Map();
        e.forEach((n) => {
            const r = j2(n);
            r.length && (t.set(n, r), n.render());
        }),
            i.forEach((n) => n.measureInitialState()),
            e.forEach((n) => {
                n.render();
                const r = t.get(n);
                r &&
                    r.forEach(([s, a]) => {
                        var l;
                        (l = n.getValue(s)) == null || l.set(a);
                    });
            }),
            i.forEach((n) => n.measureEndState()),
            i.forEach((n) => {
                n.suspendedScrollY !== void 0 &&
                    window.scrollTo(0, n.suspendedScrollY);
            });
    }
    (Jx = !1), (Zx = !1), tc.forEach((i) => i.complete(Qx)), tc.clear();
}
function RA() {
    tc.forEach((i) => {
        i.readKeyframes(), i.needsMeasurement && (Jx = !0);
    });
}
function q2() {
    (Qx = !0), RA(), CA(), (Qx = !1);
}
class iS {
    constructor(e, t, n, r, s, a = !1) {
        (this.state = 'pending'),
            (this.isAsync = !1),
            (this.needsMeasurement = !1),
            (this.unresolvedKeyframes = [...e]),
            (this.onComplete = t),
            (this.name = n),
            (this.motionValue = r),
            (this.element = s),
            (this.isAsync = a);
    }
    scheduleResolve() {
        (this.state = 'scheduled'),
            this.isAsync
                ? (tc.add(this),
                  Zx || ((Zx = !0), Xn.read(RA), Xn.resolveKeyframes(CA)))
                : (this.readKeyframes(), this.complete());
    }
    readKeyframes() {
        const {
            unresolvedKeyframes: e,
            name: t,
            element: n,
            motionValue: r,
        } = this;
        if (e[0] === null) {
            const s = r == null ? void 0 : r.get(),
                a = e[e.length - 1];
            if (s !== void 0) e[0] = s;
            else if (n && t) {
                const l = n.readValue(t, a);
                l != null && (e[0] = l);
            }
            e[0] === void 0 && (e[0] = a), r && s === void 0 && r.set(e[0]);
        }
        B2(e);
    }
    setFinalKeyframe() {}
    measureInitialState() {}
    renderEndStyles() {}
    measureEndState() {}
    complete(e = !1) {
        (this.state = 'complete'),
            this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, e),
            tc.delete(this);
    }
    cancel() {
        this.state === 'scheduled' &&
            (tc.delete(this), (this.state = 'pending'));
    }
    resume() {
        this.state === 'pending' && this.scheduleResolve();
    }
}
const $2 = (i) => i.startsWith('--');
function Y2(i, e, t) {
    $2(e) ? i.style.setProperty(e, t) : (i.style[e] = t);
}
const K2 = W_(() => window.ScrollTimeline !== void 0),
    Z2 = {};
function J2(i, e) {
    const t = W_(i);
    return () => Z2[e] ?? t();
}
const bA = J2(() => {
        try {
            document
                .createElement('div')
                .animate({ opacity: 0 }, { easing: 'linear(0, 1)' });
        } catch {
            return !1;
        }
        return !0;
    }, 'linearEasing'),
    Hd = ([i, e, t, n]) => `cubic-bezier(${i}, ${e}, ${t}, ${n})`,
    _M = {
        linear: 'linear',
        ease: 'ease',
        easeIn: 'ease-in',
        easeOut: 'ease-out',
        easeInOut: 'ease-in-out',
        circIn: Hd([0, 0.65, 0.55, 1]),
        circOut: Hd([0.55, 0, 1, 0.45]),
        backIn: Hd([0.31, 0.01, 0.66, -0.59]),
        backOut: Hd([0.33, 1.53, 0.69, 0.99]),
    };
function PA(i, e) {
    if (i)
        return typeof i == 'function'
            ? bA()
                ? EA(i, e)
                : 'ease-out'
            : pA(i)
              ? Hd(i)
              : Array.isArray(i)
                ? i.map((t) => PA(t, e) || _M.easeOut)
                : _M[i];
}
function Q2(
    i,
    e,
    t,
    {
        delay: n = 0,
        duration: r = 300,
        repeat: s = 0,
        repeatType: a = 'loop',
        ease: l = 'easeOut',
        times: c,
    } = {},
    d = void 0
) {
    const p = { [e]: t };
    c && (p.offset = c);
    const g = PA(l, r);
    Array.isArray(g) && (p.easing = g);
    const y = {
        delay: n,
        duration: r,
        easing: Array.isArray(g) ? 'linear' : g,
        fill: 'both',
        iterations: s + 1,
        direction: a === 'reverse' ? 'alternate' : 'normal',
    };
    return d && (y.pseudoElement = d), i.animate(p, y);
}
function LA(i) {
    return typeof i == 'function' && 'applyToOptions' in i;
}
function eI({ type: i, ...e }) {
    return LA(i) && bA()
        ? i.applyToOptions(e)
        : (e.duration ?? (e.duration = 300), e.ease ?? (e.ease = 'easeOut'), e);
}
class tI extends tS {
    constructor(e) {
        if ((super(), (this.finishedTime = null), (this.isStopped = !1), !e))
            return;
        const {
            element: t,
            name: n,
            keyframes: r,
            pseudoElement: s,
            allowFlatten: a = !1,
            finalKeyframe: l,
            onComplete: c,
        } = e;
        (this.isPseudoElement = !!s),
            (this.allowFlatten = a),
            (this.options = e),
            G_(typeof e.type != 'string');
        const d = eI(e);
        (this.animation = Q2(t, n, r, d, s)),
            d.autoplay === !1 && this.animation.pause(),
            (this.animation.onfinish = () => {
                if (((this.finishedTime = this.time), !s)) {
                    const p = eS(r, this.options, l, this.speed);
                    this.updateMotionValue
                        ? this.updateMotionValue(p)
                        : Y2(t, n, p),
                        this.animation.cancel();
                }
                c == null || c(), this.notifyFinished();
            });
    }
    play() {
        this.isStopped ||
            (this.animation.play(),
            this.state === 'finished' && this.updateFinished());
    }
    pause() {
        this.animation.pause();
    }
    complete() {
        var e, t;
        (t = (e = this.animation).finish) == null || t.call(e);
    }
    cancel() {
        try {
            this.animation.cancel();
        } catch {}
    }
    stop() {
        if (this.isStopped) return;
        this.isStopped = !0;
        const { state: e } = this;
        e === 'idle' ||
            e === 'finished' ||
            (this.updateMotionValue
                ? this.updateMotionValue()
                : this.commitStyles(),
            this.isPseudoElement || this.cancel());
    }
    commitStyles() {
        var e, t;
        this.isPseudoElement ||
            (t = (e = this.animation).commitStyles) == null ||
            t.call(e);
    }
    get duration() {
        var t, n;
        const e =
            ((n =
                (t = this.animation.effect) == null
                    ? void 0
                    : t.getComputedTiming) == null
                ? void 0
                : n.call(t).duration) || 0;
        return Oo(Number(e));
    }
    get time() {
        return Oo(Number(this.animation.currentTime) || 0);
    }
    set time(e) {
        (this.finishedTime = null), (this.animation.currentTime = Uo(e));
    }
    get speed() {
        return this.animation.playbackRate;
    }
    set speed(e) {
        e < 0 && (this.finishedTime = null), (this.animation.playbackRate = e);
    }
    get state() {
        return this.finishedTime !== null
            ? 'finished'
            : this.animation.playState;
    }
    get startTime() {
        return Number(this.animation.startTime);
    }
    set startTime(e) {
        this.animation.startTime = e;
    }
    attachTimeline({ timeline: e, observe: t }) {
        var n;
        return (
            this.allowFlatten &&
                ((n = this.animation.effect) == null ||
                    n.updateTiming({ easing: 'linear' })),
            (this.animation.onfinish = null),
            e && K2() ? ((this.animation.timeline = e), Es) : t(this)
        );
    }
}
const IA = { anticipate: cA, backInOut: uA, circInOut: hA };
function nI(i) {
    return i in IA;
}
function iI(i) {
    typeof i.ease == 'string' && nI(i.ease) && (i.ease = IA[i.ease]);
}
const SM = 10;
class rI extends tI {
    constructor(e) {
        iI(e),
            AA(e),
            super(e),
            e.startTime && (this.startTime = e.startTime),
            (this.options = e);
    }
    updateMotionValue(e) {
        const {
            motionValue: t,
            onUpdate: n,
            onComplete: r,
            element: s,
            ...a
        } = this.options;
        if (!t) return;
        if (e !== void 0) {
            t.set(e);
            return;
        }
        const l = new nS({ ...a, autoplay: !1 }),
            c = Uo(this.finishedTime ?? this.time);
        t.setWithVelocity(l.sample(c - SM).value, l.sample(c).value, SM),
            l.stop();
    }
}
const wM = (i, e) =>
    e === 'zIndex'
        ? !1
        : !!(
              typeof i == 'number' ||
              Array.isArray(i) ||
              (typeof i == 'string' &&
                  (Dl.test(i) || i === '0') &&
                  !i.startsWith('url('))
          );
function sI(i) {
    const e = i[0];
    if (i.length === 1) return !0;
    for (let t = 0; t < i.length; t++) if (i[t] !== e) return !0;
}
function oI(i, e, t, n) {
    const r = i[0];
    if (r === null) return !1;
    if (e === 'display' || e === 'visibility') return !0;
    const s = i[i.length - 1],
        a = wM(r, e),
        l = wM(s, e);
    return !a || !l ? !1 : sI(i) || ((t === 'spring' || LA(t)) && n);
}
function rS(i) {
    return nA(i) && 'offsetHeight' in i;
}
const aI = new Set(['opacity', 'clipPath', 'filter', 'transform']),
    lI = W_(() => Object.hasOwnProperty.call(Element.prototype, 'animate'));
function uI(i) {
    var d;
    const {
        motionValue: e,
        name: t,
        repeatDelay: n,
        repeatType: r,
        damping: s,
        type: a,
    } = i;
    if (!rS((d = e == null ? void 0 : e.owner) == null ? void 0 : d.current))
        return !1;
    const { onUpdate: l, transformTemplate: c } = e.owner.getProps();
    return (
        lI() &&
        t &&
        aI.has(t) &&
        (t !== 'transform' || !c) &&
        !l &&
        !n &&
        r !== 'mirror' &&
        s !== 0 &&
        a !== 'inertia'
    );
}
const cI = 40;
class fI extends tS {
    constructor({
        autoplay: e = !0,
        delay: t = 0,
        type: n = 'keyframes',
        repeat: r = 0,
        repeatDelay: s = 0,
        repeatType: a = 'loop',
        keyframes: l,
        name: c,
        motionValue: d,
        element: p,
        ...g
    }) {
        var S;
        super(),
            (this.stop = () => {
                var T, M;
                this._animation &&
                    (this._animation.stop(),
                    (T = this.stopTimeline) == null || T.call(this)),
                    (M = this.keyframeResolver) == null || M.cancel();
            }),
            (this.createdAt = zr.now());
        const y = {
                autoplay: e,
                delay: t,
                type: n,
                repeat: r,
                repeatDelay: s,
                repeatType: a,
                name: c,
                motionValue: d,
                element: p,
                ...g,
            },
            v = (p == null ? void 0 : p.KeyframeResolver) || iS;
        (this.keyframeResolver = new v(
            l,
            (T, M, w) => this.onKeyframesResolved(T, M, y, !w),
            c,
            d,
            p
        )),
            (S = this.keyframeResolver) == null || S.scheduleResolve();
    }
    onKeyframesResolved(e, t, n, r) {
        this.keyframeResolver = void 0;
        const {
            name: s,
            type: a,
            velocity: l,
            delay: c,
            isHandoff: d,
            onUpdate: p,
        } = n;
        (this.resolvedAt = zr.now()),
            oI(e, s, a, l) ||
                ((Ia.instantAnimations || !c) && (p == null || p(eS(e, n, t))),
                (e[0] = e[e.length - 1]),
                (n.duration = 0),
                (n.repeat = 0));
        const y = {
                startTime: r
                    ? this.resolvedAt
                        ? this.resolvedAt - this.createdAt > cI
                            ? this.resolvedAt
                            : this.createdAt
                        : this.createdAt
                    : void 0,
                finalKeyframe: t,
                ...n,
                keyframes: e,
            },
            v =
                !d && uI(y)
                    ? new rI({ ...y, element: y.motionValue.owner.current })
                    : new nS(y);
        v.finished.then(() => this.notifyFinished()).catch(Es),
            this.pendingTimeline &&
                ((this.stopTimeline = v.attachTimeline(this.pendingTimeline)),
                (this.pendingTimeline = void 0)),
            (this._animation = v);
    }
    get finished() {
        return this._animation ? this.animation.finished : this._finished;
    }
    then(e, t) {
        return this.finished.finally(e).then(() => {});
    }
    get animation() {
        var e;
        return (
            this._animation ||
                ((e = this.keyframeResolver) == null || e.resume(), q2()),
            this._animation
        );
    }
    get duration() {
        return this.animation.duration;
    }
    get time() {
        return this.animation.time;
    }
    set time(e) {
        this.animation.time = e;
    }
    get speed() {
        return this.animation.speed;
    }
    get state() {
        return this.animation.state;
    }
    set speed(e) {
        this.animation.speed = e;
    }
    get startTime() {
        return this.animation.startTime;
    }
    attachTimeline(e) {
        return (
            this._animation
                ? (this.stopTimeline = this.animation.attachTimeline(e))
                : (this.pendingTimeline = e),
            () => this.stop()
        );
    }
    play() {
        this.animation.play();
    }
    pause() {
        this.animation.pause();
    }
    complete() {
        this.animation.complete();
    }
    cancel() {
        var e;
        this._animation && this.animation.cancel(),
            (e = this.keyframeResolver) == null || e.cancel();
    }
}
const hI = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;
function dI(i) {
    const e = hI.exec(i);
    if (!e) return [,];
    const [, t, n, r] = e;
    return [`--${t ?? n}`, r];
}
function DA(i, e, t = 1) {
    const [n, r] = dI(i);
    if (!n) return;
    const s = window.getComputedStyle(e).getPropertyValue(n);
    if (s) {
        const a = s.trim();
        return tA(a) ? parseFloat(a) : a;
    }
    return Y_(r) ? DA(r, e, t + 1) : r;
}
function sS(i, e) {
    return (i == null ? void 0 : i[e]) ?? (i == null ? void 0 : i.default) ?? i;
}
const NA = new Set([
        'width',
        'height',
        'top',
        'left',
        'right',
        'bottom',
        ...yh,
    ]),
    pI = { test: (i) => i === 'auto', parse: (i) => i },
    UA = (i) => (e) => e.test(i),
    OA = [gh, Dt, ko, bl, s2, r2, pI],
    MM = (i) => OA.find(UA(i));
function mI(i) {
    return typeof i == 'number'
        ? i === 0
        : i !== null
          ? i === 'none' || i === '0' || iA(i)
          : !0;
}
const gI = new Set(['brightness', 'contrast', 'saturate', 'opacity']);
function yI(i) {
    const [e, t] = i.slice(0, -1).split('(');
    if (e === 'drop-shadow') return i;
    const [n] = t.match(K_) || [];
    if (!n) return i;
    const r = t.replace(n, '');
    let s = gI.has(e) ? 1 : 0;
    return n !== t && (s *= 100), e + '(' + s + r + ')';
}
const vI = /\b([a-z-]*)\(.*?\)/gu,
    e_ = {
        ...Dl,
        getAnimatableNone: (i) => {
            const e = i.match(vI);
            return e ? e.map(yI).join(' ') : i;
        },
    },
    EM = { ...gh, transform: Math.round },
    xI = {
        rotate: bl,
        rotateX: bl,
        rotateY: bl,
        rotateZ: bl,
        scale: eg,
        scaleX: eg,
        scaleY: eg,
        scaleZ: eg,
        skew: bl,
        skewX: bl,
        skewY: bl,
        distance: Dt,
        translateX: Dt,
        translateY: Dt,
        translateZ: Dt,
        x: Dt,
        y: Dt,
        z: Dt,
        perspective: Dt,
        transformPerspective: Dt,
        opacity: cp,
        originX: cM,
        originY: cM,
        originZ: Dt,
    },
    oS = {
        borderWidth: Dt,
        borderTopWidth: Dt,
        borderRightWidth: Dt,
        borderBottomWidth: Dt,
        borderLeftWidth: Dt,
        borderRadius: Dt,
        radius: Dt,
        borderTopLeftRadius: Dt,
        borderTopRightRadius: Dt,
        borderBottomRightRadius: Dt,
        borderBottomLeftRadius: Dt,
        width: Dt,
        maxWidth: Dt,
        height: Dt,
        maxHeight: Dt,
        top: Dt,
        right: Dt,
        bottom: Dt,
        left: Dt,
        padding: Dt,
        paddingTop: Dt,
        paddingRight: Dt,
        paddingBottom: Dt,
        paddingLeft: Dt,
        margin: Dt,
        marginTop: Dt,
        marginRight: Dt,
        marginBottom: Dt,
        marginLeft: Dt,
        backgroundPositionX: Dt,
        backgroundPositionY: Dt,
        ...xI,
        zIndex: EM,
        fillOpacity: cp,
        strokeOpacity: cp,
        numOctaves: EM,
    },
    _I = {
        ...oS,
        color: ir,
        backgroundColor: ir,
        outlineColor: ir,
        fill: ir,
        stroke: ir,
        borderColor: ir,
        borderTopColor: ir,
        borderRightColor: ir,
        borderBottomColor: ir,
        borderLeftColor: ir,
        filter: e_,
        WebkitFilter: e_,
    },
    kA = (i) => _I[i];
function FA(i, e) {
    let t = kA(i);
    return (
        t !== e_ && (t = Dl),
        t.getAnimatableNone ? t.getAnimatableNone(e) : void 0
    );
}
const SI = new Set(['auto', 'none', '0']);
function wI(i, e, t) {
    let n = 0,
        r;
    for (; n < i.length && !r; ) {
        const s = i[n];
        typeof s == 'string' && !SI.has(s) && fp(s).values.length && (r = i[n]),
            n++;
    }
    if (r && t) for (const s of e) i[s] = FA(t, r);
}
class MI extends iS {
    constructor(e, t, n, r, s) {
        super(e, t, n, r, s, !0);
    }
    readKeyframes() {
        const { unresolvedKeyframes: e, element: t, name: n } = this;
        if (!t || !t.current) return;
        super.readKeyframes();
        for (let c = 0; c < e.length; c++) {
            let d = e[c];
            if (typeof d == 'string' && ((d = d.trim()), Y_(d))) {
                const p = DA(d, t.current);
                p !== void 0 && (e[c] = p),
                    c === e.length - 1 && (this.finalKeyframe = d);
            }
        }
        if ((this.resolveNoneKeyframes(), !NA.has(n) || e.length !== 2)) return;
        const [r, s] = e,
            a = MM(r),
            l = MM(s);
        if (a !== l)
            if (xM(a) && xM(l))
                for (let c = 0; c < e.length; c++) {
                    const d = e[c];
                    typeof d == 'string' && (e[c] = parseFloat(d));
                }
            else ec[n] && (this.needsMeasurement = !0);
    }
    resolveNoneKeyframes() {
        const { unresolvedKeyframes: e, name: t } = this,
            n = [];
        for (let r = 0; r < e.length; r++)
            (e[r] === null || mI(e[r])) && n.push(r);
        n.length && wI(e, n, t);
    }
    measureInitialState() {
        const { element: e, unresolvedKeyframes: t, name: n } = this;
        if (!e || !e.current) return;
        n === 'height' && (this.suspendedScrollY = window.pageYOffset),
            (this.measuredOrigin = ec[n](
                e.measureViewportBox(),
                window.getComputedStyle(e.current)
            )),
            (t[0] = this.measuredOrigin);
        const r = t[t.length - 1];
        r !== void 0 && e.getValue(n, r).jump(r, !1);
    }
    measureEndState() {
        var l;
        const { element: e, name: t, unresolvedKeyframes: n } = this;
        if (!e || !e.current) return;
        const r = e.getValue(t);
        r && r.jump(this.measuredOrigin, !1);
        const s = n.length - 1,
            a = n[s];
        (n[s] = ec[t](
            e.measureViewportBox(),
            window.getComputedStyle(e.current)
        )),
            a !== null &&
                this.finalKeyframe === void 0 &&
                (this.finalKeyframe = a),
            (l = this.removedTransforms) != null &&
                l.length &&
                this.removedTransforms.forEach(([c, d]) => {
                    e.getValue(c).set(d);
                }),
            this.resolveNoneKeyframes();
    }
}
function EI(i, e, t) {
    if (i instanceof EventTarget) return [i];
    if (typeof i == 'string') {
        let n = document;
        const r = (t == null ? void 0 : t[i]) ?? n.querySelectorAll(i);
        return r ? Array.from(r) : [];
    }
    return Array.from(i);
}
const TM = 30,
    TI = (i) => !isNaN(parseFloat(i)),
    AM = { current: void 0 };
class AI {
    constructor(e, t = {}) {
        (this.canTrackVelocity = null),
            (this.events = {}),
            (this.updateAndNotify = (n, r = !0) => {
                var a, l;
                const s = zr.now();
                if (
                    (this.updatedAt !== s && this.setPrevFrameValue(),
                    (this.prev = this.current),
                    this.setCurrent(n),
                    this.current !== this.prev &&
                        ((a = this.events.change) == null ||
                            a.notify(this.current),
                        this.dependents))
                )
                    for (const c of this.dependents) c.dirty();
                r &&
                    ((l = this.events.renderRequest) == null ||
                        l.notify(this.current));
            }),
            (this.hasAnimated = !1),
            this.setCurrent(e),
            (this.owner = t.owner);
    }
    setCurrent(e) {
        (this.current = e),
            (this.updatedAt = zr.now()),
            this.canTrackVelocity === null &&
                e !== void 0 &&
                (this.canTrackVelocity = TI(this.current));
    }
    setPrevFrameValue(e = this.current) {
        (this.prevFrameValue = e), (this.prevUpdatedAt = this.updatedAt);
    }
    onChange(e) {
        return this.on('change', e);
    }
    on(e, t) {
        this.events[e] || (this.events[e] = new X_());
        const n = this.events[e].add(t);
        return e === 'change'
            ? () => {
                  n(),
                      Xn.read(() => {
                          this.events.change.getSize() || this.stop();
                      });
              }
            : n;
    }
    clearListeners() {
        for (const e in this.events) this.events[e].clear();
    }
    attach(e, t) {
        (this.passiveEffect = e), (this.stopPassiveEffect = t);
    }
    set(e, t = !0) {
        !t || !this.passiveEffect
            ? this.updateAndNotify(e, t)
            : this.passiveEffect(e, this.updateAndNotify);
    }
    setWithVelocity(e, t, n) {
        this.set(t),
            (this.prev = void 0),
            (this.prevFrameValue = e),
            (this.prevUpdatedAt = this.updatedAt - n);
    }
    jump(e, t = !0) {
        this.updateAndNotify(e),
            (this.prev = e),
            (this.prevUpdatedAt = this.prevFrameValue = void 0),
            t && this.stop(),
            this.stopPassiveEffect && this.stopPassiveEffect();
    }
    dirty() {
        var e;
        (e = this.events.change) == null || e.notify(this.current);
    }
    addDependent(e) {
        this.dependents || (this.dependents = new Set()),
            this.dependents.add(e);
    }
    removeDependent(e) {
        this.dependents && this.dependents.delete(e);
    }
    get() {
        return AM.current && AM.current.push(this), this.current;
    }
    getPrevious() {
        return this.prev;
    }
    getVelocity() {
        const e = zr.now();
        if (
            !this.canTrackVelocity ||
            this.prevFrameValue === void 0 ||
            e - this.updatedAt > TM
        )
            return 0;
        const t = Math.min(this.updatedAt - this.prevUpdatedAt, TM);
        return rA(
            parseFloat(this.current) - parseFloat(this.prevFrameValue),
            t
        );
    }
    start(e) {
        return (
            this.stop(),
            new Promise((t) => {
                (this.hasAnimated = !0),
                    (this.animation = e(t)),
                    this.events.animationStart &&
                        this.events.animationStart.notify();
            }).then(() => {
                this.events.animationComplete &&
                    this.events.animationComplete.notify(),
                    this.clearAnimation();
            })
        );
    }
    stop() {
        this.animation &&
            (this.animation.stop(),
            this.events.animationCancel &&
                this.events.animationCancel.notify()),
            this.clearAnimation();
    }
    isAnimating() {
        return !!this.animation;
    }
    clearAnimation() {
        delete this.animation;
    }
    destroy() {
        var e, t;
        (e = this.dependents) == null || e.clear(),
            (t = this.events.destroy) == null || t.notify(),
            this.clearListeners(),
            this.stop(),
            this.stopPassiveEffect && this.stopPassiveEffect();
    }
}
function lh(i, e) {
    return new AI(i, e);
}
const BA = (i, e) => (e && typeof i == 'number' ? e.transform(i) : i),
    { schedule: aS } = mA(queueMicrotask, !1),
    no = { x: !1, y: !1 };
function zA() {
    return no.x || no.y;
}
function CI(i) {
    return i === 'x' || i === 'y'
        ? no[i]
            ? null
            : ((no[i] = !0),
              () => {
                  no[i] = !1;
              })
        : no.x || no.y
          ? null
          : ((no.x = no.y = !0),
            () => {
                no.x = no.y = !1;
            });
}
function VA(i, e) {
    const t = EI(i),
        n = new AbortController(),
        r = { passive: !0, ...e, signal: n.signal };
    return [t, r, () => n.abort()];
}
function CM(i) {
    return !(i.pointerType === 'touch' || zA());
}
function RI(i, e, t = {}) {
    const [n, r, s] = VA(i, t),
        a = (l) => {
            if (!CM(l)) return;
            const { target: c } = l,
                d = e(c, l);
            if (typeof d != 'function' || !c) return;
            const p = (g) => {
                CM(g) && (d(g), c.removeEventListener('pointerleave', p));
            };
            c.addEventListener('pointerleave', p, r);
        };
    return (
        n.forEach((l) => {
            l.addEventListener('pointerenter', a, r);
        }),
        s
    );
}
const HA = (i, e) => (e ? (i === e ? !0 : HA(i, e.parentElement)) : !1),
    lS = (i) =>
        i.pointerType === 'mouse'
            ? typeof i.button != 'number' || i.button <= 0
            : i.isPrimary !== !1,
    bI = new Set(['BUTTON', 'INPUT', 'SELECT', 'TEXTAREA', 'A']);
function PI(i) {
    return bI.has(i.tagName) || i.tabIndex !== -1;
}
const ty = new WeakSet();
function RM(i) {
    return (e) => {
        e.key === 'Enter' && i(e);
    };
}
function P0(i, e) {
    i.dispatchEvent(
        new PointerEvent('pointer' + e, { isPrimary: !0, bubbles: !0 })
    );
}
const LI = (i, e) => {
    const t = i.currentTarget;
    if (!t) return;
    const n = RM(() => {
        if (ty.has(t)) return;
        P0(t, 'down');
        const r = RM(() => {
                P0(t, 'up');
            }),
            s = () => P0(t, 'cancel');
        t.addEventListener('keyup', r, e), t.addEventListener('blur', s, e);
    });
    t.addEventListener('keydown', n, e),
        t.addEventListener(
            'blur',
            () => t.removeEventListener('keydown', n),
            e
        );
};
function bM(i) {
    return lS(i) && !zA();
}
function II(i, e, t = {}) {
    const [n, r, s] = VA(i, t),
        a = (l) => {
            const c = l.currentTarget;
            if (!bM(l)) return;
            ty.add(c);
            const d = e(c, l),
                p = (v, S) => {
                    window.removeEventListener('pointerup', g),
                        window.removeEventListener('pointercancel', y),
                        ty.has(c) && ty.delete(c),
                        bM(v) && typeof d == 'function' && d(v, { success: S });
                },
                g = (v) => {
                    p(
                        v,
                        c === window ||
                            c === document ||
                            t.useGlobalTarget ||
                            HA(c, v.target)
                    );
                },
                y = (v) => {
                    p(v, !1);
                };
            window.addEventListener('pointerup', g, r),
                window.addEventListener('pointercancel', y, r);
        };
    return (
        n.forEach((l) => {
            (t.useGlobalTarget ? window : l).addEventListener(
                'pointerdown',
                a,
                r
            ),
                rS(l) &&
                    (l.addEventListener('focus', (d) => LI(d, r)),
                    !PI(l) && !l.hasAttribute('tabindex') && (l.tabIndex = 0));
        }),
        s
    );
}
function GA(i) {
    return nA(i) && 'ownerSVGElement' in i;
}
function DI(i) {
    return GA(i) && i.tagName === 'svg';
}
const rr = (i) => !!(i && i.getVelocity),
    NI = [...OA, ir, Dl],
    UI = (i) => NI.find(UA(i)),
    uS = K.createContext({
        transformPagePoint: (i) => i,
        isStatic: !1,
        reducedMotion: 'never',
    });
class OI extends K.Component {
    getSnapshotBeforeUpdate(e) {
        const t = this.props.childRef.current;
        if (t && e.isPresent && !this.props.isPresent) {
            const n = t.offsetParent,
                r = (rS(n) && n.offsetWidth) || 0,
                s = this.props.sizeRef.current;
            (s.height = t.offsetHeight || 0),
                (s.width = t.offsetWidth || 0),
                (s.top = t.offsetTop),
                (s.left = t.offsetLeft),
                (s.right = r - s.width - s.left);
        }
        return null;
    }
    componentDidUpdate() {}
    render() {
        return this.props.children;
    }
}
function kI({ children: i, isPresent: e, anchorX: t }) {
    const n = K.useId(),
        r = K.useRef(null),
        s = K.useRef({ width: 0, height: 0, top: 0, left: 0, right: 0 }),
        { nonce: a } = K.useContext(uS);
    return (
        K.useInsertionEffect(() => {
            const {
                width: l,
                height: c,
                top: d,
                left: p,
                right: g,
            } = s.current;
            if (e || !r.current || !l || !c) return;
            const y = t === 'left' ? `left: ${p}` : `right: ${g}`;
            r.current.dataset.motionPopId = n;
            const v = document.createElement('style');
            return (
                a && (v.nonce = a),
                document.head.appendChild(v),
                v.sheet &&
                    v.sheet.insertRule(`
          [data-motion-pop-id="${n}"] {
            position: absolute !important;
            width: ${l}px !important;
            height: ${c}px !important;
            ${y}px !important;
            top: ${d}px !important;
          }
        `),
                () => {
                    document.head.contains(v) && document.head.removeChild(v);
                }
            );
        }, [e]),
        rt.jsx(OI, {
            isPresent: e,
            childRef: r,
            sizeRef: s,
            children: K.cloneElement(i, { ref: r }),
        })
    );
}
const FI = ({
    children: i,
    initial: e,
    isPresent: t,
    onExitComplete: n,
    custom: r,
    presenceAffectsLayout: s,
    mode: a,
    anchorX: l,
}) => {
    const c = B_(BI),
        d = K.useId();
    let p = !0,
        g = K.useMemo(
            () => (
                (p = !1),
                {
                    id: d,
                    initial: e,
                    isPresent: t,
                    custom: r,
                    onExitComplete: (y) => {
                        c.set(y, !0);
                        for (const v of c.values()) if (!v) return;
                        n && n();
                    },
                    register: (y) => (c.set(y, !1), () => c.delete(y)),
                }
            ),
            [t, c, n]
        );
    return (
        s && p && (g = { ...g }),
        K.useMemo(() => {
            c.forEach((y, v) => c.set(v, !1));
        }, [t]),
        K.useEffect(() => {
            !t && !c.size && n && n();
        }, [t]),
        a === 'popLayout' &&
            (i = rt.jsx(kI, { isPresent: t, anchorX: l, children: i })),
        rt.jsx(ev.Provider, { value: g, children: i })
    );
};
function BI() {
    return new Map();
}
function WA(i = !0) {
    const e = K.useContext(ev);
    if (e === null) return [!0, null];
    const { isPresent: t, onExitComplete: n, register: r } = e,
        s = K.useId();
    K.useEffect(() => {
        if (i) return r(s);
    }, [i]);
    const a = K.useCallback(() => i && n && n(s), [s, n, i]);
    return !t && n ? [!1, a] : [!0];
}
const tg = (i) => i.key || '';
function PM(i) {
    const e = [];
    return (
        K.Children.forEach(i, (t) => {
            K.isValidElement(t) && e.push(t);
        }),
        e
    );
}
const XA = ({
        children: i,
        custom: e,
        initial: t = !0,
        onExitComplete: n,
        presenceAffectsLayout: r = !0,
        mode: s = 'sync',
        propagate: a = !1,
        anchorX: l = 'left',
    }) => {
        const [c, d] = WA(a),
            p = K.useMemo(() => PM(i), [i]),
            g = a && !c ? [] : p.map(tg),
            y = K.useRef(!0),
            v = K.useRef(p),
            S = B_(() => new Map()),
            [T, M] = K.useState(p),
            [w, b] = K.useState(p);
        eA(() => {
            (y.current = !1), (v.current = p);
            for (let F = 0; F < w.length; F++) {
                const N = tg(w[F]);
                g.includes(N) ? S.delete(N) : S.get(N) !== !0 && S.set(N, !1);
            }
        }, [w, g.length, g.join('-')]);
        const C = [];
        if (p !== T) {
            let F = [...p];
            for (let N = 0; N < w.length; N++) {
                const B = w[N],
                    z = tg(B);
                g.includes(z) || (F.splice(N, 0, B), C.push(B));
            }
            return s === 'wait' && C.length && (F = C), b(PM(F)), M(p), null;
        }
        const { forceRender: L } = K.useContext(F_);
        return rt.jsx(rt.Fragment, {
            children: w.map((F) => {
                const N = tg(F),
                    B = a && !c ? !1 : p === w || g.includes(N),
                    z = () => {
                        if (S.has(N)) S.set(N, !0);
                        else return;
                        let U = !0;
                        S.forEach((D) => {
                            D || (U = !1);
                        }),
                            U &&
                                (L == null || L(),
                                b(v.current),
                                a && (d == null || d()),
                                n && n());
                    };
                return rt.jsx(
                    FI,
                    {
                        isPresent: B,
                        initial: !y.current || t ? void 0 : !1,
                        custom: e,
                        presenceAffectsLayout: r,
                        mode: s,
                        onExitComplete: B ? void 0 : z,
                        anchorX: l,
                        children: F,
                    },
                    N
                );
            }),
        });
    },
    jA = K.createContext({ strict: !1 }),
    LM = {
        animation: [
            'animate',
            'variants',
            'whileHover',
            'whileTap',
            'exit',
            'whileInView',
            'whileFocus',
            'whileDrag',
        ],
        exit: ['exit'],
        drag: ['drag', 'dragControls'],
        focus: ['whileFocus'],
        hover: ['whileHover', 'onHoverStart', 'onHoverEnd'],
        tap: ['whileTap', 'onTap', 'onTapStart', 'onTapCancel'],
        pan: ['onPan', 'onPanStart', 'onPanSessionStart', 'onPanEnd'],
        inView: ['whileInView', 'onViewportEnter', 'onViewportLeave'],
        layout: ['layout', 'layoutId'],
    },
    uh = {};
for (const i in LM) uh[i] = { isEnabled: (e) => LM[i].some((t) => !!e[t]) };
function zI(i) {
    for (const e in i) uh[e] = { ...uh[e], ...i[e] };
}
const VI = new Set([
    'animate',
    'exit',
    'variants',
    'initial',
    'style',
    'values',
    'variants',
    'transition',
    'transformTemplate',
    'custom',
    'inherit',
    'onBeforeLayoutMeasure',
    'onAnimationStart',
    'onAnimationComplete',
    'onUpdate',
    'onDragStart',
    'onDrag',
    'onDragEnd',
    'onMeasureDragConstraints',
    'onDirectionLock',
    'onDragTransitionEnd',
    '_dragX',
    '_dragY',
    'onHoverStart',
    'onHoverEnd',
    'onViewportEnter',
    'onViewportLeave',
    'globalTapTarget',
    'ignoreStrict',
    'viewport',
]);
function hy(i) {
    return (
        i.startsWith('while') ||
        (i.startsWith('drag') && i !== 'draggable') ||
        i.startsWith('layout') ||
        i.startsWith('onTap') ||
        i.startsWith('onPan') ||
        i.startsWith('onLayout') ||
        VI.has(i)
    );
}
let qA = (i) => !hy(i);
function HI(i) {
    i && (qA = (e) => (e.startsWith('on') ? !hy(e) : i(e)));
}
try {
    HI(require('@emotion/is-prop-valid').default);
} catch {}
function GI(i, e, t) {
    const n = {};
    for (const r in i)
        (r === 'values' && typeof i.values == 'object') ||
            ((qA(r) ||
                (t === !0 && hy(r)) ||
                (!e && !hy(r)) ||
                (i.draggable && r.startsWith('onDrag'))) &&
                (n[r] = i[r]));
    return n;
}
function WI(i) {
    if (typeof Proxy > 'u') return i;
    const e = new Map(),
        t = (...n) => i(...n);
    return new Proxy(t, {
        get: (n, r) =>
            r === 'create' ? i : (e.has(r) || e.set(r, i(r)), e.get(r)),
    });
}
const tv = K.createContext({});
function nv(i) {
    return i !== null && typeof i == 'object' && typeof i.start == 'function';
}
function hp(i) {
    return typeof i == 'string' || Array.isArray(i);
}
const cS = [
        'animate',
        'whileInView',
        'whileFocus',
        'whileHover',
        'whileTap',
        'whileDrag',
        'exit',
    ],
    fS = ['initial', ...cS];
function iv(i) {
    return nv(i.animate) || fS.some((e) => hp(i[e]));
}
function $A(i) {
    return !!(iv(i) || i.variants);
}
function XI(i, e) {
    if (iv(i)) {
        const { initial: t, animate: n } = i;
        return {
            initial: t === !1 || hp(t) ? t : void 0,
            animate: hp(n) ? n : void 0,
        };
    }
    return i.inherit !== !1 ? e : {};
}
function jI(i) {
    const { initial: e, animate: t } = XI(i, K.useContext(tv));
    return K.useMemo(() => ({ initial: e, animate: t }), [IM(e), IM(t)]);
}
function IM(i) {
    return Array.isArray(i) ? i.join(' ') : i;
}
const qI = Symbol.for('motionComponentSymbol');
function $f(i) {
    return (
        i &&
        typeof i == 'object' &&
        Object.prototype.hasOwnProperty.call(i, 'current')
    );
}
function $I(i, e, t) {
    return K.useCallback(
        (n) => {
            n && i.onMount && i.onMount(n),
                e && (n ? e.mount(n) : e.unmount()),
                t && (typeof t == 'function' ? t(n) : $f(t) && (t.current = n));
        },
        [e]
    );
}
const hS = (i) => i.replace(/([a-z])([A-Z])/gu, '$1-$2').toLowerCase(),
    YI = 'framerAppearId',
    YA = 'data-' + hS(YI),
    KA = K.createContext({});
function KI(i, e, t, n, r) {
    var T, M;
    const { visualElement: s } = K.useContext(tv),
        a = K.useContext(jA),
        l = K.useContext(ev),
        c = K.useContext(uS).reducedMotion,
        d = K.useRef(null);
    (n = n || a.renderer),
        !d.current &&
            n &&
            (d.current = n(i, {
                visualState: e,
                parent: s,
                props: t,
                presenceContext: l,
                blockInitialAnimation: l ? l.initial === !1 : !1,
                reducedMotionConfig: c,
            }));
    const p = d.current,
        g = K.useContext(KA);
    p &&
        !p.projection &&
        r &&
        (p.type === 'html' || p.type === 'svg') &&
        ZI(d.current, t, r, g);
    const y = K.useRef(!1);
    K.useInsertionEffect(() => {
        p && y.current && p.update(t, l);
    });
    const v = t[YA],
        S = K.useRef(
            !!v &&
                !(
                    (T = window.MotionHandoffIsComplete) != null &&
                    T.call(window, v)
                ) &&
                ((M = window.MotionHasOptimisedAnimation) == null
                    ? void 0
                    : M.call(window, v))
        );
    return (
        eA(() => {
            p &&
                ((y.current = !0),
                (window.MotionIsMounted = !0),
                p.updateFeatures(),
                aS.render(p.render),
                S.current &&
                    p.animationState &&
                    p.animationState.animateChanges());
        }),
        K.useEffect(() => {
            p &&
                (!S.current &&
                    p.animationState &&
                    p.animationState.animateChanges(),
                S.current &&
                    (queueMicrotask(() => {
                        var w;
                        (w = window.MotionHandoffMarkAsComplete) == null ||
                            w.call(window, v);
                    }),
                    (S.current = !1)));
        }),
        p
    );
}
function ZI(i, e, t, n) {
    const {
        layoutId: r,
        layout: s,
        drag: a,
        dragConstraints: l,
        layoutScroll: c,
        layoutRoot: d,
        layoutCrossfade: p,
    } = e;
    (i.projection = new t(
        i.latestValues,
        e['data-framer-portal-id'] ? void 0 : ZA(i.parent)
    )),
        i.projection.setOptions({
            layoutId: r,
            layout: s,
            alwaysMeasureLayout: !!a || (l && $f(l)),
            visualElement: i,
            animationType: typeof s == 'string' ? s : 'both',
            initialPromotionConfig: n,
            crossfade: p,
            layoutScroll: c,
            layoutRoot: d,
        });
}
function ZA(i) {
    if (i)
        return i.options.allowProjection !== !1 ? i.projection : ZA(i.parent);
}
function JI({
    preloadedFeatures: i,
    createVisualElement: e,
    useRender: t,
    useVisualState: n,
    Component: r,
}) {
    i && zI(i);
    function s(l, c) {
        let d;
        const p = { ...K.useContext(uS), ...l, layoutId: QI(l) },
            { isStatic: g } = p,
            y = jI(l),
            v = n(l, g);
        if (!g && z_) {
            e3();
            const S = t3(p);
            (d = S.MeasureLayout),
                (y.visualElement = KI(r, v, p, e, S.ProjectionNode));
        }
        return rt.jsxs(tv.Provider, {
            value: y,
            children: [
                d && y.visualElement
                    ? rt.jsx(d, { visualElement: y.visualElement, ...p })
                    : null,
                t(r, l, $I(v, y.visualElement, c), v, g, y.visualElement),
            ],
        });
    }
    s.displayName = `motion.${typeof r == 'string' ? r : `create(${r.displayName ?? r.name ?? ''})`}`;
    const a = K.forwardRef(s);
    return (a[qI] = r), a;
}
function QI({ layoutId: i }) {
    const e = K.useContext(F_).id;
    return e && i !== void 0 ? e + '-' + i : i;
}
function e3(i, e) {
    K.useContext(jA).strict;
}
function t3(i) {
    const { drag: e, layout: t } = uh;
    if (!e && !t) return {};
    const n = { ...e, ...t };
    return {
        MeasureLayout:
            (e != null && e.isEnabled(i)) || (t != null && t.isEnabled(i))
                ? n.MeasureLayout
                : void 0,
        ProjectionNode: n.ProjectionNode,
    };
}
const dp = {};
function n3(i) {
    for (const e in i) (dp[e] = i[e]), $_(e) && (dp[e].isCSSVariable = !0);
}
function JA(i, { layout: e, layoutId: t }) {
    return (
        vh.has(i) ||
        i.startsWith('origin') ||
        ((e || t !== void 0) && (!!dp[i] || i === 'opacity'))
    );
}
const i3 = {
        x: 'translateX',
        y: 'translateY',
        z: 'translateZ',
        transformPerspective: 'perspective',
    },
    r3 = yh.length;
function s3(i, e, t) {
    let n = '',
        r = !0;
    for (let s = 0; s < r3; s++) {
        const a = yh[s],
            l = i[a];
        if (l === void 0) continue;
        let c = !0;
        if (
            (typeof l == 'number'
                ? (c = l === (a.startsWith('scale') ? 1 : 0))
                : (c = parseFloat(l) === 0),
            !c || t)
        ) {
            const d = BA(l, oS[a]);
            if (!c) {
                r = !1;
                const p = i3[a] || a;
                n += `${p}(${d}) `;
            }
            t && (e[a] = d);
        }
    }
    return (n = n.trim()), t ? (n = t(e, r ? '' : n)) : r && (n = 'none'), n;
}
function dS(i, e, t) {
    const { style: n, vars: r, transformOrigin: s } = i;
    let a = !1,
        l = !1;
    for (const c in e) {
        const d = e[c];
        if (vh.has(c)) {
            a = !0;
            continue;
        } else if ($_(c)) {
            r[c] = d;
            continue;
        } else {
            const p = BA(d, oS[c]);
            c.startsWith('origin') ? ((l = !0), (s[c] = p)) : (n[c] = p);
        }
    }
    if (
        (e.transform ||
            (a || t
                ? (n.transform = s3(e, i.transform, t))
                : n.transform && (n.transform = 'none')),
        l)
    ) {
        const { originX: c = '50%', originY: d = '50%', originZ: p = 0 } = s;
        n.transformOrigin = `${c} ${d} ${p}`;
    }
}
const pS = () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {} });
function QA(i, e, t) {
    for (const n in e) !rr(e[n]) && !JA(n, t) && (i[n] = e[n]);
}
function o3({ transformTemplate: i }, e) {
    return K.useMemo(() => {
        const t = pS();
        return dS(t, e, i), Object.assign({}, t.vars, t.style);
    }, [e]);
}
function a3(i, e) {
    const t = i.style || {},
        n = {};
    return QA(n, t, i), Object.assign(n, o3(i, e)), n;
}
function l3(i, e) {
    const t = {},
        n = a3(i, e);
    return (
        i.drag &&
            i.dragListener !== !1 &&
            ((t.draggable = !1),
            (n.userSelect = n.WebkitUserSelect = n.WebkitTouchCallout = 'none'),
            (n.touchAction =
                i.drag === !0 ? 'none' : `pan-${i.drag === 'x' ? 'y' : 'x'}`)),
        i.tabIndex === void 0 &&
            (i.onTap || i.onTapStart || i.whileTap) &&
            (t.tabIndex = 0),
        (t.style = n),
        t
    );
}
const u3 = { offset: 'stroke-dashoffset', array: 'stroke-dasharray' },
    c3 = { offset: 'strokeDashoffset', array: 'strokeDasharray' };
function f3(i, e, t = 1, n = 0, r = !0) {
    i.pathLength = 1;
    const s = r ? u3 : c3;
    i[s.offset] = Dt.transform(-n);
    const a = Dt.transform(e),
        l = Dt.transform(t);
    i[s.array] = `${a} ${l}`;
}
function eC(
    i,
    {
        attrX: e,
        attrY: t,
        attrScale: n,
        pathLength: r,
        pathSpacing: s = 1,
        pathOffset: a = 0,
        ...l
    },
    c,
    d,
    p
) {
    if ((dS(i, l, d), c)) {
        i.style.viewBox && (i.attrs.viewBox = i.style.viewBox);
        return;
    }
    (i.attrs = i.style), (i.style = {});
    const { attrs: g, style: y } = i;
    g.transform && ((y.transform = g.transform), delete g.transform),
        (y.transform || g.transformOrigin) &&
            ((y.transformOrigin = g.transformOrigin ?? '50% 50%'),
            delete g.transformOrigin),
        y.transform &&
            ((y.transformBox =
                (p == null ? void 0 : p.transformBox) ?? 'fill-box'),
            delete g.transformBox),
        e !== void 0 && (g.x = e),
        t !== void 0 && (g.y = t),
        n !== void 0 && (g.scale = n),
        r !== void 0 && f3(g, r, s, a, !1);
}
const tC = () => ({ ...pS(), attrs: {} }),
    nC = (i) => typeof i == 'string' && i.toLowerCase() === 'svg';
function h3(i, e, t, n) {
    const r = K.useMemo(() => {
        const s = tC();
        return (
            eC(s, e, nC(n), i.transformTemplate, i.style),
            { ...s.attrs, style: { ...s.style } }
        );
    }, [e]);
    if (i.style) {
        const s = {};
        QA(s, i.style, i), (r.style = { ...s, ...r.style });
    }
    return r;
}
const d3 = [
    'animate',
    'circle',
    'defs',
    'desc',
    'ellipse',
    'g',
    'image',
    'line',
    'filter',
    'marker',
    'mask',
    'metadata',
    'path',
    'pattern',
    'polygon',
    'polyline',
    'rect',
    'stop',
    'switch',
    'symbol',
    'svg',
    'text',
    'tspan',
    'use',
    'view',
];
function mS(i) {
    return typeof i != 'string' || i.includes('-')
        ? !1
        : !!(d3.indexOf(i) > -1 || /[A-Z]/u.test(i));
}
function p3(i = !1) {
    return (t, n, r, { latestValues: s }, a) => {
        const c = (mS(t) ? h3 : l3)(n, s, a, t),
            d = GI(n, typeof t == 'string', i),
            p = t !== K.Fragment ? { ...d, ...c, ref: r } : {},
            { children: g } = n,
            y = K.useMemo(() => (rr(g) ? g.get() : g), [g]);
        return K.createElement(t, { ...p, children: y });
    };
}
function DM(i) {
    const e = [{}, {}];
    return (
        i == null ||
            i.values.forEach((t, n) => {
                (e[0][n] = t.get()), (e[1][n] = t.getVelocity());
            }),
        e
    );
}
function gS(i, e, t, n) {
    if (typeof e == 'function') {
        const [r, s] = DM(n);
        e = e(t !== void 0 ? t : i.custom, r, s);
    }
    if (
        (typeof e == 'string' && (e = i.variants && i.variants[e]),
        typeof e == 'function')
    ) {
        const [r, s] = DM(n);
        e = e(t !== void 0 ? t : i.custom, r, s);
    }
    return e;
}
function ny(i) {
    return rr(i) ? i.get() : i;
}
function m3({ scrapeMotionValuesFromProps: i, createRenderState: e }, t, n, r) {
    return { latestValues: g3(t, n, r, i), renderState: e() };
}
const iC = (i) => (e, t) => {
    const n = K.useContext(tv),
        r = K.useContext(ev),
        s = () => m3(i, e, n, r);
    return t ? s() : B_(s);
};
function g3(i, e, t, n) {
    const r = {},
        s = n(i, {});
    for (const y in s) r[y] = ny(s[y]);
    let { initial: a, animate: l } = i;
    const c = iv(i),
        d = $A(i);
    e &&
        d &&
        !c &&
        i.inherit !== !1 &&
        (a === void 0 && (a = e.initial), l === void 0 && (l = e.animate));
    let p = t ? t.initial === !1 : !1;
    p = p || a === !1;
    const g = p ? l : a;
    if (g && typeof g != 'boolean' && !nv(g)) {
        const y = Array.isArray(g) ? g : [g];
        for (let v = 0; v < y.length; v++) {
            const S = gS(i, y[v]);
            if (S) {
                const { transitionEnd: T, transition: M, ...w } = S;
                for (const b in w) {
                    let C = w[b];
                    if (Array.isArray(C)) {
                        const L = p ? C.length - 1 : 0;
                        C = C[L];
                    }
                    C !== null && (r[b] = C);
                }
                for (const b in T) r[b] = T[b];
            }
        }
    }
    return r;
}
function yS(i, e, t) {
    var s;
    const { style: n } = i,
        r = {};
    for (const a in n)
        (rr(n[a]) ||
            (e.style && rr(e.style[a])) ||
            JA(a, i) ||
            ((s = t == null ? void 0 : t.getValue(a)) == null
                ? void 0
                : s.liveStyle) !== void 0) &&
            (r[a] = n[a]);
    return r;
}
const y3 = {
    useVisualState: iC({
        scrapeMotionValuesFromProps: yS,
        createRenderState: pS,
    }),
};
function rC(i, e, t) {
    const n = yS(i, e, t);
    for (const r in i)
        if (rr(i[r]) || rr(e[r])) {
            const s =
                yh.indexOf(r) !== -1
                    ? 'attr' + r.charAt(0).toUpperCase() + r.substring(1)
                    : r;
            n[s] = i[r];
        }
    return n;
}
const v3 = {
    useVisualState: iC({
        scrapeMotionValuesFromProps: rC,
        createRenderState: tC,
    }),
};
function x3(i, e) {
    return function (
        n,
        { forwardMotionProps: r } = { forwardMotionProps: !1 }
    ) {
        const a = {
            ...(mS(n) ? v3 : y3),
            preloadedFeatures: i,
            useRender: p3(r),
            createVisualElement: e,
            Component: n,
        };
        return JI(a);
    };
}
function pp(i, e, t) {
    const n = i.getProps();
    return gS(n, e, t !== void 0 ? t : n.custom, i);
}
const t_ = (i) => Array.isArray(i);
function _3(i, e, t) {
    i.hasValue(e) ? i.getValue(e).set(t) : i.addValue(e, lh(t));
}
function S3(i) {
    return t_(i) ? i[i.length - 1] || 0 : i;
}
function w3(i, e) {
    const t = pp(i, e);
    let { transitionEnd: n = {}, transition: r = {}, ...s } = t || {};
    s = { ...s, ...n };
    for (const a in s) {
        const l = S3(s[a]);
        _3(i, a, l);
    }
}
function M3(i) {
    return !!(rr(i) && i.add);
}
function n_(i, e) {
    const t = i.getValue('willChange');
    if (M3(t)) return t.add(e);
    if (!t && Ia.WillChange) {
        const n = new Ia.WillChange('auto');
        i.addValue('willChange', n), n.add(e);
    }
}
function sC(i) {
    return i.props[YA];
}
const E3 = (i) => i !== null;
function T3(i, { repeat: e, repeatType: t = 'loop' }, n) {
    const r = i.filter(E3),
        s = e && t !== 'loop' && e % 2 === 1 ? 0 : r.length - 1;
    return r[s];
}
const A3 = { type: 'spring', stiffness: 500, damping: 25, restSpeed: 10 },
    C3 = (i) => ({
        type: 'spring',
        stiffness: 550,
        damping: i === 0 ? 2 * Math.sqrt(550) : 30,
        restSpeed: 10,
    }),
    R3 = { type: 'keyframes', duration: 0.8 },
    b3 = { type: 'keyframes', ease: [0.25, 0.1, 0.35, 1], duration: 0.3 },
    P3 = (i, { keyframes: e }) =>
        e.length > 2
            ? R3
            : vh.has(i)
              ? i.startsWith('scale')
                  ? C3(e[1])
                  : A3
              : b3;
function L3({
    when: i,
    delay: e,
    delayChildren: t,
    staggerChildren: n,
    staggerDirection: r,
    repeat: s,
    repeatType: a,
    repeatDelay: l,
    from: c,
    elapsed: d,
    ...p
}) {
    return !!Object.keys(p).length;
}
const vS =
    (i, e, t, n = {}, r, s) =>
    (a) => {
        const l = sS(n, i) || {},
            c = l.delay || n.delay || 0;
        let { elapsed: d = 0 } = n;
        d = d - Uo(c);
        const p = {
            keyframes: Array.isArray(t) ? t : [null, t],
            ease: 'easeOut',
            velocity: e.getVelocity(),
            ...l,
            delay: -d,
            onUpdate: (y) => {
                e.set(y), l.onUpdate && l.onUpdate(y);
            },
            onComplete: () => {
                a(), l.onComplete && l.onComplete();
            },
            name: i,
            motionValue: e,
            element: s ? void 0 : r,
        };
        L3(l) || Object.assign(p, P3(i, p)),
            p.duration && (p.duration = Uo(p.duration)),
            p.repeatDelay && (p.repeatDelay = Uo(p.repeatDelay)),
            p.from !== void 0 && (p.keyframes[0] = p.from);
        let g = !1;
        if (
            ((p.type === !1 || (p.duration === 0 && !p.repeatDelay)) &&
                ((p.duration = 0), p.delay === 0 && (g = !0)),
            (Ia.instantAnimations || Ia.skipAnimations) &&
                ((g = !0), (p.duration = 0), (p.delay = 0)),
            (p.allowFlatten = !l.type && !l.ease),
            g && !s && e.get() !== void 0)
        ) {
            const y = T3(p.keyframes, l);
            if (y !== void 0) {
                Xn.update(() => {
                    p.onUpdate(y), p.onComplete();
                });
                return;
            }
        }
        return l.isSync ? new nS(p) : new fI(p);
    };
function I3({ protectedKeys: i, needsAnimating: e }, t) {
    const n = i.hasOwnProperty(t) && e[t] !== !0;
    return (e[t] = !1), n;
}
function oC(i, e, { delay: t = 0, transitionOverride: n, type: r } = {}) {
    let {
        transition: s = i.getDefaultTransition(),
        transitionEnd: a,
        ...l
    } = e;
    n && (s = n);
    const c = [],
        d = r && i.animationState && i.animationState.getState()[r];
    for (const p in l) {
        const g = i.getValue(p, i.latestValues[p] ?? null),
            y = l[p];
        if (y === void 0 || (d && I3(d, p))) continue;
        const v = { delay: t, ...sS(s || {}, p) },
            S = g.get();
        if (
            S !== void 0 &&
            !g.isAnimating &&
            !Array.isArray(y) &&
            y === S &&
            !v.velocity
        )
            continue;
        let T = !1;
        if (window.MotionHandoffAnimation) {
            const w = sC(i);
            if (w) {
                const b = window.MotionHandoffAnimation(w, p, Xn);
                b !== null && ((v.startTime = b), (T = !0));
            }
        }
        n_(i, p),
            g.start(
                vS(
                    p,
                    g,
                    y,
                    i.shouldReduceMotion && NA.has(p) ? { type: !1 } : v,
                    i,
                    T
                )
            );
        const M = g.animation;
        M && c.push(M);
    }
    return (
        a &&
            Promise.all(c).then(() => {
                Xn.update(() => {
                    a && w3(i, a);
                });
            }),
        c
    );
}
function i_(i, e, t = {}) {
    var c;
    const n = pp(
        i,
        e,
        t.type === 'exit'
            ? (c = i.presenceContext) == null
                ? void 0
                : c.custom
            : void 0
    );
    let { transition: r = i.getDefaultTransition() || {} } = n || {};
    t.transitionOverride && (r = t.transitionOverride);
    const s = n ? () => Promise.all(oC(i, n, t)) : () => Promise.resolve(),
        a =
            i.variantChildren && i.variantChildren.size
                ? (d = 0) => {
                      const {
                          delayChildren: p = 0,
                          staggerChildren: g,
                          staggerDirection: y,
                      } = r;
                      return D3(i, e, p + d, g, y, t);
                  }
                : () => Promise.resolve(),
        { when: l } = r;
    if (l) {
        const [d, p] = l === 'beforeChildren' ? [s, a] : [a, s];
        return d().then(() => p());
    } else return Promise.all([s(), a(t.delay)]);
}
function D3(i, e, t = 0, n = 0, r = 1, s) {
    const a = [],
        l = (i.variantChildren.size - 1) * n,
        c = r === 1 ? (d = 0) => d * n : (d = 0) => l - d * n;
    return (
        Array.from(i.variantChildren)
            .sort(N3)
            .forEach((d, p) => {
                d.notify('AnimationStart', e),
                    a.push(
                        i_(d, e, { ...s, delay: t + c(p) }).then(() =>
                            d.notify('AnimationComplete', e)
                        )
                    );
            }),
        Promise.all(a)
    );
}
function N3(i, e) {
    return i.sortNodePosition(e);
}
function U3(i, e, t = {}) {
    i.notify('AnimationStart', e);
    let n;
    if (Array.isArray(e)) {
        const r = e.map((s) => i_(i, s, t));
        n = Promise.all(r);
    } else if (typeof e == 'string') n = i_(i, e, t);
    else {
        const r = typeof e == 'function' ? pp(i, e, t.custom) : e;
        n = Promise.all(oC(i, r, t));
    }
    return n.then(() => {
        i.notify('AnimationComplete', e);
    });
}
function aC(i, e) {
    if (!Array.isArray(e)) return !1;
    const t = e.length;
    if (t !== i.length) return !1;
    for (let n = 0; n < t; n++) if (e[n] !== i[n]) return !1;
    return !0;
}
const O3 = fS.length;
function lC(i) {
    if (!i) return;
    if (!i.isControllingVariants) {
        const t = i.parent ? lC(i.parent) || {} : {};
        return i.props.initial !== void 0 && (t.initial = i.props.initial), t;
    }
    const e = {};
    for (let t = 0; t < O3; t++) {
        const n = fS[t],
            r = i.props[n];
        (hp(r) || r === !1) && (e[n] = r);
    }
    return e;
}
const k3 = [...cS].reverse(),
    F3 = cS.length;
function B3(i) {
    return (e) =>
        Promise.all(e.map(({ animation: t, options: n }) => U3(i, t, n)));
}
function z3(i) {
    let e = B3(i),
        t = NM(),
        n = !0;
    const r = (c) => (d, p) => {
        var y;
        const g = pp(
            i,
            p,
            c === 'exit'
                ? (y = i.presenceContext) == null
                    ? void 0
                    : y.custom
                : void 0
        );
        if (g) {
            const { transition: v, transitionEnd: S, ...T } = g;
            d = { ...d, ...T, ...S };
        }
        return d;
    };
    function s(c) {
        e = c(i);
    }
    function a(c) {
        const { props: d } = i,
            p = lC(i.parent) || {},
            g = [],
            y = new Set();
        let v = {},
            S = 1 / 0;
        for (let M = 0; M < F3; M++) {
            const w = k3[M],
                b = t[w],
                C = d[w] !== void 0 ? d[w] : p[w],
                L = hp(C),
                F = w === c ? b.isActive : null;
            F === !1 && (S = M);
            let N = C === p[w] && C !== d[w] && L;
            if (
                (N && n && i.manuallyAnimateOnMount && (N = !1),
                (b.protectedKeys = { ...v }),
                (!b.isActive && F === null) ||
                    (!C && !b.prevProp) ||
                    nv(C) ||
                    typeof C == 'boolean')
            )
                continue;
            const B = V3(b.prevProp, C);
            let z = B || (w === c && b.isActive && !N && L) || (M > S && L),
                U = !1;
            const D = Array.isArray(C) ? C : [C];
            let H = D.reduce(r(w), {});
            F === !1 && (H = {});
            const { prevResolvedValues: ie = {} } = b,
                ee = { ...ie, ...H },
                ue = (me) => {
                    (z = !0),
                        y.has(me) && ((U = !0), y.delete(me)),
                        (b.needsAnimating[me] = !0);
                    const X = i.getValue(me);
                    X && (X.liveStyle = !1);
                };
            for (const me in ee) {
                const X = H[me],
                    oe = ie[me];
                if (v.hasOwnProperty(me)) continue;
                let Q = !1;
                t_(X) && t_(oe) ? (Q = !aC(X, oe)) : (Q = X !== oe),
                    Q
                        ? X != null
                            ? ue(me)
                            : y.add(me)
                        : X !== void 0 && y.has(me)
                          ? ue(me)
                          : (b.protectedKeys[me] = !0);
            }
            (b.prevProp = C),
                (b.prevResolvedValues = H),
                b.isActive && (v = { ...v, ...H }),
                n && i.blockInitialAnimation && (z = !1),
                z &&
                    (!(N && B) || U) &&
                    g.push(
                        ...D.map((me) => ({
                            animation: me,
                            options: { type: w },
                        }))
                    );
        }
        if (y.size) {
            const M = {};
            if (typeof d.initial != 'boolean') {
                const w = pp(
                    i,
                    Array.isArray(d.initial) ? d.initial[0] : d.initial
                );
                w && w.transition && (M.transition = w.transition);
            }
            y.forEach((w) => {
                const b = i.getBaseTarget(w),
                    C = i.getValue(w);
                C && (C.liveStyle = !0), (M[w] = b ?? null);
            }),
                g.push({ animation: M });
        }
        let T = !!g.length;
        return (
            n &&
                (d.initial === !1 || d.initial === d.animate) &&
                !i.manuallyAnimateOnMount &&
                (T = !1),
            (n = !1),
            T ? e(g) : Promise.resolve()
        );
    }
    function l(c, d) {
        var g;
        if (t[c].isActive === d) return Promise.resolve();
        (g = i.variantChildren) == null ||
            g.forEach((y) => {
                var v;
                return (v = y.animationState) == null
                    ? void 0
                    : v.setActive(c, d);
            }),
            (t[c].isActive = d);
        const p = a(c);
        for (const y in t) t[y].protectedKeys = {};
        return p;
    }
    return {
        animateChanges: a,
        setActive: l,
        setAnimateFunction: s,
        getState: () => t,
        reset: () => {
            (t = NM()), (n = !0);
        },
    };
}
function V3(i, e) {
    return typeof e == 'string' ? e !== i : Array.isArray(e) ? !aC(e, i) : !1;
}
function Pu(i = !1) {
    return {
        isActive: i,
        protectedKeys: {},
        needsAnimating: {},
        prevResolvedValues: {},
    };
}
function NM() {
    return {
        animate: Pu(!0),
        whileInView: Pu(),
        whileHover: Pu(),
        whileTap: Pu(),
        whileDrag: Pu(),
        whileFocus: Pu(),
        exit: Pu(),
    };
}
class kl {
    constructor(e) {
        (this.isMounted = !1), (this.node = e);
    }
    update() {}
}
class H3 extends kl {
    constructor(e) {
        super(e), e.animationState || (e.animationState = z3(e));
    }
    updateAnimationControlsSubscription() {
        const { animate: e } = this.node.getProps();
        nv(e) && (this.unmountControls = e.subscribe(this.node));
    }
    mount() {
        this.updateAnimationControlsSubscription();
    }
    update() {
        const { animate: e } = this.node.getProps(),
            { animate: t } = this.node.prevProps || {};
        e !== t && this.updateAnimationControlsSubscription();
    }
    unmount() {
        var e;
        this.node.animationState.reset(),
            (e = this.unmountControls) == null || e.call(this);
    }
}
let G3 = 0;
class W3 extends kl {
    constructor() {
        super(...arguments), (this.id = G3++);
    }
    update() {
        if (!this.node.presenceContext) return;
        const { isPresent: e, onExitComplete: t } = this.node.presenceContext,
            { isPresent: n } = this.node.prevPresenceContext || {};
        if (!this.node.animationState || e === n) return;
        const r = this.node.animationState.setActive('exit', !e);
        t &&
            !e &&
            r.then(() => {
                t(this.id);
            });
    }
    mount() {
        const { register: e, onExitComplete: t } =
            this.node.presenceContext || {};
        t && t(this.id), e && (this.unmount = e(this.id));
    }
    unmount() {}
}
const X3 = { animation: { Feature: H3 }, exit: { Feature: W3 } };
function mp(i, e, t, n = { passive: !0 }) {
    return i.addEventListener(e, t, n), () => i.removeEventListener(e, t);
}
function Wp(i) {
    return { point: { x: i.pageX, y: i.pageY } };
}
const j3 = (i) => (e) => lS(e) && i(e, Wp(e));
function $d(i, e, t, n) {
    return mp(i, e, j3(t), n);
}
function uC({ top: i, left: e, right: t, bottom: n }) {
    return { x: { min: e, max: t }, y: { min: i, max: n } };
}
function q3({ x: i, y: e }) {
    return { top: e.min, right: i.max, bottom: e.max, left: i.min };
}
function $3(i, e) {
    if (!e) return i;
    const t = e({ x: i.left, y: i.top }),
        n = e({ x: i.right, y: i.bottom });
    return { top: t.y, left: t.x, bottom: n.y, right: n.x };
}
const cC = 1e-4,
    Y3 = 1 - cC,
    K3 = 1 + cC,
    fC = 0.01,
    Z3 = 0 - fC,
    J3 = 0 + fC;
function Mr(i) {
    return i.max - i.min;
}
function Q3(i, e, t) {
    return Math.abs(i - e) <= t;
}
function UM(i, e, t, n = 0.5) {
    (i.origin = n),
        (i.originPoint = Gn(e.min, e.max, i.origin)),
        (i.scale = Mr(t) / Mr(e)),
        (i.translate = Gn(t.min, t.max, i.origin) - i.originPoint),
        ((i.scale >= Y3 && i.scale <= K3) || isNaN(i.scale)) && (i.scale = 1),
        ((i.translate >= Z3 && i.translate <= J3) || isNaN(i.translate)) &&
            (i.translate = 0);
}
function Yd(i, e, t, n) {
    UM(i.x, e.x, t.x, n ? n.originX : void 0),
        UM(i.y, e.y, t.y, n ? n.originY : void 0);
}
function OM(i, e, t) {
    (i.min = t.min + e.min), (i.max = i.min + Mr(e));
}
function eD(i, e, t) {
    OM(i.x, e.x, t.x), OM(i.y, e.y, t.y);
}
function kM(i, e, t) {
    (i.min = e.min - t.min), (i.max = i.min + Mr(e));
}
function Kd(i, e, t) {
    kM(i.x, e.x, t.x), kM(i.y, e.y, t.y);
}
const FM = () => ({ translate: 0, scale: 1, origin: 0, originPoint: 0 }),
    Yf = () => ({ x: FM(), y: FM() }),
    BM = () => ({ min: 0, max: 0 }),
    ri = () => ({ x: BM(), y: BM() });
function Ss(i) {
    return [i('x'), i('y')];
}
function L0(i) {
    return i === void 0 || i === 1;
}
function r_({ scale: i, scaleX: e, scaleY: t }) {
    return !L0(i) || !L0(e) || !L0(t);
}
function Gu(i) {
    return (
        r_(i) ||
        hC(i) ||
        i.z ||
        i.rotate ||
        i.rotateX ||
        i.rotateY ||
        i.skewX ||
        i.skewY
    );
}
function hC(i) {
    return zM(i.x) || zM(i.y);
}
function zM(i) {
    return i && i !== '0%';
}
function dy(i, e, t) {
    const n = i - t,
        r = e * n;
    return t + r;
}
function VM(i, e, t, n, r) {
    return r !== void 0 && (i = dy(i, r, n)), dy(i, t, n) + e;
}
function s_(i, e = 0, t = 1, n, r) {
    (i.min = VM(i.min, e, t, n, r)), (i.max = VM(i.max, e, t, n, r));
}
function dC(i, { x: e, y: t }) {
    s_(i.x, e.translate, e.scale, e.originPoint),
        s_(i.y, t.translate, t.scale, t.originPoint);
}
const HM = 0.999999999999,
    GM = 1.0000000000001;
function tD(i, e, t, n = !1) {
    const r = t.length;
    if (!r) return;
    e.x = e.y = 1;
    let s, a;
    for (let l = 0; l < r; l++) {
        (s = t[l]), (a = s.projectionDelta);
        const { visualElement: c } = s.options;
        (c && c.props.style && c.props.style.display === 'contents') ||
            (n &&
                s.options.layoutScroll &&
                s.scroll &&
                s !== s.root &&
                Zf(i, { x: -s.scroll.offset.x, y: -s.scroll.offset.y }),
            a && ((e.x *= a.x.scale), (e.y *= a.y.scale), dC(i, a)),
            n && Gu(s.latestValues) && Zf(i, s.latestValues));
    }
    e.x < GM && e.x > HM && (e.x = 1), e.y < GM && e.y > HM && (e.y = 1);
}
function Kf(i, e) {
    (i.min = i.min + e), (i.max = i.max + e);
}
function WM(i, e, t, n, r = 0.5) {
    const s = Gn(i.min, i.max, r);
    s_(i, e, t, s, n);
}
function Zf(i, e) {
    WM(i.x, e.x, e.scaleX, e.scale, e.originX),
        WM(i.y, e.y, e.scaleY, e.scale, e.originY);
}
function pC(i, e) {
    return uC($3(i.getBoundingClientRect(), e));
}
function nD(i, e, t) {
    const n = pC(i, t),
        { scroll: r } = e;
    return r && (Kf(n.x, r.offset.x), Kf(n.y, r.offset.y)), n;
}
const mC = ({ current: i }) => (i ? i.ownerDocument.defaultView : null),
    XM = (i, e) => Math.abs(i - e);
function iD(i, e) {
    const t = XM(i.x, e.x),
        n = XM(i.y, e.y);
    return Math.sqrt(t ** 2 + n ** 2);
}
class gC {
    constructor(
        e,
        t,
        {
            transformPagePoint: n,
            contextWindow: r,
            dragSnapToOrigin: s = !1,
        } = {}
    ) {
        if (
            ((this.startEvent = null),
            (this.lastMoveEvent = null),
            (this.lastMoveEventInfo = null),
            (this.handlers = {}),
            (this.contextWindow = window),
            (this.updatePoint = () => {
                if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;
                const g = D0(this.lastMoveEventInfo, this.history),
                    y = this.startEvent !== null,
                    v = iD(g.offset, { x: 0, y: 0 }) >= 3;
                if (!y && !v) return;
                const { point: S } = g,
                    { timestamp: T } = Vi;
                this.history.push({ ...S, timestamp: T });
                const { onStart: M, onMove: w } = this.handlers;
                y ||
                    (M && M(this.lastMoveEvent, g),
                    (this.startEvent = this.lastMoveEvent)),
                    w && w(this.lastMoveEvent, g);
            }),
            (this.handlePointerMove = (g, y) => {
                (this.lastMoveEvent = g),
                    (this.lastMoveEventInfo = I0(y, this.transformPagePoint)),
                    Xn.update(this.updatePoint, !0);
            }),
            (this.handlePointerUp = (g, y) => {
                this.end();
                const {
                    onEnd: v,
                    onSessionEnd: S,
                    resumeAnimation: T,
                } = this.handlers;
                if (
                    (this.dragSnapToOrigin && T && T(),
                    !(this.lastMoveEvent && this.lastMoveEventInfo))
                )
                    return;
                const M = D0(
                    g.type === 'pointercancel'
                        ? this.lastMoveEventInfo
                        : I0(y, this.transformPagePoint),
                    this.history
                );
                this.startEvent && v && v(g, M), S && S(g, M);
            }),
            !lS(e))
        )
            return;
        (this.dragSnapToOrigin = s),
            (this.handlers = t),
            (this.transformPagePoint = n),
            (this.contextWindow = r || window);
        const a = Wp(e),
            l = I0(a, this.transformPagePoint),
            { point: c } = l,
            { timestamp: d } = Vi;
        this.history = [{ ...c, timestamp: d }];
        const { onSessionStart: p } = t;
        p && p(e, D0(l, this.history)),
            (this.removeListeners = Vp(
                $d(this.contextWindow, 'pointermove', this.handlePointerMove),
                $d(this.contextWindow, 'pointerup', this.handlePointerUp),
                $d(this.contextWindow, 'pointercancel', this.handlePointerUp)
            ));
    }
    updateHandlers(e) {
        this.handlers = e;
    }
    end() {
        this.removeListeners && this.removeListeners(), Il(this.updatePoint);
    }
}
function I0(i, e) {
    return e ? { point: e(i.point) } : i;
}
function jM(i, e) {
    return { x: i.x - e.x, y: i.y - e.y };
}
function D0({ point: i }, e) {
    return {
        point: i,
        delta: jM(i, yC(e)),
        offset: jM(i, rD(e)),
        velocity: sD(e, 0.1),
    };
}
function rD(i) {
    return i[0];
}
function yC(i) {
    return i[i.length - 1];
}
function sD(i, e) {
    if (i.length < 2) return { x: 0, y: 0 };
    let t = i.length - 1,
        n = null;
    const r = yC(i);
    for (; t >= 0 && ((n = i[t]), !(r.timestamp - n.timestamp > Uo(e))); ) t--;
    if (!n) return { x: 0, y: 0 };
    const s = Oo(r.timestamp - n.timestamp);
    if (s === 0) return { x: 0, y: 0 };
    const a = { x: (r.x - n.x) / s, y: (r.y - n.y) / s };
    return a.x === 1 / 0 && (a.x = 0), a.y === 1 / 0 && (a.y = 0), a;
}
function oD(i, { min: e, max: t }, n) {
    return (
        e !== void 0 && i < e
            ? (i = n ? Gn(e, i, n.min) : Math.max(i, e))
            : t !== void 0 &&
              i > t &&
              (i = n ? Gn(t, i, n.max) : Math.min(i, t)),
        i
    );
}
function qM(i, e, t) {
    return {
        min: e !== void 0 ? i.min + e : void 0,
        max: t !== void 0 ? i.max + t - (i.max - i.min) : void 0,
    };
}
function aD(i, { top: e, left: t, bottom: n, right: r }) {
    return { x: qM(i.x, t, r), y: qM(i.y, e, n) };
}
function $M(i, e) {
    let t = e.min - i.min,
        n = e.max - i.max;
    return (
        e.max - e.min < i.max - i.min && ([t, n] = [n, t]), { min: t, max: n }
    );
}
function lD(i, e) {
    return { x: $M(i.x, e.x), y: $M(i.y, e.y) };
}
function uD(i, e) {
    let t = 0.5;
    const n = Mr(i),
        r = Mr(e);
    return (
        r > n
            ? (t = up(e.min, e.max - n, i.min))
            : n > r && (t = up(i.min, i.max - r, e.min)),
        La(0, 1, t)
    );
}
function cD(i, e) {
    const t = {};
    return (
        e.min !== void 0 && (t.min = e.min - i.min),
        e.max !== void 0 && (t.max = e.max - i.min),
        t
    );
}
const o_ = 0.35;
function fD(i = o_) {
    return (
        i === !1 ? (i = 0) : i === !0 && (i = o_),
        { x: YM(i, 'left', 'right'), y: YM(i, 'top', 'bottom') }
    );
}
function YM(i, e, t) {
    return { min: KM(i, e), max: KM(i, t) };
}
function KM(i, e) {
    return typeof i == 'number' ? i : i[e] || 0;
}
const hD = new WeakMap();
class dD {
    constructor(e) {
        (this.openDragLock = null),
            (this.isDragging = !1),
            (this.currentDirection = null),
            (this.originPoint = { x: 0, y: 0 }),
            (this.constraints = !1),
            (this.hasMutatedConstraints = !1),
            (this.elastic = ri()),
            (this.visualElement = e);
    }
    start(e, { snapToCursor: t = !1 } = {}) {
        const { presenceContext: n } = this.visualElement;
        if (n && n.isPresent === !1) return;
        const r = (p) => {
                const { dragSnapToOrigin: g } = this.getProps();
                g ? this.pauseAnimation() : this.stopAnimation(),
                    t && this.snapToCursor(Wp(p).point);
            },
            s = (p, g) => {
                const {
                    drag: y,
                    dragPropagation: v,
                    onDragStart: S,
                } = this.getProps();
                if (
                    y &&
                    !v &&
                    (this.openDragLock && this.openDragLock(),
                    (this.openDragLock = CI(y)),
                    !this.openDragLock)
                )
                    return;
                (this.isDragging = !0),
                    (this.currentDirection = null),
                    this.resolveConstraints(),
                    this.visualElement.projection &&
                        ((this.visualElement.projection.isAnimationBlocked =
                            !0),
                        (this.visualElement.projection.target = void 0)),
                    Ss((M) => {
                        let w = this.getAxisMotionValue(M).get() || 0;
                        if (ko.test(w)) {
                            const { projection: b } = this.visualElement;
                            if (b && b.layout) {
                                const C = b.layout.layoutBox[M];
                                C && (w = Mr(C) * (parseFloat(w) / 100));
                            }
                        }
                        this.originPoint[M] = w;
                    }),
                    S && Xn.postRender(() => S(p, g)),
                    n_(this.visualElement, 'transform');
                const { animationState: T } = this.visualElement;
                T && T.setActive('whileDrag', !0);
            },
            a = (p, g) => {
                const {
                    dragPropagation: y,
                    dragDirectionLock: v,
                    onDirectionLock: S,
                    onDrag: T,
                } = this.getProps();
                if (!y && !this.openDragLock) return;
                const { offset: M } = g;
                if (v && this.currentDirection === null) {
                    (this.currentDirection = pD(M)),
                        this.currentDirection !== null &&
                            S &&
                            S(this.currentDirection);
                    return;
                }
                this.updateAxis('x', g.point, M),
                    this.updateAxis('y', g.point, M),
                    this.visualElement.render(),
                    T && T(p, g);
            },
            l = (p, g) => this.stop(p, g),
            c = () =>
                Ss((p) => {
                    var g;
                    return (
                        this.getAnimationState(p) === 'paused' &&
                        ((g = this.getAxisMotionValue(p).animation) == null
                            ? void 0
                            : g.play())
                    );
                }),
            { dragSnapToOrigin: d } = this.getProps();
        this.panSession = new gC(
            e,
            {
                onSessionStart: r,
                onStart: s,
                onMove: a,
                onSessionEnd: l,
                resumeAnimation: c,
            },
            {
                transformPagePoint: this.visualElement.getTransformPagePoint(),
                dragSnapToOrigin: d,
                contextWindow: mC(this.visualElement),
            }
        );
    }
    stop(e, t) {
        const n = this.isDragging;
        if ((this.cancel(), !n)) return;
        const { velocity: r } = t;
        this.startAnimation(r);
        const { onDragEnd: s } = this.getProps();
        s && Xn.postRender(() => s(e, t));
    }
    cancel() {
        this.isDragging = !1;
        const { projection: e, animationState: t } = this.visualElement;
        e && (e.isAnimationBlocked = !1),
            this.panSession && this.panSession.end(),
            (this.panSession = void 0);
        const { dragPropagation: n } = this.getProps();
        !n &&
            this.openDragLock &&
            (this.openDragLock(), (this.openDragLock = null)),
            t && t.setActive('whileDrag', !1);
    }
    updateAxis(e, t, n) {
        const { drag: r } = this.getProps();
        if (!n || !ng(e, r, this.currentDirection)) return;
        const s = this.getAxisMotionValue(e);
        let a = this.originPoint[e] + n[e];
        this.constraints &&
            this.constraints[e] &&
            (a = oD(a, this.constraints[e], this.elastic[e])),
            s.set(a);
    }
    resolveConstraints() {
        var s;
        const { dragConstraints: e, dragElastic: t } = this.getProps(),
            n =
                this.visualElement.projection &&
                !this.visualElement.projection.layout
                    ? this.visualElement.projection.measure(!1)
                    : (s = this.visualElement.projection) == null
                      ? void 0
                      : s.layout,
            r = this.constraints;
        e && $f(e)
            ? this.constraints ||
              (this.constraints = this.resolveRefConstraints())
            : e && n
              ? (this.constraints = aD(n.layoutBox, e))
              : (this.constraints = !1),
            (this.elastic = fD(t)),
            r !== this.constraints &&
                n &&
                this.constraints &&
                !this.hasMutatedConstraints &&
                Ss((a) => {
                    this.constraints !== !1 &&
                        this.getAxisMotionValue(a) &&
                        (this.constraints[a] = cD(
                            n.layoutBox[a],
                            this.constraints[a]
                        ));
                });
    }
    resolveRefConstraints() {
        const { dragConstraints: e, onMeasureDragConstraints: t } =
            this.getProps();
        if (!e || !$f(e)) return !1;
        const n = e.current,
            { projection: r } = this.visualElement;
        if (!r || !r.layout) return !1;
        const s = nD(n, r.root, this.visualElement.getTransformPagePoint());
        let a = lD(r.layout.layoutBox, s);
        if (t) {
            const l = t(q3(a));
            (this.hasMutatedConstraints = !!l), l && (a = uC(l));
        }
        return a;
    }
    startAnimation(e) {
        const {
                drag: t,
                dragMomentum: n,
                dragElastic: r,
                dragTransition: s,
                dragSnapToOrigin: a,
                onDragTransitionEnd: l,
            } = this.getProps(),
            c = this.constraints || {},
            d = Ss((p) => {
                if (!ng(p, t, this.currentDirection)) return;
                let g = (c && c[p]) || {};
                a && (g = { min: 0, max: 0 });
                const y = r ? 200 : 1e6,
                    v = r ? 40 : 1e7,
                    S = {
                        type: 'inertia',
                        velocity: n ? e[p] : 0,
                        bounceStiffness: y,
                        bounceDamping: v,
                        timeConstant: 750,
                        restDelta: 1,
                        restSpeed: 10,
                        ...s,
                        ...g,
                    };
                return this.startAxisValueAnimation(p, S);
            });
        return Promise.all(d).then(l);
    }
    startAxisValueAnimation(e, t) {
        const n = this.getAxisMotionValue(e);
        return (
            n_(this.visualElement, e),
            n.start(vS(e, n, 0, t, this.visualElement, !1))
        );
    }
    stopAnimation() {
        Ss((e) => this.getAxisMotionValue(e).stop());
    }
    pauseAnimation() {
        Ss((e) => {
            var t;
            return (t = this.getAxisMotionValue(e).animation) == null
                ? void 0
                : t.pause();
        });
    }
    getAnimationState(e) {
        var t;
        return (t = this.getAxisMotionValue(e).animation) == null
            ? void 0
            : t.state;
    }
    getAxisMotionValue(e) {
        const t = `_drag${e.toUpperCase()}`,
            n = this.visualElement.getProps(),
            r = n[t];
        return (
            r ||
            this.visualElement.getValue(
                e,
                (n.initial ? n.initial[e] : void 0) || 0
            )
        );
    }
    snapToCursor(e) {
        Ss((t) => {
            const { drag: n } = this.getProps();
            if (!ng(t, n, this.currentDirection)) return;
            const { projection: r } = this.visualElement,
                s = this.getAxisMotionValue(t);
            if (r && r.layout) {
                const { min: a, max: l } = r.layout.layoutBox[t];
                s.set(e[t] - Gn(a, l, 0.5));
            }
        });
    }
    scalePositionWithinConstraints() {
        if (!this.visualElement.current) return;
        const { drag: e, dragConstraints: t } = this.getProps(),
            { projection: n } = this.visualElement;
        if (!$f(t) || !n || !this.constraints) return;
        this.stopAnimation();
        const r = { x: 0, y: 0 };
        Ss((a) => {
            const l = this.getAxisMotionValue(a);
            if (l && this.constraints !== !1) {
                const c = l.get();
                r[a] = uD({ min: c, max: c }, this.constraints[a]);
            }
        });
        const { transformTemplate: s } = this.visualElement.getProps();
        (this.visualElement.current.style.transform = s ? s({}, '') : 'none'),
            n.root && n.root.updateScroll(),
            n.updateLayout(),
            this.resolveConstraints(),
            Ss((a) => {
                if (!ng(a, e, null)) return;
                const l = this.getAxisMotionValue(a),
                    { min: c, max: d } = this.constraints[a];
                l.set(Gn(c, d, r[a]));
            });
    }
    addListeners() {
        if (!this.visualElement.current) return;
        hD.set(this.visualElement, this);
        const e = this.visualElement.current,
            t = $d(e, 'pointerdown', (c) => {
                const { drag: d, dragListener: p = !0 } = this.getProps();
                d && p && this.start(c);
            }),
            n = () => {
                const { dragConstraints: c } = this.getProps();
                $f(c) &&
                    c.current &&
                    (this.constraints = this.resolveRefConstraints());
            },
            { projection: r } = this.visualElement,
            s = r.addEventListener('measure', n);
        r && !r.layout && (r.root && r.root.updateScroll(), r.updateLayout()),
            Xn.read(n);
        const a = mp(window, 'resize', () =>
                this.scalePositionWithinConstraints()
            ),
            l = r.addEventListener(
                'didUpdate',
                ({ delta: c, hasLayoutChanged: d }) => {
                    this.isDragging &&
                        d &&
                        (Ss((p) => {
                            const g = this.getAxisMotionValue(p);
                            g &&
                                ((this.originPoint[p] += c[p].translate),
                                g.set(g.get() + c[p].translate));
                        }),
                        this.visualElement.render());
                }
            );
        return () => {
            a(), t(), s(), l && l();
        };
    }
    getProps() {
        const e = this.visualElement.getProps(),
            {
                drag: t = !1,
                dragDirectionLock: n = !1,
                dragPropagation: r = !1,
                dragConstraints: s = !1,
                dragElastic: a = o_,
                dragMomentum: l = !0,
            } = e;
        return {
            ...e,
            drag: t,
            dragDirectionLock: n,
            dragPropagation: r,
            dragConstraints: s,
            dragElastic: a,
            dragMomentum: l,
        };
    }
}
function ng(i, e, t) {
    return (e === !0 || e === i) && (t === null || t === i);
}
function pD(i, e = 10) {
    let t = null;
    return Math.abs(i.y) > e ? (t = 'y') : Math.abs(i.x) > e && (t = 'x'), t;
}
class mD extends kl {
    constructor(e) {
        super(e),
            (this.removeGroupControls = Es),
            (this.removeListeners = Es),
            (this.controls = new dD(e));
    }
    mount() {
        const { dragControls: e } = this.node.getProps();
        e && (this.removeGroupControls = e.subscribe(this.controls)),
            (this.removeListeners = this.controls.addListeners() || Es);
    }
    unmount() {
        this.removeGroupControls(), this.removeListeners();
    }
}
const ZM = (i) => (e, t) => {
    i && Xn.postRender(() => i(e, t));
};
class gD extends kl {
    constructor() {
        super(...arguments), (this.removePointerDownListener = Es);
    }
    onPointerDown(e) {
        this.session = new gC(e, this.createPanHandlers(), {
            transformPagePoint: this.node.getTransformPagePoint(),
            contextWindow: mC(this.node),
        });
    }
    createPanHandlers() {
        const {
            onPanSessionStart: e,
            onPanStart: t,
            onPan: n,
            onPanEnd: r,
        } = this.node.getProps();
        return {
            onSessionStart: ZM(e),
            onStart: ZM(t),
            onMove: n,
            onEnd: (s, a) => {
                delete this.session, r && Xn.postRender(() => r(s, a));
            },
        };
    }
    mount() {
        this.removePointerDownListener = $d(
            this.node.current,
            'pointerdown',
            (e) => this.onPointerDown(e)
        );
    }
    update() {
        this.session && this.session.updateHandlers(this.createPanHandlers());
    }
    unmount() {
        this.removePointerDownListener(), this.session && this.session.end();
    }
}
const iy = { hasAnimatedSinceResize: !0, hasEverUpdated: !1 };
function JM(i, e) {
    return e.max === e.min ? 0 : (i / (e.max - e.min)) * 100;
}
const Ed = {
        correct: (i, e) => {
            if (!e.target) return i;
            if (typeof i == 'string')
                if (Dt.test(i)) i = parseFloat(i);
                else return i;
            const t = JM(i, e.target.x),
                n = JM(i, e.target.y);
            return `${t}% ${n}%`;
        },
    },
    yD = {
        correct: (i, { treeScale: e, projectionDelta: t }) => {
            const n = i,
                r = Dl.parse(i);
            if (r.length > 5) return n;
            const s = Dl.createTransformer(i),
                a = typeof r[0] != 'number' ? 1 : 0,
                l = t.x.scale * e.x,
                c = t.y.scale * e.y;
            (r[0 + a] /= l), (r[1 + a] /= c);
            const d = Gn(l, c, 0.5);
            return (
                typeof r[2 + a] == 'number' && (r[2 + a] /= d),
                typeof r[3 + a] == 'number' && (r[3 + a] /= d),
                s(r)
            );
        },
    };
class vD extends K.Component {
    componentDidMount() {
        const {
                visualElement: e,
                layoutGroup: t,
                switchLayoutGroup: n,
                layoutId: r,
            } = this.props,
            { projection: s } = e;
        n3(xD),
            s &&
                (t.group && t.group.add(s),
                n && n.register && r && n.register(s),
                s.root.didUpdate(),
                s.addEventListener('animationComplete', () => {
                    this.safeToRemove();
                }),
                s.setOptions({
                    ...s.options,
                    onExitComplete: () => this.safeToRemove(),
                })),
            (iy.hasEverUpdated = !0);
    }
    getSnapshotBeforeUpdate(e) {
        const {
                layoutDependency: t,
                visualElement: n,
                drag: r,
                isPresent: s,
            } = this.props,
            { projection: a } = n;
        return (
            a &&
                ((a.isPresent = s),
                r ||
                e.layoutDependency !== t ||
                t === void 0 ||
                e.isPresent !== s
                    ? a.willUpdate()
                    : this.safeToRemove(),
                e.isPresent !== s &&
                    (s
                        ? a.promote()
                        : a.relegate() ||
                          Xn.postRender(() => {
                              const l = a.getStack();
                              (!l || !l.members.length) && this.safeToRemove();
                          }))),
            null
        );
    }
    componentDidUpdate() {
        const { projection: e } = this.props.visualElement;
        e &&
            (e.root.didUpdate(),
            aS.postRender(() => {
                !e.currentAnimation && e.isLead() && this.safeToRemove();
            }));
    }
    componentWillUnmount() {
        const {
                visualElement: e,
                layoutGroup: t,
                switchLayoutGroup: n,
            } = this.props,
            { projection: r } = e;
        r &&
            (r.scheduleCheckAfterUnmount(),
            t && t.group && t.group.remove(r),
            n && n.deregister && n.deregister(r));
    }
    safeToRemove() {
        const { safeToRemove: e } = this.props;
        e && e();
    }
    render() {
        return null;
    }
}
function vC(i) {
    const [e, t] = WA(),
        n = K.useContext(F_);
    return rt.jsx(vD, {
        ...i,
        layoutGroup: n,
        switchLayoutGroup: K.useContext(KA),
        isPresent: e,
        safeToRemove: t,
    });
}
const xD = {
    borderRadius: {
        ...Ed,
        applyTo: [
            'borderTopLeftRadius',
            'borderTopRightRadius',
            'borderBottomLeftRadius',
            'borderBottomRightRadius',
        ],
    },
    borderTopLeftRadius: Ed,
    borderTopRightRadius: Ed,
    borderBottomLeftRadius: Ed,
    borderBottomRightRadius: Ed,
    boxShadow: yD,
};
function _D(i, e, t) {
    const n = rr(i) ? i : lh(i);
    return n.start(vS('', n, e, t)), n.animation;
}
const SD = (i, e) => i.depth - e.depth;
class wD {
    constructor() {
        (this.children = []), (this.isDirty = !1);
    }
    add(e) {
        V_(this.children, e), (this.isDirty = !0);
    }
    remove(e) {
        H_(this.children, e), (this.isDirty = !0);
    }
    forEach(e) {
        this.isDirty && this.children.sort(SD),
            (this.isDirty = !1),
            this.children.forEach(e);
    }
}
function MD(i, e) {
    const t = zr.now(),
        n = ({ timestamp: r }) => {
            const s = r - t;
            s >= e && (Il(n), i(s - e));
        };
    return Xn.setup(n, !0), () => Il(n);
}
const xC = ['TopLeft', 'TopRight', 'BottomLeft', 'BottomRight'],
    ED = xC.length,
    QM = (i) => (typeof i == 'string' ? parseFloat(i) : i),
    e1 = (i) => typeof i == 'number' || Dt.test(i);
function TD(i, e, t, n, r, s) {
    r
        ? ((i.opacity = Gn(0, t.opacity ?? 1, AD(n))),
          (i.opacityExit = Gn(e.opacity ?? 1, 0, CD(n))))
        : s && (i.opacity = Gn(e.opacity ?? 1, t.opacity ?? 1, n));
    for (let a = 0; a < ED; a++) {
        const l = `border${xC[a]}Radius`;
        let c = t1(e, l),
            d = t1(t, l);
        if (c === void 0 && d === void 0) continue;
        c || (c = 0),
            d || (d = 0),
            c === 0 || d === 0 || e1(c) === e1(d)
                ? ((i[l] = Math.max(Gn(QM(c), QM(d), n), 0)),
                  (ko.test(d) || ko.test(c)) && (i[l] += '%'))
                : (i[l] = d);
    }
    (e.rotate || t.rotate) && (i.rotate = Gn(e.rotate || 0, t.rotate || 0, n));
}
function t1(i, e) {
    return i[e] !== void 0 ? i[e] : i.borderRadius;
}
const AD = _C(0, 0.5, fA),
    CD = _C(0.5, 0.95, Es);
function _C(i, e, t) {
    return (n) => (n < i ? 0 : n > e ? 1 : t(up(i, e, n)));
}
function n1(i, e) {
    (i.min = e.min), (i.max = e.max);
}
function xs(i, e) {
    n1(i.x, e.x), n1(i.y, e.y);
}
function i1(i, e) {
    (i.translate = e.translate),
        (i.scale = e.scale),
        (i.originPoint = e.originPoint),
        (i.origin = e.origin);
}
function r1(i, e, t, n, r) {
    return (
        (i -= e),
        (i = dy(i, 1 / t, n)),
        r !== void 0 && (i = dy(i, 1 / r, n)),
        i
    );
}
function RD(i, e = 0, t = 1, n = 0.5, r, s = i, a = i) {
    if (
        (ko.test(e) &&
            ((e = parseFloat(e)), (e = Gn(a.min, a.max, e / 100) - a.min)),
        typeof e != 'number')
    )
        return;
    let l = Gn(s.min, s.max, n);
    i === s && (l -= e),
        (i.min = r1(i.min, e, t, l, r)),
        (i.max = r1(i.max, e, t, l, r));
}
function s1(i, e, [t, n, r], s, a) {
    RD(i, e[t], e[n], e[r], e.scale, s, a);
}
const bD = ['x', 'scaleX', 'originX'],
    PD = ['y', 'scaleY', 'originY'];
function o1(i, e, t, n) {
    s1(i.x, e, bD, t ? t.x : void 0, n ? n.x : void 0),
        s1(i.y, e, PD, t ? t.y : void 0, n ? n.y : void 0);
}
function a1(i) {
    return i.translate === 0 && i.scale === 1;
}
function SC(i) {
    return a1(i.x) && a1(i.y);
}
function l1(i, e) {
    return i.min === e.min && i.max === e.max;
}
function LD(i, e) {
    return l1(i.x, e.x) && l1(i.y, e.y);
}
function u1(i, e) {
    return (
        Math.round(i.min) === Math.round(e.min) &&
        Math.round(i.max) === Math.round(e.max)
    );
}
function wC(i, e) {
    return u1(i.x, e.x) && u1(i.y, e.y);
}
function c1(i) {
    return Mr(i.x) / Mr(i.y);
}
function f1(i, e) {
    return (
        i.translate === e.translate &&
        i.scale === e.scale &&
        i.originPoint === e.originPoint
    );
}
class ID {
    constructor() {
        this.members = [];
    }
    add(e) {
        V_(this.members, e), e.scheduleRender();
    }
    remove(e) {
        if (
            (H_(this.members, e),
            e === this.prevLead && (this.prevLead = void 0),
            e === this.lead)
        ) {
            const t = this.members[this.members.length - 1];
            t && this.promote(t);
        }
    }
    relegate(e) {
        const t = this.members.findIndex((r) => e === r);
        if (t === 0) return !1;
        let n;
        for (let r = t; r >= 0; r--) {
            const s = this.members[r];
            if (s.isPresent !== !1) {
                n = s;
                break;
            }
        }
        return n ? (this.promote(n), !0) : !1;
    }
    promote(e, t) {
        const n = this.lead;
        if (e !== n && ((this.prevLead = n), (this.lead = e), e.show(), n)) {
            n.instance && n.scheduleRender(),
                e.scheduleRender(),
                (e.resumeFrom = n),
                t && (e.resumeFrom.preserveOpacity = !0),
                n.snapshot &&
                    ((e.snapshot = n.snapshot),
                    (e.snapshot.latestValues =
                        n.animationValues || n.latestValues)),
                e.root && e.root.isUpdating && (e.isLayoutDirty = !0);
            const { crossfade: r } = e.options;
            r === !1 && n.hide();
        }
    }
    exitAnimationComplete() {
        this.members.forEach((e) => {
            const { options: t, resumingFrom: n } = e;
            t.onExitComplete && t.onExitComplete(),
                n && n.options.onExitComplete && n.options.onExitComplete();
        });
    }
    scheduleRender() {
        this.members.forEach((e) => {
            e.instance && e.scheduleRender(!1);
        });
    }
    removeLeadSnapshot() {
        this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
    }
}
function DD(i, e, t) {
    let n = '';
    const r = i.x.translate / e.x,
        s = i.y.translate / e.y,
        a = (t == null ? void 0 : t.z) || 0;
    if (
        ((r || s || a) && (n = `translate3d(${r}px, ${s}px, ${a}px) `),
        (e.x !== 1 || e.y !== 1) && (n += `scale(${1 / e.x}, ${1 / e.y}) `),
        t)
    ) {
        const {
            transformPerspective: d,
            rotate: p,
            rotateX: g,
            rotateY: y,
            skewX: v,
            skewY: S,
        } = t;
        d && (n = `perspective(${d}px) ${n}`),
            p && (n += `rotate(${p}deg) `),
            g && (n += `rotateX(${g}deg) `),
            y && (n += `rotateY(${y}deg) `),
            v && (n += `skewX(${v}deg) `),
            S && (n += `skewY(${S}deg) `);
    }
    const l = i.x.scale * e.x,
        c = i.y.scale * e.y;
    return (l !== 1 || c !== 1) && (n += `scale(${l}, ${c})`), n || 'none';
}
const N0 = ['', 'X', 'Y', 'Z'],
    ND = { visibility: 'hidden' },
    UD = 1e3;
let OD = 0;
function U0(i, e, t, n) {
    const { latestValues: r } = e;
    r[i] && ((t[i] = r[i]), e.setStaticValue(i, 0), n && (n[i] = 0));
}
function MC(i) {
    if (((i.hasCheckedOptimisedAppear = !0), i.root === i)) return;
    const { visualElement: e } = i.options;
    if (!e) return;
    const t = sC(e);
    if (window.MotionHasOptimisedAnimation(t, 'transform')) {
        const { layout: r, layoutId: s } = i.options;
        window.MotionCancelOptimisedAnimation(t, 'transform', Xn, !(r || s));
    }
    const { parent: n } = i;
    n && !n.hasCheckedOptimisedAppear && MC(n);
}
function EC({
    attachResizeListener: i,
    defaultParent: e,
    measureScroll: t,
    checkIsScrollRoot: n,
    resetTransform: r,
}) {
    return class {
        constructor(a = {}, l = e == null ? void 0 : e()) {
            (this.id = OD++),
                (this.animationId = 0),
                (this.children = new Set()),
                (this.options = {}),
                (this.isTreeAnimating = !1),
                (this.isAnimationBlocked = !1),
                (this.isLayoutDirty = !1),
                (this.isProjectionDirty = !1),
                (this.isSharedProjectionDirty = !1),
                (this.isTransformDirty = !1),
                (this.updateManuallyBlocked = !1),
                (this.updateBlockedByResize = !1),
                (this.isUpdating = !1),
                (this.isSVG = !1),
                (this.needsReset = !1),
                (this.shouldResetTransform = !1),
                (this.hasCheckedOptimisedAppear = !1),
                (this.treeScale = { x: 1, y: 1 }),
                (this.eventHandlers = new Map()),
                (this.hasTreeAnimated = !1),
                (this.updateScheduled = !1),
                (this.scheduleUpdate = () => this.update()),
                (this.projectionUpdateScheduled = !1),
                (this.checkUpdateFailed = () => {
                    this.isUpdating &&
                        ((this.isUpdating = !1), this.clearAllSnapshots());
                }),
                (this.updateProjection = () => {
                    (this.projectionUpdateScheduled = !1),
                        this.nodes.forEach(BD),
                        this.nodes.forEach(WD),
                        this.nodes.forEach(XD),
                        this.nodes.forEach(zD);
                }),
                (this.resolvedRelativeTargetAt = 0),
                (this.hasProjected = !1),
                (this.isVisible = !0),
                (this.animationProgress = 0),
                (this.sharedNodes = new Map()),
                (this.latestValues = a),
                (this.root = l ? l.root || l : this),
                (this.path = l ? [...l.path, l] : []),
                (this.parent = l),
                (this.depth = l ? l.depth + 1 : 0);
            for (let c = 0; c < this.path.length; c++)
                this.path[c].shouldResetTransform = !0;
            this.root === this && (this.nodes = new wD());
        }
        addEventListener(a, l) {
            return (
                this.eventHandlers.has(a) ||
                    this.eventHandlers.set(a, new X_()),
                this.eventHandlers.get(a).add(l)
            );
        }
        notifyListeners(a, ...l) {
            const c = this.eventHandlers.get(a);
            c && c.notify(...l);
        }
        hasListeners(a) {
            return this.eventHandlers.has(a);
        }
        mount(a) {
            if (this.instance) return;
            (this.isSVG = GA(a) && !DI(a)), (this.instance = a);
            const { layoutId: l, layout: c, visualElement: d } = this.options;
            if (
                (d && !d.current && d.mount(a),
                this.root.nodes.add(this),
                this.parent && this.parent.children.add(this),
                this.root.hasTreeAnimated &&
                    (c || l) &&
                    (this.isLayoutDirty = !0),
                i)
            ) {
                let p;
                const g = () => (this.root.updateBlockedByResize = !1);
                i(a, () => {
                    (this.root.updateBlockedByResize = !0),
                        p && p(),
                        (p = MD(g, 250)),
                        iy.hasAnimatedSinceResize &&
                            ((iy.hasAnimatedSinceResize = !1),
                            this.nodes.forEach(d1));
                });
            }
            l && this.root.registerSharedNode(l, this),
                this.options.animate !== !1 &&
                    d &&
                    (l || c) &&
                    this.addEventListener(
                        'didUpdate',
                        ({
                            delta: p,
                            hasLayoutChanged: g,
                            hasRelativeLayoutChanged: y,
                            layout: v,
                        }) => {
                            if (this.isTreeAnimationBlocked()) {
                                (this.target = void 0),
                                    (this.relativeTarget = void 0);
                                return;
                            }
                            const S =
                                    this.options.transition ||
                                    d.getDefaultTransition() ||
                                    KD,
                                {
                                    onLayoutAnimationStart: T,
                                    onLayoutAnimationComplete: M,
                                } = d.getProps(),
                                w =
                                    !this.targetLayout ||
                                    !wC(this.targetLayout, v),
                                b = !g && y;
                            if (
                                this.options.layoutRoot ||
                                this.resumeFrom ||
                                b ||
                                (g && (w || !this.currentAnimation))
                            ) {
                                this.resumeFrom &&
                                    ((this.resumingFrom = this.resumeFrom),
                                    (this.resumingFrom.resumingFrom = void 0)),
                                    this.setAnimationOrigin(p, b);
                                const C = {
                                    ...sS(S, 'layout'),
                                    onPlay: T,
                                    onComplete: M,
                                };
                                (d.shouldReduceMotion ||
                                    this.options.layoutRoot) &&
                                    ((C.delay = 0), (C.type = !1)),
                                    this.startAnimation(C);
                            } else
                                g || d1(this),
                                    this.isLead() &&
                                        this.options.onExitComplete &&
                                        this.options.onExitComplete();
                            this.targetLayout = v;
                        }
                    );
        }
        unmount() {
            this.options.layoutId && this.willUpdate(),
                this.root.nodes.remove(this);
            const a = this.getStack();
            a && a.remove(this),
                this.parent && this.parent.children.delete(this),
                (this.instance = void 0),
                this.eventHandlers.clear(),
                Il(this.updateProjection);
        }
        blockUpdate() {
            this.updateManuallyBlocked = !0;
        }
        unblockUpdate() {
            this.updateManuallyBlocked = !1;
        }
        isUpdateBlocked() {
            return this.updateManuallyBlocked || this.updateBlockedByResize;
        }
        isTreeAnimationBlocked() {
            return (
                this.isAnimationBlocked ||
                (this.parent && this.parent.isTreeAnimationBlocked()) ||
                !1
            );
        }
        startUpdate() {
            this.isUpdateBlocked() ||
                ((this.isUpdating = !0),
                this.nodes && this.nodes.forEach(jD),
                this.animationId++);
        }
        getTransformTemplate() {
            const { visualElement: a } = this.options;
            return a && a.getProps().transformTemplate;
        }
        willUpdate(a = !0) {
            if (
                ((this.root.hasTreeAnimated = !0), this.root.isUpdateBlocked())
            ) {
                this.options.onExitComplete && this.options.onExitComplete();
                return;
            }
            if (
                (window.MotionCancelOptimisedAnimation &&
                    !this.hasCheckedOptimisedAppear &&
                    MC(this),
                !this.root.isUpdating && this.root.startUpdate(),
                this.isLayoutDirty)
            )
                return;
            this.isLayoutDirty = !0;
            for (let p = 0; p < this.path.length; p++) {
                const g = this.path[p];
                (g.shouldResetTransform = !0),
                    g.updateScroll('snapshot'),
                    g.options.layoutRoot && g.willUpdate(!1);
            }
            const { layoutId: l, layout: c } = this.options;
            if (l === void 0 && !c) return;
            const d = this.getTransformTemplate();
            (this.prevTransformTemplateValue = d
                ? d(this.latestValues, '')
                : void 0),
                this.updateSnapshot(),
                a && this.notifyListeners('willUpdate');
        }
        update() {
            if (((this.updateScheduled = !1), this.isUpdateBlocked())) {
                this.unblockUpdate(),
                    this.clearAllSnapshots(),
                    this.nodes.forEach(h1);
                return;
            }
            this.isUpdating || this.nodes.forEach(HD),
                (this.isUpdating = !1),
                this.nodes.forEach(GD),
                this.nodes.forEach(kD),
                this.nodes.forEach(FD),
                this.clearAllSnapshots();
            const l = zr.now();
            (Vi.delta = La(0, 1e3 / 60, l - Vi.timestamp)),
                (Vi.timestamp = l),
                (Vi.isProcessing = !0),
                A0.update.process(Vi),
                A0.preRender.process(Vi),
                A0.render.process(Vi),
                (Vi.isProcessing = !1);
        }
        didUpdate() {
            this.updateScheduled ||
                ((this.updateScheduled = !0), aS.read(this.scheduleUpdate));
        }
        clearAllSnapshots() {
            this.nodes.forEach(VD), this.sharedNodes.forEach(qD);
        }
        scheduleUpdateProjection() {
            this.projectionUpdateScheduled ||
                ((this.projectionUpdateScheduled = !0),
                Xn.preRender(this.updateProjection, !1, !0));
        }
        scheduleCheckAfterUnmount() {
            Xn.postRender(() => {
                this.isLayoutDirty
                    ? this.root.didUpdate()
                    : this.root.checkUpdateFailed();
            });
        }
        updateSnapshot() {
            this.snapshot ||
                !this.instance ||
                ((this.snapshot = this.measure()),
                this.snapshot &&
                    !Mr(this.snapshot.measuredBox.x) &&
                    !Mr(this.snapshot.measuredBox.y) &&
                    (this.snapshot = void 0));
        }
        updateLayout() {
            if (
                !this.instance ||
                (this.updateScroll(),
                !(this.options.alwaysMeasureLayout && this.isLead()) &&
                    !this.isLayoutDirty)
            )
                return;
            if (this.resumeFrom && !this.resumeFrom.instance)
                for (let c = 0; c < this.path.length; c++)
                    this.path[c].updateScroll();
            const a = this.layout;
            (this.layout = this.measure(!1)),
                (this.layoutCorrected = ri()),
                (this.isLayoutDirty = !1),
                (this.projectionDelta = void 0),
                this.notifyListeners('measure', this.layout.layoutBox);
            const { visualElement: l } = this.options;
            l &&
                l.notify(
                    'LayoutMeasure',
                    this.layout.layoutBox,
                    a ? a.layoutBox : void 0
                );
        }
        updateScroll(a = 'measure') {
            let l = !!(this.options.layoutScroll && this.instance);
            if (
                (this.scroll &&
                    this.scroll.animationId === this.root.animationId &&
                    this.scroll.phase === a &&
                    (l = !1),
                l && this.instance)
            ) {
                const c = n(this.instance);
                this.scroll = {
                    animationId: this.root.animationId,
                    phase: a,
                    isRoot: c,
                    offset: t(this.instance),
                    wasRoot: this.scroll ? this.scroll.isRoot : c,
                };
            }
        }
        resetTransform() {
            if (!r) return;
            const a =
                    this.isLayoutDirty ||
                    this.shouldResetTransform ||
                    this.options.alwaysMeasureLayout,
                l = this.projectionDelta && !SC(this.projectionDelta),
                c = this.getTransformTemplate(),
                d = c ? c(this.latestValues, '') : void 0,
                p = d !== this.prevTransformTemplateValue;
            a &&
                this.instance &&
                (l || Gu(this.latestValues) || p) &&
                (r(this.instance, d),
                (this.shouldResetTransform = !1),
                this.scheduleRender());
        }
        measure(a = !0) {
            const l = this.measurePageBox();
            let c = this.removeElementScroll(l);
            return (
                a && (c = this.removeTransform(c)),
                ZD(c),
                {
                    animationId: this.root.animationId,
                    measuredBox: l,
                    layoutBox: c,
                    latestValues: {},
                    source: this.id,
                }
            );
        }
        measurePageBox() {
            var d;
            const { visualElement: a } = this.options;
            if (!a) return ri();
            const l = a.measureViewportBox();
            if (
                !(
                    ((d = this.scroll) == null ? void 0 : d.wasRoot) ||
                    this.path.some(JD)
                )
            ) {
                const { scroll: p } = this.root;
                p && (Kf(l.x, p.offset.x), Kf(l.y, p.offset.y));
            }
            return l;
        }
        removeElementScroll(a) {
            var c;
            const l = ri();
            if ((xs(l, a), (c = this.scroll) != null && c.wasRoot)) return l;
            for (let d = 0; d < this.path.length; d++) {
                const p = this.path[d],
                    { scroll: g, options: y } = p;
                p !== this.root &&
                    g &&
                    y.layoutScroll &&
                    (g.wasRoot && xs(l, a),
                    Kf(l.x, g.offset.x),
                    Kf(l.y, g.offset.y));
            }
            return l;
        }
        applyTransform(a, l = !1) {
            const c = ri();
            xs(c, a);
            for (let d = 0; d < this.path.length; d++) {
                const p = this.path[d];
                !l &&
                    p.options.layoutScroll &&
                    p.scroll &&
                    p !== p.root &&
                    Zf(c, { x: -p.scroll.offset.x, y: -p.scroll.offset.y }),
                    Gu(p.latestValues) && Zf(c, p.latestValues);
            }
            return Gu(this.latestValues) && Zf(c, this.latestValues), c;
        }
        removeTransform(a) {
            const l = ri();
            xs(l, a);
            for (let c = 0; c < this.path.length; c++) {
                const d = this.path[c];
                if (!d.instance || !Gu(d.latestValues)) continue;
                r_(d.latestValues) && d.updateSnapshot();
                const p = ri(),
                    g = d.measurePageBox();
                xs(p, g),
                    o1(
                        l,
                        d.latestValues,
                        d.snapshot ? d.snapshot.layoutBox : void 0,
                        p
                    );
            }
            return Gu(this.latestValues) && o1(l, this.latestValues), l;
        }
        setTargetDelta(a) {
            (this.targetDelta = a),
                this.root.scheduleUpdateProjection(),
                (this.isProjectionDirty = !0);
        }
        setOptions(a) {
            this.options = {
                ...this.options,
                ...a,
                crossfade: a.crossfade !== void 0 ? a.crossfade : !0,
            };
        }
        clearMeasurements() {
            (this.scroll = void 0),
                (this.layout = void 0),
                (this.snapshot = void 0),
                (this.prevTransformTemplateValue = void 0),
                (this.targetDelta = void 0),
                (this.target = void 0),
                (this.isLayoutDirty = !1);
        }
        forceRelativeParentToResolveTarget() {
            this.relativeParent &&
                this.relativeParent.resolvedRelativeTargetAt !== Vi.timestamp &&
                this.relativeParent.resolveTargetDelta(!0);
        }
        resolveTargetDelta(a = !1) {
            var y;
            const l = this.getLead();
            this.isProjectionDirty ||
                (this.isProjectionDirty = l.isProjectionDirty),
                this.isTransformDirty ||
                    (this.isTransformDirty = l.isTransformDirty),
                this.isSharedProjectionDirty ||
                    (this.isSharedProjectionDirty = l.isSharedProjectionDirty);
            const c = !!this.resumingFrom || this !== l;
            if (
                !(
                    a ||
                    (c && this.isSharedProjectionDirty) ||
                    this.isProjectionDirty ||
                    ((y = this.parent) != null && y.isProjectionDirty) ||
                    this.attemptToResolveRelativeTarget ||
                    this.root.updateBlockedByResize
                )
            )
                return;
            const { layout: p, layoutId: g } = this.options;
            if (!(!this.layout || !(p || g))) {
                if (
                    ((this.resolvedRelativeTargetAt = Vi.timestamp),
                    !this.targetDelta && !this.relativeTarget)
                ) {
                    const v = this.getClosestProjectingParent();
                    v && v.layout && this.animationProgress !== 1
                        ? ((this.relativeParent = v),
                          this.forceRelativeParentToResolveTarget(),
                          (this.relativeTarget = ri()),
                          (this.relativeTargetOrigin = ri()),
                          Kd(
                              this.relativeTargetOrigin,
                              this.layout.layoutBox,
                              v.layout.layoutBox
                          ),
                          xs(this.relativeTarget, this.relativeTargetOrigin))
                        : (this.relativeParent = this.relativeTarget = void 0);
                }
                if (
                    !(!this.relativeTarget && !this.targetDelta) &&
                    (this.target ||
                        ((this.target = ri()),
                        (this.targetWithTransforms = ri())),
                    this.relativeTarget &&
                    this.relativeTargetOrigin &&
                    this.relativeParent &&
                    this.relativeParent.target
                        ? (this.forceRelativeParentToResolveTarget(),
                          eD(
                              this.target,
                              this.relativeTarget,
                              this.relativeParent.target
                          ))
                        : this.targetDelta
                          ? (this.resumingFrom
                                ? (this.target = this.applyTransform(
                                      this.layout.layoutBox
                                  ))
                                : xs(this.target, this.layout.layoutBox),
                            dC(this.target, this.targetDelta))
                          : xs(this.target, this.layout.layoutBox),
                    this.attemptToResolveRelativeTarget)
                ) {
                    this.attemptToResolveRelativeTarget = !1;
                    const v = this.getClosestProjectingParent();
                    v &&
                    !!v.resumingFrom == !!this.resumingFrom &&
                    !v.options.layoutScroll &&
                    v.target &&
                    this.animationProgress !== 1
                        ? ((this.relativeParent = v),
                          this.forceRelativeParentToResolveTarget(),
                          (this.relativeTarget = ri()),
                          (this.relativeTargetOrigin = ri()),
                          Kd(this.relativeTargetOrigin, this.target, v.target),
                          xs(this.relativeTarget, this.relativeTargetOrigin))
                        : (this.relativeParent = this.relativeTarget = void 0);
                }
            }
        }
        getClosestProjectingParent() {
            if (
                !(
                    !this.parent ||
                    r_(this.parent.latestValues) ||
                    hC(this.parent.latestValues)
                )
            )
                return this.parent.isProjecting()
                    ? this.parent
                    : this.parent.getClosestProjectingParent();
        }
        isProjecting() {
            return !!(
                (this.relativeTarget ||
                    this.targetDelta ||
                    this.options.layoutRoot) &&
                this.layout
            );
        }
        calcProjection() {
            var S;
            const a = this.getLead(),
                l = !!this.resumingFrom || this !== a;
            let c = !0;
            if (
                ((this.isProjectionDirty ||
                    ((S = this.parent) != null && S.isProjectionDirty)) &&
                    (c = !1),
                l &&
                    (this.isSharedProjectionDirty || this.isTransformDirty) &&
                    (c = !1),
                this.resolvedRelativeTargetAt === Vi.timestamp && (c = !1),
                c)
            )
                return;
            const { layout: d, layoutId: p } = this.options;
            if (
                ((this.isTreeAnimating = !!(
                    (this.parent && this.parent.isTreeAnimating) ||
                    this.currentAnimation ||
                    this.pendingAnimation
                )),
                this.isTreeAnimating ||
                    (this.targetDelta = this.relativeTarget = void 0),
                !this.layout || !(d || p))
            )
                return;
            xs(this.layoutCorrected, this.layout.layoutBox);
            const g = this.treeScale.x,
                y = this.treeScale.y;
            tD(this.layoutCorrected, this.treeScale, this.path, l),
                a.layout &&
                    !a.target &&
                    (this.treeScale.x !== 1 || this.treeScale.y !== 1) &&
                    ((a.target = a.layout.layoutBox),
                    (a.targetWithTransforms = ri()));
            const { target: v } = a;
            if (!v) {
                this.prevProjectionDelta &&
                    (this.createProjectionDeltas(), this.scheduleRender());
                return;
            }
            !this.projectionDelta || !this.prevProjectionDelta
                ? this.createProjectionDeltas()
                : (i1(this.prevProjectionDelta.x, this.projectionDelta.x),
                  i1(this.prevProjectionDelta.y, this.projectionDelta.y)),
                Yd(
                    this.projectionDelta,
                    this.layoutCorrected,
                    v,
                    this.latestValues
                ),
                (this.treeScale.x !== g ||
                    this.treeScale.y !== y ||
                    !f1(this.projectionDelta.x, this.prevProjectionDelta.x) ||
                    !f1(this.projectionDelta.y, this.prevProjectionDelta.y)) &&
                    ((this.hasProjected = !0),
                    this.scheduleRender(),
                    this.notifyListeners('projectionUpdate', v));
        }
        hide() {
            this.isVisible = !1;
        }
        show() {
            this.isVisible = !0;
        }
        scheduleRender(a = !0) {
            var l;
            if (
                ((l = this.options.visualElement) == null || l.scheduleRender(),
                a)
            ) {
                const c = this.getStack();
                c && c.scheduleRender();
            }
            this.resumingFrom &&
                !this.resumingFrom.instance &&
                (this.resumingFrom = void 0);
        }
        createProjectionDeltas() {
            (this.prevProjectionDelta = Yf()),
                (this.projectionDelta = Yf()),
                (this.projectionDeltaWithTransform = Yf());
        }
        setAnimationOrigin(a, l = !1) {
            const c = this.snapshot,
                d = c ? c.latestValues : {},
                p = { ...this.latestValues },
                g = Yf();
            (!this.relativeParent || !this.relativeParent.options.layoutRoot) &&
                (this.relativeTarget = this.relativeTargetOrigin = void 0),
                (this.attemptToResolveRelativeTarget = !l);
            const y = ri(),
                v = c ? c.source : void 0,
                S = this.layout ? this.layout.source : void 0,
                T = v !== S,
                M = this.getStack(),
                w = !M || M.members.length <= 1,
                b = !!(
                    T &&
                    !w &&
                    this.options.crossfade === !0 &&
                    !this.path.some(YD)
                );
            this.animationProgress = 0;
            let C;
            (this.mixTargetDelta = (L) => {
                const F = L / 1e3;
                p1(g.x, a.x, F),
                    p1(g.y, a.y, F),
                    this.setTargetDelta(g),
                    this.relativeTarget &&
                        this.relativeTargetOrigin &&
                        this.layout &&
                        this.relativeParent &&
                        this.relativeParent.layout &&
                        (Kd(
                            y,
                            this.layout.layoutBox,
                            this.relativeParent.layout.layoutBox
                        ),
                        $D(
                            this.relativeTarget,
                            this.relativeTargetOrigin,
                            y,
                            F
                        ),
                        C &&
                            LD(this.relativeTarget, C) &&
                            (this.isProjectionDirty = !1),
                        C || (C = ri()),
                        xs(C, this.relativeTarget)),
                    T &&
                        ((this.animationValues = p),
                        TD(p, d, this.latestValues, F, b, w)),
                    this.root.scheduleUpdateProjection(),
                    this.scheduleRender(),
                    (this.animationProgress = F);
            }),
                this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
        }
        startAnimation(a) {
            var l, c, d;
            this.notifyListeners('animationStart'),
                (l = this.currentAnimation) == null || l.stop(!1),
                (d =
                    (c = this.resumingFrom) == null
                        ? void 0
                        : c.currentAnimation) == null || d.stop(!1),
                this.pendingAnimation &&
                    (Il(this.pendingAnimation),
                    (this.pendingAnimation = void 0)),
                (this.pendingAnimation = Xn.update(() => {
                    (iy.hasAnimatedSinceResize = !0),
                        this.motionValue || (this.motionValue = lh(0)),
                        (this.currentAnimation = _D(
                            this.motionValue,
                            [0, 1e3],
                            {
                                ...a,
                                isSync: !0,
                                onUpdate: (p) => {
                                    this.mixTargetDelta(p),
                                        a.onUpdate && a.onUpdate(p);
                                },
                                onStop: () => {},
                                onComplete: () => {
                                    a.onComplete && a.onComplete(),
                                        this.completeAnimation();
                                },
                            }
                        )),
                        this.resumingFrom &&
                            (this.resumingFrom.currentAnimation =
                                this.currentAnimation),
                        (this.pendingAnimation = void 0);
                }));
        }
        completeAnimation() {
            this.resumingFrom &&
                ((this.resumingFrom.currentAnimation = void 0),
                (this.resumingFrom.preserveOpacity = void 0));
            const a = this.getStack();
            a && a.exitAnimationComplete(),
                (this.resumingFrom =
                    this.currentAnimation =
                    this.animationValues =
                        void 0),
                this.notifyListeners('animationComplete');
        }
        finishAnimation() {
            this.currentAnimation &&
                (this.mixTargetDelta && this.mixTargetDelta(UD),
                this.currentAnimation.stop(!1)),
                this.completeAnimation();
        }
        applyTransformsToTarget() {
            const a = this.getLead();
            let {
                targetWithTransforms: l,
                target: c,
                layout: d,
                latestValues: p,
            } = a;
            if (!(!l || !c || !d)) {
                if (
                    this !== a &&
                    this.layout &&
                    d &&
                    TC(
                        this.options.animationType,
                        this.layout.layoutBox,
                        d.layoutBox
                    )
                ) {
                    c = this.target || ri();
                    const g = Mr(this.layout.layoutBox.x);
                    (c.x.min = a.target.x.min), (c.x.max = c.x.min + g);
                    const y = Mr(this.layout.layoutBox.y);
                    (c.y.min = a.target.y.min), (c.y.max = c.y.min + y);
                }
                xs(l, c),
                    Zf(l, p),
                    Yd(
                        this.projectionDeltaWithTransform,
                        this.layoutCorrected,
                        l,
                        p
                    );
            }
        }
        registerSharedNode(a, l) {
            this.sharedNodes.has(a) || this.sharedNodes.set(a, new ID()),
                this.sharedNodes.get(a).add(l);
            const d = l.options.initialPromotionConfig;
            l.promote({
                transition: d ? d.transition : void 0,
                preserveFollowOpacity:
                    d && d.shouldPreserveFollowOpacity
                        ? d.shouldPreserveFollowOpacity(l)
                        : void 0,
            });
        }
        isLead() {
            const a = this.getStack();
            return a ? a.lead === this : !0;
        }
        getLead() {
            var l;
            const { layoutId: a } = this.options;
            return a
                ? ((l = this.getStack()) == null ? void 0 : l.lead) || this
                : this;
        }
        getPrevLead() {
            var l;
            const { layoutId: a } = this.options;
            return a
                ? (l = this.getStack()) == null
                    ? void 0
                    : l.prevLead
                : void 0;
        }
        getStack() {
            const { layoutId: a } = this.options;
            if (a) return this.root.sharedNodes.get(a);
        }
        promote({
            needsReset: a,
            transition: l,
            preserveFollowOpacity: c,
        } = {}) {
            const d = this.getStack();
            d && d.promote(this, c),
                a && ((this.projectionDelta = void 0), (this.needsReset = !0)),
                l && this.setOptions({ transition: l });
        }
        relegate() {
            const a = this.getStack();
            return a ? a.relegate(this) : !1;
        }
        resetSkewAndRotation() {
            const { visualElement: a } = this.options;
            if (!a) return;
            let l = !1;
            const { latestValues: c } = a;
            if (
                ((c.z ||
                    c.rotate ||
                    c.rotateX ||
                    c.rotateY ||
                    c.rotateZ ||
                    c.skewX ||
                    c.skewY) &&
                    (l = !0),
                !l)
            )
                return;
            const d = {};
            c.z && U0('z', a, d, this.animationValues);
            for (let p = 0; p < N0.length; p++)
                U0(`rotate${N0[p]}`, a, d, this.animationValues),
                    U0(`skew${N0[p]}`, a, d, this.animationValues);
            a.render();
            for (const p in d)
                a.setStaticValue(p, d[p]),
                    this.animationValues && (this.animationValues[p] = d[p]);
            a.scheduleRender();
        }
        getProjectionStyles(a) {
            if (!this.instance || this.isSVG) return;
            if (!this.isVisible) return ND;
            const l = { visibility: '' },
                c = this.getTransformTemplate();
            if (this.needsReset)
                return (
                    (this.needsReset = !1),
                    (l.opacity = ''),
                    (l.pointerEvents =
                        ny(a == null ? void 0 : a.pointerEvents) || ''),
                    (l.transform = c ? c(this.latestValues, '') : 'none'),
                    l
                );
            const d = this.getLead();
            if (!this.projectionDelta || !this.layout || !d.target) {
                const v = {};
                return (
                    this.options.layoutId &&
                        ((v.opacity =
                            this.latestValues.opacity !== void 0
                                ? this.latestValues.opacity
                                : 1),
                        (v.pointerEvents =
                            ny(a == null ? void 0 : a.pointerEvents) || '')),
                    this.hasProjected &&
                        !Gu(this.latestValues) &&
                        ((v.transform = c ? c({}, '') : 'none'),
                        (this.hasProjected = !1)),
                    v
                );
            }
            const p = d.animationValues || d.latestValues;
            this.applyTransformsToTarget(),
                (l.transform = DD(
                    this.projectionDeltaWithTransform,
                    this.treeScale,
                    p
                )),
                c && (l.transform = c(p, l.transform));
            const { x: g, y } = this.projectionDelta;
            (l.transformOrigin = `${g.origin * 100}% ${y.origin * 100}% 0`),
                d.animationValues
                    ? (l.opacity =
                          d === this
                              ? (p.opacity ?? this.latestValues.opacity ?? 1)
                              : this.preserveOpacity
                                ? this.latestValues.opacity
                                : p.opacityExit)
                    : (l.opacity =
                          d === this
                              ? p.opacity !== void 0
                                  ? p.opacity
                                  : ''
                              : p.opacityExit !== void 0
                                ? p.opacityExit
                                : 0);
            for (const v in dp) {
                if (p[v] === void 0) continue;
                const { correct: S, applyTo: T, isCSSVariable: M } = dp[v],
                    w = l.transform === 'none' ? p[v] : S(p[v], d);
                if (T) {
                    const b = T.length;
                    for (let C = 0; C < b; C++) l[T[C]] = w;
                } else
                    M
                        ? (this.options.visualElement.renderState.vars[v] = w)
                        : (l[v] = w);
            }
            return (
                this.options.layoutId &&
                    (l.pointerEvents =
                        d === this
                            ? ny(a == null ? void 0 : a.pointerEvents) || ''
                            : 'none'),
                l
            );
        }
        clearSnapshot() {
            this.resumeFrom = this.snapshot = void 0;
        }
        resetTree() {
            this.root.nodes.forEach((a) => {
                var l;
                return (l = a.currentAnimation) == null ? void 0 : l.stop(!1);
            }),
                this.root.nodes.forEach(h1),
                this.root.sharedNodes.clear();
        }
    };
}
function kD(i) {
    i.updateLayout();
}
function FD(i) {
    var t;
    const e = ((t = i.resumeFrom) == null ? void 0 : t.snapshot) || i.snapshot;
    if (i.isLead() && i.layout && e && i.hasListeners('didUpdate')) {
        const { layoutBox: n, measuredBox: r } = i.layout,
            { animationType: s } = i.options,
            a = e.source !== i.layout.source;
        s === 'size'
            ? Ss((g) => {
                  const y = a ? e.measuredBox[g] : e.layoutBox[g],
                      v = Mr(y);
                  (y.min = n[g].min), (y.max = y.min + v);
              })
            : TC(s, e.layoutBox, n) &&
              Ss((g) => {
                  const y = a ? e.measuredBox[g] : e.layoutBox[g],
                      v = Mr(n[g]);
                  (y.max = y.min + v),
                      i.relativeTarget &&
                          !i.currentAnimation &&
                          ((i.isProjectionDirty = !0),
                          (i.relativeTarget[g].max =
                              i.relativeTarget[g].min + v));
              });
        const l = Yf();
        Yd(l, n, e.layoutBox);
        const c = Yf();
        a
            ? Yd(c, i.applyTransform(r, !0), e.measuredBox)
            : Yd(c, n, e.layoutBox);
        const d = !SC(l);
        let p = !1;
        if (!i.resumeFrom) {
            const g = i.getClosestProjectingParent();
            if (g && !g.resumeFrom) {
                const { snapshot: y, layout: v } = g;
                if (y && v) {
                    const S = ri();
                    Kd(S, e.layoutBox, y.layoutBox);
                    const T = ri();
                    Kd(T, n, v.layoutBox),
                        wC(S, T) || (p = !0),
                        g.options.layoutRoot &&
                            ((i.relativeTarget = T),
                            (i.relativeTargetOrigin = S),
                            (i.relativeParent = g));
                }
            }
        }
        i.notifyListeners('didUpdate', {
            layout: n,
            snapshot: e,
            delta: c,
            layoutDelta: l,
            hasLayoutChanged: d,
            hasRelativeLayoutChanged: p,
        });
    } else if (i.isLead()) {
        const { onExitComplete: n } = i.options;
        n && n();
    }
    i.options.transition = void 0;
}
function BD(i) {
    i.parent &&
        (i.isProjecting() || (i.isProjectionDirty = i.parent.isProjectionDirty),
        i.isSharedProjectionDirty ||
            (i.isSharedProjectionDirty = !!(
                i.isProjectionDirty ||
                i.parent.isProjectionDirty ||
                i.parent.isSharedProjectionDirty
            )),
        i.isTransformDirty || (i.isTransformDirty = i.parent.isTransformDirty));
}
function zD(i) {
    i.isProjectionDirty = i.isSharedProjectionDirty = i.isTransformDirty = !1;
}
function VD(i) {
    i.clearSnapshot();
}
function h1(i) {
    i.clearMeasurements();
}
function HD(i) {
    i.isLayoutDirty = !1;
}
function GD(i) {
    const { visualElement: e } = i.options;
    e && e.getProps().onBeforeLayoutMeasure && e.notify('BeforeLayoutMeasure'),
        i.resetTransform();
}
function d1(i) {
    i.finishAnimation(),
        (i.targetDelta = i.relativeTarget = i.target = void 0),
        (i.isProjectionDirty = !0);
}
function WD(i) {
    i.resolveTargetDelta();
}
function XD(i) {
    i.calcProjection();
}
function jD(i) {
    i.resetSkewAndRotation();
}
function qD(i) {
    i.removeLeadSnapshot();
}
function p1(i, e, t) {
    (i.translate = Gn(e.translate, 0, t)),
        (i.scale = Gn(e.scale, 1, t)),
        (i.origin = e.origin),
        (i.originPoint = e.originPoint);
}
function m1(i, e, t, n) {
    (i.min = Gn(e.min, t.min, n)), (i.max = Gn(e.max, t.max, n));
}
function $D(i, e, t, n) {
    m1(i.x, e.x, t.x, n), m1(i.y, e.y, t.y, n);
}
function YD(i) {
    return i.animationValues && i.animationValues.opacityExit !== void 0;
}
const KD = { duration: 0.45, ease: [0.4, 0, 0.1, 1] },
    g1 = (i) =>
        typeof navigator < 'u' &&
        navigator.userAgent &&
        navigator.userAgent.toLowerCase().includes(i),
    y1 = g1('applewebkit/') && !g1('chrome/') ? Math.round : Es;
function v1(i) {
    (i.min = y1(i.min)), (i.max = y1(i.max));
}
function ZD(i) {
    v1(i.x), v1(i.y);
}
function TC(i, e, t) {
    return (
        i === 'position' || (i === 'preserve-aspect' && !Q3(c1(e), c1(t), 0.2))
    );
}
function JD(i) {
    var e;
    return i !== i.root && ((e = i.scroll) == null ? void 0 : e.wasRoot);
}
const QD = EC({
        attachResizeListener: (i, e) => mp(i, 'resize', e),
        measureScroll: () => ({
            x: document.documentElement.scrollLeft || document.body.scrollLeft,
            y: document.documentElement.scrollTop || document.body.scrollTop,
        }),
        checkIsScrollRoot: () => !0,
    }),
    O0 = { current: void 0 },
    AC = EC({
        measureScroll: (i) => ({ x: i.scrollLeft, y: i.scrollTop }),
        defaultParent: () => {
            if (!O0.current) {
                const i = new QD({});
                i.mount(window),
                    i.setOptions({ layoutScroll: !0 }),
                    (O0.current = i);
            }
            return O0.current;
        },
        resetTransform: (i, e) => {
            i.style.transform = e !== void 0 ? e : 'none';
        },
        checkIsScrollRoot: (i) =>
            window.getComputedStyle(i).position === 'fixed',
    }),
    eN = {
        pan: { Feature: gD },
        drag: { Feature: mD, ProjectionNode: AC, MeasureLayout: vC },
    };
function x1(i, e, t) {
    const { props: n } = i;
    i.animationState &&
        n.whileHover &&
        i.animationState.setActive('whileHover', t === 'Start');
    const r = 'onHover' + t,
        s = n[r];
    s && Xn.postRender(() => s(e, Wp(e)));
}
class tN extends kl {
    mount() {
        const { current: e } = this.node;
        e &&
            (this.unmount = RI(
                e,
                (t, n) => (
                    x1(this.node, n, 'Start'), (r) => x1(this.node, r, 'End')
                )
            ));
    }
    unmount() {}
}
class nN extends kl {
    constructor() {
        super(...arguments), (this.isActive = !1);
    }
    onFocus() {
        let e = !1;
        try {
            e = this.node.current.matches(':focus-visible');
        } catch {
            e = !0;
        }
        !e ||
            !this.node.animationState ||
            (this.node.animationState.setActive('whileFocus', !0),
            (this.isActive = !0));
    }
    onBlur() {
        !this.isActive ||
            !this.node.animationState ||
            (this.node.animationState.setActive('whileFocus', !1),
            (this.isActive = !1));
    }
    mount() {
        this.unmount = Vp(
            mp(this.node.current, 'focus', () => this.onFocus()),
            mp(this.node.current, 'blur', () => this.onBlur())
        );
    }
    unmount() {}
}
function _1(i, e, t) {
    const { props: n } = i;
    if (i.current instanceof HTMLButtonElement && i.current.disabled) return;
    i.animationState &&
        n.whileTap &&
        i.animationState.setActive('whileTap', t === 'Start');
    const r = 'onTap' + (t === 'End' ? '' : t),
        s = n[r];
    s && Xn.postRender(() => s(e, Wp(e)));
}
class iN extends kl {
    mount() {
        const { current: e } = this.node;
        e &&
            (this.unmount = II(
                e,
                (t, n) => (
                    _1(this.node, n, 'Start'),
                    (r, { success: s }) =>
                        _1(this.node, r, s ? 'End' : 'Cancel')
                ),
                { useGlobalTarget: this.node.props.globalTapTarget }
            ));
    }
    unmount() {}
}
const a_ = new WeakMap(),
    k0 = new WeakMap(),
    rN = (i) => {
        const e = a_.get(i.target);
        e && e(i);
    },
    sN = (i) => {
        i.forEach(rN);
    };
function oN({ root: i, ...e }) {
    const t = i || document;
    k0.has(t) || k0.set(t, {});
    const n = k0.get(t),
        r = JSON.stringify(e);
    return (
        n[r] || (n[r] = new IntersectionObserver(sN, { root: i, ...e })), n[r]
    );
}
function aN(i, e, t) {
    const n = oN(e);
    return (
        a_.set(i, t),
        n.observe(i),
        () => {
            a_.delete(i), n.unobserve(i);
        }
    );
}
const lN = { some: 0, all: 1 };
class uN extends kl {
    constructor() {
        super(...arguments), (this.hasEnteredView = !1), (this.isInView = !1);
    }
    startObserver() {
        this.unmount();
        const { viewport: e = {} } = this.node.getProps(),
            { root: t, margin: n, amount: r = 'some', once: s } = e,
            a = {
                root: t ? t.current : void 0,
                rootMargin: n,
                threshold: typeof r == 'number' ? r : lN[r],
            },
            l = (c) => {
                const { isIntersecting: d } = c;
                if (
                    this.isInView === d ||
                    ((this.isInView = d), s && !d && this.hasEnteredView)
                )
                    return;
                d && (this.hasEnteredView = !0),
                    this.node.animationState &&
                        this.node.animationState.setActive('whileInView', d);
                const { onViewportEnter: p, onViewportLeave: g } =
                        this.node.getProps(),
                    y = d ? p : g;
                y && y(c);
            };
        return aN(this.node.current, a, l);
    }
    mount() {
        this.startObserver();
    }
    update() {
        if (typeof IntersectionObserver > 'u') return;
        const { props: e, prevProps: t } = this.node;
        ['amount', 'margin', 'root'].some(cN(e, t)) && this.startObserver();
    }
    unmount() {}
}
function cN({ viewport: i = {} }, { viewport: e = {} } = {}) {
    return (t) => i[t] !== e[t];
}
const fN = {
        inView: { Feature: uN },
        tap: { Feature: iN },
        focus: { Feature: nN },
        hover: { Feature: tN },
    },
    hN = { layout: { ProjectionNode: AC, MeasureLayout: vC } },
    l_ = { current: null },
    CC = { current: !1 };
function dN() {
    if (((CC.current = !0), !!z_))
        if (window.matchMedia) {
            const i = window.matchMedia('(prefers-reduced-motion)'),
                e = () => (l_.current = i.matches);
            i.addListener(e), e();
        } else l_.current = !1;
}
const pN = new WeakMap();
function mN(i, e, t) {
    for (const n in e) {
        const r = e[n],
            s = t[n];
        if (rr(r)) i.addValue(n, r);
        else if (rr(s)) i.addValue(n, lh(r, { owner: i }));
        else if (s !== r)
            if (i.hasValue(n)) {
                const a = i.getValue(n);
                a.liveStyle === !0 ? a.jump(r) : a.hasAnimated || a.set(r);
            } else {
                const a = i.getStaticValue(n);
                i.addValue(n, lh(a !== void 0 ? a : r, { owner: i }));
            }
    }
    for (const n in t) e[n] === void 0 && i.removeValue(n);
    return e;
}
const S1 = [
    'AnimationStart',
    'AnimationComplete',
    'Update',
    'BeforeLayoutMeasure',
    'LayoutMeasure',
    'LayoutAnimationStart',
    'LayoutAnimationComplete',
];
class gN {
    scrapeMotionValuesFromProps(e, t, n) {
        return {};
    }
    constructor(
        {
            parent: e,
            props: t,
            presenceContext: n,
            reducedMotionConfig: r,
            blockInitialAnimation: s,
            visualState: a,
        },
        l = {}
    ) {
        (this.current = null),
            (this.children = new Set()),
            (this.isVariantNode = !1),
            (this.isControllingVariants = !1),
            (this.shouldReduceMotion = null),
            (this.values = new Map()),
            (this.KeyframeResolver = iS),
            (this.features = {}),
            (this.valueSubscriptions = new Map()),
            (this.prevMotionValues = {}),
            (this.events = {}),
            (this.propEventSubscriptions = {}),
            (this.notifyUpdate = () =>
                this.notify('Update', this.latestValues)),
            (this.render = () => {
                this.current &&
                    (this.triggerBuild(),
                    this.renderInstance(
                        this.current,
                        this.renderState,
                        this.props.style,
                        this.projection
                    ));
            }),
            (this.renderScheduledAt = 0),
            (this.scheduleRender = () => {
                const y = zr.now();
                this.renderScheduledAt < y &&
                    ((this.renderScheduledAt = y),
                    Xn.render(this.render, !1, !0));
            });
        const { latestValues: c, renderState: d } = a;
        (this.latestValues = c),
            (this.baseTarget = { ...c }),
            (this.initialValues = t.initial ? { ...c } : {}),
            (this.renderState = d),
            (this.parent = e),
            (this.props = t),
            (this.presenceContext = n),
            (this.depth = e ? e.depth + 1 : 0),
            (this.reducedMotionConfig = r),
            (this.options = l),
            (this.blockInitialAnimation = !!s),
            (this.isControllingVariants = iv(t)),
            (this.isVariantNode = $A(t)),
            this.isVariantNode && (this.variantChildren = new Set()),
            (this.manuallyAnimateOnMount = !!(e && e.current));
        const { willChange: p, ...g } = this.scrapeMotionValuesFromProps(
            t,
            {},
            this
        );
        for (const y in g) {
            const v = g[y];
            c[y] !== void 0 && rr(v) && v.set(c[y], !1);
        }
    }
    mount(e) {
        (this.current = e),
            pN.set(e, this),
            this.projection &&
                !this.projection.instance &&
                this.projection.mount(e),
            this.parent &&
                this.isVariantNode &&
                !this.isControllingVariants &&
                (this.removeFromVariantTree =
                    this.parent.addVariantChild(this)),
            this.values.forEach((t, n) => this.bindToMotionValue(n, t)),
            CC.current || dN(),
            (this.shouldReduceMotion =
                this.reducedMotionConfig === 'never'
                    ? !1
                    : this.reducedMotionConfig === 'always'
                      ? !0
                      : l_.current),
            this.parent && this.parent.children.add(this),
            this.update(this.props, this.presenceContext);
    }
    unmount() {
        this.projection && this.projection.unmount(),
            Il(this.notifyUpdate),
            Il(this.render),
            this.valueSubscriptions.forEach((e) => e()),
            this.valueSubscriptions.clear(),
            this.removeFromVariantTree && this.removeFromVariantTree(),
            this.parent && this.parent.children.delete(this);
        for (const e in this.events) this.events[e].clear();
        for (const e in this.features) {
            const t = this.features[e];
            t && (t.unmount(), (t.isMounted = !1));
        }
        this.current = null;
    }
    bindToMotionValue(e, t) {
        this.valueSubscriptions.has(e) && this.valueSubscriptions.get(e)();
        const n = vh.has(e);
        n && this.onBindTransform && this.onBindTransform();
        const r = t.on('change', (l) => {
                (this.latestValues[e] = l),
                    this.props.onUpdate && Xn.preRender(this.notifyUpdate),
                    n &&
                        this.projection &&
                        (this.projection.isTransformDirty = !0);
            }),
            s = t.on('renderRequest', this.scheduleRender);
        let a;
        window.MotionCheckAppearSync &&
            (a = window.MotionCheckAppearSync(this, e, t)),
            this.valueSubscriptions.set(e, () => {
                r(), s(), a && a(), t.owner && t.stop();
            });
    }
    sortNodePosition(e) {
        return !this.current ||
            !this.sortInstanceNodePosition ||
            this.type !== e.type
            ? 0
            : this.sortInstanceNodePosition(this.current, e.current);
    }
    updateFeatures() {
        let e = 'animation';
        for (e in uh) {
            const t = uh[e];
            if (!t) continue;
            const { isEnabled: n, Feature: r } = t;
            if (
                (!this.features[e] &&
                    r &&
                    n(this.props) &&
                    (this.features[e] = new r(this)),
                this.features[e])
            ) {
                const s = this.features[e];
                s.isMounted ? s.update() : (s.mount(), (s.isMounted = !0));
            }
        }
    }
    triggerBuild() {
        this.build(this.renderState, this.latestValues, this.props);
    }
    measureViewportBox() {
        return this.current
            ? this.measureInstanceViewportBox(this.current, this.props)
            : ri();
    }
    getStaticValue(e) {
        return this.latestValues[e];
    }
    setStaticValue(e, t) {
        this.latestValues[e] = t;
    }
    update(e, t) {
        (e.transformTemplate || this.props.transformTemplate) &&
            this.scheduleRender(),
            (this.prevProps = this.props),
            (this.props = e),
            (this.prevPresenceContext = this.presenceContext),
            (this.presenceContext = t);
        for (let n = 0; n < S1.length; n++) {
            const r = S1[n];
            this.propEventSubscriptions[r] &&
                (this.propEventSubscriptions[r](),
                delete this.propEventSubscriptions[r]);
            const s = 'on' + r,
                a = e[s];
            a && (this.propEventSubscriptions[r] = this.on(r, a));
        }
        (this.prevMotionValues = mN(
            this,
            this.scrapeMotionValuesFromProps(e, this.prevProps, this),
            this.prevMotionValues
        )),
            this.handleChildMotionValue && this.handleChildMotionValue();
    }
    getProps() {
        return this.props;
    }
    getVariant(e) {
        return this.props.variants ? this.props.variants[e] : void 0;
    }
    getDefaultTransition() {
        return this.props.transition;
    }
    getTransformPagePoint() {
        return this.props.transformPagePoint;
    }
    getClosestVariantNode() {
        return this.isVariantNode
            ? this
            : this.parent
              ? this.parent.getClosestVariantNode()
              : void 0;
    }
    addVariantChild(e) {
        const t = this.getClosestVariantNode();
        if (t)
            return (
                t.variantChildren && t.variantChildren.add(e),
                () => t.variantChildren.delete(e)
            );
    }
    addValue(e, t) {
        const n = this.values.get(e);
        t !== n &&
            (n && this.removeValue(e),
            this.bindToMotionValue(e, t),
            this.values.set(e, t),
            (this.latestValues[e] = t.get()));
    }
    removeValue(e) {
        this.values.delete(e);
        const t = this.valueSubscriptions.get(e);
        t && (t(), this.valueSubscriptions.delete(e)),
            delete this.latestValues[e],
            this.removeValueFromRenderState(e, this.renderState);
    }
    hasValue(e) {
        return this.values.has(e);
    }
    getValue(e, t) {
        if (this.props.values && this.props.values[e])
            return this.props.values[e];
        let n = this.values.get(e);
        return (
            n === void 0 &&
                t !== void 0 &&
                ((n = lh(t === null ? void 0 : t, { owner: this })),
                this.addValue(e, n)),
            n
        );
    }
    readValue(e, t) {
        let n =
            this.latestValues[e] !== void 0 || !this.current
                ? this.latestValues[e]
                : (this.getBaseTargetFromProps(this.props, e) ??
                  this.readValueFromInstance(this.current, e, this.options));
        return (
            n != null &&
                (typeof n == 'string' && (tA(n) || iA(n))
                    ? (n = parseFloat(n))
                    : !UI(n) && Dl.test(t) && (n = FA(e, t)),
                this.setBaseTarget(e, rr(n) ? n.get() : n)),
            rr(n) ? n.get() : n
        );
    }
    setBaseTarget(e, t) {
        this.baseTarget[e] = t;
    }
    getBaseTarget(e) {
        var s;
        const { initial: t } = this.props;
        let n;
        if (typeof t == 'string' || typeof t == 'object') {
            const a = gS(
                this.props,
                t,
                (s = this.presenceContext) == null ? void 0 : s.custom
            );
            a && (n = a[e]);
        }
        if (t && n !== void 0) return n;
        const r = this.getBaseTargetFromProps(this.props, e);
        return r !== void 0 && !rr(r)
            ? r
            : this.initialValues[e] !== void 0 && n === void 0
              ? void 0
              : this.baseTarget[e];
    }
    on(e, t) {
        return (
            this.events[e] || (this.events[e] = new X_()), this.events[e].add(t)
        );
    }
    notify(e, ...t) {
        this.events[e] && this.events[e].notify(...t);
    }
}
class RC extends gN {
    constructor() {
        super(...arguments), (this.KeyframeResolver = MI);
    }
    sortInstanceNodePosition(e, t) {
        return e.compareDocumentPosition(t) & 2 ? 1 : -1;
    }
    getBaseTargetFromProps(e, t) {
        return e.style ? e.style[t] : void 0;
    }
    removeValueFromRenderState(e, { vars: t, style: n }) {
        delete t[e], delete n[e];
    }
    handleChildMotionValue() {
        this.childSubscription &&
            (this.childSubscription(), delete this.childSubscription);
        const { children: e } = this.props;
        rr(e) &&
            (this.childSubscription = e.on('change', (t) => {
                this.current && (this.current.textContent = `${t}`);
            }));
    }
}
function bC(i, { style: e, vars: t }, n, r) {
    Object.assign(i.style, e, r && r.getProjectionStyles(n));
    for (const s in t) i.style.setProperty(s, t[s]);
}
function yN(i) {
    return window.getComputedStyle(i);
}
class vN extends RC {
    constructor() {
        super(...arguments), (this.type = 'html'), (this.renderInstance = bC);
    }
    readValueFromInstance(e, t) {
        var n;
        if (vh.has(t))
            return (n = this.projection) != null && n.isProjecting
                ? Yx(t)
                : H2(e, t);
        {
            const r = yN(e),
                s = ($_(t) ? r.getPropertyValue(t) : r[t]) || 0;
            return typeof s == 'string' ? s.trim() : s;
        }
    }
    measureInstanceViewportBox(e, { transformPagePoint: t }) {
        return pC(e, t);
    }
    build(e, t, n) {
        dS(e, t, n.transformTemplate);
    }
    scrapeMotionValuesFromProps(e, t, n) {
        return yS(e, t, n);
    }
}
const PC = new Set([
    'baseFrequency',
    'diffuseConstant',
    'kernelMatrix',
    'kernelUnitLength',
    'keySplines',
    'keyTimes',
    'limitingConeAngle',
    'markerHeight',
    'markerWidth',
    'numOctaves',
    'targetX',
    'targetY',
    'surfaceScale',
    'specularConstant',
    'specularExponent',
    'stdDeviation',
    'tableValues',
    'viewBox',
    'gradientTransform',
    'pathLength',
    'startOffset',
    'textLength',
    'lengthAdjust',
]);
function xN(i, e, t, n) {
    bC(i, e, void 0, n);
    for (const r in e.attrs) i.setAttribute(PC.has(r) ? r : hS(r), e.attrs[r]);
}
class _N extends RC {
    constructor() {
        super(...arguments),
            (this.type = 'svg'),
            (this.isSVGTag = !1),
            (this.measureInstanceViewportBox = ri);
    }
    getBaseTargetFromProps(e, t) {
        return e[t];
    }
    readValueFromInstance(e, t) {
        if (vh.has(t)) {
            const n = kA(t);
            return (n && n.default) || 0;
        }
        return (t = PC.has(t) ? t : hS(t)), e.getAttribute(t);
    }
    scrapeMotionValuesFromProps(e, t, n) {
        return rC(e, t, n);
    }
    build(e, t, n) {
        eC(e, t, this.isSVGTag, n.transformTemplate, n.style);
    }
    renderInstance(e, t, n, r) {
        xN(e, t, n, r);
    }
    mount(e) {
        (this.isSVGTag = nC(e.tagName)), super.mount(e);
    }
}
const SN = (i, e) =>
        mS(i) ? new _N(e) : new vN(e, { allowProjection: i !== K.Fragment }),
    wN = x3({ ...X3, ...fN, ...eN, ...hN }, SN),
    MN = WI(wN);
var Td = {},
    w1;
function EN() {
    if (w1) return Td;
    (w1 = 1),
        Object.defineProperty(Td, '__esModule', { value: !0 }),
        (Td.parse = a),
        (Td.serialize = d);
    const i = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/,
        e = /^[\u0021-\u003A\u003C-\u007E]*$/,
        t =
            /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i,
        n = /^[\u0020-\u003A\u003D-\u007E]*$/,
        r = Object.prototype.toString,
        s = (() => {
            const y = function () {};
            return (y.prototype = Object.create(null)), y;
        })();
    function a(y, v) {
        const S = new s(),
            T = y.length;
        if (T < 2) return S;
        const M = (v == null ? void 0 : v.decode) || p;
        let w = 0;
        do {
            const b = y.indexOf('=', w);
            if (b === -1) break;
            const C = y.indexOf(';', w),
                L = C === -1 ? T : C;
            if (b > L) {
                w = y.lastIndexOf(';', b - 1) + 1;
                continue;
            }
            const F = l(y, w, b),
                N = c(y, b, F),
                B = y.slice(F, N);
            if (S[B] === void 0) {
                let z = l(y, b + 1, L),
                    U = c(y, L, z);
                const D = M(y.slice(z, U));
                S[B] = D;
            }
            w = L + 1;
        } while (w < T);
        return S;
    }
    function l(y, v, S) {
        do {
            const T = y.charCodeAt(v);
            if (T !== 32 && T !== 9) return v;
        } while (++v < S);
        return S;
    }
    function c(y, v, S) {
        for (; v > S; ) {
            const T = y.charCodeAt(--v);
            if (T !== 32 && T !== 9) return v + 1;
        }
        return S;
    }
    function d(y, v, S) {
        const T = (S == null ? void 0 : S.encode) || encodeURIComponent;
        if (!i.test(y)) throw new TypeError(`argument name is invalid: ${y}`);
        const M = T(v);
        if (!e.test(M)) throw new TypeError(`argument val is invalid: ${v}`);
        let w = y + '=' + M;
        if (!S) return w;
        if (S.maxAge !== void 0) {
            if (!Number.isInteger(S.maxAge))
                throw new TypeError(`option maxAge is invalid: ${S.maxAge}`);
            w += '; Max-Age=' + S.maxAge;
        }
        if (S.domain) {
            if (!t.test(S.domain))
                throw new TypeError(`option domain is invalid: ${S.domain}`);
            w += '; Domain=' + S.domain;
        }
        if (S.path) {
            if (!n.test(S.path))
                throw new TypeError(`option path is invalid: ${S.path}`);
            w += '; Path=' + S.path;
        }
        if (S.expires) {
            if (!g(S.expires) || !Number.isFinite(S.expires.valueOf()))
                throw new TypeError(`option expires is invalid: ${S.expires}`);
            w += '; Expires=' + S.expires.toUTCString();
        }
        if (
            (S.httpOnly && (w += '; HttpOnly'),
            S.secure && (w += '; Secure'),
            S.partitioned && (w += '; Partitioned'),
            S.priority)
        )
            switch (
                typeof S.priority == 'string'
                    ? S.priority.toLowerCase()
                    : void 0
            ) {
                case 'low':
                    w += '; Priority=Low';
                    break;
                case 'medium':
                    w += '; Priority=Medium';
                    break;
                case 'high':
                    w += '; Priority=High';
                    break;
                default:
                    throw new TypeError(
                        `option priority is invalid: ${S.priority}`
                    );
            }
        if (S.sameSite)
            switch (
                typeof S.sameSite == 'string'
                    ? S.sameSite.toLowerCase()
                    : S.sameSite
            ) {
                case !0:
                case 'strict':
                    w += '; SameSite=Strict';
                    break;
                case 'lax':
                    w += '; SameSite=Lax';
                    break;
                case 'none':
                    w += '; SameSite=None';
                    break;
                default:
                    throw new TypeError(
                        `option sameSite is invalid: ${S.sameSite}`
                    );
            }
        return w;
    }
    function p(y) {
        if (y.indexOf('%') === -1) return y;
        try {
            return decodeURIComponent(y);
        } catch {
            return y;
        }
    }
    function g(y) {
        return r.call(y) === '[object Date]';
    }
    return Td;
}
EN();
var M1 = 'popstate';
function TN(i = {}) {
    function e(n, r) {
        let { pathname: s, search: a, hash: l } = n.location;
        return u_(
            '',
            { pathname: s, search: a, hash: l },
            (r.state && r.state.usr) || null,
            (r.state && r.state.key) || 'default'
        );
    }
    function t(n, r) {
        return typeof r == 'string' ? r : gp(r);
    }
    return CN(e, t, null, i);
}
function Bn(i, e) {
    if (i === !1 || i === null || typeof i > 'u') throw new Error(e);
}
function oo(i, e) {
    if (!i) {
        typeof console < 'u' && console.warn(e);
        try {
            throw new Error(e);
        } catch {}
    }
}
function AN() {
    return Math.random().toString(36).substring(2, 10);
}
function E1(i, e) {
    return { usr: i.state, key: i.key, idx: e };
}
function u_(i, e, t = null, n) {
    return {
        pathname: typeof i == 'string' ? i : i.pathname,
        search: '',
        hash: '',
        ...(typeof e == 'string' ? xh(e) : e),
        state: t,
        key: (e && e.key) || n || AN(),
    };
}
function gp({ pathname: i = '/', search: e = '', hash: t = '' }) {
    return (
        e && e !== '?' && (i += e.charAt(0) === '?' ? e : '?' + e),
        t && t !== '#' && (i += t.charAt(0) === '#' ? t : '#' + t),
        i
    );
}
function xh(i) {
    let e = {};
    if (i) {
        let t = i.indexOf('#');
        t >= 0 && ((e.hash = i.substring(t)), (i = i.substring(0, t)));
        let n = i.indexOf('?');
        n >= 0 && ((e.search = i.substring(n)), (i = i.substring(0, n))),
            i && (e.pathname = i);
    }
    return e;
}
function CN(i, e, t, n = {}) {
    let { window: r = document.defaultView, v5Compat: s = !1 } = n,
        a = r.history,
        l = 'POP',
        c = null,
        d = p();
    d == null && ((d = 0), a.replaceState({ ...a.state, idx: d }, ''));
    function p() {
        return (a.state || { idx: null }).idx;
    }
    function g() {
        l = 'POP';
        let M = p(),
            w = M == null ? null : M - d;
        (d = M), c && c({ action: l, location: T.location, delta: w });
    }
    function y(M, w) {
        l = 'PUSH';
        let b = u_(T.location, M, w);
        d = p() + 1;
        let C = E1(b, d),
            L = T.createHref(b);
        try {
            a.pushState(C, '', L);
        } catch (F) {
            if (F instanceof DOMException && F.name === 'DataCloneError')
                throw F;
            r.location.assign(L);
        }
        s && c && c({ action: l, location: T.location, delta: 1 });
    }
    function v(M, w) {
        l = 'REPLACE';
        let b = u_(T.location, M, w);
        d = p();
        let C = E1(b, d),
            L = T.createHref(b);
        a.replaceState(C, '', L),
            s && c && c({ action: l, location: T.location, delta: 0 });
    }
    function S(M) {
        return RN(M);
    }
    let T = {
        get action() {
            return l;
        },
        get location() {
            return i(r, a);
        },
        listen(M) {
            if (c)
                throw new Error('A history only accepts one active listener');
            return (
                r.addEventListener(M1, g),
                (c = M),
                () => {
                    r.removeEventListener(M1, g), (c = null);
                }
            );
        },
        createHref(M) {
            return e(r, M);
        },
        createURL: S,
        encodeLocation(M) {
            let w = S(M);
            return { pathname: w.pathname, search: w.search, hash: w.hash };
        },
        push: y,
        replace: v,
        go(M) {
            return a.go(M);
        },
    };
    return T;
}
function RN(i, e = !1) {
    let t = 'http://localhost';
    typeof window < 'u' &&
        (t =
            window.location.origin !== 'null'
                ? window.location.origin
                : window.location.href),
        Bn(t, 'No window.location.(origin|href) available to create URL');
    let n = typeof i == 'string' ? i : gp(i);
    return (
        (n = n.replace(/ $/, '%20')),
        !e && n.startsWith('//') && (n = t + n),
        new URL(n, t)
    );
}
function LC(i, e, t = '/') {
    return bN(i, e, t, !1);
}
function bN(i, e, t, n) {
    let r = typeof e == 'string' ? xh(e) : e,
        s = Da(r.pathname || '/', t);
    if (s == null) return null;
    let a = IC(i);
    PN(a);
    let l = null;
    for (let c = 0; l == null && c < a.length; ++c) {
        let d = VN(s);
        l = BN(a[c], d, n);
    }
    return l;
}
function IC(i, e = [], t = [], n = '') {
    let r = (s, a, l) => {
        let c = {
            relativePath: l === void 0 ? s.path || '' : l,
            caseSensitive: s.caseSensitive === !0,
            childrenIndex: a,
            route: s,
        };
        c.relativePath.startsWith('/') &&
            (Bn(
                c.relativePath.startsWith(n),
                `Absolute route path "${c.relativePath}" nested under path "${n}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`
            ),
            (c.relativePath = c.relativePath.slice(n.length)));
        let d = ba([n, c.relativePath]),
            p = t.concat(c);
        s.children &&
            s.children.length > 0 &&
            (Bn(
                s.index !== !0,
                `Index routes must not have child routes. Please remove all child routes from route path "${d}".`
            ),
            IC(s.children, e, p, d)),
            !(s.path == null && !s.index) &&
                e.push({ path: d, score: kN(d, s.index), routesMeta: p });
    };
    return (
        i.forEach((s, a) => {
            var l;
            if (s.path === '' || !((l = s.path) != null && l.includes('?')))
                r(s, a);
            else for (let c of DC(s.path)) r(s, a, c);
        }),
        e
    );
}
function DC(i) {
    let e = i.split('/');
    if (e.length === 0) return [];
    let [t, ...n] = e,
        r = t.endsWith('?'),
        s = t.replace(/\?$/, '');
    if (n.length === 0) return r ? [s, ''] : [s];
    let a = DC(n.join('/')),
        l = [];
    return (
        l.push(...a.map((c) => (c === '' ? s : [s, c].join('/')))),
        r && l.push(...a),
        l.map((c) => (i.startsWith('/') && c === '' ? '/' : c))
    );
}
function PN(i) {
    i.sort((e, t) =>
        e.score !== t.score
            ? t.score - e.score
            : FN(
                  e.routesMeta.map((n) => n.childrenIndex),
                  t.routesMeta.map((n) => n.childrenIndex)
              )
    );
}
var LN = /^:[\w-]+$/,
    IN = 3,
    DN = 2,
    NN = 1,
    UN = 10,
    ON = -2,
    T1 = (i) => i === '*';
function kN(i, e) {
    let t = i.split('/'),
        n = t.length;
    return (
        t.some(T1) && (n += ON),
        e && (n += DN),
        t
            .filter((r) => !T1(r))
            .reduce((r, s) => r + (LN.test(s) ? IN : s === '' ? NN : UN), n)
    );
}
function FN(i, e) {
    return i.length === e.length && i.slice(0, -1).every((n, r) => n === e[r])
        ? i[i.length - 1] - e[e.length - 1]
        : 0;
}
function BN(i, e, t = !1) {
    let { routesMeta: n } = i,
        r = {},
        s = '/',
        a = [];
    for (let l = 0; l < n.length; ++l) {
        let c = n[l],
            d = l === n.length - 1,
            p = s === '/' ? e : e.slice(s.length) || '/',
            g = py(
                {
                    path: c.relativePath,
                    caseSensitive: c.caseSensitive,
                    end: d,
                },
                p
            ),
            y = c.route;
        if (
            (!g &&
                d &&
                t &&
                !n[n.length - 1].route.index &&
                (g = py(
                    {
                        path: c.relativePath,
                        caseSensitive: c.caseSensitive,
                        end: !1,
                    },
                    p
                )),
            !g)
        )
            return null;
        Object.assign(r, g.params),
            a.push({
                params: r,
                pathname: ba([s, g.pathname]),
                pathnameBase: XN(ba([s, g.pathnameBase])),
                route: y,
            }),
            g.pathnameBase !== '/' && (s = ba([s, g.pathnameBase]));
    }
    return a;
}
function py(i, e) {
    typeof i == 'string' && (i = { path: i, caseSensitive: !1, end: !0 });
    let [t, n] = zN(i.path, i.caseSensitive, i.end),
        r = e.match(t);
    if (!r) return null;
    let s = r[0],
        a = s.replace(/(.)\/+$/, '$1'),
        l = r.slice(1);
    return {
        params: n.reduce((d, { paramName: p, isOptional: g }, y) => {
            if (p === '*') {
                let S = l[y] || '';
                a = s.slice(0, s.length - S.length).replace(/(.)\/+$/, '$1');
            }
            const v = l[y];
            return (
                g && !v
                    ? (d[p] = void 0)
                    : (d[p] = (v || '').replace(/%2F/g, '/')),
                d
            );
        }, {}),
        pathname: s,
        pathnameBase: a,
        pattern: i,
    };
}
function zN(i, e = !1, t = !0) {
    oo(
        i === '*' || !i.endsWith('*') || i.endsWith('/*'),
        `Route path "${i}" will be treated as if it were "${i.replace(/\*$/, '/*')}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${i.replace(/\*$/, '/*')}".`
    );
    let n = [],
        r =
            '^' +
            i
                .replace(/\/*\*?$/, '')
                .replace(/^\/*/, '/')
                .replace(/[\\.*+^${}|()[\]]/g, '\\$&')
                .replace(
                    /\/:([\w-]+)(\?)?/g,
                    (a, l, c) => (
                        n.push({ paramName: l, isOptional: c != null }),
                        c ? '/?([^\\/]+)?' : '/([^\\/]+)'
                    )
                );
    return (
        i.endsWith('*')
            ? (n.push({ paramName: '*' }),
              (r += i === '*' || i === '/*' ? '(.*)$' : '(?:\\/(.+)|\\/*)$'))
            : t
              ? (r += '\\/*$')
              : i !== '' && i !== '/' && (r += '(?:(?=\\/|$))'),
        [new RegExp(r, e ? void 0 : 'i'), n]
    );
}
function VN(i) {
    try {
        return i
            .split('/')
            .map((e) => decodeURIComponent(e).replace(/\//g, '%2F'))
            .join('/');
    } catch (e) {
        return (
            oo(
                !1,
                `The URL path "${i}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${e}).`
            ),
            i
        );
    }
}
function Da(i, e) {
    if (e === '/') return i;
    if (!i.toLowerCase().startsWith(e.toLowerCase())) return null;
    let t = e.endsWith('/') ? e.length - 1 : e.length,
        n = i.charAt(t);
    return n && n !== '/' ? null : i.slice(t) || '/';
}
function HN(i, e = '/') {
    let {
        pathname: t,
        search: n = '',
        hash: r = '',
    } = typeof i == 'string' ? xh(i) : i;
    return {
        pathname: t ? (t.startsWith('/') ? t : GN(t, e)) : e,
        search: jN(n),
        hash: qN(r),
    };
}
function GN(i, e) {
    let t = e.replace(/\/+$/, '').split('/');
    return (
        i.split('/').forEach((r) => {
            r === '..' ? t.length > 1 && t.pop() : r !== '.' && t.push(r);
        }),
        t.length > 1 ? t.join('/') : '/'
    );
}
function F0(i, e, t, n) {
    return `Cannot include a '${i}' character in a manually specified \`to.${e}\` field [${JSON.stringify(n)}].  Please separate it out to the \`to.${t}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`;
}
function WN(i) {
    return i.filter(
        (e, t) => t === 0 || (e.route.path && e.route.path.length > 0)
    );
}
function xS(i) {
    let e = WN(i);
    return e.map((t, n) => (n === e.length - 1 ? t.pathname : t.pathnameBase));
}
function _S(i, e, t, n = !1) {
    let r;
    typeof i == 'string'
        ? (r = xh(i))
        : ((r = { ...i }),
          Bn(
              !r.pathname || !r.pathname.includes('?'),
              F0('?', 'pathname', 'search', r)
          ),
          Bn(
              !r.pathname || !r.pathname.includes('#'),
              F0('#', 'pathname', 'hash', r)
          ),
          Bn(
              !r.search || !r.search.includes('#'),
              F0('#', 'search', 'hash', r)
          ));
    let s = i === '' || r.pathname === '',
        a = s ? '/' : r.pathname,
        l;
    if (a == null) l = t;
    else {
        let g = e.length - 1;
        if (!n && a.startsWith('..')) {
            let y = a.split('/');
            for (; y[0] === '..'; ) y.shift(), (g -= 1);
            r.pathname = y.join('/');
        }
        l = g >= 0 ? e[g] : '/';
    }
    let c = HN(r, l),
        d = a && a !== '/' && a.endsWith('/'),
        p = (s || a === '.') && t.endsWith('/');
    return !c.pathname.endsWith('/') && (d || p) && (c.pathname += '/'), c;
}
var ba = (i) => i.join('/').replace(/\/\/+/g, '/'),
    XN = (i) => i.replace(/\/+$/, '').replace(/^\/*/, '/'),
    jN = (i) => (!i || i === '?' ? '' : i.startsWith('?') ? i : '?' + i),
    qN = (i) => (!i || i === '#' ? '' : i.startsWith('#') ? i : '#' + i);
function $N(i) {
    return (
        i != null &&
        typeof i.status == 'number' &&
        typeof i.statusText == 'string' &&
        typeof i.internal == 'boolean' &&
        'data' in i
    );
}
var NC = ['POST', 'PUT', 'PATCH', 'DELETE'];
new Set(NC);
var YN = ['GET', ...NC];
new Set(YN);
var _h = K.createContext(null);
_h.displayName = 'DataRouter';
var rv = K.createContext(null);
rv.displayName = 'DataRouterState';
var UC = K.createContext({ isTransitioning: !1 });
UC.displayName = 'ViewTransition';
var KN = K.createContext(new Map());
KN.displayName = 'Fetchers';
var ZN = K.createContext(null);
ZN.displayName = 'Await';
var co = K.createContext(null);
co.displayName = 'Navigation';
var Xp = K.createContext(null);
Xp.displayName = 'Location';
var As = K.createContext({ outlet: null, matches: [], isDataRoute: !1 });
As.displayName = 'Route';
var SS = K.createContext(null);
SS.displayName = 'RouteError';
function JN(i, { relative: e } = {}) {
    Bn(
        Sh(),
        'useHref() may be used only in the context of a <Router> component.'
    );
    let { basename: t, navigator: n } = K.useContext(co),
        { hash: r, pathname: s, search: a } = jp(i, { relative: e }),
        l = s;
    return (
        t !== '/' && (l = s === '/' ? t : ba([t, s])),
        n.createHref({ pathname: l, search: a, hash: r })
    );
}
function Sh() {
    return K.useContext(Xp) != null;
}
function Fl() {
    return (
        Bn(
            Sh(),
            'useLocation() may be used only in the context of a <Router> component.'
        ),
        K.useContext(Xp).location
    );
}
var OC =
    'You should call navigate() in a React.useEffect(), not when your component is first rendered.';
function kC(i) {
    K.useContext(co).static || K.useLayoutEffect(i);
}
function FC() {
    let { isDataRoute: i } = K.useContext(As);
    return i ? dU() : QN();
}
function QN() {
    Bn(
        Sh(),
        'useNavigate() may be used only in the context of a <Router> component.'
    );
    let i = K.useContext(_h),
        { basename: e, navigator: t } = K.useContext(co),
        { matches: n } = K.useContext(As),
        { pathname: r } = Fl(),
        s = JSON.stringify(xS(n)),
        a = K.useRef(!1);
    return (
        kC(() => {
            a.current = !0;
        }),
        K.useCallback(
            (c, d = {}) => {
                if ((oo(a.current, OC), !a.current)) return;
                if (typeof c == 'number') {
                    t.go(c);
                    return;
                }
                let p = _S(c, JSON.parse(s), r, d.relative === 'path');
                i == null &&
                    e !== '/' &&
                    (p.pathname = p.pathname === '/' ? e : ba([e, p.pathname])),
                    (d.replace ? t.replace : t.push)(p, d.state, d);
            },
            [e, t, s, r, i]
        )
    );
}
var eU = K.createContext(null);
function tU(i) {
    let e = K.useContext(As).outlet;
    return e && K.createElement(eU.Provider, { value: i }, e);
}
function ZW() {
    let { matches: i } = K.useContext(As),
        e = i[i.length - 1];
    return e ? e.params : {};
}
function jp(i, { relative: e } = {}) {
    let { matches: t } = K.useContext(As),
        { pathname: n } = Fl(),
        r = JSON.stringify(xS(t));
    return K.useMemo(() => _S(i, JSON.parse(r), n, e === 'path'), [i, r, n, e]);
}
function nU(i, e) {
    return BC(i, e);
}
function BC(i, e, t, n) {
    var b;
    Bn(
        Sh(),
        'useRoutes() may be used only in the context of a <Router> component.'
    );
    let { navigator: r, static: s } = K.useContext(co),
        { matches: a } = K.useContext(As),
        l = a[a.length - 1],
        c = l ? l.params : {},
        d = l ? l.pathname : '/',
        p = l ? l.pathnameBase : '/',
        g = l && l.route;
    {
        let C = (g && g.path) || '';
        zC(
            d,
            !g || C.endsWith('*') || C.endsWith('*?'),
            `You rendered descendant <Routes> (or called \`useRoutes()\`) at "${d}" (under <Route path="${C}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${C}"> to <Route path="${C === '/' ? '*' : `${C}/*`}">.`
        );
    }
    let y = Fl(),
        v;
    if (e) {
        let C = typeof e == 'string' ? xh(e) : e;
        Bn(
            p === '/' || ((b = C.pathname) == null ? void 0 : b.startsWith(p)),
            `When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${p}" but pathname "${C.pathname}" was given in the \`location\` prop.`
        ),
            (v = C);
    } else v = y;
    let S = v.pathname || '/',
        T = S;
    if (p !== '/') {
        let C = p.replace(/^\//, '').split('/');
        T = '/' + S.replace(/^\//, '').split('/').slice(C.length).join('/');
    }
    let M =
        !s && t && t.matches && t.matches.length > 0
            ? t.matches
            : LC(i, { pathname: T });
    oo(
        g || M != null,
        `No routes matched location "${v.pathname}${v.search}${v.hash}" `
    ),
        oo(
            M == null ||
                M[M.length - 1].route.element !== void 0 ||
                M[M.length - 1].route.Component !== void 0 ||
                M[M.length - 1].route.lazy !== void 0,
            `Matched leaf route at location "${v.pathname}${v.search}${v.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`
        );
    let w = aU(
        M &&
            M.map((C) =>
                Object.assign({}, C, {
                    params: Object.assign({}, c, C.params),
                    pathname: ba([
                        p,
                        r.encodeLocation
                            ? r.encodeLocation(C.pathname).pathname
                            : C.pathname,
                    ]),
                    pathnameBase:
                        C.pathnameBase === '/'
                            ? p
                            : ba([
                                  p,
                                  r.encodeLocation
                                      ? r.encodeLocation(C.pathnameBase)
                                            .pathname
                                      : C.pathnameBase,
                              ]),
                })
            ),
        a,
        t,
        n
    );
    return e && w
        ? K.createElement(
              Xp.Provider,
              {
                  value: {
                      location: {
                          pathname: '/',
                          search: '',
                          hash: '',
                          state: null,
                          key: 'default',
                          ...v,
                      },
                      navigationType: 'POP',
                  },
              },
              w
          )
        : w;
}
function iU() {
    let i = hU(),
        e = $N(i)
            ? `${i.status} ${i.statusText}`
            : i instanceof Error
              ? i.message
              : JSON.stringify(i),
        t = i instanceof Error ? i.stack : null,
        n = 'rgba(200,200,200, 0.5)',
        r = { padding: '0.5rem', backgroundColor: n },
        s = { padding: '2px 4px', backgroundColor: n },
        a = null;
    return (
        console.error(
            'Error handled by React Router default ErrorBoundary:',
            i
        ),
        (a = K.createElement(
            K.Fragment,
            null,
            K.createElement('p', null, '💿 Hey developer 👋'),
            K.createElement(
                'p',
                null,
                'You can provide a way better UX than this when your app throws errors by providing your own ',
                K.createElement('code', { style: s }, 'ErrorBoundary'),
                ' or',
                ' ',
                K.createElement('code', { style: s }, 'errorElement'),
                ' prop on your route.'
            )
        )),
        K.createElement(
            K.Fragment,
            null,
            K.createElement('h2', null, 'Unexpected Application Error!'),
            K.createElement('h3', { style: { fontStyle: 'italic' } }, e),
            t ? K.createElement('pre', { style: r }, t) : null,
            a
        )
    );
}
var rU = K.createElement(iU, null),
    sU = class extends K.Component {
        constructor(i) {
            super(i),
                (this.state = {
                    location: i.location,
                    revalidation: i.revalidation,
                    error: i.error,
                });
        }
        static getDerivedStateFromError(i) {
            return { error: i };
        }
        static getDerivedStateFromProps(i, e) {
            return e.location !== i.location ||
                (e.revalidation !== 'idle' && i.revalidation === 'idle')
                ? {
                      error: i.error,
                      location: i.location,
                      revalidation: i.revalidation,
                  }
                : {
                      error: i.error !== void 0 ? i.error : e.error,
                      location: e.location,
                      revalidation: i.revalidation || e.revalidation,
                  };
        }
        componentDidCatch(i, e) {
            console.error(
                'React Router caught the following error during render',
                i,
                e
            );
        }
        render() {
            return this.state.error !== void 0
                ? K.createElement(
                      As.Provider,
                      { value: this.props.routeContext },
                      K.createElement(SS.Provider, {
                          value: this.state.error,
                          children: this.props.component,
                      })
                  )
                : this.props.children;
        }
    };
function oU({ routeContext: i, match: e, children: t }) {
    let n = K.useContext(_h);
    return (
        n &&
            n.static &&
            n.staticContext &&
            (e.route.errorElement || e.route.ErrorBoundary) &&
            (n.staticContext._deepestRenderedBoundaryId = e.route.id),
        K.createElement(As.Provider, { value: i }, t)
    );
}
function aU(i, e = [], t = null, n = null) {
    if (i == null) {
        if (!t) return null;
        if (t.errors) i = t.matches;
        else if (e.length === 0 && !t.initialized && t.matches.length > 0)
            i = t.matches;
        else return null;
    }
    let r = i,
        s = t == null ? void 0 : t.errors;
    if (s != null) {
        let c = r.findIndex(
            (d) => d.route.id && (s == null ? void 0 : s[d.route.id]) !== void 0
        );
        Bn(
            c >= 0,
            `Could not find a matching route for errors on route IDs: ${Object.keys(s).join(',')}`
        ),
            (r = r.slice(0, Math.min(r.length, c + 1)));
    }
    let a = !1,
        l = -1;
    if (t)
        for (let c = 0; c < r.length; c++) {
            let d = r[c];
            if (
                ((d.route.HydrateFallback || d.route.hydrateFallbackElement) &&
                    (l = c),
                d.route.id)
            ) {
                let { loaderData: p, errors: g } = t,
                    y =
                        d.route.loader &&
                        !p.hasOwnProperty(d.route.id) &&
                        (!g || g[d.route.id] === void 0);
                if (d.route.lazy || y) {
                    (a = !0), l >= 0 ? (r = r.slice(0, l + 1)) : (r = [r[0]]);
                    break;
                }
            }
        }
    return r.reduceRight((c, d, p) => {
        let g,
            y = !1,
            v = null,
            S = null;
        t &&
            ((g = s && d.route.id ? s[d.route.id] : void 0),
            (v = d.route.errorElement || rU),
            a &&
                (l < 0 && p === 0
                    ? (zC(
                          'route-fallback',
                          !1,
                          'No `HydrateFallback` element provided to render during initial hydration'
                      ),
                      (y = !0),
                      (S = null))
                    : l === p &&
                      ((y = !0),
                      (S = d.route.hydrateFallbackElement || null))));
        let T = e.concat(r.slice(0, p + 1)),
            M = () => {
                let w;
                return (
                    g
                        ? (w = v)
                        : y
                          ? (w = S)
                          : d.route.Component
                            ? (w = K.createElement(d.route.Component, null))
                            : d.route.element
                              ? (w = d.route.element)
                              : (w = c),
                    K.createElement(oU, {
                        match: d,
                        routeContext: {
                            outlet: c,
                            matches: T,
                            isDataRoute: t != null,
                        },
                        children: w,
                    })
                );
            };
        return t && (d.route.ErrorBoundary || d.route.errorElement || p === 0)
            ? K.createElement(sU, {
                  location: t.location,
                  revalidation: t.revalidation,
                  component: v,
                  error: g,
                  children: M(),
                  routeContext: { outlet: null, matches: T, isDataRoute: !0 },
              })
            : M();
    }, null);
}
function wS(i) {
    return `${i} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
}
function lU(i) {
    let e = K.useContext(_h);
    return Bn(e, wS(i)), e;
}
function uU(i) {
    let e = K.useContext(rv);
    return Bn(e, wS(i)), e;
}
function cU(i) {
    let e = K.useContext(As);
    return Bn(e, wS(i)), e;
}
function MS(i) {
    let e = cU(i),
        t = e.matches[e.matches.length - 1];
    return (
        Bn(
            t.route.id,
            `${i} can only be used on routes that contain a unique "id"`
        ),
        t.route.id
    );
}
function fU() {
    return MS('useRouteId');
}
function hU() {
    var n;
    let i = K.useContext(SS),
        e = uU('useRouteError'),
        t = MS('useRouteError');
    return i !== void 0 ? i : (n = e.errors) == null ? void 0 : n[t];
}
function dU() {
    let { router: i } = lU('useNavigate'),
        e = MS('useNavigate'),
        t = K.useRef(!1);
    return (
        kC(() => {
            t.current = !0;
        }),
        K.useCallback(
            async (r, s = {}) => {
                oo(t.current, OC),
                    t.current &&
                        (typeof r == 'number'
                            ? i.navigate(r)
                            : await i.navigate(r, { fromRouteId: e, ...s }));
            },
            [i, e]
        )
    );
}
var A1 = {};
function zC(i, e, t) {
    !e && !A1[i] && ((A1[i] = !0), oo(!1, t));
}
K.memo(pU);
function pU({ routes: i, future: e, state: t }) {
    return BC(i, void 0, t, e);
}
function my({ to: i, replace: e, state: t, relative: n }) {
    Bn(
        Sh(),
        '<Navigate> may be used only in the context of a <Router> component.'
    );
    let { static: r } = K.useContext(co);
    oo(
        !r,
        '<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change.'
    );
    let { matches: s } = K.useContext(As),
        { pathname: a } = Fl(),
        l = FC(),
        c = _S(i, xS(s), a, n === 'path'),
        d = JSON.stringify(c);
    return (
        K.useEffect(() => {
            l(JSON.parse(d), { replace: e, state: t, relative: n });
        }, [l, d, n, e, t]),
        null
    );
}
function mU(i) {
    return tU(i.context);
}
function rs(i) {
    Bn(
        !1,
        'A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.'
    );
}
function gU({
    basename: i = '/',
    children: e = null,
    location: t,
    navigationType: n = 'POP',
    navigator: r,
    static: s = !1,
}) {
    Bn(
        !Sh(),
        'You cannot render a <Router> inside another <Router>. You should never have more than one in your app.'
    );
    let a = i.replace(/^\/*/, '/'),
        l = K.useMemo(
            () => ({ basename: a, navigator: r, static: s, future: {} }),
            [a, r, s]
        );
    typeof t == 'string' && (t = xh(t));
    let {
            pathname: c = '/',
            search: d = '',
            hash: p = '',
            state: g = null,
            key: y = 'default',
        } = t,
        v = K.useMemo(() => {
            let S = Da(c, a);
            return S == null
                ? null
                : {
                      location: {
                          pathname: S,
                          search: d,
                          hash: p,
                          state: g,
                          key: y,
                      },
                      navigationType: n,
                  };
        }, [a, c, d, p, g, y, n]);
    return (
        oo(
            v != null,
            `<Router basename="${a}"> is not able to match the URL "${c}${d}${p}" because it does not start with the basename, so the <Router> won't render anything.`
        ),
        v == null
            ? null
            : K.createElement(
                  co.Provider,
                  { value: l },
                  K.createElement(Xp.Provider, { children: e, value: v })
              )
    );
}
function yU({ children: i, location: e }) {
    return nU(c_(i), e);
}
function c_(i, e = []) {
    let t = [];
    return (
        K.Children.forEach(i, (n, r) => {
            if (!K.isValidElement(n)) return;
            let s = [...e, r];
            if (n.type === K.Fragment) {
                t.push.apply(t, c_(n.props.children, s));
                return;
            }
            Bn(
                n.type === rs,
                `[${typeof n.type == 'string' ? n.type : n.type.name}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`
            ),
                Bn(
                    !n.props.index || !n.props.children,
                    'An index route cannot have child routes.'
                );
            let a = {
                id: n.props.id || s.join('-'),
                caseSensitive: n.props.caseSensitive,
                element: n.props.element,
                Component: n.props.Component,
                index: n.props.index,
                path: n.props.path,
                loader: n.props.loader,
                action: n.props.action,
                hydrateFallbackElement: n.props.hydrateFallbackElement,
                HydrateFallback: n.props.HydrateFallback,
                errorElement: n.props.errorElement,
                ErrorBoundary: n.props.ErrorBoundary,
                hasErrorBoundary:
                    n.props.hasErrorBoundary === !0 ||
                    n.props.ErrorBoundary != null ||
                    n.props.errorElement != null,
                shouldRevalidate: n.props.shouldRevalidate,
                handle: n.props.handle,
                lazy: n.props.lazy,
            };
            n.props.children && (a.children = c_(n.props.children, s)),
                t.push(a);
        }),
        t
    );
}
var ry = 'get',
    sy = 'application/x-www-form-urlencoded';
function sv(i) {
    return i != null && typeof i.tagName == 'string';
}
function vU(i) {
    return sv(i) && i.tagName.toLowerCase() === 'button';
}
function xU(i) {
    return sv(i) && i.tagName.toLowerCase() === 'form';
}
function _U(i) {
    return sv(i) && i.tagName.toLowerCase() === 'input';
}
function SU(i) {
    return !!(i.metaKey || i.altKey || i.ctrlKey || i.shiftKey);
}
function wU(i, e) {
    return i.button === 0 && (!e || e === '_self') && !SU(i);
}
var ig = null;
function MU() {
    if (ig === null)
        try {
            new FormData(document.createElement('form'), 0), (ig = !1);
        } catch {
            ig = !0;
        }
    return ig;
}
var EU = new Set([
    'application/x-www-form-urlencoded',
    'multipart/form-data',
    'text/plain',
]);
function B0(i) {
    return i != null && !EU.has(i)
        ? (oo(
              !1,
              `"${i}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${sy}"`
          ),
          null)
        : i;
}
function TU(i, e) {
    let t, n, r, s, a;
    if (xU(i)) {
        let l = i.getAttribute('action');
        (n = l ? Da(l, e) : null),
            (t = i.getAttribute('method') || ry),
            (r = B0(i.getAttribute('enctype')) || sy),
            (s = new FormData(i));
    } else if (
        vU(i) ||
        (_U(i) && (i.type === 'submit' || i.type === 'image'))
    ) {
        let l = i.form;
        if (l == null)
            throw new Error(
                'Cannot submit a <button> or <input type="submit"> without a <form>'
            );
        let c = i.getAttribute('formaction') || l.getAttribute('action');
        if (
            ((n = c ? Da(c, e) : null),
            (t =
                i.getAttribute('formmethod') || l.getAttribute('method') || ry),
            (r =
                B0(i.getAttribute('formenctype')) ||
                B0(l.getAttribute('enctype')) ||
                sy),
            (s = new FormData(l, i)),
            !MU())
        ) {
            let { name: d, type: p, value: g } = i;
            if (p === 'image') {
                let y = d ? `${d}.` : '';
                s.append(`${y}x`, '0'), s.append(`${y}y`, '0');
            } else d && s.append(d, g);
        }
    } else {
        if (sv(i))
            throw new Error(
                'Cannot submit element that is not <form>, <button>, or <input type="submit|image">'
            );
        (t = ry), (n = null), (r = sy), (a = i);
    }
    return (
        s && r === 'text/plain' && ((a = s), (s = void 0)),
        { action: n, method: t.toLowerCase(), encType: r, formData: s, body: a }
    );
}
function ES(i, e) {
    if (i === !1 || i === null || typeof i > 'u') throw new Error(e);
}
async function AU(i, e) {
    if (i.id in e) return e[i.id];
    try {
        let t = await import(i.module);
        return (e[i.id] = t), t;
    } catch (t) {
        return (
            console.error(
                `Error loading route module \`${i.module}\`, reloading page...`
            ),
            console.error(t),
            window.__reactRouterContext &&
                window.__reactRouterContext.isSpaMode,
            window.location.reload(),
            new Promise(() => {})
        );
    }
}
function CU(i) {
    return i == null
        ? !1
        : i.href == null
          ? i.rel === 'preload' &&
            typeof i.imageSrcSet == 'string' &&
            typeof i.imageSizes == 'string'
          : typeof i.rel == 'string' && typeof i.href == 'string';
}
async function RU(i, e, t) {
    let n = await Promise.all(
        i.map(async (r) => {
            let s = e.routes[r.route.id];
            if (s) {
                let a = await AU(s, t);
                return a.links ? a.links() : [];
            }
            return [];
        })
    );
    return IU(
        n
            .flat(1)
            .filter(CU)
            .filter((r) => r.rel === 'stylesheet' || r.rel === 'preload')
            .map((r) =>
                r.rel === 'stylesheet'
                    ? { ...r, rel: 'prefetch', as: 'style' }
                    : { ...r, rel: 'prefetch' }
            )
    );
}
function C1(i, e, t, n, r, s) {
    let a = (c, d) => (t[d] ? c.route.id !== t[d].route.id : !0),
        l = (c, d) => {
            var p;
            return (
                t[d].pathname !== c.pathname ||
                (((p = t[d].route.path) == null ? void 0 : p.endsWith('*')) &&
                    t[d].params['*'] !== c.params['*'])
            );
        };
    return s === 'assets'
        ? e.filter((c, d) => a(c, d) || l(c, d))
        : s === 'data'
          ? e.filter((c, d) => {
                var g;
                let p = n.routes[c.route.id];
                if (!p || !p.hasLoader) return !1;
                if (a(c, d) || l(c, d)) return !0;
                if (c.route.shouldRevalidate) {
                    let y = c.route.shouldRevalidate({
                        currentUrl: new URL(
                            r.pathname + r.search + r.hash,
                            window.origin
                        ),
                        currentParams:
                            ((g = t[0]) == null ? void 0 : g.params) || {},
                        nextUrl: new URL(i, window.origin),
                        nextParams: c.params,
                        defaultShouldRevalidate: !0,
                    });
                    if (typeof y == 'boolean') return y;
                }
                return !0;
            })
          : [];
}
function bU(i, e, { includeHydrateFallback: t } = {}) {
    return PU(
        i
            .map((n) => {
                let r = e.routes[n.route.id];
                if (!r) return [];
                let s = [r.module];
                return (
                    r.clientActionModule &&
                        (s = s.concat(r.clientActionModule)),
                    r.clientLoaderModule &&
                        (s = s.concat(r.clientLoaderModule)),
                    t &&
                        r.hydrateFallbackModule &&
                        (s = s.concat(r.hydrateFallbackModule)),
                    r.imports && (s = s.concat(r.imports)),
                    s
                );
            })
            .flat(1)
    );
}
function PU(i) {
    return [...new Set(i)];
}
function LU(i) {
    let e = {},
        t = Object.keys(i).sort();
    for (let n of t) e[n] = i[n];
    return e;
}
function IU(i, e) {
    let t = new Set();
    return (
        new Set(e),
        i.reduce((n, r) => {
            let s = JSON.stringify(LU(r));
            return t.has(s) || (t.add(s), n.push({ key: s, link: r })), n;
        }, [])
    );
}
Object.getOwnPropertyNames(Object.prototype).sort().join('\0');
var DU = new Set([100, 101, 204, 205]);
function NU(i, e) {
    let t =
        typeof i == 'string'
            ? new URL(
                  i,
                  typeof window > 'u'
                      ? 'server://singlefetch/'
                      : window.location.origin
              )
            : i;
    return (
        t.pathname === '/'
            ? (t.pathname = '_root.data')
            : e && Da(t.pathname, e) === '/'
              ? (t.pathname = `${e.replace(/\/$/, '')}/_root.data`)
              : (t.pathname = `${t.pathname.replace(/\/$/, '')}.data`),
        t
    );
}
function VC() {
    let i = K.useContext(_h);
    return (
        ES(
            i,
            'You must render this element inside a <DataRouterContext.Provider> element'
        ),
        i
    );
}
function UU() {
    let i = K.useContext(rv);
    return (
        ES(
            i,
            'You must render this element inside a <DataRouterStateContext.Provider> element'
        ),
        i
    );
}
var TS = K.createContext(void 0);
TS.displayName = 'FrameworkContext';
function HC() {
    let i = K.useContext(TS);
    return (
        ES(i, 'You must render this element inside a <HydratedRouter> element'),
        i
    );
}
function OU(i, e) {
    let t = K.useContext(TS),
        [n, r] = K.useState(!1),
        [s, a] = K.useState(!1),
        {
            onFocus: l,
            onBlur: c,
            onMouseEnter: d,
            onMouseLeave: p,
            onTouchStart: g,
        } = e,
        y = K.useRef(null);
    K.useEffect(() => {
        if ((i === 'render' && a(!0), i === 'viewport')) {
            let T = (w) => {
                    w.forEach((b) => {
                        a(b.isIntersecting);
                    });
                },
                M = new IntersectionObserver(T, { threshold: 0.5 });
            return (
                y.current && M.observe(y.current),
                () => {
                    M.disconnect();
                }
            );
        }
    }, [i]),
        K.useEffect(() => {
            if (n) {
                let T = setTimeout(() => {
                    a(!0);
                }, 100);
                return () => {
                    clearTimeout(T);
                };
            }
        }, [n]);
    let v = () => {
            r(!0);
        },
        S = () => {
            r(!1), a(!1);
        };
    return t
        ? i !== 'intent'
            ? [s, y, {}]
            : [
                  s,
                  y,
                  {
                      onFocus: Ad(l, v),
                      onBlur: Ad(c, S),
                      onMouseEnter: Ad(d, v),
                      onMouseLeave: Ad(p, S),
                      onTouchStart: Ad(g, v),
                  },
              ]
        : [!1, y, {}];
}
function Ad(i, e) {
    return (t) => {
        i && i(t), t.defaultPrevented || e(t);
    };
}
function kU({ page: i, ...e }) {
    let { router: t } = VC(),
        n = K.useMemo(
            () => LC(t.routes, i, t.basename),
            [t.routes, i, t.basename]
        );
    return n ? K.createElement(BU, { page: i, matches: n, ...e }) : null;
}
function FU(i) {
    let { manifest: e, routeModules: t } = HC(),
        [n, r] = K.useState([]);
    return (
        K.useEffect(() => {
            let s = !1;
            return (
                RU(i, e, t).then((a) => {
                    s || r(a);
                }),
                () => {
                    s = !0;
                }
            );
        }, [i, e, t]),
        n
    );
}
function BU({ page: i, matches: e, ...t }) {
    let n = Fl(),
        { manifest: r, routeModules: s } = HC(),
        { basename: a } = VC(),
        { loaderData: l, matches: c } = UU(),
        d = K.useMemo(() => C1(i, e, c, r, n, 'data'), [i, e, c, r, n]),
        p = K.useMemo(() => C1(i, e, c, r, n, 'assets'), [i, e, c, r, n]),
        g = K.useMemo(() => {
            if (i === n.pathname + n.search + n.hash) return [];
            let S = new Set(),
                T = !1;
            if (
                (e.forEach((w) => {
                    var C;
                    let b = r.routes[w.route.id];
                    !b ||
                        !b.hasLoader ||
                        ((!d.some((L) => L.route.id === w.route.id) &&
                            w.route.id in l &&
                            (C = s[w.route.id]) != null &&
                            C.shouldRevalidate) ||
                        b.hasClientLoader
                            ? (T = !0)
                            : S.add(w.route.id));
                }),
                S.size === 0)
            )
                return [];
            let M = NU(i, a);
            return (
                T &&
                    S.size > 0 &&
                    M.searchParams.set(
                        '_routes',
                        e
                            .filter((w) => S.has(w.route.id))
                            .map((w) => w.route.id)
                            .join(',')
                    ),
                [M.pathname + M.search]
            );
        }, [a, l, n, r, d, e, i, s]),
        y = K.useMemo(() => bU(p, r), [p, r]),
        v = FU(p);
    return K.createElement(
        K.Fragment,
        null,
        g.map((S) =>
            K.createElement('link', {
                key: S,
                rel: 'prefetch',
                as: 'fetch',
                href: S,
                ...t,
            })
        ),
        y.map((S) =>
            K.createElement('link', {
                key: S,
                rel: 'modulepreload',
                href: S,
                ...t,
            })
        ),
        v.map(({ key: S, link: T }) =>
            K.createElement('link', { key: S, ...T })
        )
    );
}
function zU(...i) {
    return (e) => {
        i.forEach((t) => {
            typeof t == 'function' ? t(e) : t != null && (t.current = e);
        });
    };
}
var GC =
    typeof window < 'u' &&
    typeof window.document < 'u' &&
    typeof window.document.createElement < 'u';
try {
    GC && (window.__reactRouterVersion = '7.6.0');
} catch {}
function VU({ basename: i, children: e, window: t }) {
    let n = K.useRef();
    n.current == null && (n.current = TN({ window: t, v5Compat: !0 }));
    let r = n.current,
        [s, a] = K.useState({ action: r.action, location: r.location }),
        l = K.useCallback(
            (c) => {
                K.startTransition(() => a(c));
            },
            [a]
        );
    return (
        K.useLayoutEffect(() => r.listen(l), [r, l]),
        K.createElement(gU, {
            basename: i,
            children: e,
            location: s.location,
            navigationType: s.action,
            navigator: r,
        })
    );
}
var WC = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,
    XC = K.forwardRef(function (
        {
            onClick: e,
            discover: t = 'render',
            prefetch: n = 'none',
            relative: r,
            reloadDocument: s,
            replace: a,
            state: l,
            target: c,
            to: d,
            preventScrollReset: p,
            viewTransition: g,
            ...y
        },
        v
    ) {
        let { basename: S } = K.useContext(co),
            T = typeof d == 'string' && WC.test(d),
            M,
            w = !1;
        if (typeof d == 'string' && T && ((M = d), GC))
            try {
                let U = new URL(window.location.href),
                    D = d.startsWith('//')
                        ? new URL(U.protocol + d)
                        : new URL(d),
                    H = Da(D.pathname, S);
                D.origin === U.origin && H != null
                    ? (d = H + D.search + D.hash)
                    : (w = !0);
            } catch {
                oo(
                    !1,
                    `<Link to="${d}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`
                );
            }
        let b = JN(d, { relative: r }),
            [C, L, F] = OU(n, y),
            N = XU(d, {
                replace: a,
                state: l,
                target: c,
                preventScrollReset: p,
                relative: r,
                viewTransition: g,
            });
        function B(U) {
            e && e(U), U.defaultPrevented || N(U);
        }
        let z = K.createElement('a', {
            ...y,
            ...F,
            href: M || b,
            onClick: w || s ? e : B,
            ref: zU(v, L),
            target: c,
            'data-discover': !T && t === 'render' ? 'true' : void 0,
        });
        return C && !T
            ? K.createElement(
                  K.Fragment,
                  null,
                  z,
                  K.createElement(kU, { page: b })
              )
            : z;
    });
XC.displayName = 'Link';
var HU = K.forwardRef(function (
    {
        'aria-current': e = 'page',
        caseSensitive: t = !1,
        className: n = '',
        end: r = !1,
        style: s,
        to: a,
        viewTransition: l,
        children: c,
        ...d
    },
    p
) {
    let g = jp(a, { relative: d.relative }),
        y = Fl(),
        v = K.useContext(rv),
        { navigator: S, basename: T } = K.useContext(co),
        M = v != null && KU(g) && l === !0,
        w = S.encodeLocation ? S.encodeLocation(g).pathname : g.pathname,
        b = y.pathname,
        C =
            v && v.navigation && v.navigation.location
                ? v.navigation.location.pathname
                : null;
    t ||
        ((b = b.toLowerCase()),
        (C = C ? C.toLowerCase() : null),
        (w = w.toLowerCase())),
        C && T && (C = Da(C, T) || C);
    const L = w !== '/' && w.endsWith('/') ? w.length - 1 : w.length;
    let F = b === w || (!r && b.startsWith(w) && b.charAt(L) === '/'),
        N =
            C != null &&
            (C === w || (!r && C.startsWith(w) && C.charAt(w.length) === '/')),
        B = { isActive: F, isPending: N, isTransitioning: M },
        z = F ? e : void 0,
        U;
    typeof n == 'function'
        ? (U = n(B))
        : (U = [
              n,
              F ? 'active' : null,
              N ? 'pending' : null,
              M ? 'transitioning' : null,
          ]
              .filter(Boolean)
              .join(' '));
    let D = typeof s == 'function' ? s(B) : s;
    return K.createElement(
        XC,
        {
            ...d,
            'aria-current': z,
            className: U,
            ref: p,
            style: D,
            to: a,
            viewTransition: l,
        },
        typeof c == 'function' ? c(B) : c
    );
});
HU.displayName = 'NavLink';
var GU = K.forwardRef(
    (
        {
            discover: i = 'render',
            fetcherKey: e,
            navigate: t,
            reloadDocument: n,
            replace: r,
            state: s,
            method: a = ry,
            action: l,
            onSubmit: c,
            relative: d,
            preventScrollReset: p,
            viewTransition: g,
            ...y
        },
        v
    ) => {
        let S = $U(),
            T = YU(l, { relative: d }),
            M = a.toLowerCase() === 'get' ? 'get' : 'post',
            w = typeof l == 'string' && WC.test(l),
            b = (C) => {
                if ((c && c(C), C.defaultPrevented)) return;
                C.preventDefault();
                let L = C.nativeEvent.submitter,
                    F =
                        (L == null ? void 0 : L.getAttribute('formmethod')) ||
                        a;
                S(L || C.currentTarget, {
                    fetcherKey: e,
                    method: F,
                    navigate: t,
                    replace: r,
                    state: s,
                    relative: d,
                    preventScrollReset: p,
                    viewTransition: g,
                });
            };
        return K.createElement('form', {
            ref: v,
            method: M,
            action: T,
            onSubmit: n ? c : b,
            ...y,
            'data-discover': !w && i === 'render' ? 'true' : void 0,
        });
    }
);
GU.displayName = 'Form';
function WU(i) {
    return `${i} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
}
function jC(i) {
    let e = K.useContext(_h);
    return Bn(e, WU(i)), e;
}
function XU(
    i,
    {
        target: e,
        replace: t,
        state: n,
        preventScrollReset: r,
        relative: s,
        viewTransition: a,
    } = {}
) {
    let l = FC(),
        c = Fl(),
        d = jp(i, { relative: s });
    return K.useCallback(
        (p) => {
            if (wU(p, e)) {
                p.preventDefault();
                let g = t !== void 0 ? t : gp(c) === gp(d);
                l(i, {
                    replace: g,
                    state: n,
                    preventScrollReset: r,
                    relative: s,
                    viewTransition: a,
                });
            }
        },
        [c, l, d, t, n, e, i, r, s, a]
    );
}
var jU = 0,
    qU = () => `__${String(++jU)}__`;
function $U() {
    let { router: i } = jC('useSubmit'),
        { basename: e } = K.useContext(co),
        t = fU();
    return K.useCallback(
        async (n, r = {}) => {
            let {
                action: s,
                method: a,
                encType: l,
                formData: c,
                body: d,
            } = TU(n, e);
            if (r.navigate === !1) {
                let p = r.fetcherKey || qU();
                await i.fetch(p, t, r.action || s, {
                    preventScrollReset: r.preventScrollReset,
                    formData: c,
                    body: d,
                    formMethod: r.method || a,
                    formEncType: r.encType || l,
                    flushSync: r.flushSync,
                });
            } else
                await i.navigate(r.action || s, {
                    preventScrollReset: r.preventScrollReset,
                    formData: c,
                    body: d,
                    formMethod: r.method || a,
                    formEncType: r.encType || l,
                    replace: r.replace,
                    state: r.state,
                    fromRouteId: t,
                    flushSync: r.flushSync,
                    viewTransition: r.viewTransition,
                });
        },
        [i, e, t]
    );
}
function YU(i, { relative: e } = {}) {
    let { basename: t } = K.useContext(co),
        n = K.useContext(As);
    Bn(n, 'useFormAction must be used inside a RouteContext');
    let [r] = n.matches.slice(-1),
        s = { ...jp(i || '.', { relative: e }) },
        a = Fl();
    if (i == null) {
        s.search = a.search;
        let l = new URLSearchParams(s.search),
            c = l.getAll('index');
        if (c.some((p) => p === '')) {
            l.delete('index'),
                c.filter((g) => g).forEach((g) => l.append('index', g));
            let p = l.toString();
            s.search = p ? `?${p}` : '';
        }
    }
    return (
        (!i || i === '.') &&
            r.route.index &&
            (s.search = s.search
                ? s.search.replace(/^\?/, '?index&')
                : '?index'),
        t !== '/' &&
            (s.pathname = s.pathname === '/' ? t : ba([t, s.pathname])),
        gp(s)
    );
}
function KU(i, e = {}) {
    let t = K.useContext(UC);
    Bn(
        t != null,
        "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?"
    );
    let { basename: n } = jC('useViewTransitionState'),
        r = jp(i, { relative: e.relative });
    if (!t.isTransitioning) return !1;
    let s = Da(t.currentLocation.pathname, n) || t.currentLocation.pathname,
        a = Da(t.nextLocation.pathname, n) || t.nextLocation.pathname;
    return py(r.pathname, a) != null || py(r.pathname, s) != null;
}
[...DU];
const ZU = () => {
    const [i, e] = K.useState(!1),
        [t, n] = K.useState(!1);
    K.useEffect(() => {
        const s = () => {
                e(!0), n(!0), setTimeout(() => n(!1), 3e3);
            },
            a = () => {
                e(!1), n(!0);
            };
        return (
            window.addEventListener('online', s),
            window.addEventListener('offline', a),
            () => {
                window.removeEventListener('online', s),
                    window.removeEventListener('offline', a);
            }
        );
    }, []);
    const r = () => {
        n(!1);
    };
    return t
        ? rt.jsx(rt.Fragment, {
              children: rt.jsxs('div', {
                  className: `ConnectionStatus ${i ? 'online' : 'offline'} font-poppins z-50 outline outline-offset-2 outline-slate-200`,
                  children: [
                      rt.jsx('div', { className: 'close-button', onClick: r }),
                      i
                          ? rt.jsxs('div', {
                                children: [
                                    rt.jsx('h1', {
                                        children: 'Connexion rétablie',
                                    }),
                                    rt.jsx('p', {
                                        children:
                                            'Votre connexion internet est rétablie.',
                                    }),
                                ],
                            })
                          : rt.jsxs('div', {
                                children: [
                                    rt.jsx('a', {
                                        className: 'rounded-xl',
                                        href: 'https://icons8.com/illustrations/author/7WmtYU90j36d',
                                        children: 'Illustration by Fruzka',
                                    }),
                                    rt.jsx('h1', {
                                        children: "Pas d'accès Internet",
                                    }),
                                    rt.jsx('p', {
                                        children:
                                            "Il semble que vous n'ayez actuellement pas accès à Internet. Nous vous recommandons de vérifier votre connexion Internet.",
                                    }),
                                ],
                            }),
                  ],
              }),
          })
        : null;
};
class Gd extends Error {}
Gd.prototype.name = 'InvalidTokenError';
function JU(i) {
    return decodeURIComponent(
        atob(i).replace(/(.)/g, (e, t) => {
            let n = t.charCodeAt(0).toString(16).toUpperCase();
            return n.length < 2 && (n = '0' + n), '%' + n;
        })
    );
}
function QU(i) {
    let e = i.replace(/-/g, '+').replace(/_/g, '/');
    switch (e.length % 4) {
        case 0:
            break;
        case 2:
            e += '==';
            break;
        case 3:
            e += '=';
            break;
        default:
            throw new Error('base64 string is not of the correct length');
    }
    try {
        return JU(e);
    } catch {
        return atob(e);
    }
}
function eO(i, e) {
    if (typeof i != 'string')
        throw new Gd('Invalid token specified: must be a string');
    e || (e = {});
    const t = e.header === !0 ? 0 : 1,
        n = i.split('.')[t];
    if (typeof n != 'string')
        throw new Gd(`Invalid token specified: missing part #${t + 1}`);
    let r;
    try {
        r = QU(n);
    } catch (s) {
        throw new Gd(
            `Invalid token specified: invalid base64 for part #${t + 1} (${s.message})`
        );
    }
    try {
        return JSON.parse(r);
    } catch (s) {
        throw new Gd(
            `Invalid token specified: invalid json for part #${t + 1} (${s.message})`
        );
    }
}
const tO = (i) => {
        try {
            if (!i) return null;
            const e = eO(i),
                t = Date.now() / 1e3;
            return e.exp && e.exp < t ? null : e;
        } catch (e) {
            return console.error('Error decoding token:', e), null;
        }
    },
    nO = () => {
        const i = localStorage.getItem('token'),
            e = tO(i);
        return !e || !e.data ? null : e.data;
    },
    iO = () => localStorage.getItem('token'),
    rO = () => {
        try {
            const i = nO();
            return i ? i.role : null;
        } catch (i) {
            return console.error('Error decoding token:', i), null;
        }
    },
    sO = ({ requiredRoles: i = [] }) => {
        const e = iO(),
            t = rO();
        return e
            ? i.length > 0 && !i.includes(t || '')
                ? rt.jsx(my, { to: '/redirect/not-authorized', replace: !0 })
                : rt.jsx(mU, {})
            : rt.jsx(my, { to: '/auth', replace: !0 });
    };
/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ const ov = '166',
    oO = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
    aO = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
    qC = 0,
    f_ = 1,
    $C = 2,
    lO = 3,
    YC = 0,
    av = 1,
    Zd = 2,
    io = 3,
    Na = 0,
    Er = 1,
    Lo = 2,
    Pa = 0,
    nc = 1,
    h_ = 2,
    d_ = 3,
    p_ = 4,
    KC = 5,
    Ll = 100,
    ZC = 101,
    JC = 102,
    QC = 103,
    eR = 104,
    tR = 200,
    nR = 201,
    iR = 202,
    rR = 203,
    gy = 204,
    yy = 205,
    sR = 206,
    oR = 207,
    aR = 208,
    lR = 209,
    uR = 210,
    cR = 211,
    fR = 212,
    hR = 213,
    dR = 214,
    pR = 0,
    mR = 1,
    gR = 2,
    yp = 3,
    yR = 4,
    vR = 5,
    xR = 6,
    _R = 7,
    qp = 0,
    SR = 1,
    wR = 2,
    Fo = 0,
    MR = 1,
    ER = 2,
    TR = 3,
    AS = 4,
    AR = 5,
    CR = 6,
    RR = 7,
    m_ = 'attached',
    bR = 'detached',
    lv = 300,
    Ua = 301,
    Nl = 302,
    vp = 303,
    xp = 304,
    wh = 306,
    _p = 1e3,
    Ms = 1001,
    Sp = 1002,
    Li = 1003,
    CS = 1004,
    uO = 1004,
    Jf = 1005,
    cO = 1005,
    hi = 1006,
    Jd = 1007,
    fO = 1007,
    Io = 1008,
    hO = 1008,
    ao = 1009,
    RS = 1010,
    bS = 1011,
    ch = 1012,
    uv = 1013,
    Oa = 1014,
    Vr = 1015,
    Mh = 1016,
    cv = 1017,
    fv = 1018,
    ac = 1020,
    PS = 35902,
    LS = 1021,
    IS = 1022,
    sr = 1023,
    DS = 1024,
    NS = 1025,
    ic = 1026,
    lc = 1027,
    hv = 1028,
    $p = 1029,
    US = 1030,
    dv = 1031,
    dO = 1032,
    pv = 1033,
    Qd = 33776,
    ep = 33777,
    tp = 33778,
    np = 33779,
    vy = 35840,
    xy = 35841,
    _y = 35842,
    Sy = 35843,
    wy = 36196,
    My = 37492,
    Ey = 37496,
    Ty = 37808,
    Ay = 37809,
    Cy = 37810,
    Ry = 37811,
    by = 37812,
    Py = 37813,
    Ly = 37814,
    Iy = 37815,
    Dy = 37816,
    Ny = 37817,
    Uy = 37818,
    Oy = 37819,
    ky = 37820,
    Fy = 37821,
    ip = 36492,
    By = 36494,
    zy = 36495,
    OS = 36283,
    Vy = 36284,
    Hy = 36285,
    Gy = 36286,
    PR = 2200,
    LR = 2201,
    IR = 2202,
    wp = 2300,
    Wy = 2301,
    oy = 2302,
    Yu = 2400,
    Ku = 2401,
    Mp = 2402,
    mv = 2500,
    kS = 2501,
    pO = 0,
    mO = 1,
    gO = 2,
    DR = 3200,
    NR = 3201,
    Bl = 0,
    UR = 1,
    Aa = '',
    ws = 'srgb',
    Fa = 'srgb-linear',
    gv = 'display-p3',
    Yp = 'display-p3-linear',
    Ep = 'linear',
    Pn = 'srgb',
    Tp = 'rec709',
    Ap = 'p3',
    yO = 0,
    Wu = 7680,
    vO = 7681,
    xO = 7682,
    _O = 7683,
    SO = 34055,
    wO = 34056,
    MO = 5386,
    EO = 512,
    TO = 513,
    AO = 514,
    CO = 515,
    RO = 516,
    bO = 517,
    PO = 518,
    g_ = 519,
    OR = 512,
    kR = 513,
    FR = 514,
    FS = 515,
    BR = 516,
    zR = 517,
    VR = 518,
    HR = 519,
    Cp = 35044,
    LO = 35048,
    IO = 35040,
    DO = 35045,
    NO = 35049,
    UO = 35041,
    OO = 35046,
    kO = 35050,
    FO = 35042,
    BO = '100',
    y_ = '300 es',
    Do = 2e3,
    Rp = 2001;
class Ba {
    addEventListener(e, t) {
        this._listeners === void 0 && (this._listeners = {});
        const n = this._listeners;
        n[e] === void 0 && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t);
    }
    hasEventListener(e, t) {
        if (this._listeners === void 0) return !1;
        const n = this._listeners;
        return n[e] !== void 0 && n[e].indexOf(t) !== -1;
    }
    removeEventListener(e, t) {
        if (this._listeners === void 0) return;
        const r = this._listeners[e];
        if (r !== void 0) {
            const s = r.indexOf(t);
            s !== -1 && r.splice(s, 1);
        }
    }
    dispatchEvent(e) {
        if (this._listeners === void 0) return;
        const n = this._listeners[e.type];
        if (n !== void 0) {
            e.target = this;
            const r = n.slice(0);
            for (let s = 0, a = r.length; s < a; s++) r[s].call(this, e);
            e.target = null;
        }
    }
}
const er = [
    '00',
    '01',
    '02',
    '03',
    '04',
    '05',
    '06',
    '07',
    '08',
    '09',
    '0a',
    '0b',
    '0c',
    '0d',
    '0e',
    '0f',
    '10',
    '11',
    '12',
    '13',
    '14',
    '15',
    '16',
    '17',
    '18',
    '19',
    '1a',
    '1b',
    '1c',
    '1d',
    '1e',
    '1f',
    '20',
    '21',
    '22',
    '23',
    '24',
    '25',
    '26',
    '27',
    '28',
    '29',
    '2a',
    '2b',
    '2c',
    '2d',
    '2e',
    '2f',
    '30',
    '31',
    '32',
    '33',
    '34',
    '35',
    '36',
    '37',
    '38',
    '39',
    '3a',
    '3b',
    '3c',
    '3d',
    '3e',
    '3f',
    '40',
    '41',
    '42',
    '43',
    '44',
    '45',
    '46',
    '47',
    '48',
    '49',
    '4a',
    '4b',
    '4c',
    '4d',
    '4e',
    '4f',
    '50',
    '51',
    '52',
    '53',
    '54',
    '55',
    '56',
    '57',
    '58',
    '59',
    '5a',
    '5b',
    '5c',
    '5d',
    '5e',
    '5f',
    '60',
    '61',
    '62',
    '63',
    '64',
    '65',
    '66',
    '67',
    '68',
    '69',
    '6a',
    '6b',
    '6c',
    '6d',
    '6e',
    '6f',
    '70',
    '71',
    '72',
    '73',
    '74',
    '75',
    '76',
    '77',
    '78',
    '79',
    '7a',
    '7b',
    '7c',
    '7d',
    '7e',
    '7f',
    '80',
    '81',
    '82',
    '83',
    '84',
    '85',
    '86',
    '87',
    '88',
    '89',
    '8a',
    '8b',
    '8c',
    '8d',
    '8e',
    '8f',
    '90',
    '91',
    '92',
    '93',
    '94',
    '95',
    '96',
    '97',
    '98',
    '99',
    '9a',
    '9b',
    '9c',
    '9d',
    '9e',
    '9f',
    'a0',
    'a1',
    'a2',
    'a3',
    'a4',
    'a5',
    'a6',
    'a7',
    'a8',
    'a9',
    'aa',
    'ab',
    'ac',
    'ad',
    'ae',
    'af',
    'b0',
    'b1',
    'b2',
    'b3',
    'b4',
    'b5',
    'b6',
    'b7',
    'b8',
    'b9',
    'ba',
    'bb',
    'bc',
    'bd',
    'be',
    'bf',
    'c0',
    'c1',
    'c2',
    'c3',
    'c4',
    'c5',
    'c6',
    'c7',
    'c8',
    'c9',
    'ca',
    'cb',
    'cc',
    'cd',
    'ce',
    'cf',
    'd0',
    'd1',
    'd2',
    'd3',
    'd4',
    'd5',
    'd6',
    'd7',
    'd8',
    'd9',
    'da',
    'db',
    'dc',
    'dd',
    'de',
    'df',
    'e0',
    'e1',
    'e2',
    'e3',
    'e4',
    'e5',
    'e6',
    'e7',
    'e8',
    'e9',
    'ea',
    'eb',
    'ec',
    'ed',
    'ee',
    'ef',
    'f0',
    'f1',
    'f2',
    'f3',
    'f4',
    'f5',
    'f6',
    'f7',
    'f8',
    'f9',
    'fa',
    'fb',
    'fc',
    'fd',
    'fe',
    'ff',
];
let R1 = 1234567;
const rc = Math.PI / 180,
    fh = 180 / Math.PI;
function os() {
    const i = (Math.random() * 4294967295) | 0,
        e = (Math.random() * 4294967295) | 0,
        t = (Math.random() * 4294967295) | 0,
        n = (Math.random() * 4294967295) | 0;
    return (
        er[i & 255] +
        er[(i >> 8) & 255] +
        er[(i >> 16) & 255] +
        er[(i >> 24) & 255] +
        '-' +
        er[e & 255] +
        er[(e >> 8) & 255] +
        '-' +
        er[((e >> 16) & 15) | 64] +
        er[(e >> 24) & 255] +
        '-' +
        er[(t & 63) | 128] +
        er[(t >> 8) & 255] +
        '-' +
        er[(t >> 16) & 255] +
        er[(t >> 24) & 255] +
        er[n & 255] +
        er[(n >> 8) & 255] +
        er[(n >> 16) & 255] +
        er[(n >> 24) & 255]
    ).toLowerCase();
}
function Jn(i, e, t) {
    return Math.max(e, Math.min(t, i));
}
function BS(i, e) {
    return ((i % e) + e) % e;
}
function zO(i, e, t, n, r) {
    return n + ((i - e) * (r - n)) / (t - e);
}
function VO(i, e, t) {
    return i !== e ? (t - i) / (e - i) : 0;
}
function rp(i, e, t) {
    return (1 - t) * i + t * e;
}
function HO(i, e, t, n) {
    return rp(i, e, 1 - Math.exp(-t * n));
}
function GO(i, e = 1) {
    return e - Math.abs(BS(i, e * 2) - e);
}
function WO(i, e, t) {
    return i <= e
        ? 0
        : i >= t
          ? 1
          : ((i = (i - e) / (t - e)), i * i * (3 - 2 * i));
}
function XO(i, e, t) {
    return i <= e
        ? 0
        : i >= t
          ? 1
          : ((i = (i - e) / (t - e)), i * i * i * (i * (i * 6 - 15) + 10));
}
function jO(i, e) {
    return i + Math.floor(Math.random() * (e - i + 1));
}
function qO(i, e) {
    return i + Math.random() * (e - i);
}
function $O(i) {
    return i * (0.5 - Math.random());
}
function YO(i) {
    i !== void 0 && (R1 = i);
    let e = (R1 += 1831565813);
    return (
        (e = Math.imul(e ^ (e >>> 15), e | 1)),
        (e ^= e + Math.imul(e ^ (e >>> 7), e | 61)),
        ((e ^ (e >>> 14)) >>> 0) / 4294967296
    );
}
function KO(i) {
    return i * rc;
}
function ZO(i) {
    return i * fh;
}
function JO(i) {
    return (i & (i - 1)) === 0 && i !== 0;
}
function QO(i) {
    return Math.pow(2, Math.ceil(Math.log(i) / Math.LN2));
}
function ek(i) {
    return Math.pow(2, Math.floor(Math.log(i) / Math.LN2));
}
function tk(i, e, t, n, r) {
    const s = Math.cos,
        a = Math.sin,
        l = s(t / 2),
        c = a(t / 2),
        d = s((e + n) / 2),
        p = a((e + n) / 2),
        g = s((e - n) / 2),
        y = a((e - n) / 2),
        v = s((n - e) / 2),
        S = a((n - e) / 2);
    switch (r) {
        case 'XYX':
            i.set(l * p, c * g, c * y, l * d);
            break;
        case 'YZY':
            i.set(c * y, l * p, c * g, l * d);
            break;
        case 'ZXZ':
            i.set(c * g, c * y, l * p, l * d);
            break;
        case 'XZX':
            i.set(l * p, c * S, c * v, l * d);
            break;
        case 'YXY':
            i.set(c * v, l * p, c * S, l * d);
            break;
        case 'ZYZ':
            i.set(c * S, c * v, l * p, l * d);
            break;
        default:
            console.warn(
                'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' +
                    r
            );
    }
}
function wr(i, e) {
    switch (e.constructor) {
        case Float32Array:
            return i;
        case Uint32Array:
            return i / 4294967295;
        case Uint16Array:
            return i / 65535;
        case Uint8Array:
            return i / 255;
        case Int32Array:
            return Math.max(i / 2147483647, -1);
        case Int16Array:
            return Math.max(i / 32767, -1);
        case Int8Array:
            return Math.max(i / 127, -1);
        default:
            throw new Error('Invalid component type.');
    }
}
function Xt(i, e) {
    switch (e.constructor) {
        case Float32Array:
            return i;
        case Uint32Array:
            return Math.round(i * 4294967295);
        case Uint16Array:
            return Math.round(i * 65535);
        case Uint8Array:
            return Math.round(i * 255);
        case Int32Array:
            return Math.round(i * 2147483647);
        case Int16Array:
            return Math.round(i * 32767);
        case Int8Array:
            return Math.round(i * 127);
        default:
            throw new Error('Invalid component type.');
    }
}
const GR = {
    DEG2RAD: rc,
    RAD2DEG: fh,
    generateUUID: os,
    clamp: Jn,
    euclideanModulo: BS,
    mapLinear: zO,
    inverseLerp: VO,
    lerp: rp,
    damp: HO,
    pingpong: GO,
    smoothstep: WO,
    smootherstep: XO,
    randInt: jO,
    randFloat: qO,
    randFloatSpread: $O,
    seededRandom: YO,
    degToRad: KO,
    radToDeg: ZO,
    isPowerOfTwo: JO,
    ceilPowerOfTwo: QO,
    floorPowerOfTwo: ek,
    setQuaternionFromProperEuler: tk,
    normalize: Xt,
    denormalize: wr,
};
class Ce {
    constructor(e = 0, t = 0) {
        (Ce.prototype.isVector2 = !0), (this.x = e), (this.y = t);
    }
    get width() {
        return this.x;
    }
    set width(e) {
        this.x = e;
    }
    get height() {
        return this.y;
    }
    set height(e) {
        this.y = e;
    }
    set(e, t) {
        return (this.x = e), (this.y = t), this;
    }
    setScalar(e) {
        return (this.x = e), (this.y = e), this;
    }
    setX(e) {
        return (this.x = e), this;
    }
    setY(e) {
        return (this.y = e), this;
    }
    setComponent(e, t) {
        switch (e) {
            case 0:
                this.x = t;
                break;
            case 1:
                this.y = t;
                break;
            default:
                throw new Error('index is out of range: ' + e);
        }
        return this;
    }
    getComponent(e) {
        switch (e) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            default:
                throw new Error('index is out of range: ' + e);
        }
    }
    clone() {
        return new this.constructor(this.x, this.y);
    }
    copy(e) {
        return (this.x = e.x), (this.y = e.y), this;
    }
    add(e) {
        return (this.x += e.x), (this.y += e.y), this;
    }
    addScalar(e) {
        return (this.x += e), (this.y += e), this;
    }
    addVectors(e, t) {
        return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
    }
    addScaledVector(e, t) {
        return (this.x += e.x * t), (this.y += e.y * t), this;
    }
    sub(e) {
        return (this.x -= e.x), (this.y -= e.y), this;
    }
    subScalar(e) {
        return (this.x -= e), (this.y -= e), this;
    }
    subVectors(e, t) {
        return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
    }
    multiply(e) {
        return (this.x *= e.x), (this.y *= e.y), this;
    }
    multiplyScalar(e) {
        return (this.x *= e), (this.y *= e), this;
    }
    divide(e) {
        return (this.x /= e.x), (this.y /= e.y), this;
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e);
    }
    applyMatrix3(e) {
        const t = this.x,
            n = this.y,
            r = e.elements;
        return (
            (this.x = r[0] * t + r[3] * n + r[6]),
            (this.y = r[1] * t + r[4] * n + r[7]),
            this
        );
    }
    min(e) {
        return (
            (this.x = Math.min(this.x, e.x)),
            (this.y = Math.min(this.y, e.y)),
            this
        );
    }
    max(e) {
        return (
            (this.x = Math.max(this.x, e.x)),
            (this.y = Math.max(this.y, e.y)),
            this
        );
    }
    clamp(e, t) {
        return (
            (this.x = Math.max(e.x, Math.min(t.x, this.x))),
            (this.y = Math.max(e.y, Math.min(t.y, this.y))),
            this
        );
    }
    clampScalar(e, t) {
        return (
            (this.x = Math.max(e, Math.min(t, this.x))),
            (this.y = Math.max(e, Math.min(t, this.y))),
            this
        );
    }
    clampLength(e, t) {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(
            Math.max(e, Math.min(t, n))
        );
    }
    floor() {
        return (
            (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this
        );
    }
    ceil() {
        return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
    }
    round() {
        return (
            (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this
        );
    }
    roundToZero() {
        return (
            (this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), this
        );
    }
    negate() {
        return (this.x = -this.x), (this.y = -this.y), this;
    }
    dot(e) {
        return this.x * e.x + this.y * e.y;
    }
    cross(e) {
        return this.x * e.y - this.y * e.x;
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y;
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y);
    }
    normalize() {
        return this.divideScalar(this.length() || 1);
    }
    angle() {
        return Math.atan2(-this.y, -this.x) + Math.PI;
    }
    angleTo(e) {
        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (t === 0) return Math.PI / 2;
        const n = this.dot(e) / t;
        return Math.acos(Jn(n, -1, 1));
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e));
    }
    distanceToSquared(e) {
        const t = this.x - e.x,
            n = this.y - e.y;
        return t * t + n * n;
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e);
    }
    lerp(e, t) {
        return (
            (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this
        );
    }
    lerpVectors(e, t, n) {
        return (
            (this.x = e.x + (t.x - e.x) * n),
            (this.y = e.y + (t.y - e.y) * n),
            this
        );
    }
    equals(e) {
        return e.x === this.x && e.y === this.y;
    }
    fromArray(e, t = 0) {
        return (this.x = e[t]), (this.y = e[t + 1]), this;
    }
    toArray(e = [], t = 0) {
        return (e[t] = this.x), (e[t + 1] = this.y), e;
    }
    fromBufferAttribute(e, t) {
        return (this.x = e.getX(t)), (this.y = e.getY(t)), this;
    }
    rotateAround(e, t) {
        const n = Math.cos(t),
            r = Math.sin(t),
            s = this.x - e.x,
            a = this.y - e.y;
        return (
            (this.x = s * n - a * r + e.x), (this.y = s * r + a * n + e.y), this
        );
    }
    random() {
        return (this.x = Math.random()), (this.y = Math.random()), this;
    }
    *[Symbol.iterator]() {
        yield this.x, yield this.y;
    }
}
class Wt {
    constructor(e, t, n, r, s, a, l, c, d) {
        (Wt.prototype.isMatrix3 = !0),
            (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
            e !== void 0 && this.set(e, t, n, r, s, a, l, c, d);
    }
    set(e, t, n, r, s, a, l, c, d) {
        const p = this.elements;
        return (
            (p[0] = e),
            (p[1] = r),
            (p[2] = l),
            (p[3] = t),
            (p[4] = s),
            (p[5] = c),
            (p[6] = n),
            (p[7] = a),
            (p[8] = d),
            this
        );
    }
    identity() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
    }
    copy(e) {
        const t = this.elements,
            n = e.elements;
        return (
            (t[0] = n[0]),
            (t[1] = n[1]),
            (t[2] = n[2]),
            (t[3] = n[3]),
            (t[4] = n[4]),
            (t[5] = n[5]),
            (t[6] = n[6]),
            (t[7] = n[7]),
            (t[8] = n[8]),
            this
        );
    }
    extractBasis(e, t, n) {
        return (
            e.setFromMatrix3Column(this, 0),
            t.setFromMatrix3Column(this, 1),
            n.setFromMatrix3Column(this, 2),
            this
        );
    }
    setFromMatrix4(e) {
        const t = e.elements;
        return (
            this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
            this
        );
    }
    multiply(e) {
        return this.multiplyMatrices(this, e);
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this);
    }
    multiplyMatrices(e, t) {
        const n = e.elements,
            r = t.elements,
            s = this.elements,
            a = n[0],
            l = n[3],
            c = n[6],
            d = n[1],
            p = n[4],
            g = n[7],
            y = n[2],
            v = n[5],
            S = n[8],
            T = r[0],
            M = r[3],
            w = r[6],
            b = r[1],
            C = r[4],
            L = r[7],
            F = r[2],
            N = r[5],
            B = r[8];
        return (
            (s[0] = a * T + l * b + c * F),
            (s[3] = a * M + l * C + c * N),
            (s[6] = a * w + l * L + c * B),
            (s[1] = d * T + p * b + g * F),
            (s[4] = d * M + p * C + g * N),
            (s[7] = d * w + p * L + g * B),
            (s[2] = y * T + v * b + S * F),
            (s[5] = y * M + v * C + S * N),
            (s[8] = y * w + v * L + S * B),
            this
        );
    }
    multiplyScalar(e) {
        const t = this.elements;
        return (
            (t[0] *= e),
            (t[3] *= e),
            (t[6] *= e),
            (t[1] *= e),
            (t[4] *= e),
            (t[7] *= e),
            (t[2] *= e),
            (t[5] *= e),
            (t[8] *= e),
            this
        );
    }
    determinant() {
        const e = this.elements,
            t = e[0],
            n = e[1],
            r = e[2],
            s = e[3],
            a = e[4],
            l = e[5],
            c = e[6],
            d = e[7],
            p = e[8];
        return (
            t * a * p -
            t * l * d -
            n * s * p +
            n * l * c +
            r * s * d -
            r * a * c
        );
    }
    invert() {
        const e = this.elements,
            t = e[0],
            n = e[1],
            r = e[2],
            s = e[3],
            a = e[4],
            l = e[5],
            c = e[6],
            d = e[7],
            p = e[8],
            g = p * a - l * d,
            y = l * c - p * s,
            v = d * s - a * c,
            S = t * g + n * y + r * v;
        if (S === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const T = 1 / S;
        return (
            (e[0] = g * T),
            (e[1] = (r * d - p * n) * T),
            (e[2] = (l * n - r * a) * T),
            (e[3] = y * T),
            (e[4] = (p * t - r * c) * T),
            (e[5] = (r * s - l * t) * T),
            (e[6] = v * T),
            (e[7] = (n * c - d * t) * T),
            (e[8] = (a * t - n * s) * T),
            this
        );
    }
    transpose() {
        let e;
        const t = this.elements;
        return (
            (e = t[1]),
            (t[1] = t[3]),
            (t[3] = e),
            (e = t[2]),
            (t[2] = t[6]),
            (t[6] = e),
            (e = t[5]),
            (t[5] = t[7]),
            (t[7] = e),
            this
        );
    }
    getNormalMatrix(e) {
        return this.setFromMatrix4(e).invert().transpose();
    }
    transposeIntoArray(e) {
        const t = this.elements;
        return (
            (e[0] = t[0]),
            (e[1] = t[3]),
            (e[2] = t[6]),
            (e[3] = t[1]),
            (e[4] = t[4]),
            (e[5] = t[7]),
            (e[6] = t[2]),
            (e[7] = t[5]),
            (e[8] = t[8]),
            this
        );
    }
    setUvTransform(e, t, n, r, s, a, l) {
        const c = Math.cos(s),
            d = Math.sin(s);
        return (
            this.set(
                n * c,
                n * d,
                -n * (c * a + d * l) + a + e,
                -r * d,
                r * c,
                -r * (-d * a + c * l) + l + t,
                0,
                0,
                1
            ),
            this
        );
    }
    scale(e, t) {
        return this.premultiply(z0.makeScale(e, t)), this;
    }
    rotate(e) {
        return this.premultiply(z0.makeRotation(-e)), this;
    }
    translate(e, t) {
        return this.premultiply(z0.makeTranslation(e, t)), this;
    }
    makeTranslation(e, t) {
        return (
            e.isVector2
                ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1)
                : this.set(1, 0, e, 0, 1, t, 0, 0, 1),
            this
        );
    }
    makeRotation(e) {
        const t = Math.cos(e),
            n = Math.sin(e);
        return this.set(t, -n, 0, n, t, 0, 0, 0, 1), this;
    }
    makeScale(e, t) {
        return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this;
    }
    equals(e) {
        const t = this.elements,
            n = e.elements;
        for (let r = 0; r < 9; r++) if (t[r] !== n[r]) return !1;
        return !0;
    }
    fromArray(e, t = 0) {
        for (let n = 0; n < 9; n++) this.elements[n] = e[n + t];
        return this;
    }
    toArray(e = [], t = 0) {
        const n = this.elements;
        return (
            (e[t] = n[0]),
            (e[t + 1] = n[1]),
            (e[t + 2] = n[2]),
            (e[t + 3] = n[3]),
            (e[t + 4] = n[4]),
            (e[t + 5] = n[5]),
            (e[t + 6] = n[6]),
            (e[t + 7] = n[7]),
            (e[t + 8] = n[8]),
            e
        );
    }
    clone() {
        return new this.constructor().fromArray(this.elements);
    }
}
const z0 = new Wt();
function WR(i) {
    for (let e = i.length - 1; e >= 0; --e) if (i[e] >= 65535) return !0;
    return !1;
}
const nk = {
    Int8Array,
    Uint8Array,
    Uint8ClampedArray,
    Int16Array,
    Uint16Array,
    Int32Array,
    Uint32Array,
    Float32Array,
    Float64Array,
};
function Qf(i, e) {
    return new nk[i](e);
}
function bp(i) {
    return document.createElementNS('http://www.w3.org/1999/xhtml', i);
}
function XR() {
    const i = bp('canvas');
    return (i.style.display = 'block'), i;
}
const b1 = {};
function zS(i) {
    i in b1 || ((b1[i] = !0), console.warn(i));
}
function ik(i, e, t) {
    return new Promise(function (n, r) {
        function s() {
            switch (i.clientWaitSync(e, i.SYNC_FLUSH_COMMANDS_BIT, 0)) {
                case i.WAIT_FAILED:
                    r();
                    break;
                case i.TIMEOUT_EXPIRED:
                    setTimeout(s, t);
                    break;
                default:
                    n();
            }
        }
        setTimeout(s, t);
    });
}
const P1 = new Wt().set(
        0.8224621,
        0.177538,
        0,
        0.0331941,
        0.9668058,
        0,
        0.0170827,
        0.0723974,
        0.9105199
    ),
    L1 = new Wt().set(
        1.2249401,
        -0.2249404,
        0,
        -0.0420569,
        1.0420571,
        0,
        -0.0196376,
        -0.0786361,
        1.0982735
    ),
    rg = {
        [Fa]: {
            transfer: Ep,
            primaries: Tp,
            toReference: (i) => i,
            fromReference: (i) => i,
        },
        [ws]: {
            transfer: Pn,
            primaries: Tp,
            toReference: (i) => i.convertSRGBToLinear(),
            fromReference: (i) => i.convertLinearToSRGB(),
        },
        [Yp]: {
            transfer: Ep,
            primaries: Ap,
            toReference: (i) => i.applyMatrix3(L1),
            fromReference: (i) => i.applyMatrix3(P1),
        },
        [gv]: {
            transfer: Pn,
            primaries: Ap,
            toReference: (i) => i.convertSRGBToLinear().applyMatrix3(L1),
            fromReference: (i) => i.applyMatrix3(P1).convertLinearToSRGB(),
        },
    },
    rk = new Set([Fa, Yp]),
    hn = {
        enabled: !0,
        _workingColorSpace: Fa,
        get workingColorSpace() {
            return this._workingColorSpace;
        },
        set workingColorSpace(i) {
            if (!rk.has(i))
                throw new Error(`Unsupported working color space, "${i}".`);
            this._workingColorSpace = i;
        },
        convert: function (i, e, t) {
            if (this.enabled === !1 || e === t || !e || !t) return i;
            const n = rg[e].toReference,
                r = rg[t].fromReference;
            return r(n(i));
        },
        fromWorkingColorSpace: function (i, e) {
            return this.convert(i, this._workingColorSpace, e);
        },
        toWorkingColorSpace: function (i, e) {
            return this.convert(i, e, this._workingColorSpace);
        },
        getPrimaries: function (i) {
            return rg[i].primaries;
        },
        getTransfer: function (i) {
            return i === Aa ? Ep : rg[i].transfer;
        },
    };
function sh(i) {
    return i < 0.04045
        ? i * 0.0773993808
        : Math.pow(i * 0.9478672986 + 0.0521327014, 2.4);
}
function V0(i) {
    return i < 0.0031308 ? i * 12.92 : 1.055 * Math.pow(i, 0.41666) - 0.055;
}
let yf;
class jR {
    static getDataURL(e) {
        if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > 'u')
            return e.src;
        let t;
        if (e instanceof HTMLCanvasElement) t = e;
        else {
            yf === void 0 && (yf = bp('canvas')),
                (yf.width = e.width),
                (yf.height = e.height);
            const n = yf.getContext('2d');
            e instanceof ImageData
                ? n.putImageData(e, 0, 0)
                : n.drawImage(e, 0, 0, e.width, e.height),
                (t = yf);
        }
        return t.width > 2048 || t.height > 2048
            ? (console.warn(
                  'THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons',
                  e
              ),
              t.toDataURL('image/jpeg', 0.6))
            : t.toDataURL('image/png');
    }
    static sRGBToLinear(e) {
        if (
            (typeof HTMLImageElement < 'u' && e instanceof HTMLImageElement) ||
            (typeof HTMLCanvasElement < 'u' &&
                e instanceof HTMLCanvasElement) ||
            (typeof ImageBitmap < 'u' && e instanceof ImageBitmap)
        ) {
            const t = bp('canvas');
            (t.width = e.width), (t.height = e.height);
            const n = t.getContext('2d');
            n.drawImage(e, 0, 0, e.width, e.height);
            const r = n.getImageData(0, 0, e.width, e.height),
                s = r.data;
            for (let a = 0; a < s.length; a++) s[a] = sh(s[a] / 255) * 255;
            return n.putImageData(r, 0, 0), t;
        } else if (e.data) {
            const t = e.data.slice(0);
            for (let n = 0; n < t.length; n++)
                t instanceof Uint8Array || t instanceof Uint8ClampedArray
                    ? (t[n] = Math.floor(sh(t[n] / 255) * 255))
                    : (t[n] = sh(t[n]));
            return { data: t, width: e.width, height: e.height };
        } else
            return (
                console.warn(
                    'THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.'
                ),
                e
            );
    }
}
let sk = 0;
class Zu {
    constructor(e = null) {
        (this.isSource = !0),
            Object.defineProperty(this, 'id', { value: sk++ }),
            (this.uuid = os()),
            (this.data = e),
            (this.dataReady = !0),
            (this.version = 0);
    }
    set needsUpdate(e) {
        e === !0 && this.version++;
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == 'string';
        if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
        const n = { uuid: this.uuid, url: '' },
            r = this.data;
        if (r !== null) {
            let s;
            if (Array.isArray(r)) {
                s = [];
                for (let a = 0, l = r.length; a < l; a++)
                    r[a].isDataTexture
                        ? s.push(H0(r[a].image))
                        : s.push(H0(r[a]));
            } else s = H0(r);
            n.url = s;
        }
        return t || (e.images[this.uuid] = n), n;
    }
}
function H0(i) {
    return (typeof HTMLImageElement < 'u' && i instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement < 'u' && i instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap < 'u' && i instanceof ImageBitmap)
        ? jR.getDataURL(i)
        : i.data
          ? {
                data: Array.from(i.data),
                width: i.width,
                height: i.height,
                type: i.data.constructor.name,
            }
          : (console.warn('THREE.Texture: Unable to serialize Texture.'), {});
}
let ok = 0;
class Qn extends Ba {
    constructor(
        e = Qn.DEFAULT_IMAGE,
        t = Qn.DEFAULT_MAPPING,
        n = Ms,
        r = Ms,
        s = hi,
        a = Io,
        l = sr,
        c = ao,
        d = Qn.DEFAULT_ANISOTROPY,
        p = Aa
    ) {
        super(),
            (this.isTexture = !0),
            Object.defineProperty(this, 'id', { value: ok++ }),
            (this.uuid = os()),
            (this.name = ''),
            (this.source = new Zu(e)),
            (this.mipmaps = []),
            (this.mapping = t),
            (this.channel = 0),
            (this.wrapS = n),
            (this.wrapT = r),
            (this.magFilter = s),
            (this.minFilter = a),
            (this.anisotropy = d),
            (this.format = l),
            (this.internalFormat = null),
            (this.type = c),
            (this.offset = new Ce(0, 0)),
            (this.repeat = new Ce(1, 1)),
            (this.center = new Ce(0, 0)),
            (this.rotation = 0),
            (this.matrixAutoUpdate = !0),
            (this.matrix = new Wt()),
            (this.generateMipmaps = !0),
            (this.premultiplyAlpha = !1),
            (this.flipY = !0),
            (this.unpackAlignment = 4),
            (this.colorSpace = p),
            (this.userData = {}),
            (this.version = 0),
            (this.onUpdate = null),
            (this.isRenderTargetTexture = !1),
            (this.pmremVersion = 0);
    }
    get image() {
        return this.source.data;
    }
    set image(e = null) {
        this.source.data = e;
    }
    updateMatrix() {
        this.matrix.setUvTransform(
            this.offset.x,
            this.offset.y,
            this.repeat.x,
            this.repeat.y,
            this.rotation,
            this.center.x,
            this.center.y
        );
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(e) {
        return (
            (this.name = e.name),
            (this.source = e.source),
            (this.mipmaps = e.mipmaps.slice(0)),
            (this.mapping = e.mapping),
            (this.channel = e.channel),
            (this.wrapS = e.wrapS),
            (this.wrapT = e.wrapT),
            (this.magFilter = e.magFilter),
            (this.minFilter = e.minFilter),
            (this.anisotropy = e.anisotropy),
            (this.format = e.format),
            (this.internalFormat = e.internalFormat),
            (this.type = e.type),
            this.offset.copy(e.offset),
            this.repeat.copy(e.repeat),
            this.center.copy(e.center),
            (this.rotation = e.rotation),
            (this.matrixAutoUpdate = e.matrixAutoUpdate),
            this.matrix.copy(e.matrix),
            (this.generateMipmaps = e.generateMipmaps),
            (this.premultiplyAlpha = e.premultiplyAlpha),
            (this.flipY = e.flipY),
            (this.unpackAlignment = e.unpackAlignment),
            (this.colorSpace = e.colorSpace),
            (this.userData = JSON.parse(JSON.stringify(e.userData))),
            (this.needsUpdate = !0),
            this
        );
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == 'string';
        if (!t && e.textures[this.uuid] !== void 0)
            return e.textures[this.uuid];
        const n = {
            metadata: {
                version: 4.6,
                type: 'Texture',
                generator: 'Texture.toJSON',
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(e).uuid,
            mapping: this.mapping,
            channel: this.channel,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            internalFormat: this.internalFormat,
            type: this.type,
            colorSpace: this.colorSpace,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            generateMipmaps: this.generateMipmaps,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment,
        };
        return (
            Object.keys(this.userData).length > 0 &&
                (n.userData = this.userData),
            t || (e.textures[this.uuid] = n),
            n
        );
    }
    dispose() {
        this.dispatchEvent({ type: 'dispose' });
    }
    transformUv(e) {
        if (this.mapping !== lv) return e;
        if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
            switch (this.wrapS) {
                case _p:
                    e.x = e.x - Math.floor(e.x);
                    break;
                case Ms:
                    e.x = e.x < 0 ? 0 : 1;
                    break;
                case Sp:
                    Math.abs(Math.floor(e.x) % 2) === 1
                        ? (e.x = Math.ceil(e.x) - e.x)
                        : (e.x = e.x - Math.floor(e.x));
                    break;
            }
        if (e.y < 0 || e.y > 1)
            switch (this.wrapT) {
                case _p:
                    e.y = e.y - Math.floor(e.y);
                    break;
                case Ms:
                    e.y = e.y < 0 ? 0 : 1;
                    break;
                case Sp:
                    Math.abs(Math.floor(e.y) % 2) === 1
                        ? (e.y = Math.ceil(e.y) - e.y)
                        : (e.y = e.y - Math.floor(e.y));
                    break;
            }
        return this.flipY && (e.y = 1 - e.y), e;
    }
    set needsUpdate(e) {
        e === !0 && (this.version++, (this.source.needsUpdate = !0));
    }
    set needsPMREMUpdate(e) {
        e === !0 && this.pmremVersion++;
    }
}
Qn.DEFAULT_IMAGE = null;
Qn.DEFAULT_MAPPING = lv;
Qn.DEFAULT_ANISOTROPY = 1;
class gn {
    constructor(e = 0, t = 0, n = 0, r = 1) {
        (gn.prototype.isVector4 = !0),
            (this.x = e),
            (this.y = t),
            (this.z = n),
            (this.w = r);
    }
    get width() {
        return this.z;
    }
    set width(e) {
        this.z = e;
    }
    get height() {
        return this.w;
    }
    set height(e) {
        this.w = e;
    }
    set(e, t, n, r) {
        return (this.x = e), (this.y = t), (this.z = n), (this.w = r), this;
    }
    setScalar(e) {
        return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
    }
    setX(e) {
        return (this.x = e), this;
    }
    setY(e) {
        return (this.y = e), this;
    }
    setZ(e) {
        return (this.z = e), this;
    }
    setW(e) {
        return (this.w = e), this;
    }
    setComponent(e, t) {
        switch (e) {
            case 0:
                this.x = t;
                break;
            case 1:
                this.y = t;
                break;
            case 2:
                this.z = t;
                break;
            case 3:
                this.w = t;
                break;
            default:
                throw new Error('index is out of range: ' + e);
        }
        return this;
    }
    getComponent(e) {
        switch (e) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            case 3:
                return this.w;
            default:
                throw new Error('index is out of range: ' + e);
        }
    }
    clone() {
        return new this.constructor(this.x, this.y, this.z, this.w);
    }
    copy(e) {
        return (
            (this.x = e.x),
            (this.y = e.y),
            (this.z = e.z),
            (this.w = e.w !== void 0 ? e.w : 1),
            this
        );
    }
    add(e) {
        return (
            (this.x += e.x),
            (this.y += e.y),
            (this.z += e.z),
            (this.w += e.w),
            this
        );
    }
    addScalar(e) {
        return (this.x += e), (this.y += e), (this.z += e), (this.w += e), this;
    }
    addVectors(e, t) {
        return (
            (this.x = e.x + t.x),
            (this.y = e.y + t.y),
            (this.z = e.z + t.z),
            (this.w = e.w + t.w),
            this
        );
    }
    addScaledVector(e, t) {
        return (
            (this.x += e.x * t),
            (this.y += e.y * t),
            (this.z += e.z * t),
            (this.w += e.w * t),
            this
        );
    }
    sub(e) {
        return (
            (this.x -= e.x),
            (this.y -= e.y),
            (this.z -= e.z),
            (this.w -= e.w),
            this
        );
    }
    subScalar(e) {
        return (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this;
    }
    subVectors(e, t) {
        return (
            (this.x = e.x - t.x),
            (this.y = e.y - t.y),
            (this.z = e.z - t.z),
            (this.w = e.w - t.w),
            this
        );
    }
    multiply(e) {
        return (
            (this.x *= e.x),
            (this.y *= e.y),
            (this.z *= e.z),
            (this.w *= e.w),
            this
        );
    }
    multiplyScalar(e) {
        return (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this;
    }
    applyMatrix4(e) {
        const t = this.x,
            n = this.y,
            r = this.z,
            s = this.w,
            a = e.elements;
        return (
            (this.x = a[0] * t + a[4] * n + a[8] * r + a[12] * s),
            (this.y = a[1] * t + a[5] * n + a[9] * r + a[13] * s),
            (this.z = a[2] * t + a[6] * n + a[10] * r + a[14] * s),
            (this.w = a[3] * t + a[7] * n + a[11] * r + a[15] * s),
            this
        );
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e);
    }
    setAxisAngleFromQuaternion(e) {
        this.w = 2 * Math.acos(e.w);
        const t = Math.sqrt(1 - e.w * e.w);
        return (
            t < 1e-4
                ? ((this.x = 1), (this.y = 0), (this.z = 0))
                : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
            this
        );
    }
    setAxisAngleFromRotationMatrix(e) {
        let t, n, r, s;
        const c = e.elements,
            d = c[0],
            p = c[4],
            g = c[8],
            y = c[1],
            v = c[5],
            S = c[9],
            T = c[2],
            M = c[6],
            w = c[10];
        if (
            Math.abs(p - y) < 0.01 &&
            Math.abs(g - T) < 0.01 &&
            Math.abs(S - M) < 0.01
        ) {
            if (
                Math.abs(p + y) < 0.1 &&
                Math.abs(g + T) < 0.1 &&
                Math.abs(S + M) < 0.1 &&
                Math.abs(d + v + w - 3) < 0.1
            )
                return this.set(1, 0, 0, 0), this;
            t = Math.PI;
            const C = (d + 1) / 2,
                L = (v + 1) / 2,
                F = (w + 1) / 2,
                N = (p + y) / 4,
                B = (g + T) / 4,
                z = (S + M) / 4;
            return (
                C > L && C > F
                    ? C < 0.01
                        ? ((n = 0), (r = 0.707106781), (s = 0.707106781))
                        : ((n = Math.sqrt(C)), (r = N / n), (s = B / n))
                    : L > F
                      ? L < 0.01
                          ? ((n = 0.707106781), (r = 0), (s = 0.707106781))
                          : ((r = Math.sqrt(L)), (n = N / r), (s = z / r))
                      : F < 0.01
                        ? ((n = 0.707106781), (r = 0.707106781), (s = 0))
                        : ((s = Math.sqrt(F)), (n = B / s), (r = z / s)),
                this.set(n, r, s, t),
                this
            );
        }
        let b = Math.sqrt(
            (M - S) * (M - S) + (g - T) * (g - T) + (y - p) * (y - p)
        );
        return (
            Math.abs(b) < 0.001 && (b = 1),
            (this.x = (M - S) / b),
            (this.y = (g - T) / b),
            (this.z = (y - p) / b),
            (this.w = Math.acos((d + v + w - 1) / 2)),
            this
        );
    }
    setFromMatrixPosition(e) {
        const t = e.elements;
        return (
            (this.x = t[12]),
            (this.y = t[13]),
            (this.z = t[14]),
            (this.w = t[15]),
            this
        );
    }
    min(e) {
        return (
            (this.x = Math.min(this.x, e.x)),
            (this.y = Math.min(this.y, e.y)),
            (this.z = Math.min(this.z, e.z)),
            (this.w = Math.min(this.w, e.w)),
            this
        );
    }
    max(e) {
        return (
            (this.x = Math.max(this.x, e.x)),
            (this.y = Math.max(this.y, e.y)),
            (this.z = Math.max(this.z, e.z)),
            (this.w = Math.max(this.w, e.w)),
            this
        );
    }
    clamp(e, t) {
        return (
            (this.x = Math.max(e.x, Math.min(t.x, this.x))),
            (this.y = Math.max(e.y, Math.min(t.y, this.y))),
            (this.z = Math.max(e.z, Math.min(t.z, this.z))),
            (this.w = Math.max(e.w, Math.min(t.w, this.w))),
            this
        );
    }
    clampScalar(e, t) {
        return (
            (this.x = Math.max(e, Math.min(t, this.x))),
            (this.y = Math.max(e, Math.min(t, this.y))),
            (this.z = Math.max(e, Math.min(t, this.z))),
            (this.w = Math.max(e, Math.min(t, this.w))),
            this
        );
    }
    clampLength(e, t) {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(
            Math.max(e, Math.min(t, n))
        );
    }
    floor() {
        return (
            (this.x = Math.floor(this.x)),
            (this.y = Math.floor(this.y)),
            (this.z = Math.floor(this.z)),
            (this.w = Math.floor(this.w)),
            this
        );
    }
    ceil() {
        return (
            (this.x = Math.ceil(this.x)),
            (this.y = Math.ceil(this.y)),
            (this.z = Math.ceil(this.z)),
            (this.w = Math.ceil(this.w)),
            this
        );
    }
    round() {
        return (
            (this.x = Math.round(this.x)),
            (this.y = Math.round(this.y)),
            (this.z = Math.round(this.z)),
            (this.w = Math.round(this.w)),
            this
        );
    }
    roundToZero() {
        return (
            (this.x = Math.trunc(this.x)),
            (this.y = Math.trunc(this.y)),
            (this.z = Math.trunc(this.z)),
            (this.w = Math.trunc(this.w)),
            this
        );
    }
    negate() {
        return (
            (this.x = -this.x),
            (this.y = -this.y),
            (this.z = -this.z),
            (this.w = -this.w),
            this
        );
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
    }
    lengthSq() {
        return (
            this.x * this.x +
            this.y * this.y +
            this.z * this.z +
            this.w * this.w
        );
    }
    length() {
        return Math.sqrt(
            this.x * this.x +
                this.y * this.y +
                this.z * this.z +
                this.w * this.w
        );
    }
    manhattanLength() {
        return (
            Math.abs(this.x) +
            Math.abs(this.y) +
            Math.abs(this.z) +
            Math.abs(this.w)
        );
    }
    normalize() {
        return this.divideScalar(this.length() || 1);
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e);
    }
    lerp(e, t) {
        return (
            (this.x += (e.x - this.x) * t),
            (this.y += (e.y - this.y) * t),
            (this.z += (e.z - this.z) * t),
            (this.w += (e.w - this.w) * t),
            this
        );
    }
    lerpVectors(e, t, n) {
        return (
            (this.x = e.x + (t.x - e.x) * n),
            (this.y = e.y + (t.y - e.y) * n),
            (this.z = e.z + (t.z - e.z) * n),
            (this.w = e.w + (t.w - e.w) * n),
            this
        );
    }
    equals(e) {
        return (
            e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
        );
    }
    fromArray(e, t = 0) {
        return (
            (this.x = e[t]),
            (this.y = e[t + 1]),
            (this.z = e[t + 2]),
            (this.w = e[t + 3]),
            this
        );
    }
    toArray(e = [], t = 0) {
        return (
            (e[t] = this.x),
            (e[t + 1] = this.y),
            (e[t + 2] = this.z),
            (e[t + 3] = this.w),
            e
        );
    }
    fromBufferAttribute(e, t) {
        return (
            (this.x = e.getX(t)),
            (this.y = e.getY(t)),
            (this.z = e.getZ(t)),
            (this.w = e.getW(t)),
            this
        );
    }
    random() {
        return (
            (this.x = Math.random()),
            (this.y = Math.random()),
            (this.z = Math.random()),
            (this.w = Math.random()),
            this
        );
    }
    *[Symbol.iterator]() {
        yield this.x, yield this.y, yield this.z, yield this.w;
    }
}
class qR extends Ba {
    constructor(e = 1, t = 1, n = {}) {
        super(),
            (this.isRenderTarget = !0),
            (this.width = e),
            (this.height = t),
            (this.depth = 1),
            (this.scissor = new gn(0, 0, e, t)),
            (this.scissorTest = !1),
            (this.viewport = new gn(0, 0, e, t));
        const r = { width: e, height: t, depth: 1 };
        n = Object.assign(
            {
                generateMipmaps: !1,
                internalFormat: null,
                minFilter: hi,
                depthBuffer: !0,
                stencilBuffer: !1,
                resolveDepthBuffer: !0,
                resolveStencilBuffer: !0,
                depthTexture: null,
                samples: 0,
                count: 1,
            },
            n
        );
        const s = new Qn(
            r,
            n.mapping,
            n.wrapS,
            n.wrapT,
            n.magFilter,
            n.minFilter,
            n.format,
            n.type,
            n.anisotropy,
            n.colorSpace
        );
        (s.flipY = !1),
            (s.generateMipmaps = n.generateMipmaps),
            (s.internalFormat = n.internalFormat),
            (this.textures = []);
        const a = n.count;
        for (let l = 0; l < a; l++)
            (this.textures[l] = s.clone()),
                (this.textures[l].isRenderTargetTexture = !0);
        (this.depthBuffer = n.depthBuffer),
            (this.stencilBuffer = n.stencilBuffer),
            (this.resolveDepthBuffer = n.resolveDepthBuffer),
            (this.resolveStencilBuffer = n.resolveStencilBuffer),
            (this.depthTexture = n.depthTexture),
            (this.samples = n.samples);
    }
    get texture() {
        return this.textures[0];
    }
    set texture(e) {
        this.textures[0] = e;
    }
    setSize(e, t, n = 1) {
        if (this.width !== e || this.height !== t || this.depth !== n) {
            (this.width = e), (this.height = t), (this.depth = n);
            for (let r = 0, s = this.textures.length; r < s; r++)
                (this.textures[r].image.width = e),
                    (this.textures[r].image.height = t),
                    (this.textures[r].image.depth = n);
            this.dispose();
        }
        this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(e) {
        (this.width = e.width),
            (this.height = e.height),
            (this.depth = e.depth),
            this.scissor.copy(e.scissor),
            (this.scissorTest = e.scissorTest),
            this.viewport.copy(e.viewport),
            (this.textures.length = 0);
        for (let n = 0, r = e.textures.length; n < r; n++)
            (this.textures[n] = e.textures[n].clone()),
                (this.textures[n].isRenderTargetTexture = !0);
        const t = Object.assign({}, e.texture.image);
        return (
            (this.texture.source = new Zu(t)),
            (this.depthBuffer = e.depthBuffer),
            (this.stencilBuffer = e.stencilBuffer),
            (this.resolveDepthBuffer = e.resolveDepthBuffer),
            (this.resolveStencilBuffer = e.resolveStencilBuffer),
            e.depthTexture !== null &&
                (this.depthTexture = e.depthTexture.clone()),
            (this.samples = e.samples),
            this
        );
    }
    dispose() {
        this.dispatchEvent({ type: 'dispose' });
    }
}
class lo extends qR {
    constructor(e = 1, t = 1, n = {}) {
        super(e, t, n), (this.isWebGLRenderTarget = !0);
    }
}
class yv extends Qn {
    constructor(e = null, t = 1, n = 1, r = 1) {
        super(null),
            (this.isDataArrayTexture = !0),
            (this.image = { data: e, width: t, height: n, depth: r }),
            (this.magFilter = Li),
            (this.minFilter = Li),
            (this.wrapR = Ms),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1),
            (this.layerUpdates = new Set());
    }
    addLayerUpdate(e) {
        this.layerUpdates.add(e);
    }
    clearLayerUpdates() {
        this.layerUpdates.clear();
    }
}
class ak extends lo {
    constructor(e = 1, t = 1, n = 1, r = {}) {
        super(e, t, r),
            (this.isWebGLArrayRenderTarget = !0),
            (this.depth = n),
            (this.texture = new yv(null, e, t, n)),
            (this.texture.isRenderTargetTexture = !0);
    }
}
class VS extends Qn {
    constructor(e = null, t = 1, n = 1, r = 1) {
        super(null),
            (this.isData3DTexture = !0),
            (this.image = { data: e, width: t, height: n, depth: r }),
            (this.magFilter = Li),
            (this.minFilter = Li),
            (this.wrapR = Ms),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1);
    }
}
class lk extends lo {
    constructor(e = 1, t = 1, n = 1, r = {}) {
        super(e, t, r),
            (this.isWebGL3DRenderTarget = !0),
            (this.depth = n),
            (this.texture = new VS(null, e, t, n)),
            (this.texture.isRenderTargetTexture = !0);
    }
}
class Hr {
    constructor(e = 0, t = 0, n = 0, r = 1) {
        (this.isQuaternion = !0),
            (this._x = e),
            (this._y = t),
            (this._z = n),
            (this._w = r);
    }
    static slerpFlat(e, t, n, r, s, a, l) {
        let c = n[r + 0],
            d = n[r + 1],
            p = n[r + 2],
            g = n[r + 3];
        const y = s[a + 0],
            v = s[a + 1],
            S = s[a + 2],
            T = s[a + 3];
        if (l === 0) {
            (e[t + 0] = c), (e[t + 1] = d), (e[t + 2] = p), (e[t + 3] = g);
            return;
        }
        if (l === 1) {
            (e[t + 0] = y), (e[t + 1] = v), (e[t + 2] = S), (e[t + 3] = T);
            return;
        }
        if (g !== T || c !== y || d !== v || p !== S) {
            let M = 1 - l;
            const w = c * y + d * v + p * S + g * T,
                b = w >= 0 ? 1 : -1,
                C = 1 - w * w;
            if (C > Number.EPSILON) {
                const F = Math.sqrt(C),
                    N = Math.atan2(F, w * b);
                (M = Math.sin(M * N) / F), (l = Math.sin(l * N) / F);
            }
            const L = l * b;
            if (
                ((c = c * M + y * L),
                (d = d * M + v * L),
                (p = p * M + S * L),
                (g = g * M + T * L),
                M === 1 - l)
            ) {
                const F = 1 / Math.sqrt(c * c + d * d + p * p + g * g);
                (c *= F), (d *= F), (p *= F), (g *= F);
            }
        }
        (e[t] = c), (e[t + 1] = d), (e[t + 2] = p), (e[t + 3] = g);
    }
    static multiplyQuaternionsFlat(e, t, n, r, s, a) {
        const l = n[r],
            c = n[r + 1],
            d = n[r + 2],
            p = n[r + 3],
            g = s[a],
            y = s[a + 1],
            v = s[a + 2],
            S = s[a + 3];
        return (
            (e[t] = l * S + p * g + c * v - d * y),
            (e[t + 1] = c * S + p * y + d * g - l * v),
            (e[t + 2] = d * S + p * v + l * y - c * g),
            (e[t + 3] = p * S - l * g - c * y - d * v),
            e
        );
    }
    get x() {
        return this._x;
    }
    set x(e) {
        (this._x = e), this._onChangeCallback();
    }
    get y() {
        return this._y;
    }
    set y(e) {
        (this._y = e), this._onChangeCallback();
    }
    get z() {
        return this._z;
    }
    set z(e) {
        (this._z = e), this._onChangeCallback();
    }
    get w() {
        return this._w;
    }
    set w(e) {
        (this._w = e), this._onChangeCallback();
    }
    set(e, t, n, r) {
        return (
            (this._x = e),
            (this._y = t),
            (this._z = n),
            (this._w = r),
            this._onChangeCallback(),
            this
        );
    }
    clone() {
        return new this.constructor(this._x, this._y, this._z, this._w);
    }
    copy(e) {
        return (
            (this._x = e.x),
            (this._y = e.y),
            (this._z = e.z),
            (this._w = e.w),
            this._onChangeCallback(),
            this
        );
    }
    setFromEuler(e, t = !0) {
        const n = e._x,
            r = e._y,
            s = e._z,
            a = e._order,
            l = Math.cos,
            c = Math.sin,
            d = l(n / 2),
            p = l(r / 2),
            g = l(s / 2),
            y = c(n / 2),
            v = c(r / 2),
            S = c(s / 2);
        switch (a) {
            case 'XYZ':
                (this._x = y * p * g + d * v * S),
                    (this._y = d * v * g - y * p * S),
                    (this._z = d * p * S + y * v * g),
                    (this._w = d * p * g - y * v * S);
                break;
            case 'YXZ':
                (this._x = y * p * g + d * v * S),
                    (this._y = d * v * g - y * p * S),
                    (this._z = d * p * S - y * v * g),
                    (this._w = d * p * g + y * v * S);
                break;
            case 'ZXY':
                (this._x = y * p * g - d * v * S),
                    (this._y = d * v * g + y * p * S),
                    (this._z = d * p * S + y * v * g),
                    (this._w = d * p * g - y * v * S);
                break;
            case 'ZYX':
                (this._x = y * p * g - d * v * S),
                    (this._y = d * v * g + y * p * S),
                    (this._z = d * p * S - y * v * g),
                    (this._w = d * p * g + y * v * S);
                break;
            case 'YZX':
                (this._x = y * p * g + d * v * S),
                    (this._y = d * v * g + y * p * S),
                    (this._z = d * p * S - y * v * g),
                    (this._w = d * p * g - y * v * S);
                break;
            case 'XZY':
                (this._x = y * p * g - d * v * S),
                    (this._y = d * v * g - y * p * S),
                    (this._z = d * p * S + y * v * g),
                    (this._w = d * p * g + y * v * S);
                break;
            default:
                console.warn(
                    'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' +
                        a
                );
        }
        return t === !0 && this._onChangeCallback(), this;
    }
    setFromAxisAngle(e, t) {
        const n = t / 2,
            r = Math.sin(n);
        return (
            (this._x = e.x * r),
            (this._y = e.y * r),
            (this._z = e.z * r),
            (this._w = Math.cos(n)),
            this._onChangeCallback(),
            this
        );
    }
    setFromRotationMatrix(e) {
        const t = e.elements,
            n = t[0],
            r = t[4],
            s = t[8],
            a = t[1],
            l = t[5],
            c = t[9],
            d = t[2],
            p = t[6],
            g = t[10],
            y = n + l + g;
        if (y > 0) {
            const v = 0.5 / Math.sqrt(y + 1);
            (this._w = 0.25 / v),
                (this._x = (p - c) * v),
                (this._y = (s - d) * v),
                (this._z = (a - r) * v);
        } else if (n > l && n > g) {
            const v = 2 * Math.sqrt(1 + n - l - g);
            (this._w = (p - c) / v),
                (this._x = 0.25 * v),
                (this._y = (r + a) / v),
                (this._z = (s + d) / v);
        } else if (l > g) {
            const v = 2 * Math.sqrt(1 + l - n - g);
            (this._w = (s - d) / v),
                (this._x = (r + a) / v),
                (this._y = 0.25 * v),
                (this._z = (c + p) / v);
        } else {
            const v = 2 * Math.sqrt(1 + g - n - l);
            (this._w = (a - r) / v),
                (this._x = (s + d) / v),
                (this._y = (c + p) / v),
                (this._z = 0.25 * v);
        }
        return this._onChangeCallback(), this;
    }
    setFromUnitVectors(e, t) {
        let n = e.dot(t) + 1;
        return (
            n < Number.EPSILON
                ? ((n = 0),
                  Math.abs(e.x) > Math.abs(e.z)
                      ? ((this._x = -e.y),
                        (this._y = e.x),
                        (this._z = 0),
                        (this._w = n))
                      : ((this._x = 0),
                        (this._y = -e.z),
                        (this._z = e.y),
                        (this._w = n)))
                : ((this._x = e.y * t.z - e.z * t.y),
                  (this._y = e.z * t.x - e.x * t.z),
                  (this._z = e.x * t.y - e.y * t.x),
                  (this._w = n)),
            this.normalize()
        );
    }
    angleTo(e) {
        return 2 * Math.acos(Math.abs(Jn(this.dot(e), -1, 1)));
    }
    rotateTowards(e, t) {
        const n = this.angleTo(e);
        if (n === 0) return this;
        const r = Math.min(1, t / n);
        return this.slerp(e, r), this;
    }
    identity() {
        return this.set(0, 0, 0, 1);
    }
    invert() {
        return this.conjugate();
    }
    conjugate() {
        return (
            (this._x *= -1),
            (this._y *= -1),
            (this._z *= -1),
            this._onChangeCallback(),
            this
        );
    }
    dot(e) {
        return (
            this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
        );
    }
    lengthSq() {
        return (
            this._x * this._x +
            this._y * this._y +
            this._z * this._z +
            this._w * this._w
        );
    }
    length() {
        return Math.sqrt(
            this._x * this._x +
                this._y * this._y +
                this._z * this._z +
                this._w * this._w
        );
    }
    normalize() {
        let e = this.length();
        return (
            e === 0
                ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
                : ((e = 1 / e),
                  (this._x = this._x * e),
                  (this._y = this._y * e),
                  (this._z = this._z * e),
                  (this._w = this._w * e)),
            this._onChangeCallback(),
            this
        );
    }
    multiply(e) {
        return this.multiplyQuaternions(this, e);
    }
    premultiply(e) {
        return this.multiplyQuaternions(e, this);
    }
    multiplyQuaternions(e, t) {
        const n = e._x,
            r = e._y,
            s = e._z,
            a = e._w,
            l = t._x,
            c = t._y,
            d = t._z,
            p = t._w;
        return (
            (this._x = n * p + a * l + r * d - s * c),
            (this._y = r * p + a * c + s * l - n * d),
            (this._z = s * p + a * d + n * c - r * l),
            (this._w = a * p - n * l - r * c - s * d),
            this._onChangeCallback(),
            this
        );
    }
    slerp(e, t) {
        if (t === 0) return this;
        if (t === 1) return this.copy(e);
        const n = this._x,
            r = this._y,
            s = this._z,
            a = this._w;
        let l = a * e._w + n * e._x + r * e._y + s * e._z;
        if (
            (l < 0
                ? ((this._w = -e._w),
                  (this._x = -e._x),
                  (this._y = -e._y),
                  (this._z = -e._z),
                  (l = -l))
                : this.copy(e),
            l >= 1)
        )
            return (
                (this._w = a), (this._x = n), (this._y = r), (this._z = s), this
            );
        const c = 1 - l * l;
        if (c <= Number.EPSILON) {
            const v = 1 - t;
            return (
                (this._w = v * a + t * this._w),
                (this._x = v * n + t * this._x),
                (this._y = v * r + t * this._y),
                (this._z = v * s + t * this._z),
                this.normalize(),
                this
            );
        }
        const d = Math.sqrt(c),
            p = Math.atan2(d, l),
            g = Math.sin((1 - t) * p) / d,
            y = Math.sin(t * p) / d;
        return (
            (this._w = a * g + this._w * y),
            (this._x = n * g + this._x * y),
            (this._y = r * g + this._y * y),
            (this._z = s * g + this._z * y),
            this._onChangeCallback(),
            this
        );
    }
    slerpQuaternions(e, t, n) {
        return this.copy(e).slerp(t, n);
    }
    random() {
        const e = 2 * Math.PI * Math.random(),
            t = 2 * Math.PI * Math.random(),
            n = Math.random(),
            r = Math.sqrt(1 - n),
            s = Math.sqrt(n);
        return this.set(
            r * Math.sin(e),
            r * Math.cos(e),
            s * Math.sin(t),
            s * Math.cos(t)
        );
    }
    equals(e) {
        return (
            e._x === this._x &&
            e._y === this._y &&
            e._z === this._z &&
            e._w === this._w
        );
    }
    fromArray(e, t = 0) {
        return (
            (this._x = e[t]),
            (this._y = e[t + 1]),
            (this._z = e[t + 2]),
            (this._w = e[t + 3]),
            this._onChangeCallback(),
            this
        );
    }
    toArray(e = [], t = 0) {
        return (
            (e[t] = this._x),
            (e[t + 1] = this._y),
            (e[t + 2] = this._z),
            (e[t + 3] = this._w),
            e
        );
    }
    fromBufferAttribute(e, t) {
        return (
            (this._x = e.getX(t)),
            (this._y = e.getY(t)),
            (this._z = e.getZ(t)),
            (this._w = e.getW(t)),
            this._onChangeCallback(),
            this
        );
    }
    toJSON() {
        return this.toArray();
    }
    _onChange(e) {
        return (this._onChangeCallback = e), this;
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
        yield this._x, yield this._y, yield this._z, yield this._w;
    }
}
class j {
    constructor(e = 0, t = 0, n = 0) {
        (j.prototype.isVector3 = !0), (this.x = e), (this.y = t), (this.z = n);
    }
    set(e, t, n) {
        return (
            n === void 0 && (n = this.z),
            (this.x = e),
            (this.y = t),
            (this.z = n),
            this
        );
    }
    setScalar(e) {
        return (this.x = e), (this.y = e), (this.z = e), this;
    }
    setX(e) {
        return (this.x = e), this;
    }
    setY(e) {
        return (this.y = e), this;
    }
    setZ(e) {
        return (this.z = e), this;
    }
    setComponent(e, t) {
        switch (e) {
            case 0:
                this.x = t;
                break;
            case 1:
                this.y = t;
                break;
            case 2:
                this.z = t;
                break;
            default:
                throw new Error('index is out of range: ' + e);
        }
        return this;
    }
    getComponent(e) {
        switch (e) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            default:
                throw new Error('index is out of range: ' + e);
        }
    }
    clone() {
        return new this.constructor(this.x, this.y, this.z);
    }
    copy(e) {
        return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
    }
    add(e) {
        return (this.x += e.x), (this.y += e.y), (this.z += e.z), this;
    }
    addScalar(e) {
        return (this.x += e), (this.y += e), (this.z += e), this;
    }
    addVectors(e, t) {
        return (
            (this.x = e.x + t.x),
            (this.y = e.y + t.y),
            (this.z = e.z + t.z),
            this
        );
    }
    addScaledVector(e, t) {
        return (
            (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this
        );
    }
    sub(e) {
        return (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this;
    }
    subScalar(e) {
        return (this.x -= e), (this.y -= e), (this.z -= e), this;
    }
    subVectors(e, t) {
        return (
            (this.x = e.x - t.x),
            (this.y = e.y - t.y),
            (this.z = e.z - t.z),
            this
        );
    }
    multiply(e) {
        return (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this;
    }
    multiplyScalar(e) {
        return (this.x *= e), (this.y *= e), (this.z *= e), this;
    }
    multiplyVectors(e, t) {
        return (
            (this.x = e.x * t.x),
            (this.y = e.y * t.y),
            (this.z = e.z * t.z),
            this
        );
    }
    applyEuler(e) {
        return this.applyQuaternion(I1.setFromEuler(e));
    }
    applyAxisAngle(e, t) {
        return this.applyQuaternion(I1.setFromAxisAngle(e, t));
    }
    applyMatrix3(e) {
        const t = this.x,
            n = this.y,
            r = this.z,
            s = e.elements;
        return (
            (this.x = s[0] * t + s[3] * n + s[6] * r),
            (this.y = s[1] * t + s[4] * n + s[7] * r),
            (this.z = s[2] * t + s[5] * n + s[8] * r),
            this
        );
    }
    applyNormalMatrix(e) {
        return this.applyMatrix3(e).normalize();
    }
    applyMatrix4(e) {
        const t = this.x,
            n = this.y,
            r = this.z,
            s = e.elements,
            a = 1 / (s[3] * t + s[7] * n + s[11] * r + s[15]);
        return (
            (this.x = (s[0] * t + s[4] * n + s[8] * r + s[12]) * a),
            (this.y = (s[1] * t + s[5] * n + s[9] * r + s[13]) * a),
            (this.z = (s[2] * t + s[6] * n + s[10] * r + s[14]) * a),
            this
        );
    }
    applyQuaternion(e) {
        const t = this.x,
            n = this.y,
            r = this.z,
            s = e.x,
            a = e.y,
            l = e.z,
            c = e.w,
            d = 2 * (a * r - l * n),
            p = 2 * (l * t - s * r),
            g = 2 * (s * n - a * t);
        return (
            (this.x = t + c * d + a * g - l * p),
            (this.y = n + c * p + l * d - s * g),
            (this.z = r + c * g + s * p - a * d),
            this
        );
    }
    project(e) {
        return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
            e.projectionMatrix
        );
    }
    unproject(e) {
        return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
            e.matrixWorld
        );
    }
    transformDirection(e) {
        const t = this.x,
            n = this.y,
            r = this.z,
            s = e.elements;
        return (
            (this.x = s[0] * t + s[4] * n + s[8] * r),
            (this.y = s[1] * t + s[5] * n + s[9] * r),
            (this.z = s[2] * t + s[6] * n + s[10] * r),
            this.normalize()
        );
    }
    divide(e) {
        return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e);
    }
    min(e) {
        return (
            (this.x = Math.min(this.x, e.x)),
            (this.y = Math.min(this.y, e.y)),
            (this.z = Math.min(this.z, e.z)),
            this
        );
    }
    max(e) {
        return (
            (this.x = Math.max(this.x, e.x)),
            (this.y = Math.max(this.y, e.y)),
            (this.z = Math.max(this.z, e.z)),
            this
        );
    }
    clamp(e, t) {
        return (
            (this.x = Math.max(e.x, Math.min(t.x, this.x))),
            (this.y = Math.max(e.y, Math.min(t.y, this.y))),
            (this.z = Math.max(e.z, Math.min(t.z, this.z))),
            this
        );
    }
    clampScalar(e, t) {
        return (
            (this.x = Math.max(e, Math.min(t, this.x))),
            (this.y = Math.max(e, Math.min(t, this.y))),
            (this.z = Math.max(e, Math.min(t, this.z))),
            this
        );
    }
    clampLength(e, t) {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(
            Math.max(e, Math.min(t, n))
        );
    }
    floor() {
        return (
            (this.x = Math.floor(this.x)),
            (this.y = Math.floor(this.y)),
            (this.z = Math.floor(this.z)),
            this
        );
    }
    ceil() {
        return (
            (this.x = Math.ceil(this.x)),
            (this.y = Math.ceil(this.y)),
            (this.z = Math.ceil(this.z)),
            this
        );
    }
    round() {
        return (
            (this.x = Math.round(this.x)),
            (this.y = Math.round(this.y)),
            (this.z = Math.round(this.z)),
            this
        );
    }
    roundToZero() {
        return (
            (this.x = Math.trunc(this.x)),
            (this.y = Math.trunc(this.y)),
            (this.z = Math.trunc(this.z)),
            this
        );
    }
    negate() {
        return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z;
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    }
    normalize() {
        return this.divideScalar(this.length() || 1);
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e);
    }
    lerp(e, t) {
        return (
            (this.x += (e.x - this.x) * t),
            (this.y += (e.y - this.y) * t),
            (this.z += (e.z - this.z) * t),
            this
        );
    }
    lerpVectors(e, t, n) {
        return (
            (this.x = e.x + (t.x - e.x) * n),
            (this.y = e.y + (t.y - e.y) * n),
            (this.z = e.z + (t.z - e.z) * n),
            this
        );
    }
    cross(e) {
        return this.crossVectors(this, e);
    }
    crossVectors(e, t) {
        const n = e.x,
            r = e.y,
            s = e.z,
            a = t.x,
            l = t.y,
            c = t.z;
        return (
            (this.x = r * c - s * l),
            (this.y = s * a - n * c),
            (this.z = n * l - r * a),
            this
        );
    }
    projectOnVector(e) {
        const t = e.lengthSq();
        if (t === 0) return this.set(0, 0, 0);
        const n = e.dot(this) / t;
        return this.copy(e).multiplyScalar(n);
    }
    projectOnPlane(e) {
        return G0.copy(this).projectOnVector(e), this.sub(G0);
    }
    reflect(e) {
        return this.sub(G0.copy(e).multiplyScalar(2 * this.dot(e)));
    }
    angleTo(e) {
        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (t === 0) return Math.PI / 2;
        const n = this.dot(e) / t;
        return Math.acos(Jn(n, -1, 1));
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e));
    }
    distanceToSquared(e) {
        const t = this.x - e.x,
            n = this.y - e.y,
            r = this.z - e.z;
        return t * t + n * n + r * r;
    }
    manhattanDistanceTo(e) {
        return (
            Math.abs(this.x - e.x) +
            Math.abs(this.y - e.y) +
            Math.abs(this.z - e.z)
        );
    }
    setFromSpherical(e) {
        return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
    }
    setFromSphericalCoords(e, t, n) {
        const r = Math.sin(t) * e;
        return (
            (this.x = r * Math.sin(n)),
            (this.y = Math.cos(t) * e),
            (this.z = r * Math.cos(n)),
            this
        );
    }
    setFromCylindrical(e) {
        return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
    }
    setFromCylindricalCoords(e, t, n) {
        return (
            (this.x = e * Math.sin(t)),
            (this.y = n),
            (this.z = e * Math.cos(t)),
            this
        );
    }
    setFromMatrixPosition(e) {
        const t = e.elements;
        return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
    }
    setFromMatrixScale(e) {
        const t = this.setFromMatrixColumn(e, 0).length(),
            n = this.setFromMatrixColumn(e, 1).length(),
            r = this.setFromMatrixColumn(e, 2).length();
        return (this.x = t), (this.y = n), (this.z = r), this;
    }
    setFromMatrixColumn(e, t) {
        return this.fromArray(e.elements, t * 4);
    }
    setFromMatrix3Column(e, t) {
        return this.fromArray(e.elements, t * 3);
    }
    setFromEuler(e) {
        return (this.x = e._x), (this.y = e._y), (this.z = e._z), this;
    }
    setFromColor(e) {
        return (this.x = e.r), (this.y = e.g), (this.z = e.b), this;
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z;
    }
    fromArray(e, t = 0) {
        return (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this;
    }
    toArray(e = [], t = 0) {
        return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e;
    }
    fromBufferAttribute(e, t) {
        return (
            (this.x = e.getX(t)),
            (this.y = e.getY(t)),
            (this.z = e.getZ(t)),
            this
        );
    }
    random() {
        return (
            (this.x = Math.random()),
            (this.y = Math.random()),
            (this.z = Math.random()),
            this
        );
    }
    randomDirection() {
        const e = Math.random() * Math.PI * 2,
            t = Math.random() * 2 - 1,
            n = Math.sqrt(1 - t * t);
        return (
            (this.x = n * Math.cos(e)),
            (this.y = t),
            (this.z = n * Math.sin(e)),
            this
        );
    }
    *[Symbol.iterator]() {
        yield this.x, yield this.y, yield this.z;
    }
}
const G0 = new j(),
    I1 = new Hr();
class Tr {
    constructor(
        e = new j(1 / 0, 1 / 0, 1 / 0),
        t = new j(-1 / 0, -1 / 0, -1 / 0)
    ) {
        (this.isBox3 = !0), (this.min = e), (this.max = t);
    }
    set(e, t) {
        return this.min.copy(e), this.max.copy(t), this;
    }
    setFromArray(e) {
        this.makeEmpty();
        for (let t = 0, n = e.length; t < n; t += 3)
            this.expandByPoint(Qs.fromArray(e, t));
        return this;
    }
    setFromBufferAttribute(e) {
        this.makeEmpty();
        for (let t = 0, n = e.count; t < n; t++)
            this.expandByPoint(Qs.fromBufferAttribute(e, t));
        return this;
    }
    setFromPoints(e) {
        this.makeEmpty();
        for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
        return this;
    }
    setFromCenterAndSize(e, t) {
        const n = Qs.copy(t).multiplyScalar(0.5);
        return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
    }
    setFromObject(e, t = !1) {
        return this.makeEmpty(), this.expandByObject(e, t);
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(e) {
        return this.min.copy(e.min), this.max.copy(e.max), this;
    }
    makeEmpty() {
        return (
            (this.min.x = this.min.y = this.min.z = 1 / 0),
            (this.max.x = this.max.y = this.max.z = -1 / 0),
            this
        );
    }
    isEmpty() {
        return (
            this.max.x < this.min.x ||
            this.max.y < this.min.y ||
            this.max.z < this.min.z
        );
    }
    getCenter(e) {
        return this.isEmpty()
            ? e.set(0, 0, 0)
            : e.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
    getSize(e) {
        return this.isEmpty()
            ? e.set(0, 0, 0)
            : e.subVectors(this.max, this.min);
    }
    expandByPoint(e) {
        return this.min.min(e), this.max.max(e), this;
    }
    expandByVector(e) {
        return this.min.sub(e), this.max.add(e), this;
    }
    expandByScalar(e) {
        return this.min.addScalar(-e), this.max.addScalar(e), this;
    }
    expandByObject(e, t = !1) {
        e.updateWorldMatrix(!1, !1);
        const n = e.geometry;
        if (n !== void 0) {
            const s = n.getAttribute('position');
            if (t === !0 && s !== void 0 && e.isInstancedMesh !== !0)
                for (let a = 0, l = s.count; a < l; a++)
                    e.isMesh === !0
                        ? e.getVertexPosition(a, Qs)
                        : Qs.fromBufferAttribute(s, a),
                        Qs.applyMatrix4(e.matrixWorld),
                        this.expandByPoint(Qs);
            else
                e.boundingBox !== void 0
                    ? (e.boundingBox === null && e.computeBoundingBox(),
                      sg.copy(e.boundingBox))
                    : (n.boundingBox === null && n.computeBoundingBox(),
                      sg.copy(n.boundingBox)),
                    sg.applyMatrix4(e.matrixWorld),
                    this.union(sg);
        }
        const r = e.children;
        for (let s = 0, a = r.length; s < a; s++) this.expandByObject(r[s], t);
        return this;
    }
    containsPoint(e) {
        return !(
            e.x < this.min.x ||
            e.x > this.max.x ||
            e.y < this.min.y ||
            e.y > this.max.y ||
            e.z < this.min.z ||
            e.z > this.max.z
        );
    }
    containsBox(e) {
        return (
            this.min.x <= e.min.x &&
            e.max.x <= this.max.x &&
            this.min.y <= e.min.y &&
            e.max.y <= this.max.y &&
            this.min.z <= e.min.z &&
            e.max.z <= this.max.z
        );
    }
    getParameter(e, t) {
        return t.set(
            (e.x - this.min.x) / (this.max.x - this.min.x),
            (e.y - this.min.y) / (this.max.y - this.min.y),
            (e.z - this.min.z) / (this.max.z - this.min.z)
        );
    }
    intersectsBox(e) {
        return !(
            e.max.x < this.min.x ||
            e.min.x > this.max.x ||
            e.max.y < this.min.y ||
            e.min.y > this.max.y ||
            e.max.z < this.min.z ||
            e.min.z > this.max.z
        );
    }
    intersectsSphere(e) {
        return (
            this.clampPoint(e.center, Qs),
            Qs.distanceToSquared(e.center) <= e.radius * e.radius
        );
    }
    intersectsPlane(e) {
        let t, n;
        return (
            e.normal.x > 0
                ? ((t = e.normal.x * this.min.x), (n = e.normal.x * this.max.x))
                : ((t = e.normal.x * this.max.x),
                  (n = e.normal.x * this.min.x)),
            e.normal.y > 0
                ? ((t += e.normal.y * this.min.y),
                  (n += e.normal.y * this.max.y))
                : ((t += e.normal.y * this.max.y),
                  (n += e.normal.y * this.min.y)),
            e.normal.z > 0
                ? ((t += e.normal.z * this.min.z),
                  (n += e.normal.z * this.max.z))
                : ((t += e.normal.z * this.max.z),
                  (n += e.normal.z * this.min.z)),
            t <= -e.constant && n >= -e.constant
        );
    }
    intersectsTriangle(e) {
        if (this.isEmpty()) return !1;
        this.getCenter(Cd),
            og.subVectors(this.max, Cd),
            vf.subVectors(e.a, Cd),
            xf.subVectors(e.b, Cd),
            _f.subVectors(e.c, Cd),
            _l.subVectors(xf, vf),
            Sl.subVectors(_f, xf),
            Lu.subVectors(vf, _f);
        let t = [
            0,
            -_l.z,
            _l.y,
            0,
            -Sl.z,
            Sl.y,
            0,
            -Lu.z,
            Lu.y,
            _l.z,
            0,
            -_l.x,
            Sl.z,
            0,
            -Sl.x,
            Lu.z,
            0,
            -Lu.x,
            -_l.y,
            _l.x,
            0,
            -Sl.y,
            Sl.x,
            0,
            -Lu.y,
            Lu.x,
            0,
        ];
        return !W0(t, vf, xf, _f, og) ||
            ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !W0(t, vf, xf, _f, og))
            ? !1
            : (ag.crossVectors(_l, Sl),
              (t = [ag.x, ag.y, ag.z]),
              W0(t, vf, xf, _f, og));
    }
    clampPoint(e, t) {
        return t.copy(e).clamp(this.min, this.max);
    }
    distanceToPoint(e) {
        return this.clampPoint(e, Qs).distanceTo(e);
    }
    getBoundingSphere(e) {
        return (
            this.isEmpty()
                ? e.makeEmpty()
                : (this.getCenter(e.center),
                  (e.radius = this.getSize(Qs).length() * 0.5)),
            e
        );
    }
    intersect(e) {
        return (
            this.min.max(e.min),
            this.max.min(e.max),
            this.isEmpty() && this.makeEmpty(),
            this
        );
    }
    union(e) {
        return this.min.min(e.min), this.max.max(e.max), this;
    }
    applyMatrix4(e) {
        return this.isEmpty()
            ? this
            : (_a[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
              _a[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
              _a[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
              _a[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
              _a[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
              _a[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
              _a[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
              _a[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
              this.setFromPoints(_a),
              this);
    }
    translate(e) {
        return this.min.add(e), this.max.add(e), this;
    }
    equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max);
    }
}
const _a = [
        new j(),
        new j(),
        new j(),
        new j(),
        new j(),
        new j(),
        new j(),
        new j(),
    ],
    Qs = new j(),
    sg = new Tr(),
    vf = new j(),
    xf = new j(),
    _f = new j(),
    _l = new j(),
    Sl = new j(),
    Lu = new j(),
    Cd = new j(),
    og = new j(),
    ag = new j(),
    Iu = new j();
function W0(i, e, t, n, r) {
    for (let s = 0, a = i.length - 3; s <= a; s += 3) {
        Iu.fromArray(i, s);
        const l =
                r.x * Math.abs(Iu.x) +
                r.y * Math.abs(Iu.y) +
                r.z * Math.abs(Iu.z),
            c = e.dot(Iu),
            d = t.dot(Iu),
            p = n.dot(Iu);
        if (Math.max(-Math.max(c, d, p), Math.min(c, d, p)) > l) return !1;
    }
    return !0;
}
const uk = new Tr(),
    Rd = new j(),
    X0 = new j();
class or {
    constructor(e = new j(), t = -1) {
        (this.isSphere = !0), (this.center = e), (this.radius = t);
    }
    set(e, t) {
        return this.center.copy(e), (this.radius = t), this;
    }
    setFromPoints(e, t) {
        const n = this.center;
        t !== void 0 ? n.copy(t) : uk.setFromPoints(e).getCenter(n);
        let r = 0;
        for (let s = 0, a = e.length; s < a; s++)
            r = Math.max(r, n.distanceToSquared(e[s]));
        return (this.radius = Math.sqrt(r)), this;
    }
    copy(e) {
        return this.center.copy(e.center), (this.radius = e.radius), this;
    }
    isEmpty() {
        return this.radius < 0;
    }
    makeEmpty() {
        return this.center.set(0, 0, 0), (this.radius = -1), this;
    }
    containsPoint(e) {
        return e.distanceToSquared(this.center) <= this.radius * this.radius;
    }
    distanceToPoint(e) {
        return e.distanceTo(this.center) - this.radius;
    }
    intersectsSphere(e) {
        const t = this.radius + e.radius;
        return e.center.distanceToSquared(this.center) <= t * t;
    }
    intersectsBox(e) {
        return e.intersectsSphere(this);
    }
    intersectsPlane(e) {
        return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
    }
    clampPoint(e, t) {
        const n = this.center.distanceToSquared(e);
        return (
            t.copy(e),
            n > this.radius * this.radius &&
                (t.sub(this.center).normalize(),
                t.multiplyScalar(this.radius).add(this.center)),
            t
        );
    }
    getBoundingBox(e) {
        return this.isEmpty()
            ? (e.makeEmpty(), e)
            : (e.set(this.center, this.center),
              e.expandByScalar(this.radius),
              e);
    }
    applyMatrix4(e) {
        return (
            this.center.applyMatrix4(e),
            (this.radius = this.radius * e.getMaxScaleOnAxis()),
            this
        );
    }
    translate(e) {
        return this.center.add(e), this;
    }
    expandByPoint(e) {
        if (this.isEmpty()) return this.center.copy(e), (this.radius = 0), this;
        Rd.subVectors(e, this.center);
        const t = Rd.lengthSq();
        if (t > this.radius * this.radius) {
            const n = Math.sqrt(t),
                r = (n - this.radius) * 0.5;
            this.center.addScaledVector(Rd, r / n), (this.radius += r);
        }
        return this;
    }
    union(e) {
        return e.isEmpty()
            ? this
            : this.isEmpty()
              ? (this.copy(e), this)
              : (this.center.equals(e.center) === !0
                    ? (this.radius = Math.max(this.radius, e.radius))
                    : (X0.subVectors(e.center, this.center).setLength(e.radius),
                      this.expandByPoint(Rd.copy(e.center).add(X0)),
                      this.expandByPoint(Rd.copy(e.center).sub(X0))),
                this);
    }
    equals(e) {
        return e.center.equals(this.center) && e.radius === this.radius;
    }
    clone() {
        return new this.constructor().copy(this);
    }
}
const Sa = new j(),
    j0 = new j(),
    lg = new j(),
    wl = new j(),
    q0 = new j(),
    ug = new j(),
    $0 = new j();
class Eh {
    constructor(e = new j(), t = new j(0, 0, -1)) {
        (this.origin = e), (this.direction = t);
    }
    set(e, t) {
        return this.origin.copy(e), this.direction.copy(t), this;
    }
    copy(e) {
        return (
            this.origin.copy(e.origin), this.direction.copy(e.direction), this
        );
    }
    at(e, t) {
        return t.copy(this.origin).addScaledVector(this.direction, e);
    }
    lookAt(e) {
        return this.direction.copy(e).sub(this.origin).normalize(), this;
    }
    recast(e) {
        return this.origin.copy(this.at(e, Sa)), this;
    }
    closestPointToPoint(e, t) {
        t.subVectors(e, this.origin);
        const n = t.dot(this.direction);
        return n < 0
            ? t.copy(this.origin)
            : t.copy(this.origin).addScaledVector(this.direction, n);
    }
    distanceToPoint(e) {
        return Math.sqrt(this.distanceSqToPoint(e));
    }
    distanceSqToPoint(e) {
        const t = Sa.subVectors(e, this.origin).dot(this.direction);
        return t < 0
            ? this.origin.distanceToSquared(e)
            : (Sa.copy(this.origin).addScaledVector(this.direction, t),
              Sa.distanceToSquared(e));
    }
    distanceSqToSegment(e, t, n, r) {
        j0.copy(e).add(t).multiplyScalar(0.5),
            lg.copy(t).sub(e).normalize(),
            wl.copy(this.origin).sub(j0);
        const s = e.distanceTo(t) * 0.5,
            a = -this.direction.dot(lg),
            l = wl.dot(this.direction),
            c = -wl.dot(lg),
            d = wl.lengthSq(),
            p = Math.abs(1 - a * a);
        let g, y, v, S;
        if (p > 0)
            if (((g = a * c - l), (y = a * l - c), (S = s * p), g >= 0))
                if (y >= -S)
                    if (y <= S) {
                        const T = 1 / p;
                        (g *= T),
                            (y *= T),
                            (v =
                                g * (g + a * y + 2 * l) +
                                y * (a * g + y + 2 * c) +
                                d);
                    } else
                        (y = s),
                            (g = Math.max(0, -(a * y + l))),
                            (v = -g * g + y * (y + 2 * c) + d);
                else
                    (y = -s),
                        (g = Math.max(0, -(a * y + l))),
                        (v = -g * g + y * (y + 2 * c) + d);
            else
                y <= -S
                    ? ((g = Math.max(0, -(-a * s + l))),
                      (y = g > 0 ? -s : Math.min(Math.max(-s, -c), s)),
                      (v = -g * g + y * (y + 2 * c) + d))
                    : y <= S
                      ? ((g = 0),
                        (y = Math.min(Math.max(-s, -c), s)),
                        (v = y * (y + 2 * c) + d))
                      : ((g = Math.max(0, -(a * s + l))),
                        (y = g > 0 ? s : Math.min(Math.max(-s, -c), s)),
                        (v = -g * g + y * (y + 2 * c) + d));
        else
            (y = a > 0 ? -s : s),
                (g = Math.max(0, -(a * y + l))),
                (v = -g * g + y * (y + 2 * c) + d);
        return (
            n && n.copy(this.origin).addScaledVector(this.direction, g),
            r && r.copy(j0).addScaledVector(lg, y),
            v
        );
    }
    intersectSphere(e, t) {
        Sa.subVectors(e.center, this.origin);
        const n = Sa.dot(this.direction),
            r = Sa.dot(Sa) - n * n,
            s = e.radius * e.radius;
        if (r > s) return null;
        const a = Math.sqrt(s - r),
            l = n - a,
            c = n + a;
        return c < 0 ? null : l < 0 ? this.at(c, t) : this.at(l, t);
    }
    intersectsSphere(e) {
        return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
    }
    distanceToPlane(e) {
        const t = e.normal.dot(this.direction);
        if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
        const n = -(this.origin.dot(e.normal) + e.constant) / t;
        return n >= 0 ? n : null;
    }
    intersectPlane(e, t) {
        const n = this.distanceToPlane(e);
        return n === null ? null : this.at(n, t);
    }
    intersectsPlane(e) {
        const t = e.distanceToPoint(this.origin);
        return t === 0 || e.normal.dot(this.direction) * t < 0;
    }
    intersectBox(e, t) {
        let n, r, s, a, l, c;
        const d = 1 / this.direction.x,
            p = 1 / this.direction.y,
            g = 1 / this.direction.z,
            y = this.origin;
        return (
            d >= 0
                ? ((n = (e.min.x - y.x) * d), (r = (e.max.x - y.x) * d))
                : ((n = (e.max.x - y.x) * d), (r = (e.min.x - y.x) * d)),
            p >= 0
                ? ((s = (e.min.y - y.y) * p), (a = (e.max.y - y.y) * p))
                : ((s = (e.max.y - y.y) * p), (a = (e.min.y - y.y) * p)),
            n > a ||
            s > r ||
            ((s > n || isNaN(n)) && (n = s),
            (a < r || isNaN(r)) && (r = a),
            g >= 0
                ? ((l = (e.min.z - y.z) * g), (c = (e.max.z - y.z) * g))
                : ((l = (e.max.z - y.z) * g), (c = (e.min.z - y.z) * g)),
            n > c || l > r) ||
            ((l > n || n !== n) && (n = l),
            (c < r || r !== r) && (r = c),
            r < 0)
                ? null
                : this.at(n >= 0 ? n : r, t)
        );
    }
    intersectsBox(e) {
        return this.intersectBox(e, Sa) !== null;
    }
    intersectTriangle(e, t, n, r, s) {
        q0.subVectors(t, e), ug.subVectors(n, e), $0.crossVectors(q0, ug);
        let a = this.direction.dot($0),
            l;
        if (a > 0) {
            if (r) return null;
            l = 1;
        } else if (a < 0) (l = -1), (a = -a);
        else return null;
        wl.subVectors(this.origin, e);
        const c = l * this.direction.dot(ug.crossVectors(wl, ug));
        if (c < 0) return null;
        const d = l * this.direction.dot(q0.cross(wl));
        if (d < 0 || c + d > a) return null;
        const p = -l * wl.dot($0);
        return p < 0 ? null : this.at(p / a, s);
    }
    applyMatrix4(e) {
        return (
            this.origin.applyMatrix4(e),
            this.direction.transformDirection(e),
            this
        );
    }
    equals(e) {
        return (
            e.origin.equals(this.origin) && e.direction.equals(this.direction)
        );
    }
    clone() {
        return new this.constructor().copy(this);
    }
}
class Pt {
    constructor(e, t, n, r, s, a, l, c, d, p, g, y, v, S, T, M) {
        (Pt.prototype.isMatrix4 = !0),
            (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
            e !== void 0 &&
                this.set(e, t, n, r, s, a, l, c, d, p, g, y, v, S, T, M);
    }
    set(e, t, n, r, s, a, l, c, d, p, g, y, v, S, T, M) {
        const w = this.elements;
        return (
            (w[0] = e),
            (w[4] = t),
            (w[8] = n),
            (w[12] = r),
            (w[1] = s),
            (w[5] = a),
            (w[9] = l),
            (w[13] = c),
            (w[2] = d),
            (w[6] = p),
            (w[10] = g),
            (w[14] = y),
            (w[3] = v),
            (w[7] = S),
            (w[11] = T),
            (w[15] = M),
            this
        );
    }
    identity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    }
    clone() {
        return new Pt().fromArray(this.elements);
    }
    copy(e) {
        const t = this.elements,
            n = e.elements;
        return (
            (t[0] = n[0]),
            (t[1] = n[1]),
            (t[2] = n[2]),
            (t[3] = n[3]),
            (t[4] = n[4]),
            (t[5] = n[5]),
            (t[6] = n[6]),
            (t[7] = n[7]),
            (t[8] = n[8]),
            (t[9] = n[9]),
            (t[10] = n[10]),
            (t[11] = n[11]),
            (t[12] = n[12]),
            (t[13] = n[13]),
            (t[14] = n[14]),
            (t[15] = n[15]),
            this
        );
    }
    copyPosition(e) {
        const t = this.elements,
            n = e.elements;
        return (t[12] = n[12]), (t[13] = n[13]), (t[14] = n[14]), this;
    }
    setFromMatrix3(e) {
        const t = e.elements;
        return (
            this.set(
                t[0],
                t[3],
                t[6],
                0,
                t[1],
                t[4],
                t[7],
                0,
                t[2],
                t[5],
                t[8],
                0,
                0,
                0,
                0,
                1
            ),
            this
        );
    }
    extractBasis(e, t, n) {
        return (
            e.setFromMatrixColumn(this, 0),
            t.setFromMatrixColumn(this, 1),
            n.setFromMatrixColumn(this, 2),
            this
        );
    }
    makeBasis(e, t, n) {
        return (
            this.set(
                e.x,
                t.x,
                n.x,
                0,
                e.y,
                t.y,
                n.y,
                0,
                e.z,
                t.z,
                n.z,
                0,
                0,
                0,
                0,
                1
            ),
            this
        );
    }
    extractRotation(e) {
        const t = this.elements,
            n = e.elements,
            r = 1 / Sf.setFromMatrixColumn(e, 0).length(),
            s = 1 / Sf.setFromMatrixColumn(e, 1).length(),
            a = 1 / Sf.setFromMatrixColumn(e, 2).length();
        return (
            (t[0] = n[0] * r),
            (t[1] = n[1] * r),
            (t[2] = n[2] * r),
            (t[3] = 0),
            (t[4] = n[4] * s),
            (t[5] = n[5] * s),
            (t[6] = n[6] * s),
            (t[7] = 0),
            (t[8] = n[8] * a),
            (t[9] = n[9] * a),
            (t[10] = n[10] * a),
            (t[11] = 0),
            (t[12] = 0),
            (t[13] = 0),
            (t[14] = 0),
            (t[15] = 1),
            this
        );
    }
    makeRotationFromEuler(e) {
        const t = this.elements,
            n = e.x,
            r = e.y,
            s = e.z,
            a = Math.cos(n),
            l = Math.sin(n),
            c = Math.cos(r),
            d = Math.sin(r),
            p = Math.cos(s),
            g = Math.sin(s);
        if (e.order === 'XYZ') {
            const y = a * p,
                v = a * g,
                S = l * p,
                T = l * g;
            (t[0] = c * p),
                (t[4] = -c * g),
                (t[8] = d),
                (t[1] = v + S * d),
                (t[5] = y - T * d),
                (t[9] = -l * c),
                (t[2] = T - y * d),
                (t[6] = S + v * d),
                (t[10] = a * c);
        } else if (e.order === 'YXZ') {
            const y = c * p,
                v = c * g,
                S = d * p,
                T = d * g;
            (t[0] = y + T * l),
                (t[4] = S * l - v),
                (t[8] = a * d),
                (t[1] = a * g),
                (t[5] = a * p),
                (t[9] = -l),
                (t[2] = v * l - S),
                (t[6] = T + y * l),
                (t[10] = a * c);
        } else if (e.order === 'ZXY') {
            const y = c * p,
                v = c * g,
                S = d * p,
                T = d * g;
            (t[0] = y - T * l),
                (t[4] = -a * g),
                (t[8] = S + v * l),
                (t[1] = v + S * l),
                (t[5] = a * p),
                (t[9] = T - y * l),
                (t[2] = -a * d),
                (t[6] = l),
                (t[10] = a * c);
        } else if (e.order === 'ZYX') {
            const y = a * p,
                v = a * g,
                S = l * p,
                T = l * g;
            (t[0] = c * p),
                (t[4] = S * d - v),
                (t[8] = y * d + T),
                (t[1] = c * g),
                (t[5] = T * d + y),
                (t[9] = v * d - S),
                (t[2] = -d),
                (t[6] = l * c),
                (t[10] = a * c);
        } else if (e.order === 'YZX') {
            const y = a * c,
                v = a * d,
                S = l * c,
                T = l * d;
            (t[0] = c * p),
                (t[4] = T - y * g),
                (t[8] = S * g + v),
                (t[1] = g),
                (t[5] = a * p),
                (t[9] = -l * p),
                (t[2] = -d * p),
                (t[6] = v * g + S),
                (t[10] = y - T * g);
        } else if (e.order === 'XZY') {
            const y = a * c,
                v = a * d,
                S = l * c,
                T = l * d;
            (t[0] = c * p),
                (t[4] = -g),
                (t[8] = d * p),
                (t[1] = y * g + T),
                (t[5] = a * p),
                (t[9] = v * g - S),
                (t[2] = S * g - v),
                (t[6] = l * p),
                (t[10] = T * g + y);
        }
        return (
            (t[3] = 0),
            (t[7] = 0),
            (t[11] = 0),
            (t[12] = 0),
            (t[13] = 0),
            (t[14] = 0),
            (t[15] = 1),
            this
        );
    }
    makeRotationFromQuaternion(e) {
        return this.compose(ck, e, fk);
    }
    lookAt(e, t, n) {
        const r = this.elements;
        return (
            ns.subVectors(e, t),
            ns.lengthSq() === 0 && (ns.z = 1),
            ns.normalize(),
            Ml.crossVectors(n, ns),
            Ml.lengthSq() === 0 &&
                (Math.abs(n.z) === 1 ? (ns.x += 1e-4) : (ns.z += 1e-4),
                ns.normalize(),
                Ml.crossVectors(n, ns)),
            Ml.normalize(),
            cg.crossVectors(ns, Ml),
            (r[0] = Ml.x),
            (r[4] = cg.x),
            (r[8] = ns.x),
            (r[1] = Ml.y),
            (r[5] = cg.y),
            (r[9] = ns.y),
            (r[2] = Ml.z),
            (r[6] = cg.z),
            (r[10] = ns.z),
            this
        );
    }
    multiply(e) {
        return this.multiplyMatrices(this, e);
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this);
    }
    multiplyMatrices(e, t) {
        const n = e.elements,
            r = t.elements,
            s = this.elements,
            a = n[0],
            l = n[4],
            c = n[8],
            d = n[12],
            p = n[1],
            g = n[5],
            y = n[9],
            v = n[13],
            S = n[2],
            T = n[6],
            M = n[10],
            w = n[14],
            b = n[3],
            C = n[7],
            L = n[11],
            F = n[15],
            N = r[0],
            B = r[4],
            z = r[8],
            U = r[12],
            D = r[1],
            H = r[5],
            ie = r[9],
            ee = r[13],
            ue = r[2],
            Se = r[6],
            ce = r[10],
            me = r[14],
            X = r[3],
            oe = r[7],
            Q = r[11],
            G = r[15];
        return (
            (s[0] = a * N + l * D + c * ue + d * X),
            (s[4] = a * B + l * H + c * Se + d * oe),
            (s[8] = a * z + l * ie + c * ce + d * Q),
            (s[12] = a * U + l * ee + c * me + d * G),
            (s[1] = p * N + g * D + y * ue + v * X),
            (s[5] = p * B + g * H + y * Se + v * oe),
            (s[9] = p * z + g * ie + y * ce + v * Q),
            (s[13] = p * U + g * ee + y * me + v * G),
            (s[2] = S * N + T * D + M * ue + w * X),
            (s[6] = S * B + T * H + M * Se + w * oe),
            (s[10] = S * z + T * ie + M * ce + w * Q),
            (s[14] = S * U + T * ee + M * me + w * G),
            (s[3] = b * N + C * D + L * ue + F * X),
            (s[7] = b * B + C * H + L * Se + F * oe),
            (s[11] = b * z + C * ie + L * ce + F * Q),
            (s[15] = b * U + C * ee + L * me + F * G),
            this
        );
    }
    multiplyScalar(e) {
        const t = this.elements;
        return (
            (t[0] *= e),
            (t[4] *= e),
            (t[8] *= e),
            (t[12] *= e),
            (t[1] *= e),
            (t[5] *= e),
            (t[9] *= e),
            (t[13] *= e),
            (t[2] *= e),
            (t[6] *= e),
            (t[10] *= e),
            (t[14] *= e),
            (t[3] *= e),
            (t[7] *= e),
            (t[11] *= e),
            (t[15] *= e),
            this
        );
    }
    determinant() {
        const e = this.elements,
            t = e[0],
            n = e[4],
            r = e[8],
            s = e[12],
            a = e[1],
            l = e[5],
            c = e[9],
            d = e[13],
            p = e[2],
            g = e[6],
            y = e[10],
            v = e[14],
            S = e[3],
            T = e[7],
            M = e[11],
            w = e[15];
        return (
            S *
                (+s * c * g -
                    r * d * g -
                    s * l * y +
                    n * d * y +
                    r * l * v -
                    n * c * v) +
            T *
                (+t * c * v -
                    t * d * y +
                    s * a * y -
                    r * a * v +
                    r * d * p -
                    s * c * p) +
            M *
                (+t * d * g -
                    t * l * v -
                    s * a * g +
                    n * a * v +
                    s * l * p -
                    n * d * p) +
            w *
                (-r * l * p -
                    t * c * g +
                    t * l * y +
                    r * a * g -
                    n * a * y +
                    n * c * p)
        );
    }
    transpose() {
        const e = this.elements;
        let t;
        return (
            (t = e[1]),
            (e[1] = e[4]),
            (e[4] = t),
            (t = e[2]),
            (e[2] = e[8]),
            (e[8] = t),
            (t = e[6]),
            (e[6] = e[9]),
            (e[9] = t),
            (t = e[3]),
            (e[3] = e[12]),
            (e[12] = t),
            (t = e[7]),
            (e[7] = e[13]),
            (e[13] = t),
            (t = e[11]),
            (e[11] = e[14]),
            (e[14] = t),
            this
        );
    }
    setPosition(e, t, n) {
        const r = this.elements;
        return (
            e.isVector3
                ? ((r[12] = e.x), (r[13] = e.y), (r[14] = e.z))
                : ((r[12] = e), (r[13] = t), (r[14] = n)),
            this
        );
    }
    invert() {
        const e = this.elements,
            t = e[0],
            n = e[1],
            r = e[2],
            s = e[3],
            a = e[4],
            l = e[5],
            c = e[6],
            d = e[7],
            p = e[8],
            g = e[9],
            y = e[10],
            v = e[11],
            S = e[12],
            T = e[13],
            M = e[14],
            w = e[15],
            b =
                g * M * d -
                T * y * d +
                T * c * v -
                l * M * v -
                g * c * w +
                l * y * w,
            C =
                S * y * d -
                p * M * d -
                S * c * v +
                a * M * v +
                p * c * w -
                a * y * w,
            L =
                p * T * d -
                S * g * d +
                S * l * v -
                a * T * v -
                p * l * w +
                a * g * w,
            F =
                S * g * c -
                p * T * c -
                S * l * y +
                a * T * y +
                p * l * M -
                a * g * M,
            N = t * b + n * C + r * L + s * F;
        if (N === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const B = 1 / N;
        return (
            (e[0] = b * B),
            (e[1] =
                (T * y * s -
                    g * M * s -
                    T * r * v +
                    n * M * v +
                    g * r * w -
                    n * y * w) *
                B),
            (e[2] =
                (l * M * s -
                    T * c * s +
                    T * r * d -
                    n * M * d -
                    l * r * w +
                    n * c * w) *
                B),
            (e[3] =
                (g * c * s -
                    l * y * s -
                    g * r * d +
                    n * y * d +
                    l * r * v -
                    n * c * v) *
                B),
            (e[4] = C * B),
            (e[5] =
                (p * M * s -
                    S * y * s +
                    S * r * v -
                    t * M * v -
                    p * r * w +
                    t * y * w) *
                B),
            (e[6] =
                (S * c * s -
                    a * M * s -
                    S * r * d +
                    t * M * d +
                    a * r * w -
                    t * c * w) *
                B),
            (e[7] =
                (a * y * s -
                    p * c * s +
                    p * r * d -
                    t * y * d -
                    a * r * v +
                    t * c * v) *
                B),
            (e[8] = L * B),
            (e[9] =
                (S * g * s -
                    p * T * s -
                    S * n * v +
                    t * T * v +
                    p * n * w -
                    t * g * w) *
                B),
            (e[10] =
                (a * T * s -
                    S * l * s +
                    S * n * d -
                    t * T * d -
                    a * n * w +
                    t * l * w) *
                B),
            (e[11] =
                (p * l * s -
                    a * g * s -
                    p * n * d +
                    t * g * d +
                    a * n * v -
                    t * l * v) *
                B),
            (e[12] = F * B),
            (e[13] =
                (p * T * r -
                    S * g * r +
                    S * n * y -
                    t * T * y -
                    p * n * M +
                    t * g * M) *
                B),
            (e[14] =
                (S * l * r -
                    a * T * r -
                    S * n * c +
                    t * T * c +
                    a * n * M -
                    t * l * M) *
                B),
            (e[15] =
                (a * g * r -
                    p * l * r +
                    p * n * c -
                    t * g * c -
                    a * n * y +
                    t * l * y) *
                B),
            this
        );
    }
    scale(e) {
        const t = this.elements,
            n = e.x,
            r = e.y,
            s = e.z;
        return (
            (t[0] *= n),
            (t[4] *= r),
            (t[8] *= s),
            (t[1] *= n),
            (t[5] *= r),
            (t[9] *= s),
            (t[2] *= n),
            (t[6] *= r),
            (t[10] *= s),
            (t[3] *= n),
            (t[7] *= r),
            (t[11] *= s),
            this
        );
    }
    getMaxScaleOnAxis() {
        const e = this.elements,
            t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
            n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
            r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
        return Math.sqrt(Math.max(t, n, r));
    }
    makeTranslation(e, t, n) {
        return (
            e.isVector3
                ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1)
                : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1),
            this
        );
    }
    makeRotationX(e) {
        const t = Math.cos(e),
            n = Math.sin(e);
        return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this;
    }
    makeRotationY(e) {
        const t = Math.cos(e),
            n = Math.sin(e);
        return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this;
    }
    makeRotationZ(e) {
        const t = Math.cos(e),
            n = Math.sin(e);
        return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    }
    makeRotationAxis(e, t) {
        const n = Math.cos(t),
            r = Math.sin(t),
            s = 1 - n,
            a = e.x,
            l = e.y,
            c = e.z,
            d = s * a,
            p = s * l;
        return (
            this.set(
                d * a + n,
                d * l - r * c,
                d * c + r * l,
                0,
                d * l + r * c,
                p * l + n,
                p * c - r * a,
                0,
                d * c - r * l,
                p * c + r * a,
                s * c * c + n,
                0,
                0,
                0,
                0,
                1
            ),
            this
        );
    }
    makeScale(e, t, n) {
        return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
    }
    makeShear(e, t, n, r, s, a) {
        return this.set(1, n, s, 0, e, 1, a, 0, t, r, 1, 0, 0, 0, 0, 1), this;
    }
    compose(e, t, n) {
        const r = this.elements,
            s = t._x,
            a = t._y,
            l = t._z,
            c = t._w,
            d = s + s,
            p = a + a,
            g = l + l,
            y = s * d,
            v = s * p,
            S = s * g,
            T = a * p,
            M = a * g,
            w = l * g,
            b = c * d,
            C = c * p,
            L = c * g,
            F = n.x,
            N = n.y,
            B = n.z;
        return (
            (r[0] = (1 - (T + w)) * F),
            (r[1] = (v + L) * F),
            (r[2] = (S - C) * F),
            (r[3] = 0),
            (r[4] = (v - L) * N),
            (r[5] = (1 - (y + w)) * N),
            (r[6] = (M + b) * N),
            (r[7] = 0),
            (r[8] = (S + C) * B),
            (r[9] = (M - b) * B),
            (r[10] = (1 - (y + T)) * B),
            (r[11] = 0),
            (r[12] = e.x),
            (r[13] = e.y),
            (r[14] = e.z),
            (r[15] = 1),
            this
        );
    }
    decompose(e, t, n) {
        const r = this.elements;
        let s = Sf.set(r[0], r[1], r[2]).length();
        const a = Sf.set(r[4], r[5], r[6]).length(),
            l = Sf.set(r[8], r[9], r[10]).length();
        this.determinant() < 0 && (s = -s),
            (e.x = r[12]),
            (e.y = r[13]),
            (e.z = r[14]),
            eo.copy(this);
        const d = 1 / s,
            p = 1 / a,
            g = 1 / l;
        return (
            (eo.elements[0] *= d),
            (eo.elements[1] *= d),
            (eo.elements[2] *= d),
            (eo.elements[4] *= p),
            (eo.elements[5] *= p),
            (eo.elements[6] *= p),
            (eo.elements[8] *= g),
            (eo.elements[9] *= g),
            (eo.elements[10] *= g),
            t.setFromRotationMatrix(eo),
            (n.x = s),
            (n.y = a),
            (n.z = l),
            this
        );
    }
    makePerspective(e, t, n, r, s, a, l = Do) {
        const c = this.elements,
            d = (2 * s) / (t - e),
            p = (2 * s) / (n - r),
            g = (t + e) / (t - e),
            y = (n + r) / (n - r);
        let v, S;
        if (l === Do) (v = -(a + s) / (a - s)), (S = (-2 * a * s) / (a - s));
        else if (l === Rp) (v = -a / (a - s)), (S = (-a * s) / (a - s));
        else
            throw new Error(
                'THREE.Matrix4.makePerspective(): Invalid coordinate system: ' +
                    l
            );
        return (
            (c[0] = d),
            (c[4] = 0),
            (c[8] = g),
            (c[12] = 0),
            (c[1] = 0),
            (c[5] = p),
            (c[9] = y),
            (c[13] = 0),
            (c[2] = 0),
            (c[6] = 0),
            (c[10] = v),
            (c[14] = S),
            (c[3] = 0),
            (c[7] = 0),
            (c[11] = -1),
            (c[15] = 0),
            this
        );
    }
    makeOrthographic(e, t, n, r, s, a, l = Do) {
        const c = this.elements,
            d = 1 / (t - e),
            p = 1 / (n - r),
            g = 1 / (a - s),
            y = (t + e) * d,
            v = (n + r) * p;
        let S, T;
        if (l === Do) (S = (a + s) * g), (T = -2 * g);
        else if (l === Rp) (S = s * g), (T = -1 * g);
        else
            throw new Error(
                'THREE.Matrix4.makeOrthographic(): Invalid coordinate system: ' +
                    l
            );
        return (
            (c[0] = 2 * d),
            (c[4] = 0),
            (c[8] = 0),
            (c[12] = -y),
            (c[1] = 0),
            (c[5] = 2 * p),
            (c[9] = 0),
            (c[13] = -v),
            (c[2] = 0),
            (c[6] = 0),
            (c[10] = T),
            (c[14] = -S),
            (c[3] = 0),
            (c[7] = 0),
            (c[11] = 0),
            (c[15] = 1),
            this
        );
    }
    equals(e) {
        const t = this.elements,
            n = e.elements;
        for (let r = 0; r < 16; r++) if (t[r] !== n[r]) return !1;
        return !0;
    }
    fromArray(e, t = 0) {
        for (let n = 0; n < 16; n++) this.elements[n] = e[n + t];
        return this;
    }
    toArray(e = [], t = 0) {
        const n = this.elements;
        return (
            (e[t] = n[0]),
            (e[t + 1] = n[1]),
            (e[t + 2] = n[2]),
            (e[t + 3] = n[3]),
            (e[t + 4] = n[4]),
            (e[t + 5] = n[5]),
            (e[t + 6] = n[6]),
            (e[t + 7] = n[7]),
            (e[t + 8] = n[8]),
            (e[t + 9] = n[9]),
            (e[t + 10] = n[10]),
            (e[t + 11] = n[11]),
            (e[t + 12] = n[12]),
            (e[t + 13] = n[13]),
            (e[t + 14] = n[14]),
            (e[t + 15] = n[15]),
            e
        );
    }
}
const Sf = new j(),
    eo = new Pt(),
    ck = new j(0, 0, 0),
    fk = new j(1, 1, 1),
    Ml = new j(),
    cg = new j(),
    ns = new j(),
    D1 = new Pt(),
    N1 = new Hr();
class as {
    constructor(e = 0, t = 0, n = 0, r = as.DEFAULT_ORDER) {
        (this.isEuler = !0),
            (this._x = e),
            (this._y = t),
            (this._z = n),
            (this._order = r);
    }
    get x() {
        return this._x;
    }
    set x(e) {
        (this._x = e), this._onChangeCallback();
    }
    get y() {
        return this._y;
    }
    set y(e) {
        (this._y = e), this._onChangeCallback();
    }
    get z() {
        return this._z;
    }
    set z(e) {
        (this._z = e), this._onChangeCallback();
    }
    get order() {
        return this._order;
    }
    set order(e) {
        (this._order = e), this._onChangeCallback();
    }
    set(e, t, n, r = this._order) {
        return (
            (this._x = e),
            (this._y = t),
            (this._z = n),
            (this._order = r),
            this._onChangeCallback(),
            this
        );
    }
    clone() {
        return new this.constructor(this._x, this._y, this._z, this._order);
    }
    copy(e) {
        return (
            (this._x = e._x),
            (this._y = e._y),
            (this._z = e._z),
            (this._order = e._order),
            this._onChangeCallback(),
            this
        );
    }
    setFromRotationMatrix(e, t = this._order, n = !0) {
        const r = e.elements,
            s = r[0],
            a = r[4],
            l = r[8],
            c = r[1],
            d = r[5],
            p = r[9],
            g = r[2],
            y = r[6],
            v = r[10];
        switch (t) {
            case 'XYZ':
                (this._y = Math.asin(Jn(l, -1, 1))),
                    Math.abs(l) < 0.9999999
                        ? ((this._x = Math.atan2(-p, v)),
                          (this._z = Math.atan2(-a, s)))
                        : ((this._x = Math.atan2(y, d)), (this._z = 0));
                break;
            case 'YXZ':
                (this._x = Math.asin(-Jn(p, -1, 1))),
                    Math.abs(p) < 0.9999999
                        ? ((this._y = Math.atan2(l, v)),
                          (this._z = Math.atan2(c, d)))
                        : ((this._y = Math.atan2(-g, s)), (this._z = 0));
                break;
            case 'ZXY':
                (this._x = Math.asin(Jn(y, -1, 1))),
                    Math.abs(y) < 0.9999999
                        ? ((this._y = Math.atan2(-g, v)),
                          (this._z = Math.atan2(-a, d)))
                        : ((this._y = 0), (this._z = Math.atan2(c, s)));
                break;
            case 'ZYX':
                (this._y = Math.asin(-Jn(g, -1, 1))),
                    Math.abs(g) < 0.9999999
                        ? ((this._x = Math.atan2(y, v)),
                          (this._z = Math.atan2(c, s)))
                        : ((this._x = 0), (this._z = Math.atan2(-a, d)));
                break;
            case 'YZX':
                (this._z = Math.asin(Jn(c, -1, 1))),
                    Math.abs(c) < 0.9999999
                        ? ((this._x = Math.atan2(-p, d)),
                          (this._y = Math.atan2(-g, s)))
                        : ((this._x = 0), (this._y = Math.atan2(l, v)));
                break;
            case 'XZY':
                (this._z = Math.asin(-Jn(a, -1, 1))),
                    Math.abs(a) < 0.9999999
                        ? ((this._x = Math.atan2(y, d)),
                          (this._y = Math.atan2(l, s)))
                        : ((this._x = Math.atan2(-p, v)), (this._y = 0));
                break;
            default:
                console.warn(
                    'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' +
                        t
                );
        }
        return (this._order = t), n === !0 && this._onChangeCallback(), this;
    }
    setFromQuaternion(e, t, n) {
        return (
            D1.makeRotationFromQuaternion(e),
            this.setFromRotationMatrix(D1, t, n)
        );
    }
    setFromVector3(e, t = this._order) {
        return this.set(e.x, e.y, e.z, t);
    }
    reorder(e) {
        return N1.setFromEuler(this), this.setFromQuaternion(N1, e);
    }
    equals(e) {
        return (
            e._x === this._x &&
            e._y === this._y &&
            e._z === this._z &&
            e._order === this._order
        );
    }
    fromArray(e) {
        return (
            (this._x = e[0]),
            (this._y = e[1]),
            (this._z = e[2]),
            e[3] !== void 0 && (this._order = e[3]),
            this._onChangeCallback(),
            this
        );
    }
    toArray(e = [], t = 0) {
        return (
            (e[t] = this._x),
            (e[t + 1] = this._y),
            (e[t + 2] = this._z),
            (e[t + 3] = this._order),
            e
        );
    }
    _onChange(e) {
        return (this._onChangeCallback = e), this;
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
        yield this._x, yield this._y, yield this._z, yield this._order;
    }
}
as.DEFAULT_ORDER = 'XYZ';
class sc {
    constructor() {
        this.mask = 1;
    }
    set(e) {
        this.mask = ((1 << e) | 0) >>> 0;
    }
    enable(e) {
        this.mask |= (1 << e) | 0;
    }
    enableAll() {
        this.mask = -1;
    }
    toggle(e) {
        this.mask ^= (1 << e) | 0;
    }
    disable(e) {
        this.mask &= ~((1 << e) | 0);
    }
    disableAll() {
        this.mask = 0;
    }
    test(e) {
        return (this.mask & e.mask) !== 0;
    }
    isEnabled(e) {
        return (this.mask & ((1 << e) | 0)) !== 0;
    }
}
let hk = 0;
const U1 = new j(),
    wf = new Hr(),
    wa = new Pt(),
    fg = new j(),
    bd = new j(),
    dk = new j(),
    pk = new Hr(),
    O1 = new j(1, 0, 0),
    k1 = new j(0, 1, 0),
    F1 = new j(0, 0, 1),
    B1 = { type: 'added' },
    mk = { type: 'removed' },
    Mf = { type: 'childadded', child: null },
    Y0 = { type: 'childremoved', child: null };
class ln extends Ba {
    constructor() {
        super(),
            (this.isObject3D = !0),
            Object.defineProperty(this, 'id', { value: hk++ }),
            (this.uuid = os()),
            (this.name = ''),
            (this.type = 'Object3D'),
            (this.parent = null),
            (this.children = []),
            (this.up = ln.DEFAULT_UP.clone());
        const e = new j(),
            t = new as(),
            n = new Hr(),
            r = new j(1, 1, 1);
        function s() {
            n.setFromEuler(t, !1);
        }
        function a() {
            t.setFromQuaternion(n, void 0, !1);
        }
        t._onChange(s),
            n._onChange(a),
            Object.defineProperties(this, {
                position: { configurable: !0, enumerable: !0, value: e },
                rotation: { configurable: !0, enumerable: !0, value: t },
                quaternion: { configurable: !0, enumerable: !0, value: n },
                scale: { configurable: !0, enumerable: !0, value: r },
                modelViewMatrix: { value: new Pt() },
                normalMatrix: { value: new Wt() },
            }),
            (this.matrix = new Pt()),
            (this.matrixWorld = new Pt()),
            (this.matrixAutoUpdate = ln.DEFAULT_MATRIX_AUTO_UPDATE),
            (this.matrixWorldAutoUpdate = ln.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
            (this.matrixWorldNeedsUpdate = !1),
            (this.layers = new sc()),
            (this.visible = !0),
            (this.castShadow = !1),
            (this.receiveShadow = !1),
            (this.frustumCulled = !0),
            (this.renderOrder = 0),
            (this.animations = []),
            (this.userData = {});
    }
    onBeforeShadow() {}
    onAfterShadow() {}
    onBeforeRender() {}
    onAfterRender() {}
    applyMatrix4(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
            this.matrix.premultiply(e),
            this.matrix.decompose(this.position, this.quaternion, this.scale);
    }
    applyQuaternion(e) {
        return this.quaternion.premultiply(e), this;
    }
    setRotationFromAxisAngle(e, t) {
        this.quaternion.setFromAxisAngle(e, t);
    }
    setRotationFromEuler(e) {
        this.quaternion.setFromEuler(e, !0);
    }
    setRotationFromMatrix(e) {
        this.quaternion.setFromRotationMatrix(e);
    }
    setRotationFromQuaternion(e) {
        this.quaternion.copy(e);
    }
    rotateOnAxis(e, t) {
        return wf.setFromAxisAngle(e, t), this.quaternion.multiply(wf), this;
    }
    rotateOnWorldAxis(e, t) {
        return wf.setFromAxisAngle(e, t), this.quaternion.premultiply(wf), this;
    }
    rotateX(e) {
        return this.rotateOnAxis(O1, e);
    }
    rotateY(e) {
        return this.rotateOnAxis(k1, e);
    }
    rotateZ(e) {
        return this.rotateOnAxis(F1, e);
    }
    translateOnAxis(e, t) {
        return (
            U1.copy(e).applyQuaternion(this.quaternion),
            this.position.add(U1.multiplyScalar(t)),
            this
        );
    }
    translateX(e) {
        return this.translateOnAxis(O1, e);
    }
    translateY(e) {
        return this.translateOnAxis(k1, e);
    }
    translateZ(e) {
        return this.translateOnAxis(F1, e);
    }
    localToWorld(e) {
        return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
    }
    worldToLocal(e) {
        return (
            this.updateWorldMatrix(!0, !1),
            e.applyMatrix4(wa.copy(this.matrixWorld).invert())
        );
    }
    lookAt(e, t, n) {
        e.isVector3 ? fg.copy(e) : fg.set(e, t, n);
        const r = this.parent;
        this.updateWorldMatrix(!0, !1),
            bd.setFromMatrixPosition(this.matrixWorld),
            this.isCamera || this.isLight
                ? wa.lookAt(bd, fg, this.up)
                : wa.lookAt(fg, bd, this.up),
            this.quaternion.setFromRotationMatrix(wa),
            r &&
                (wa.extractRotation(r.matrixWorld),
                wf.setFromRotationMatrix(wa),
                this.quaternion.premultiply(wf.invert()));
    }
    add(e) {
        if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
            return this;
        }
        return e === this
            ? (console.error(
                  "THREE.Object3D.add: object can't be added as a child of itself.",
                  e
              ),
              this)
            : (e && e.isObject3D
                  ? (e.removeFromParent(),
                    (e.parent = this),
                    this.children.push(e),
                    e.dispatchEvent(B1),
                    (Mf.child = e),
                    this.dispatchEvent(Mf),
                    (Mf.child = null))
                  : console.error(
                        'THREE.Object3D.add: object not an instance of THREE.Object3D.',
                        e
                    ),
              this);
    }
    remove(e) {
        if (arguments.length > 1) {
            for (let n = 0; n < arguments.length; n++)
                this.remove(arguments[n]);
            return this;
        }
        const t = this.children.indexOf(e);
        return (
            t !== -1 &&
                ((e.parent = null),
                this.children.splice(t, 1),
                e.dispatchEvent(mk),
                (Y0.child = e),
                this.dispatchEvent(Y0),
                (Y0.child = null)),
            this
        );
    }
    removeFromParent() {
        const e = this.parent;
        return e !== null && e.remove(this), this;
    }
    clear() {
        return this.remove(...this.children);
    }
    attach(e) {
        return (
            this.updateWorldMatrix(!0, !1),
            wa.copy(this.matrixWorld).invert(),
            e.parent !== null &&
                (e.parent.updateWorldMatrix(!0, !1),
                wa.multiply(e.parent.matrixWorld)),
            e.applyMatrix4(wa),
            e.removeFromParent(),
            (e.parent = this),
            this.children.push(e),
            e.updateWorldMatrix(!1, !0),
            e.dispatchEvent(B1),
            (Mf.child = e),
            this.dispatchEvent(Mf),
            (Mf.child = null),
            this
        );
    }
    getObjectById(e) {
        return this.getObjectByProperty('id', e);
    }
    getObjectByName(e) {
        return this.getObjectByProperty('name', e);
    }
    getObjectByProperty(e, t) {
        if (this[e] === t) return this;
        for (let n = 0, r = this.children.length; n < r; n++) {
            const a = this.children[n].getObjectByProperty(e, t);
            if (a !== void 0) return a;
        }
    }
    getObjectsByProperty(e, t, n = []) {
        this[e] === t && n.push(this);
        const r = this.children;
        for (let s = 0, a = r.length; s < a; s++)
            r[s].getObjectsByProperty(e, t, n);
        return n;
    }
    getWorldPosition(e) {
        return (
            this.updateWorldMatrix(!0, !1),
            e.setFromMatrixPosition(this.matrixWorld)
        );
    }
    getWorldQuaternion(e) {
        return (
            this.updateWorldMatrix(!0, !1),
            this.matrixWorld.decompose(bd, e, dk),
            e
        );
    }
    getWorldScale(e) {
        return (
            this.updateWorldMatrix(!0, !1),
            this.matrixWorld.decompose(bd, pk, e),
            e
        );
    }
    getWorldDirection(e) {
        this.updateWorldMatrix(!0, !1);
        const t = this.matrixWorld.elements;
        return e.set(t[8], t[9], t[10]).normalize();
    }
    raycast() {}
    traverse(e) {
        e(this);
        const t = this.children;
        for (let n = 0, r = t.length; n < r; n++) t[n].traverse(e);
    }
    traverseVisible(e) {
        if (this.visible === !1) return;
        e(this);
        const t = this.children;
        for (let n = 0, r = t.length; n < r; n++) t[n].traverseVisible(e);
    }
    traverseAncestors(e) {
        const t = this.parent;
        t !== null && (e(t), t.traverseAncestors(e));
    }
    updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale),
            (this.matrixWorldNeedsUpdate = !0);
    }
    updateMatrixWorld(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
            (this.matrixWorldNeedsUpdate || e) &&
                (this.matrixWorldAutoUpdate === !0 &&
                    (this.parent === null
                        ? this.matrixWorld.copy(this.matrix)
                        : this.matrixWorld.multiplyMatrices(
                              this.parent.matrixWorld,
                              this.matrix
                          )),
                (this.matrixWorldNeedsUpdate = !1),
                (e = !0));
        const t = this.children;
        for (let n = 0, r = t.length; n < r; n++) t[n].updateMatrixWorld(e);
    }
    updateWorldMatrix(e, t) {
        const n = this.parent;
        if (
            (e === !0 && n !== null && n.updateWorldMatrix(!0, !1),
            this.matrixAutoUpdate && this.updateMatrix(),
            this.matrixWorldAutoUpdate === !0 &&
                (this.parent === null
                    ? this.matrixWorld.copy(this.matrix)
                    : this.matrixWorld.multiplyMatrices(
                          this.parent.matrixWorld,
                          this.matrix
                      )),
            t === !0)
        ) {
            const r = this.children;
            for (let s = 0, a = r.length; s < a; s++)
                r[s].updateWorldMatrix(!1, !0);
        }
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == 'string',
            n = {};
        t &&
            ((e = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {},
                skeletons: {},
                animations: {},
                nodes: {},
            }),
            (n.metadata = {
                version: 4.6,
                type: 'Object',
                generator: 'Object3D.toJSON',
            }));
        const r = {};
        (r.uuid = this.uuid),
            (r.type = this.type),
            this.name !== '' && (r.name = this.name),
            this.castShadow === !0 && (r.castShadow = !0),
            this.receiveShadow === !0 && (r.receiveShadow = !0),
            this.visible === !1 && (r.visible = !1),
            this.frustumCulled === !1 && (r.frustumCulled = !1),
            this.renderOrder !== 0 && (r.renderOrder = this.renderOrder),
            Object.keys(this.userData).length > 0 &&
                (r.userData = this.userData),
            (r.layers = this.layers.mask),
            (r.matrix = this.matrix.toArray()),
            (r.up = this.up.toArray()),
            this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1),
            this.isInstancedMesh &&
                ((r.type = 'InstancedMesh'),
                (r.count = this.count),
                (r.instanceMatrix = this.instanceMatrix.toJSON()),
                this.instanceColor !== null &&
                    (r.instanceColor = this.instanceColor.toJSON())),
            this.isBatchedMesh &&
                ((r.type = 'BatchedMesh'),
                (r.perObjectFrustumCulled = this.perObjectFrustumCulled),
                (r.sortObjects = this.sortObjects),
                (r.drawRanges = this._drawRanges),
                (r.reservedRanges = this._reservedRanges),
                (r.visibility = this._visibility),
                (r.active = this._active),
                (r.bounds = this._bounds.map((l) => ({
                    boxInitialized: l.boxInitialized,
                    boxMin: l.box.min.toArray(),
                    boxMax: l.box.max.toArray(),
                    sphereInitialized: l.sphereInitialized,
                    sphereRadius: l.sphere.radius,
                    sphereCenter: l.sphere.center.toArray(),
                }))),
                (r.maxInstanceCount = this._maxInstanceCount),
                (r.maxVertexCount = this._maxVertexCount),
                (r.maxIndexCount = this._maxIndexCount),
                (r.geometryInitialized = this._geometryInitialized),
                (r.geometryCount = this._geometryCount),
                (r.matricesTexture = this._matricesTexture.toJSON(e)),
                this._colorsTexture !== null &&
                    (r.colorsTexture = this._colorsTexture.toJSON(e)),
                this.boundingSphere !== null &&
                    (r.boundingSphere = {
                        center: r.boundingSphere.center.toArray(),
                        radius: r.boundingSphere.radius,
                    }),
                this.boundingBox !== null &&
                    (r.boundingBox = {
                        min: r.boundingBox.min.toArray(),
                        max: r.boundingBox.max.toArray(),
                    }));
        function s(l, c) {
            return l[c.uuid] === void 0 && (l[c.uuid] = c.toJSON(e)), c.uuid;
        }
        if (this.isScene)
            this.background &&
                (this.background.isColor
                    ? (r.background = this.background.toJSON())
                    : this.background.isTexture &&
                      (r.background = this.background.toJSON(e).uuid)),
                this.environment &&
                    this.environment.isTexture &&
                    this.environment.isRenderTargetTexture !== !0 &&
                    (r.environment = this.environment.toJSON(e).uuid);
        else if (this.isMesh || this.isLine || this.isPoints) {
            r.geometry = s(e.geometries, this.geometry);
            const l = this.geometry.parameters;
            if (l !== void 0 && l.shapes !== void 0) {
                const c = l.shapes;
                if (Array.isArray(c))
                    for (let d = 0, p = c.length; d < p; d++) {
                        const g = c[d];
                        s(e.shapes, g);
                    }
                else s(e.shapes, c);
            }
        }
        if (
            (this.isSkinnedMesh &&
                ((r.bindMode = this.bindMode),
                (r.bindMatrix = this.bindMatrix.toArray()),
                this.skeleton !== void 0 &&
                    (s(e.skeletons, this.skeleton),
                    (r.skeleton = this.skeleton.uuid))),
            this.material !== void 0)
        )
            if (Array.isArray(this.material)) {
                const l = [];
                for (let c = 0, d = this.material.length; c < d; c++)
                    l.push(s(e.materials, this.material[c]));
                r.material = l;
            } else r.material = s(e.materials, this.material);
        if (this.children.length > 0) {
            r.children = [];
            for (let l = 0; l < this.children.length; l++)
                r.children.push(this.children[l].toJSON(e).object);
        }
        if (this.animations.length > 0) {
            r.animations = [];
            for (let l = 0; l < this.animations.length; l++) {
                const c = this.animations[l];
                r.animations.push(s(e.animations, c));
            }
        }
        if (t) {
            const l = a(e.geometries),
                c = a(e.materials),
                d = a(e.textures),
                p = a(e.images),
                g = a(e.shapes),
                y = a(e.skeletons),
                v = a(e.animations),
                S = a(e.nodes);
            l.length > 0 && (n.geometries = l),
                c.length > 0 && (n.materials = c),
                d.length > 0 && (n.textures = d),
                p.length > 0 && (n.images = p),
                g.length > 0 && (n.shapes = g),
                y.length > 0 && (n.skeletons = y),
                v.length > 0 && (n.animations = v),
                S.length > 0 && (n.nodes = S);
        }
        return (n.object = r), n;
        function a(l) {
            const c = [];
            for (const d in l) {
                const p = l[d];
                delete p.metadata, c.push(p);
            }
            return c;
        }
    }
    clone(e) {
        return new this.constructor().copy(this, e);
    }
    copy(e, t = !0) {
        if (
            ((this.name = e.name),
            this.up.copy(e.up),
            this.position.copy(e.position),
            (this.rotation.order = e.rotation.order),
            this.quaternion.copy(e.quaternion),
            this.scale.copy(e.scale),
            this.matrix.copy(e.matrix),
            this.matrixWorld.copy(e.matrixWorld),
            (this.matrixAutoUpdate = e.matrixAutoUpdate),
            (this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate),
            (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
            (this.layers.mask = e.layers.mask),
            (this.visible = e.visible),
            (this.castShadow = e.castShadow),
            (this.receiveShadow = e.receiveShadow),
            (this.frustumCulled = e.frustumCulled),
            (this.renderOrder = e.renderOrder),
            (this.animations = e.animations.slice()),
            (this.userData = JSON.parse(JSON.stringify(e.userData))),
            t === !0)
        )
            for (let n = 0; n < e.children.length; n++) {
                const r = e.children[n];
                this.add(r.clone());
            }
        return this;
    }
}
ln.DEFAULT_UP = new j(0, 1, 0);
ln.DEFAULT_MATRIX_AUTO_UPDATE = !0;
ln.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const to = new j(),
    Ma = new j(),
    K0 = new j(),
    Ea = new j(),
    Ef = new j(),
    Tf = new j(),
    z1 = new j(),
    Z0 = new j(),
    J0 = new j(),
    Q0 = new j();
class ss {
    constructor(e = new j(), t = new j(), n = new j()) {
        (this.a = e), (this.b = t), (this.c = n);
    }
    static getNormal(e, t, n, r) {
        r.subVectors(n, t), to.subVectors(e, t), r.cross(to);
        const s = r.lengthSq();
        return s > 0 ? r.multiplyScalar(1 / Math.sqrt(s)) : r.set(0, 0, 0);
    }
    static getBarycoord(e, t, n, r, s) {
        to.subVectors(r, t), Ma.subVectors(n, t), K0.subVectors(e, t);
        const a = to.dot(to),
            l = to.dot(Ma),
            c = to.dot(K0),
            d = Ma.dot(Ma),
            p = Ma.dot(K0),
            g = a * d - l * l;
        if (g === 0) return s.set(0, 0, 0), null;
        const y = 1 / g,
            v = (d * c - l * p) * y,
            S = (a * p - l * c) * y;
        return s.set(1 - v - S, S, v);
    }
    static containsPoint(e, t, n, r) {
        return this.getBarycoord(e, t, n, r, Ea) === null
            ? !1
            : Ea.x >= 0 && Ea.y >= 0 && Ea.x + Ea.y <= 1;
    }
    static getInterpolation(e, t, n, r, s, a, l, c) {
        return this.getBarycoord(e, t, n, r, Ea) === null
            ? ((c.x = 0),
              (c.y = 0),
              'z' in c && (c.z = 0),
              'w' in c && (c.w = 0),
              null)
            : (c.setScalar(0),
              c.addScaledVector(s, Ea.x),
              c.addScaledVector(a, Ea.y),
              c.addScaledVector(l, Ea.z),
              c);
    }
    static isFrontFacing(e, t, n, r) {
        return (
            to.subVectors(n, t), Ma.subVectors(e, t), to.cross(Ma).dot(r) < 0
        );
    }
    set(e, t, n) {
        return this.a.copy(e), this.b.copy(t), this.c.copy(n), this;
    }
    setFromPointsAndIndices(e, t, n, r) {
        return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[r]), this;
    }
    setFromAttributeAndIndices(e, t, n, r) {
        return (
            this.a.fromBufferAttribute(e, t),
            this.b.fromBufferAttribute(e, n),
            this.c.fromBufferAttribute(e, r),
            this
        );
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(e) {
        return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
    }
    getArea() {
        return (
            to.subVectors(this.c, this.b),
            Ma.subVectors(this.a, this.b),
            to.cross(Ma).length() * 0.5
        );
    }
    getMidpoint(e) {
        return e
            .addVectors(this.a, this.b)
            .add(this.c)
            .multiplyScalar(1 / 3);
    }
    getNormal(e) {
        return ss.getNormal(this.a, this.b, this.c, e);
    }
    getPlane(e) {
        return e.setFromCoplanarPoints(this.a, this.b, this.c);
    }
    getBarycoord(e, t) {
        return ss.getBarycoord(e, this.a, this.b, this.c, t);
    }
    getInterpolation(e, t, n, r, s) {
        return ss.getInterpolation(e, this.a, this.b, this.c, t, n, r, s);
    }
    containsPoint(e) {
        return ss.containsPoint(e, this.a, this.b, this.c);
    }
    isFrontFacing(e) {
        return ss.isFrontFacing(this.a, this.b, this.c, e);
    }
    intersectsBox(e) {
        return e.intersectsTriangle(this);
    }
    closestPointToPoint(e, t) {
        const n = this.a,
            r = this.b,
            s = this.c;
        let a, l;
        Ef.subVectors(r, n), Tf.subVectors(s, n), Z0.subVectors(e, n);
        const c = Ef.dot(Z0),
            d = Tf.dot(Z0);
        if (c <= 0 && d <= 0) return t.copy(n);
        J0.subVectors(e, r);
        const p = Ef.dot(J0),
            g = Tf.dot(J0);
        if (p >= 0 && g <= p) return t.copy(r);
        const y = c * g - p * d;
        if (y <= 0 && c >= 0 && p <= 0)
            return (a = c / (c - p)), t.copy(n).addScaledVector(Ef, a);
        Q0.subVectors(e, s);
        const v = Ef.dot(Q0),
            S = Tf.dot(Q0);
        if (S >= 0 && v <= S) return t.copy(s);
        const T = v * d - c * S;
        if (T <= 0 && d >= 0 && S <= 0)
            return (l = d / (d - S)), t.copy(n).addScaledVector(Tf, l);
        const M = p * S - v * g;
        if (M <= 0 && g - p >= 0 && v - S >= 0)
            return (
                z1.subVectors(s, r),
                (l = (g - p) / (g - p + (v - S))),
                t.copy(r).addScaledVector(z1, l)
            );
        const w = 1 / (M + T + y);
        return (
            (a = T * w),
            (l = y * w),
            t.copy(n).addScaledVector(Ef, a).addScaledVector(Tf, l)
        );
    }
    equals(e) {
        return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
    }
}
const $R = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074,
    },
    El = { h: 0, s: 0, l: 0 },
    hg = { h: 0, s: 0, l: 0 };
function ex(i, e, t) {
    return (
        t < 0 && (t += 1),
        t > 1 && (t -= 1),
        t < 1 / 6
            ? i + (e - i) * 6 * t
            : t < 1 / 2
              ? e
              : t < 2 / 3
                ? i + (e - i) * 6 * (2 / 3 - t)
                : i
    );
}
class st {
    constructor(e, t, n) {
        return (
            (this.isColor = !0),
            (this.r = 1),
            (this.g = 1),
            (this.b = 1),
            this.set(e, t, n)
        );
    }
    set(e, t, n) {
        if (t === void 0 && n === void 0) {
            const r = e;
            r && r.isColor
                ? this.copy(r)
                : typeof r == 'number'
                  ? this.setHex(r)
                  : typeof r == 'string' && this.setStyle(r);
        } else this.setRGB(e, t, n);
        return this;
    }
    setScalar(e) {
        return (this.r = e), (this.g = e), (this.b = e), this;
    }
    setHex(e, t = ws) {
        return (
            (e = Math.floor(e)),
            (this.r = ((e >> 16) & 255) / 255),
            (this.g = ((e >> 8) & 255) / 255),
            (this.b = (e & 255) / 255),
            hn.toWorkingColorSpace(this, t),
            this
        );
    }
    setRGB(e, t, n, r = hn.workingColorSpace) {
        return (
            (this.r = e),
            (this.g = t),
            (this.b = n),
            hn.toWorkingColorSpace(this, r),
            this
        );
    }
    setHSL(e, t, n, r = hn.workingColorSpace) {
        if (((e = BS(e, 1)), (t = Jn(t, 0, 1)), (n = Jn(n, 0, 1)), t === 0))
            this.r = this.g = this.b = n;
        else {
            const s = n <= 0.5 ? n * (1 + t) : n + t - n * t,
                a = 2 * n - s;
            (this.r = ex(a, s, e + 1 / 3)),
                (this.g = ex(a, s, e)),
                (this.b = ex(a, s, e - 1 / 3));
        }
        return hn.toWorkingColorSpace(this, r), this;
    }
    setStyle(e, t = ws) {
        function n(s) {
            s !== void 0 &&
                parseFloat(s) < 1 &&
                console.warn(
                    'THREE.Color: Alpha component of ' + e + ' will be ignored.'
                );
        }
        let r;
        if ((r = /^(\w+)\(([^\)]*)\)/.exec(e))) {
            let s;
            const a = r[1],
                l = r[2];
            switch (a) {
                case 'rgb':
                case 'rgba':
                    if (
                        (s =
                            /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                                l
                            ))
                    )
                        return (
                            n(s[4]),
                            this.setRGB(
                                Math.min(255, parseInt(s[1], 10)) / 255,
                                Math.min(255, parseInt(s[2], 10)) / 255,
                                Math.min(255, parseInt(s[3], 10)) / 255,
                                t
                            )
                        );
                    if (
                        (s =
                            /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                                l
                            ))
                    )
                        return (
                            n(s[4]),
                            this.setRGB(
                                Math.min(100, parseInt(s[1], 10)) / 100,
                                Math.min(100, parseInt(s[2], 10)) / 100,
                                Math.min(100, parseInt(s[3], 10)) / 100,
                                t
                            )
                        );
                    break;
                case 'hsl':
                case 'hsla':
                    if (
                        (s =
                            /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                                l
                            ))
                    )
                        return (
                            n(s[4]),
                            this.setHSL(
                                parseFloat(s[1]) / 360,
                                parseFloat(s[2]) / 100,
                                parseFloat(s[3]) / 100,
                                t
                            )
                        );
                    break;
                default:
                    console.warn('THREE.Color: Unknown color model ' + e);
            }
        } else if ((r = /^\#([A-Fa-f\d]+)$/.exec(e))) {
            const s = r[1],
                a = s.length;
            if (a === 3)
                return this.setRGB(
                    parseInt(s.charAt(0), 16) / 15,
                    parseInt(s.charAt(1), 16) / 15,
                    parseInt(s.charAt(2), 16) / 15,
                    t
                );
            if (a === 6) return this.setHex(parseInt(s, 16), t);
            console.warn('THREE.Color: Invalid hex color ' + e);
        } else if (e && e.length > 0) return this.setColorName(e, t);
        return this;
    }
    setColorName(e, t = ws) {
        const n = $R[e.toLowerCase()];
        return (
            n !== void 0
                ? this.setHex(n, t)
                : console.warn('THREE.Color: Unknown color ' + e),
            this
        );
    }
    clone() {
        return new this.constructor(this.r, this.g, this.b);
    }
    copy(e) {
        return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
    }
    copySRGBToLinear(e) {
        return (this.r = sh(e.r)), (this.g = sh(e.g)), (this.b = sh(e.b)), this;
    }
    copyLinearToSRGB(e) {
        return (this.r = V0(e.r)), (this.g = V0(e.g)), (this.b = V0(e.b)), this;
    }
    convertSRGBToLinear() {
        return this.copySRGBToLinear(this), this;
    }
    convertLinearToSRGB() {
        return this.copyLinearToSRGB(this), this;
    }
    getHex(e = ws) {
        return (
            hn.fromWorkingColorSpace(tr.copy(this), e),
            Math.round(Jn(tr.r * 255, 0, 255)) * 65536 +
                Math.round(Jn(tr.g * 255, 0, 255)) * 256 +
                Math.round(Jn(tr.b * 255, 0, 255))
        );
    }
    getHexString(e = ws) {
        return ('000000' + this.getHex(e).toString(16)).slice(-6);
    }
    getHSL(e, t = hn.workingColorSpace) {
        hn.fromWorkingColorSpace(tr.copy(this), t);
        const n = tr.r,
            r = tr.g,
            s = tr.b,
            a = Math.max(n, r, s),
            l = Math.min(n, r, s);
        let c, d;
        const p = (l + a) / 2;
        if (l === a) (c = 0), (d = 0);
        else {
            const g = a - l;
            switch (((d = p <= 0.5 ? g / (a + l) : g / (2 - a - l)), a)) {
                case n:
                    c = (r - s) / g + (r < s ? 6 : 0);
                    break;
                case r:
                    c = (s - n) / g + 2;
                    break;
                case s:
                    c = (n - r) / g + 4;
                    break;
            }
            c /= 6;
        }
        return (e.h = c), (e.s = d), (e.l = p), e;
    }
    getRGB(e, t = hn.workingColorSpace) {
        return (
            hn.fromWorkingColorSpace(tr.copy(this), t),
            (e.r = tr.r),
            (e.g = tr.g),
            (e.b = tr.b),
            e
        );
    }
    getStyle(e = ws) {
        hn.fromWorkingColorSpace(tr.copy(this), e);
        const t = tr.r,
            n = tr.g,
            r = tr.b;
        return e !== ws
            ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${r.toFixed(3)})`
            : `rgb(${Math.round(t * 255)},${Math.round(n * 255)},${Math.round(r * 255)})`;
    }
    offsetHSL(e, t, n) {
        return this.getHSL(El), this.setHSL(El.h + e, El.s + t, El.l + n);
    }
    add(e) {
        return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
    }
    addColors(e, t) {
        return (
            (this.r = e.r + t.r),
            (this.g = e.g + t.g),
            (this.b = e.b + t.b),
            this
        );
    }
    addScalar(e) {
        return (this.r += e), (this.g += e), (this.b += e), this;
    }
    sub(e) {
        return (
            (this.r = Math.max(0, this.r - e.r)),
            (this.g = Math.max(0, this.g - e.g)),
            (this.b = Math.max(0, this.b - e.b)),
            this
        );
    }
    multiply(e) {
        return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
    }
    multiplyScalar(e) {
        return (this.r *= e), (this.g *= e), (this.b *= e), this;
    }
    lerp(e, t) {
        return (
            (this.r += (e.r - this.r) * t),
            (this.g += (e.g - this.g) * t),
            (this.b += (e.b - this.b) * t),
            this
        );
    }
    lerpColors(e, t, n) {
        return (
            (this.r = e.r + (t.r - e.r) * n),
            (this.g = e.g + (t.g - e.g) * n),
            (this.b = e.b + (t.b - e.b) * n),
            this
        );
    }
    lerpHSL(e, t) {
        this.getHSL(El), e.getHSL(hg);
        const n = rp(El.h, hg.h, t),
            r = rp(El.s, hg.s, t),
            s = rp(El.l, hg.l, t);
        return this.setHSL(n, r, s), this;
    }
    setFromVector3(e) {
        return (this.r = e.x), (this.g = e.y), (this.b = e.z), this;
    }
    applyMatrix3(e) {
        const t = this.r,
            n = this.g,
            r = this.b,
            s = e.elements;
        return (
            (this.r = s[0] * t + s[3] * n + s[6] * r),
            (this.g = s[1] * t + s[4] * n + s[7] * r),
            (this.b = s[2] * t + s[5] * n + s[8] * r),
            this
        );
    }
    equals(e) {
        return e.r === this.r && e.g === this.g && e.b === this.b;
    }
    fromArray(e, t = 0) {
        return (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this;
    }
    toArray(e = [], t = 0) {
        return (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e;
    }
    fromBufferAttribute(e, t) {
        return (
            (this.r = e.getX(t)),
            (this.g = e.getY(t)),
            (this.b = e.getZ(t)),
            this
        );
    }
    toJSON() {
        return this.getHex();
    }
    *[Symbol.iterator]() {
        yield this.r, yield this.g, yield this.b;
    }
}
const tr = new st();
st.NAMES = $R;
let gk = 0;
class lr extends Ba {
    constructor() {
        super(),
            (this.isMaterial = !0),
            Object.defineProperty(this, 'id', { value: gk++ }),
            (this.uuid = os()),
            (this.name = ''),
            (this.type = 'Material'),
            (this.blending = nc),
            (this.side = Na),
            (this.vertexColors = !1),
            (this.opacity = 1),
            (this.transparent = !1),
            (this.alphaHash = !1),
            (this.blendSrc = gy),
            (this.blendDst = yy),
            (this.blendEquation = Ll),
            (this.blendSrcAlpha = null),
            (this.blendDstAlpha = null),
            (this.blendEquationAlpha = null),
            (this.blendColor = new st(0, 0, 0)),
            (this.blendAlpha = 0),
            (this.depthFunc = yp),
            (this.depthTest = !0),
            (this.depthWrite = !0),
            (this.stencilWriteMask = 255),
            (this.stencilFunc = g_),
            (this.stencilRef = 0),
            (this.stencilFuncMask = 255),
            (this.stencilFail = Wu),
            (this.stencilZFail = Wu),
            (this.stencilZPass = Wu),
            (this.stencilWrite = !1),
            (this.clippingPlanes = null),
            (this.clipIntersection = !1),
            (this.clipShadows = !1),
            (this.shadowSide = null),
            (this.colorWrite = !0),
            (this.precision = null),
            (this.polygonOffset = !1),
            (this.polygonOffsetFactor = 0),
            (this.polygonOffsetUnits = 0),
            (this.dithering = !1),
            (this.alphaToCoverage = !1),
            (this.premultipliedAlpha = !1),
            (this.forceSinglePass = !1),
            (this.visible = !0),
            (this.toneMapped = !0),
            (this.userData = {}),
            (this.version = 0),
            (this._alphaTest = 0);
    }
    get alphaTest() {
        return this._alphaTest;
    }
    set alphaTest(e) {
        this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e);
    }
    onBeforeCompile() {}
    customProgramCacheKey() {
        return this.onBeforeCompile.toString();
    }
    setValues(e) {
        if (e !== void 0)
            for (const t in e) {
                const n = e[t];
                if (n === void 0) {
                    console.warn(
                        `THREE.Material: parameter '${t}' has value of undefined.`
                    );
                    continue;
                }
                const r = this[t];
                if (r === void 0) {
                    console.warn(
                        `THREE.Material: '${t}' is not a property of THREE.${this.type}.`
                    );
                    continue;
                }
                r && r.isColor
                    ? r.set(n)
                    : r && r.isVector3 && n && n.isVector3
                      ? r.copy(n)
                      : (this[t] = n);
            }
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == 'string';
        t && (e = { textures: {}, images: {} });
        const n = {
            metadata: {
                version: 4.6,
                type: 'Material',
                generator: 'Material.toJSON',
            },
        };
        (n.uuid = this.uuid),
            (n.type = this.type),
            this.name !== '' && (n.name = this.name),
            this.color && this.color.isColor && (n.color = this.color.getHex()),
            this.roughness !== void 0 && (n.roughness = this.roughness),
            this.metalness !== void 0 && (n.metalness = this.metalness),
            this.sheen !== void 0 && (n.sheen = this.sheen),
            this.sheenColor &&
                this.sheenColor.isColor &&
                (n.sheenColor = this.sheenColor.getHex()),
            this.sheenRoughness !== void 0 &&
                (n.sheenRoughness = this.sheenRoughness),
            this.emissive &&
                this.emissive.isColor &&
                (n.emissive = this.emissive.getHex()),
            this.emissiveIntensity !== void 0 &&
                this.emissiveIntensity !== 1 &&
                (n.emissiveIntensity = this.emissiveIntensity),
            this.specular &&
                this.specular.isColor &&
                (n.specular = this.specular.getHex()),
            this.specularIntensity !== void 0 &&
                (n.specularIntensity = this.specularIntensity),
            this.specularColor &&
                this.specularColor.isColor &&
                (n.specularColor = this.specularColor.getHex()),
            this.shininess !== void 0 && (n.shininess = this.shininess),
            this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat),
            this.clearcoatRoughness !== void 0 &&
                (n.clearcoatRoughness = this.clearcoatRoughness),
            this.clearcoatMap &&
                this.clearcoatMap.isTexture &&
                (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
            this.clearcoatRoughnessMap &&
                this.clearcoatRoughnessMap.isTexture &&
                (n.clearcoatRoughnessMap =
                    this.clearcoatRoughnessMap.toJSON(e).uuid),
            this.clearcoatNormalMap &&
                this.clearcoatNormalMap.isTexture &&
                ((n.clearcoatNormalMap =
                    this.clearcoatNormalMap.toJSON(e).uuid),
                (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
            this.dispersion !== void 0 && (n.dispersion = this.dispersion),
            this.iridescence !== void 0 && (n.iridescence = this.iridescence),
            this.iridescenceIOR !== void 0 &&
                (n.iridescenceIOR = this.iridescenceIOR),
            this.iridescenceThicknessRange !== void 0 &&
                (n.iridescenceThicknessRange = this.iridescenceThicknessRange),
            this.iridescenceMap &&
                this.iridescenceMap.isTexture &&
                (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
            this.iridescenceThicknessMap &&
                this.iridescenceThicknessMap.isTexture &&
                (n.iridescenceThicknessMap =
                    this.iridescenceThicknessMap.toJSON(e).uuid),
            this.anisotropy !== void 0 && (n.anisotropy = this.anisotropy),
            this.anisotropyRotation !== void 0 &&
                (n.anisotropyRotation = this.anisotropyRotation),
            this.anisotropyMap &&
                this.anisotropyMap.isTexture &&
                (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
            this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid),
            this.matcap &&
                this.matcap.isTexture &&
                (n.matcap = this.matcap.toJSON(e).uuid),
            this.alphaMap &&
                this.alphaMap.isTexture &&
                (n.alphaMap = this.alphaMap.toJSON(e).uuid),
            this.lightMap &&
                this.lightMap.isTexture &&
                ((n.lightMap = this.lightMap.toJSON(e).uuid),
                (n.lightMapIntensity = this.lightMapIntensity)),
            this.aoMap &&
                this.aoMap.isTexture &&
                ((n.aoMap = this.aoMap.toJSON(e).uuid),
                (n.aoMapIntensity = this.aoMapIntensity)),
            this.bumpMap &&
                this.bumpMap.isTexture &&
                ((n.bumpMap = this.bumpMap.toJSON(e).uuid),
                (n.bumpScale = this.bumpScale)),
            this.normalMap &&
                this.normalMap.isTexture &&
                ((n.normalMap = this.normalMap.toJSON(e).uuid),
                (n.normalMapType = this.normalMapType),
                (n.normalScale = this.normalScale.toArray())),
            this.displacementMap &&
                this.displacementMap.isTexture &&
                ((n.displacementMap = this.displacementMap.toJSON(e).uuid),
                (n.displacementScale = this.displacementScale),
                (n.displacementBias = this.displacementBias)),
            this.roughnessMap &&
                this.roughnessMap.isTexture &&
                (n.roughnessMap = this.roughnessMap.toJSON(e).uuid),
            this.metalnessMap &&
                this.metalnessMap.isTexture &&
                (n.metalnessMap = this.metalnessMap.toJSON(e).uuid),
            this.emissiveMap &&
                this.emissiveMap.isTexture &&
                (n.emissiveMap = this.emissiveMap.toJSON(e).uuid),
            this.specularMap &&
                this.specularMap.isTexture &&
                (n.specularMap = this.specularMap.toJSON(e).uuid),
            this.specularIntensityMap &&
                this.specularIntensityMap.isTexture &&
                (n.specularIntensityMap =
                    this.specularIntensityMap.toJSON(e).uuid),
            this.specularColorMap &&
                this.specularColorMap.isTexture &&
                (n.specularColorMap = this.specularColorMap.toJSON(e).uuid),
            this.envMap &&
                this.envMap.isTexture &&
                ((n.envMap = this.envMap.toJSON(e).uuid),
                this.combine !== void 0 && (n.combine = this.combine)),
            this.envMapRotation !== void 0 &&
                (n.envMapRotation = this.envMapRotation.toArray()),
            this.envMapIntensity !== void 0 &&
                (n.envMapIntensity = this.envMapIntensity),
            this.reflectivity !== void 0 &&
                (n.reflectivity = this.reflectivity),
            this.refractionRatio !== void 0 &&
                (n.refractionRatio = this.refractionRatio),
            this.gradientMap &&
                this.gradientMap.isTexture &&
                (n.gradientMap = this.gradientMap.toJSON(e).uuid),
            this.transmission !== void 0 &&
                (n.transmission = this.transmission),
            this.transmissionMap &&
                this.transmissionMap.isTexture &&
                (n.transmissionMap = this.transmissionMap.toJSON(e).uuid),
            this.thickness !== void 0 && (n.thickness = this.thickness),
            this.thicknessMap &&
                this.thicknessMap.isTexture &&
                (n.thicknessMap = this.thicknessMap.toJSON(e).uuid),
            this.attenuationDistance !== void 0 &&
                this.attenuationDistance !== 1 / 0 &&
                (n.attenuationDistance = this.attenuationDistance),
            this.attenuationColor !== void 0 &&
                (n.attenuationColor = this.attenuationColor.getHex()),
            this.size !== void 0 && (n.size = this.size),
            this.shadowSide !== null && (n.shadowSide = this.shadowSide),
            this.sizeAttenuation !== void 0 &&
                (n.sizeAttenuation = this.sizeAttenuation),
            this.blending !== nc && (n.blending = this.blending),
            this.side !== Na && (n.side = this.side),
            this.vertexColors === !0 && (n.vertexColors = !0),
            this.opacity < 1 && (n.opacity = this.opacity),
            this.transparent === !0 && (n.transparent = !0),
            this.blendSrc !== gy && (n.blendSrc = this.blendSrc),
            this.blendDst !== yy && (n.blendDst = this.blendDst),
            this.blendEquation !== Ll && (n.blendEquation = this.blendEquation),
            this.blendSrcAlpha !== null &&
                (n.blendSrcAlpha = this.blendSrcAlpha),
            this.blendDstAlpha !== null &&
                (n.blendDstAlpha = this.blendDstAlpha),
            this.blendEquationAlpha !== null &&
                (n.blendEquationAlpha = this.blendEquationAlpha),
            this.blendColor &&
                this.blendColor.isColor &&
                (n.blendColor = this.blendColor.getHex()),
            this.blendAlpha !== 0 && (n.blendAlpha = this.blendAlpha),
            this.depthFunc !== yp && (n.depthFunc = this.depthFunc),
            this.depthTest === !1 && (n.depthTest = this.depthTest),
            this.depthWrite === !1 && (n.depthWrite = this.depthWrite),
            this.colorWrite === !1 && (n.colorWrite = this.colorWrite),
            this.stencilWriteMask !== 255 &&
                (n.stencilWriteMask = this.stencilWriteMask),
            this.stencilFunc !== g_ && (n.stencilFunc = this.stencilFunc),
            this.stencilRef !== 0 && (n.stencilRef = this.stencilRef),
            this.stencilFuncMask !== 255 &&
                (n.stencilFuncMask = this.stencilFuncMask),
            this.stencilFail !== Wu && (n.stencilFail = this.stencilFail),
            this.stencilZFail !== Wu && (n.stencilZFail = this.stencilZFail),
            this.stencilZPass !== Wu && (n.stencilZPass = this.stencilZPass),
            this.stencilWrite === !0 && (n.stencilWrite = this.stencilWrite),
            this.rotation !== void 0 &&
                this.rotation !== 0 &&
                (n.rotation = this.rotation),
            this.polygonOffset === !0 && (n.polygonOffset = !0),
            this.polygonOffsetFactor !== 0 &&
                (n.polygonOffsetFactor = this.polygonOffsetFactor),
            this.polygonOffsetUnits !== 0 &&
                (n.polygonOffsetUnits = this.polygonOffsetUnits),
            this.linewidth !== void 0 &&
                this.linewidth !== 1 &&
                (n.linewidth = this.linewidth),
            this.dashSize !== void 0 && (n.dashSize = this.dashSize),
            this.gapSize !== void 0 && (n.gapSize = this.gapSize),
            this.scale !== void 0 && (n.scale = this.scale),
            this.dithering === !0 && (n.dithering = !0),
            this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
            this.alphaHash === !0 && (n.alphaHash = !0),
            this.alphaToCoverage === !0 && (n.alphaToCoverage = !0),
            this.premultipliedAlpha === !0 && (n.premultipliedAlpha = !0),
            this.forceSinglePass === !0 && (n.forceSinglePass = !0),
            this.wireframe === !0 && (n.wireframe = !0),
            this.wireframeLinewidth > 1 &&
                (n.wireframeLinewidth = this.wireframeLinewidth),
            this.wireframeLinecap !== 'round' &&
                (n.wireframeLinecap = this.wireframeLinecap),
            this.wireframeLinejoin !== 'round' &&
                (n.wireframeLinejoin = this.wireframeLinejoin),
            this.flatShading === !0 && (n.flatShading = !0),
            this.visible === !1 && (n.visible = !1),
            this.toneMapped === !1 && (n.toneMapped = !1),
            this.fog === !1 && (n.fog = !1),
            Object.keys(this.userData).length > 0 &&
                (n.userData = this.userData);
        function r(s) {
            const a = [];
            for (const l in s) {
                const c = s[l];
                delete c.metadata, a.push(c);
            }
            return a;
        }
        if (t) {
            const s = r(e.textures),
                a = r(e.images);
            s.length > 0 && (n.textures = s), a.length > 0 && (n.images = a);
        }
        return n;
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(e) {
        (this.name = e.name),
            (this.blending = e.blending),
            (this.side = e.side),
            (this.vertexColors = e.vertexColors),
            (this.opacity = e.opacity),
            (this.transparent = e.transparent),
            (this.blendSrc = e.blendSrc),
            (this.blendDst = e.blendDst),
            (this.blendEquation = e.blendEquation),
            (this.blendSrcAlpha = e.blendSrcAlpha),
            (this.blendDstAlpha = e.blendDstAlpha),
            (this.blendEquationAlpha = e.blendEquationAlpha),
            this.blendColor.copy(e.blendColor),
            (this.blendAlpha = e.blendAlpha),
            (this.depthFunc = e.depthFunc),
            (this.depthTest = e.depthTest),
            (this.depthWrite = e.depthWrite),
            (this.stencilWriteMask = e.stencilWriteMask),
            (this.stencilFunc = e.stencilFunc),
            (this.stencilRef = e.stencilRef),
            (this.stencilFuncMask = e.stencilFuncMask),
            (this.stencilFail = e.stencilFail),
            (this.stencilZFail = e.stencilZFail),
            (this.stencilZPass = e.stencilZPass),
            (this.stencilWrite = e.stencilWrite);
        const t = e.clippingPlanes;
        let n = null;
        if (t !== null) {
            const r = t.length;
            n = new Array(r);
            for (let s = 0; s !== r; ++s) n[s] = t[s].clone();
        }
        return (
            (this.clippingPlanes = n),
            (this.clipIntersection = e.clipIntersection),
            (this.clipShadows = e.clipShadows),
            (this.shadowSide = e.shadowSide),
            (this.colorWrite = e.colorWrite),
            (this.precision = e.precision),
            (this.polygonOffset = e.polygonOffset),
            (this.polygonOffsetFactor = e.polygonOffsetFactor),
            (this.polygonOffsetUnits = e.polygonOffsetUnits),
            (this.dithering = e.dithering),
            (this.alphaTest = e.alphaTest),
            (this.alphaHash = e.alphaHash),
            (this.alphaToCoverage = e.alphaToCoverage),
            (this.premultipliedAlpha = e.premultipliedAlpha),
            (this.forceSinglePass = e.forceSinglePass),
            (this.visible = e.visible),
            (this.toneMapped = e.toneMapped),
            (this.userData = JSON.parse(JSON.stringify(e.userData))),
            this
        );
    }
    dispose() {
        this.dispatchEvent({ type: 'dispose' });
    }
    set needsUpdate(e) {
        e === !0 && this.version++;
    }
    onBuild() {
        console.warn('Material: onBuild() has been removed.');
    }
    onBeforeRender() {
        console.warn('Material: onBeforeRender() has been removed.');
    }
}
class zl extends lr {
    constructor(e) {
        super(),
            (this.isMeshBasicMaterial = !0),
            (this.type = 'MeshBasicMaterial'),
            (this.color = new st(16777215)),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.specularMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.envMapRotation = new as()),
            (this.combine = qp),
            (this.reflectivity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = 'round'),
            (this.wireframeLinejoin = 'round'),
            (this.fog = !0),
            this.setValues(e);
    }
    copy(e) {
        return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            (this.specularMap = e.specularMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            this.envMapRotation.copy(e.envMapRotation),
            (this.combine = e.combine),
            (this.reflectivity = e.reflectivity),
            (this.refractionRatio = e.refractionRatio),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.fog = e.fog),
            this
        );
    }
}
const Ca = yk();
function yk() {
    const i = new ArrayBuffer(4),
        e = new Float32Array(i),
        t = new Uint32Array(i),
        n = new Uint32Array(512),
        r = new Uint32Array(512);
    for (let c = 0; c < 256; ++c) {
        const d = c - 127;
        d < -27
            ? ((n[c] = 0), (n[c | 256] = 32768), (r[c] = 24), (r[c | 256] = 24))
            : d < -14
              ? ((n[c] = 1024 >> (-d - 14)),
                (n[c | 256] = (1024 >> (-d - 14)) | 32768),
                (r[c] = -d - 1),
                (r[c | 256] = -d - 1))
              : d <= 15
                ? ((n[c] = (d + 15) << 10),
                  (n[c | 256] = ((d + 15) << 10) | 32768),
                  (r[c] = 13),
                  (r[c | 256] = 13))
                : d < 128
                  ? ((n[c] = 31744),
                    (n[c | 256] = 64512),
                    (r[c] = 24),
                    (r[c | 256] = 24))
                  : ((n[c] = 31744),
                    (n[c | 256] = 64512),
                    (r[c] = 13),
                    (r[c | 256] = 13));
    }
    const s = new Uint32Array(2048),
        a = new Uint32Array(64),
        l = new Uint32Array(64);
    for (let c = 1; c < 1024; ++c) {
        let d = c << 13,
            p = 0;
        for (; (d & 8388608) === 0; ) (d <<= 1), (p -= 8388608);
        (d &= -8388609), (p += 947912704), (s[c] = d | p);
    }
    for (let c = 1024; c < 2048; ++c) s[c] = 939524096 + ((c - 1024) << 13);
    for (let c = 1; c < 31; ++c) a[c] = c << 23;
    (a[31] = 1199570944), (a[32] = 2147483648);
    for (let c = 33; c < 63; ++c) a[c] = 2147483648 + ((c - 32) << 23);
    a[63] = 3347054592;
    for (let c = 1; c < 64; ++c) c !== 32 && (l[c] = 1024);
    return {
        floatView: e,
        uint32View: t,
        baseTable: n,
        shiftTable: r,
        mantissaTable: s,
        exponentTable: a,
        offsetTable: l,
    };
}
function Br(i) {
    Math.abs(i) > 65504 &&
        console.warn('THREE.DataUtils.toHalfFloat(): Value out of range.'),
        (i = Jn(i, -65504, 65504)),
        (Ca.floatView[0] = i);
    const e = Ca.uint32View[0],
        t = (e >> 23) & 511;
    return Ca.baseTable[t] + ((e & 8388607) >> Ca.shiftTable[t]);
}
function Wd(i) {
    const e = i >> 10;
    return (
        (Ca.uint32View[0] =
            Ca.mantissaTable[Ca.offsetTable[e] + (i & 1023)] +
            Ca.exponentTable[e]),
        Ca.floatView[0]
    );
}
const vk = { toHalfFloat: Br, fromHalfFloat: Wd },
    fi = new j(),
    dg = new Ce();
class Mn {
    constructor(e, t, n = !1) {
        if (Array.isArray(e))
            throw new TypeError(
                'THREE.BufferAttribute: array should be a Typed Array.'
            );
        (this.isBufferAttribute = !0),
            (this.name = ''),
            (this.array = e),
            (this.itemSize = t),
            (this.count = e !== void 0 ? e.length / t : 0),
            (this.normalized = n),
            (this.usage = Cp),
            (this._updateRange = { offset: 0, count: -1 }),
            (this.updateRanges = []),
            (this.gpuType = Vr),
            (this.version = 0);
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        e === !0 && this.version++;
    }
    get updateRange() {
        return (
            zS(
                'THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead.'
            ),
            this._updateRange
        );
    }
    setUsage(e) {
        return (this.usage = e), this;
    }
    addUpdateRange(e, t) {
        this.updateRanges.push({ start: e, count: t });
    }
    clearUpdateRanges() {
        this.updateRanges.length = 0;
    }
    copy(e) {
        return (
            (this.name = e.name),
            (this.array = new e.array.constructor(e.array)),
            (this.itemSize = e.itemSize),
            (this.count = e.count),
            (this.normalized = e.normalized),
            (this.usage = e.usage),
            (this.gpuType = e.gpuType),
            this
        );
    }
    copyAt(e, t, n) {
        (e *= this.itemSize), (n *= t.itemSize);
        for (let r = 0, s = this.itemSize; r < s; r++)
            this.array[e + r] = t.array[n + r];
        return this;
    }
    copyArray(e) {
        return this.array.set(e), this;
    }
    applyMatrix3(e) {
        if (this.itemSize === 2)
            for (let t = 0, n = this.count; t < n; t++)
                dg.fromBufferAttribute(this, t),
                    dg.applyMatrix3(e),
                    this.setXY(t, dg.x, dg.y);
        else if (this.itemSize === 3)
            for (let t = 0, n = this.count; t < n; t++)
                fi.fromBufferAttribute(this, t),
                    fi.applyMatrix3(e),
                    this.setXYZ(t, fi.x, fi.y, fi.z);
        return this;
    }
    applyMatrix4(e) {
        for (let t = 0, n = this.count; t < n; t++)
            fi.fromBufferAttribute(this, t),
                fi.applyMatrix4(e),
                this.setXYZ(t, fi.x, fi.y, fi.z);
        return this;
    }
    applyNormalMatrix(e) {
        for (let t = 0, n = this.count; t < n; t++)
            fi.fromBufferAttribute(this, t),
                fi.applyNormalMatrix(e),
                this.setXYZ(t, fi.x, fi.y, fi.z);
        return this;
    }
    transformDirection(e) {
        for (let t = 0, n = this.count; t < n; t++)
            fi.fromBufferAttribute(this, t),
                fi.transformDirection(e),
                this.setXYZ(t, fi.x, fi.y, fi.z);
        return this;
    }
    set(e, t = 0) {
        return this.array.set(e, t), this;
    }
    getComponent(e, t) {
        let n = this.array[e * this.itemSize + t];
        return this.normalized && (n = wr(n, this.array)), n;
    }
    setComponent(e, t, n) {
        return (
            this.normalized && (n = Xt(n, this.array)),
            (this.array[e * this.itemSize + t] = n),
            this
        );
    }
    getX(e) {
        let t = this.array[e * this.itemSize];
        return this.normalized && (t = wr(t, this.array)), t;
    }
    setX(e, t) {
        return (
            this.normalized && (t = Xt(t, this.array)),
            (this.array[e * this.itemSize] = t),
            this
        );
    }
    getY(e) {
        let t = this.array[e * this.itemSize + 1];
        return this.normalized && (t = wr(t, this.array)), t;
    }
    setY(e, t) {
        return (
            this.normalized && (t = Xt(t, this.array)),
            (this.array[e * this.itemSize + 1] = t),
            this
        );
    }
    getZ(e) {
        let t = this.array[e * this.itemSize + 2];
        return this.normalized && (t = wr(t, this.array)), t;
    }
    setZ(e, t) {
        return (
            this.normalized && (t = Xt(t, this.array)),
            (this.array[e * this.itemSize + 2] = t),
            this
        );
    }
    getW(e) {
        let t = this.array[e * this.itemSize + 3];
        return this.normalized && (t = wr(t, this.array)), t;
    }
    setW(e, t) {
        return (
            this.normalized && (t = Xt(t, this.array)),
            (this.array[e * this.itemSize + 3] = t),
            this
        );
    }
    setXY(e, t, n) {
        return (
            (e *= this.itemSize),
            this.normalized &&
                ((t = Xt(t, this.array)), (n = Xt(n, this.array))),
            (this.array[e + 0] = t),
            (this.array[e + 1] = n),
            this
        );
    }
    setXYZ(e, t, n, r) {
        return (
            (e *= this.itemSize),
            this.normalized &&
                ((t = Xt(t, this.array)),
                (n = Xt(n, this.array)),
                (r = Xt(r, this.array))),
            (this.array[e + 0] = t),
            (this.array[e + 1] = n),
            (this.array[e + 2] = r),
            this
        );
    }
    setXYZW(e, t, n, r, s) {
        return (
            (e *= this.itemSize),
            this.normalized &&
                ((t = Xt(t, this.array)),
                (n = Xt(n, this.array)),
                (r = Xt(r, this.array)),
                (s = Xt(s, this.array))),
            (this.array[e + 0] = t),
            (this.array[e + 1] = n),
            (this.array[e + 2] = r),
            (this.array[e + 3] = s),
            this
        );
    }
    onUpload(e) {
        return (this.onUploadCallback = e), this;
    }
    clone() {
        return new this.constructor(this.array, this.itemSize).copy(this);
    }
    toJSON() {
        const e = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.from(this.array),
            normalized: this.normalized,
        };
        return (
            this.name !== '' && (e.name = this.name),
            this.usage !== Cp && (e.usage = this.usage),
            e
        );
    }
}
class xk extends Mn {
    constructor(e, t, n) {
        super(new Int8Array(e), t, n);
    }
}
class _k extends Mn {
    constructor(e, t, n) {
        super(new Uint8Array(e), t, n);
    }
}
class Sk extends Mn {
    constructor(e, t, n) {
        super(new Uint8ClampedArray(e), t, n);
    }
}
class wk extends Mn {
    constructor(e, t, n) {
        super(new Int16Array(e), t, n);
    }
}
class HS extends Mn {
    constructor(e, t, n) {
        super(new Uint16Array(e), t, n);
    }
}
class Mk extends Mn {
    constructor(e, t, n) {
        super(new Int32Array(e), t, n);
    }
}
class GS extends Mn {
    constructor(e, t, n) {
        super(new Uint32Array(e), t, n);
    }
}
class Ek extends Mn {
    constructor(e, t, n) {
        super(new Uint16Array(e), t, n), (this.isFloat16BufferAttribute = !0);
    }
    getX(e) {
        let t = Wd(this.array[e * this.itemSize]);
        return this.normalized && (t = wr(t, this.array)), t;
    }
    setX(e, t) {
        return (
            this.normalized && (t = Xt(t, this.array)),
            (this.array[e * this.itemSize] = Br(t)),
            this
        );
    }
    getY(e) {
        let t = Wd(this.array[e * this.itemSize + 1]);
        return this.normalized && (t = wr(t, this.array)), t;
    }
    setY(e, t) {
        return (
            this.normalized && (t = Xt(t, this.array)),
            (this.array[e * this.itemSize + 1] = Br(t)),
            this
        );
    }
    getZ(e) {
        let t = Wd(this.array[e * this.itemSize + 2]);
        return this.normalized && (t = wr(t, this.array)), t;
    }
    setZ(e, t) {
        return (
            this.normalized && (t = Xt(t, this.array)),
            (this.array[e * this.itemSize + 2] = Br(t)),
            this
        );
    }
    getW(e) {
        let t = Wd(this.array[e * this.itemSize + 3]);
        return this.normalized && (t = wr(t, this.array)), t;
    }
    setW(e, t) {
        return (
            this.normalized && (t = Xt(t, this.array)),
            (this.array[e * this.itemSize + 3] = Br(t)),
            this
        );
    }
    setXY(e, t, n) {
        return (
            (e *= this.itemSize),
            this.normalized &&
                ((t = Xt(t, this.array)), (n = Xt(n, this.array))),
            (this.array[e + 0] = Br(t)),
            (this.array[e + 1] = Br(n)),
            this
        );
    }
    setXYZ(e, t, n, r) {
        return (
            (e *= this.itemSize),
            this.normalized &&
                ((t = Xt(t, this.array)),
                (n = Xt(n, this.array)),
                (r = Xt(r, this.array))),
            (this.array[e + 0] = Br(t)),
            (this.array[e + 1] = Br(n)),
            (this.array[e + 2] = Br(r)),
            this
        );
    }
    setXYZW(e, t, n, r, s) {
        return (
            (e *= this.itemSize),
            this.normalized &&
                ((t = Xt(t, this.array)),
                (n = Xt(n, this.array)),
                (r = Xt(r, this.array)),
                (s = Xt(s, this.array))),
            (this.array[e + 0] = Br(t)),
            (this.array[e + 1] = Br(n)),
            (this.array[e + 2] = Br(r)),
            (this.array[e + 3] = Br(s)),
            this
        );
    }
}
class vt extends Mn {
    constructor(e, t, n) {
        super(new Float32Array(e), t, n);
    }
}
let Tk = 0;
const _s = new Pt(),
    tx = new ln(),
    Af = new j(),
    is = new Tr(),
    Pd = new Tr(),
    bi = new j();
class $t extends Ba {
    constructor() {
        super(),
            (this.isBufferGeometry = !0),
            Object.defineProperty(this, 'id', { value: Tk++ }),
            (this.uuid = os()),
            (this.name = ''),
            (this.type = 'BufferGeometry'),
            (this.index = null),
            (this.attributes = {}),
            (this.morphAttributes = {}),
            (this.morphTargetsRelative = !1),
            (this.groups = []),
            (this.boundingBox = null),
            (this.boundingSphere = null),
            (this.drawRange = { start: 0, count: 1 / 0 }),
            (this.userData = {});
    }
    getIndex() {
        return this.index;
    }
    setIndex(e) {
        return (
            Array.isArray(e)
                ? (this.index = new (WR(e) ? GS : HS)(e, 1))
                : (this.index = e),
            this
        );
    }
    getAttribute(e) {
        return this.attributes[e];
    }
    setAttribute(e, t) {
        return (this.attributes[e] = t), this;
    }
    deleteAttribute(e) {
        return delete this.attributes[e], this;
    }
    hasAttribute(e) {
        return this.attributes[e] !== void 0;
    }
    addGroup(e, t, n = 0) {
        this.groups.push({ start: e, count: t, materialIndex: n });
    }
    clearGroups() {
        this.groups = [];
    }
    setDrawRange(e, t) {
        (this.drawRange.start = e), (this.drawRange.count = t);
    }
    applyMatrix4(e) {
        const t = this.attributes.position;
        t !== void 0 && (t.applyMatrix4(e), (t.needsUpdate = !0));
        const n = this.attributes.normal;
        if (n !== void 0) {
            const s = new Wt().getNormalMatrix(e);
            n.applyNormalMatrix(s), (n.needsUpdate = !0);
        }
        const r = this.attributes.tangent;
        return (
            r !== void 0 && (r.transformDirection(e), (r.needsUpdate = !0)),
            this.boundingBox !== null && this.computeBoundingBox(),
            this.boundingSphere !== null && this.computeBoundingSphere(),
            this
        );
    }
    applyQuaternion(e) {
        return _s.makeRotationFromQuaternion(e), this.applyMatrix4(_s), this;
    }
    rotateX(e) {
        return _s.makeRotationX(e), this.applyMatrix4(_s), this;
    }
    rotateY(e) {
        return _s.makeRotationY(e), this.applyMatrix4(_s), this;
    }
    rotateZ(e) {
        return _s.makeRotationZ(e), this.applyMatrix4(_s), this;
    }
    translate(e, t, n) {
        return _s.makeTranslation(e, t, n), this.applyMatrix4(_s), this;
    }
    scale(e, t, n) {
        return _s.makeScale(e, t, n), this.applyMatrix4(_s), this;
    }
    lookAt(e) {
        return (
            tx.lookAt(e), tx.updateMatrix(), this.applyMatrix4(tx.matrix), this
        );
    }
    center() {
        return (
            this.computeBoundingBox(),
            this.boundingBox.getCenter(Af).negate(),
            this.translate(Af.x, Af.y, Af.z),
            this
        );
    }
    setFromPoints(e) {
        const t = [];
        for (let n = 0, r = e.length; n < r; n++) {
            const s = e[n];
            t.push(s.x, s.y, s.z || 0);
        }
        return this.setAttribute('position', new vt(t, 3)), this;
    }
    computeBoundingBox() {
        this.boundingBox === null && (this.boundingBox = new Tr());
        const e = this.attributes.position,
            t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error(
                'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.',
                this
            ),
                this.boundingBox.set(
                    new j(-1 / 0, -1 / 0, -1 / 0),
                    new j(1 / 0, 1 / 0, 1 / 0)
                );
            return;
        }
        if (e !== void 0) {
            if ((this.boundingBox.setFromBufferAttribute(e), t))
                for (let n = 0, r = t.length; n < r; n++) {
                    const s = t[n];
                    is.setFromBufferAttribute(s),
                        this.morphTargetsRelative
                            ? (bi.addVectors(this.boundingBox.min, is.min),
                              this.boundingBox.expandByPoint(bi),
                              bi.addVectors(this.boundingBox.max, is.max),
                              this.boundingBox.expandByPoint(bi))
                            : (this.boundingBox.expandByPoint(is.min),
                              this.boundingBox.expandByPoint(is.max));
                }
        } else this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) ||
            isNaN(this.boundingBox.min.y) ||
            isNaN(this.boundingBox.min.z)) &&
            console.error(
                'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
                this
            );
    }
    computeBoundingSphere() {
        this.boundingSphere === null && (this.boundingSphere = new or());
        const e = this.attributes.position,
            t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error(
                'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.',
                this
            ),
                this.boundingSphere.set(new j(), 1 / 0);
            return;
        }
        if (e) {
            const n = this.boundingSphere.center;
            if ((is.setFromBufferAttribute(e), t))
                for (let s = 0, a = t.length; s < a; s++) {
                    const l = t[s];
                    Pd.setFromBufferAttribute(l),
                        this.morphTargetsRelative
                            ? (bi.addVectors(is.min, Pd.min),
                              is.expandByPoint(bi),
                              bi.addVectors(is.max, Pd.max),
                              is.expandByPoint(bi))
                            : (is.expandByPoint(Pd.min),
                              is.expandByPoint(Pd.max));
                }
            is.getCenter(n);
            let r = 0;
            for (let s = 0, a = e.count; s < a; s++)
                bi.fromBufferAttribute(e, s),
                    (r = Math.max(r, n.distanceToSquared(bi)));
            if (t)
                for (let s = 0, a = t.length; s < a; s++) {
                    const l = t[s],
                        c = this.morphTargetsRelative;
                    for (let d = 0, p = l.count; d < p; d++)
                        bi.fromBufferAttribute(l, d),
                            c && (Af.fromBufferAttribute(e, d), bi.add(Af)),
                            (r = Math.max(r, n.distanceToSquared(bi)));
                }
            (this.boundingSphere.radius = Math.sqrt(r)),
                isNaN(this.boundingSphere.radius) &&
                    console.error(
                        'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                        this
                    );
        }
    }
    computeTangents() {
        const e = this.index,
            t = this.attributes;
        if (
            e === null ||
            t.position === void 0 ||
            t.normal === void 0 ||
            t.uv === void 0
        ) {
            console.error(
                'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)'
            );
            return;
        }
        const n = t.position,
            r = t.normal,
            s = t.uv;
        this.hasAttribute('tangent') === !1 &&
            this.setAttribute(
                'tangent',
                new Mn(new Float32Array(4 * n.count), 4)
            );
        const a = this.getAttribute('tangent'),
            l = [],
            c = [];
        for (let z = 0; z < n.count; z++) (l[z] = new j()), (c[z] = new j());
        const d = new j(),
            p = new j(),
            g = new j(),
            y = new Ce(),
            v = new Ce(),
            S = new Ce(),
            T = new j(),
            M = new j();
        function w(z, U, D) {
            d.fromBufferAttribute(n, z),
                p.fromBufferAttribute(n, U),
                g.fromBufferAttribute(n, D),
                y.fromBufferAttribute(s, z),
                v.fromBufferAttribute(s, U),
                S.fromBufferAttribute(s, D),
                p.sub(d),
                g.sub(d),
                v.sub(y),
                S.sub(y);
            const H = 1 / (v.x * S.y - S.x * v.y);
            isFinite(H) &&
                (T.copy(p)
                    .multiplyScalar(S.y)
                    .addScaledVector(g, -v.y)
                    .multiplyScalar(H),
                M.copy(g)
                    .multiplyScalar(v.x)
                    .addScaledVector(p, -S.x)
                    .multiplyScalar(H),
                l[z].add(T),
                l[U].add(T),
                l[D].add(T),
                c[z].add(M),
                c[U].add(M),
                c[D].add(M));
        }
        let b = this.groups;
        b.length === 0 && (b = [{ start: 0, count: e.count }]);
        for (let z = 0, U = b.length; z < U; ++z) {
            const D = b[z],
                H = D.start,
                ie = D.count;
            for (let ee = H, ue = H + ie; ee < ue; ee += 3)
                w(e.getX(ee + 0), e.getX(ee + 1), e.getX(ee + 2));
        }
        const C = new j(),
            L = new j(),
            F = new j(),
            N = new j();
        function B(z) {
            F.fromBufferAttribute(r, z), N.copy(F);
            const U = l[z];
            C.copy(U),
                C.sub(F.multiplyScalar(F.dot(U))).normalize(),
                L.crossVectors(N, U);
            const H = L.dot(c[z]) < 0 ? -1 : 1;
            a.setXYZW(z, C.x, C.y, C.z, H);
        }
        for (let z = 0, U = b.length; z < U; ++z) {
            const D = b[z],
                H = D.start,
                ie = D.count;
            for (let ee = H, ue = H + ie; ee < ue; ee += 3)
                B(e.getX(ee + 0)), B(e.getX(ee + 1)), B(e.getX(ee + 2));
        }
    }
    computeVertexNormals() {
        const e = this.index,
            t = this.getAttribute('position');
        if (t !== void 0) {
            let n = this.getAttribute('normal');
            if (n === void 0)
                (n = new Mn(new Float32Array(t.count * 3), 3)),
                    this.setAttribute('normal', n);
            else for (let y = 0, v = n.count; y < v; y++) n.setXYZ(y, 0, 0, 0);
            const r = new j(),
                s = new j(),
                a = new j(),
                l = new j(),
                c = new j(),
                d = new j(),
                p = new j(),
                g = new j();
            if (e)
                for (let y = 0, v = e.count; y < v; y += 3) {
                    const S = e.getX(y + 0),
                        T = e.getX(y + 1),
                        M = e.getX(y + 2);
                    r.fromBufferAttribute(t, S),
                        s.fromBufferAttribute(t, T),
                        a.fromBufferAttribute(t, M),
                        p.subVectors(a, s),
                        g.subVectors(r, s),
                        p.cross(g),
                        l.fromBufferAttribute(n, S),
                        c.fromBufferAttribute(n, T),
                        d.fromBufferAttribute(n, M),
                        l.add(p),
                        c.add(p),
                        d.add(p),
                        n.setXYZ(S, l.x, l.y, l.z),
                        n.setXYZ(T, c.x, c.y, c.z),
                        n.setXYZ(M, d.x, d.y, d.z);
                }
            else
                for (let y = 0, v = t.count; y < v; y += 3)
                    r.fromBufferAttribute(t, y + 0),
                        s.fromBufferAttribute(t, y + 1),
                        a.fromBufferAttribute(t, y + 2),
                        p.subVectors(a, s),
                        g.subVectors(r, s),
                        p.cross(g),
                        n.setXYZ(y + 0, p.x, p.y, p.z),
                        n.setXYZ(y + 1, p.x, p.y, p.z),
                        n.setXYZ(y + 2, p.x, p.y, p.z);
            this.normalizeNormals(), (n.needsUpdate = !0);
        }
    }
    normalizeNormals() {
        const e = this.attributes.normal;
        for (let t = 0, n = e.count; t < n; t++)
            bi.fromBufferAttribute(e, t),
                bi.normalize(),
                e.setXYZ(t, bi.x, bi.y, bi.z);
    }
    toNonIndexed() {
        function e(l, c) {
            const d = l.array,
                p = l.itemSize,
                g = l.normalized,
                y = new d.constructor(c.length * p);
            let v = 0,
                S = 0;
            for (let T = 0, M = c.length; T < M; T++) {
                l.isInterleavedBufferAttribute
                    ? (v = c[T] * l.data.stride + l.offset)
                    : (v = c[T] * p);
                for (let w = 0; w < p; w++) y[S++] = d[v++];
            }
            return new Mn(y, p, g);
        }
        if (this.index === null)
            return (
                console.warn(
                    'THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.'
                ),
                this
            );
        const t = new $t(),
            n = this.index.array,
            r = this.attributes;
        for (const l in r) {
            const c = r[l],
                d = e(c, n);
            t.setAttribute(l, d);
        }
        const s = this.morphAttributes;
        for (const l in s) {
            const c = [],
                d = s[l];
            for (let p = 0, g = d.length; p < g; p++) {
                const y = d[p],
                    v = e(y, n);
                c.push(v);
            }
            t.morphAttributes[l] = c;
        }
        t.morphTargetsRelative = this.morphTargetsRelative;
        const a = this.groups;
        for (let l = 0, c = a.length; l < c; l++) {
            const d = a[l];
            t.addGroup(d.start, d.count, d.materialIndex);
        }
        return t;
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.6,
                type: 'BufferGeometry',
                generator: 'BufferGeometry.toJSON',
            },
        };
        if (
            ((e.uuid = this.uuid),
            (e.type = this.type),
            this.name !== '' && (e.name = this.name),
            Object.keys(this.userData).length > 0 &&
                (e.userData = this.userData),
            this.parameters !== void 0)
        ) {
            const c = this.parameters;
            for (const d in c) c[d] !== void 0 && (e[d] = c[d]);
            return e;
        }
        e.data = { attributes: {} };
        const t = this.index;
        t !== null &&
            (e.data.index = {
                type: t.array.constructor.name,
                array: Array.prototype.slice.call(t.array),
            });
        const n = this.attributes;
        for (const c in n) {
            const d = n[c];
            e.data.attributes[c] = d.toJSON(e.data);
        }
        const r = {};
        let s = !1;
        for (const c in this.morphAttributes) {
            const d = this.morphAttributes[c],
                p = [];
            for (let g = 0, y = d.length; g < y; g++) {
                const v = d[g];
                p.push(v.toJSON(e.data));
            }
            p.length > 0 && ((r[c] = p), (s = !0));
        }
        s &&
            ((e.data.morphAttributes = r),
            (e.data.morphTargetsRelative = this.morphTargetsRelative));
        const a = this.groups;
        a.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(a)));
        const l = this.boundingSphere;
        return (
            l !== null &&
                (e.data.boundingSphere = {
                    center: l.center.toArray(),
                    radius: l.radius,
                }),
            e
        );
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(e) {
        (this.index = null),
            (this.attributes = {}),
            (this.morphAttributes = {}),
            (this.groups = []),
            (this.boundingBox = null),
            (this.boundingSphere = null);
        const t = {};
        this.name = e.name;
        const n = e.index;
        n !== null && this.setIndex(n.clone(t));
        const r = e.attributes;
        for (const d in r) {
            const p = r[d];
            this.setAttribute(d, p.clone(t));
        }
        const s = e.morphAttributes;
        for (const d in s) {
            const p = [],
                g = s[d];
            for (let y = 0, v = g.length; y < v; y++) p.push(g[y].clone(t));
            this.morphAttributes[d] = p;
        }
        this.morphTargetsRelative = e.morphTargetsRelative;
        const a = e.groups;
        for (let d = 0, p = a.length; d < p; d++) {
            const g = a[d];
            this.addGroup(g.start, g.count, g.materialIndex);
        }
        const l = e.boundingBox;
        l !== null && (this.boundingBox = l.clone());
        const c = e.boundingSphere;
        return (
            c !== null && (this.boundingSphere = c.clone()),
            (this.drawRange.start = e.drawRange.start),
            (this.drawRange.count = e.drawRange.count),
            (this.userData = e.userData),
            this
        );
    }
    dispose() {
        this.dispatchEvent({ type: 'dispose' });
    }
}
const V1 = new Pt(),
    Du = new Eh(),
    pg = new or(),
    H1 = new j(),
    Cf = new j(),
    Rf = new j(),
    bf = new j(),
    nx = new j(),
    mg = new j(),
    gg = new Ce(),
    yg = new Ce(),
    vg = new Ce(),
    G1 = new j(),
    W1 = new j(),
    X1 = new j(),
    xg = new j(),
    _g = new j();
class di extends ln {
    constructor(e = new $t(), t = new zl()) {
        super(),
            (this.isMesh = !0),
            (this.type = 'Mesh'),
            (this.geometry = e),
            (this.material = t),
            this.updateMorphTargets();
    }
    copy(e, t) {
        return (
            super.copy(e, t),
            e.morphTargetInfluences !== void 0 &&
                (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
            e.morphTargetDictionary !== void 0 &&
                (this.morphTargetDictionary = Object.assign(
                    {},
                    e.morphTargetDictionary
                )),
            (this.material = Array.isArray(e.material)
                ? e.material.slice()
                : e.material),
            (this.geometry = e.geometry),
            this
        );
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes,
            n = Object.keys(t);
        if (n.length > 0) {
            const r = t[n[0]];
            if (r !== void 0) {
                (this.morphTargetInfluences = []),
                    (this.morphTargetDictionary = {});
                for (let s = 0, a = r.length; s < a; s++) {
                    const l = r[s].name || String(s);
                    this.morphTargetInfluences.push(0),
                        (this.morphTargetDictionary[l] = s);
                }
            }
        }
    }
    getVertexPosition(e, t) {
        const n = this.geometry,
            r = n.attributes.position,
            s = n.morphAttributes.position,
            a = n.morphTargetsRelative;
        t.fromBufferAttribute(r, e);
        const l = this.morphTargetInfluences;
        if (s && l) {
            mg.set(0, 0, 0);
            for (let c = 0, d = s.length; c < d; c++) {
                const p = l[c],
                    g = s[c];
                p !== 0 &&
                    (nx.fromBufferAttribute(g, e),
                    a
                        ? mg.addScaledVector(nx, p)
                        : mg.addScaledVector(nx.sub(t), p));
            }
            t.add(mg);
        }
        return t;
    }
    raycast(e, t) {
        const n = this.geometry,
            r = this.material,
            s = this.matrixWorld;
        r !== void 0 &&
            (n.boundingSphere === null && n.computeBoundingSphere(),
            pg.copy(n.boundingSphere),
            pg.applyMatrix4(s),
            Du.copy(e.ray).recast(e.near),
            !(
                pg.containsPoint(Du.origin) === !1 &&
                (Du.intersectSphere(pg, H1) === null ||
                    Du.origin.distanceToSquared(H1) > (e.far - e.near) ** 2)
            ) &&
                (V1.copy(s).invert(),
                Du.copy(e.ray).applyMatrix4(V1),
                !(
                    n.boundingBox !== null &&
                    Du.intersectsBox(n.boundingBox) === !1
                ) && this._computeIntersections(e, t, Du)));
    }
    _computeIntersections(e, t, n) {
        let r;
        const s = this.geometry,
            a = this.material,
            l = s.index,
            c = s.attributes.position,
            d = s.attributes.uv,
            p = s.attributes.uv1,
            g = s.attributes.normal,
            y = s.groups,
            v = s.drawRange;
        if (l !== null)
            if (Array.isArray(a))
                for (let S = 0, T = y.length; S < T; S++) {
                    const M = y[S],
                        w = a[M.materialIndex],
                        b = Math.max(M.start, v.start),
                        C = Math.min(
                            l.count,
                            Math.min(M.start + M.count, v.start + v.count)
                        );
                    for (let L = b, F = C; L < F; L += 3) {
                        const N = l.getX(L),
                            B = l.getX(L + 1),
                            z = l.getX(L + 2);
                        (r = Sg(this, w, e, n, d, p, g, N, B, z)),
                            r &&
                                ((r.faceIndex = Math.floor(L / 3)),
                                (r.face.materialIndex = M.materialIndex),
                                t.push(r));
                    }
                }
            else {
                const S = Math.max(0, v.start),
                    T = Math.min(l.count, v.start + v.count);
                for (let M = S, w = T; M < w; M += 3) {
                    const b = l.getX(M),
                        C = l.getX(M + 1),
                        L = l.getX(M + 2);
                    (r = Sg(this, a, e, n, d, p, g, b, C, L)),
                        r && ((r.faceIndex = Math.floor(M / 3)), t.push(r));
                }
            }
        else if (c !== void 0)
            if (Array.isArray(a))
                for (let S = 0, T = y.length; S < T; S++) {
                    const M = y[S],
                        w = a[M.materialIndex],
                        b = Math.max(M.start, v.start),
                        C = Math.min(
                            c.count,
                            Math.min(M.start + M.count, v.start + v.count)
                        );
                    for (let L = b, F = C; L < F; L += 3) {
                        const N = L,
                            B = L + 1,
                            z = L + 2;
                        (r = Sg(this, w, e, n, d, p, g, N, B, z)),
                            r &&
                                ((r.faceIndex = Math.floor(L / 3)),
                                (r.face.materialIndex = M.materialIndex),
                                t.push(r));
                    }
                }
            else {
                const S = Math.max(0, v.start),
                    T = Math.min(c.count, v.start + v.count);
                for (let M = S, w = T; M < w; M += 3) {
                    const b = M,
                        C = M + 1,
                        L = M + 2;
                    (r = Sg(this, a, e, n, d, p, g, b, C, L)),
                        r && ((r.faceIndex = Math.floor(M / 3)), t.push(r));
                }
            }
    }
}
function Ak(i, e, t, n, r, s, a, l) {
    let c;
    if (
        (e.side === Er
            ? (c = n.intersectTriangle(a, s, r, !0, l))
            : (c = n.intersectTriangle(r, s, a, e.side === Na, l)),
        c === null)
    )
        return null;
    _g.copy(l), _g.applyMatrix4(i.matrixWorld);
    const d = t.ray.origin.distanceTo(_g);
    return d < t.near || d > t.far
        ? null
        : { distance: d, point: _g.clone(), object: i };
}
function Sg(i, e, t, n, r, s, a, l, c, d) {
    i.getVertexPosition(l, Cf),
        i.getVertexPosition(c, Rf),
        i.getVertexPosition(d, bf);
    const p = Ak(i, e, t, n, Cf, Rf, bf, xg);
    if (p) {
        r &&
            (gg.fromBufferAttribute(r, l),
            yg.fromBufferAttribute(r, c),
            vg.fromBufferAttribute(r, d),
            (p.uv = ss.getInterpolation(xg, Cf, Rf, bf, gg, yg, vg, new Ce()))),
            s &&
                (gg.fromBufferAttribute(s, l),
                yg.fromBufferAttribute(s, c),
                vg.fromBufferAttribute(s, d),
                (p.uv1 = ss.getInterpolation(
                    xg,
                    Cf,
                    Rf,
                    bf,
                    gg,
                    yg,
                    vg,
                    new Ce()
                ))),
            a &&
                (G1.fromBufferAttribute(a, l),
                W1.fromBufferAttribute(a, c),
                X1.fromBufferAttribute(a, d),
                (p.normal = ss.getInterpolation(
                    xg,
                    Cf,
                    Rf,
                    bf,
                    G1,
                    W1,
                    X1,
                    new j()
                )),
                p.normal.dot(n.direction) > 0 && p.normal.multiplyScalar(-1));
        const g = { a: l, b: c, c: d, normal: new j(), materialIndex: 0 };
        ss.getNormal(Cf, Rf, bf, g.normal), (p.face = g);
    }
    return p;
}
class dc extends $t {
    constructor(e = 1, t = 1, n = 1, r = 1, s = 1, a = 1) {
        super(),
            (this.type = 'BoxGeometry'),
            (this.parameters = {
                width: e,
                height: t,
                depth: n,
                widthSegments: r,
                heightSegments: s,
                depthSegments: a,
            });
        const l = this;
        (r = Math.floor(r)), (s = Math.floor(s)), (a = Math.floor(a));
        const c = [],
            d = [],
            p = [],
            g = [];
        let y = 0,
            v = 0;
        S('z', 'y', 'x', -1, -1, n, t, e, a, s, 0),
            S('z', 'y', 'x', 1, -1, n, t, -e, a, s, 1),
            S('x', 'z', 'y', 1, 1, e, n, t, r, a, 2),
            S('x', 'z', 'y', 1, -1, e, n, -t, r, a, 3),
            S('x', 'y', 'z', 1, -1, e, t, n, r, s, 4),
            S('x', 'y', 'z', -1, -1, e, t, -n, r, s, 5),
            this.setIndex(c),
            this.setAttribute('position', new vt(d, 3)),
            this.setAttribute('normal', new vt(p, 3)),
            this.setAttribute('uv', new vt(g, 2));
        function S(T, M, w, b, C, L, F, N, B, z, U) {
            const D = L / B,
                H = F / z,
                ie = L / 2,
                ee = F / 2,
                ue = N / 2,
                Se = B + 1,
                ce = z + 1;
            let me = 0,
                X = 0;
            const oe = new j();
            for (let Q = 0; Q < ce; Q++) {
                const G = Q * H - ee;
                for (let ae = 0; ae < Se; ae++) {
                    const Oe = ae * D - ie;
                    (oe[T] = Oe * b),
                        (oe[M] = G * C),
                        (oe[w] = ue),
                        d.push(oe.x, oe.y, oe.z),
                        (oe[T] = 0),
                        (oe[M] = 0),
                        (oe[w] = N > 0 ? 1 : -1),
                        p.push(oe.x, oe.y, oe.z),
                        g.push(ae / B),
                        g.push(1 - Q / z),
                        (me += 1);
                }
            }
            for (let Q = 0; Q < z; Q++)
                for (let G = 0; G < B; G++) {
                    const ae = y + G + Se * Q,
                        Oe = y + G + Se * (Q + 1),
                        fe = y + (G + 1) + Se * (Q + 1),
                        we = y + (G + 1) + Se * Q;
                    c.push(ae, Oe, we), c.push(Oe, fe, we), (X += 6);
                }
            l.addGroup(v, X, U), (v += X), (y += me);
        }
    }
    copy(e) {
        return (
            super.copy(e),
            (this.parameters = Object.assign({}, e.parameters)),
            this
        );
    }
    static fromJSON(e) {
        return new dc(
            e.width,
            e.height,
            e.depth,
            e.widthSegments,
            e.heightSegments,
            e.depthSegments
        );
    }
}
function hh(i) {
    const e = {};
    for (const t in i) {
        e[t] = {};
        for (const n in i[t]) {
            const r = i[t][n];
            r &&
            (r.isColor ||
                r.isMatrix3 ||
                r.isMatrix4 ||
                r.isVector2 ||
                r.isVector3 ||
                r.isVector4 ||
                r.isTexture ||
                r.isQuaternion)
                ? r.isRenderTargetTexture
                    ? (console.warn(
                          'UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().'
                      ),
                      (e[t][n] = null))
                    : (e[t][n] = r.clone())
                : Array.isArray(r)
                  ? (e[t][n] = r.slice())
                  : (e[t][n] = r);
        }
    }
    return e;
}
function Sr(i) {
    const e = {};
    for (let t = 0; t < i.length; t++) {
        const n = hh(i[t]);
        for (const r in n) e[r] = n[r];
    }
    return e;
}
function Ck(i) {
    const e = [];
    for (let t = 0; t < i.length; t++) e.push(i[t].clone());
    return e;
}
function YR(i) {
    const e = i.getRenderTarget();
    return e === null
        ? i.outputColorSpace
        : e.isXRRenderTarget === !0
          ? e.texture.colorSpace
          : hn.workingColorSpace;
}
const WS = { clone: hh, merge: Sr };
var Rk = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
    bk = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class Ts extends lr {
    constructor(e) {
        super(),
            (this.isShaderMaterial = !0),
            (this.type = 'ShaderMaterial'),
            (this.defines = {}),
            (this.uniforms = {}),
            (this.uniformsGroups = []),
            (this.vertexShader = Rk),
            (this.fragmentShader = bk),
            (this.linewidth = 1),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.fog = !1),
            (this.lights = !1),
            (this.clipping = !1),
            (this.forceSinglePass = !0),
            (this.extensions = { clipCullDistance: !1, multiDraw: !1 }),
            (this.defaultAttributeValues = {
                color: [1, 1, 1],
                uv: [0, 0],
                uv1: [0, 0],
            }),
            (this.index0AttributeName = void 0),
            (this.uniformsNeedUpdate = !1),
            (this.glslVersion = null),
            e !== void 0 && this.setValues(e);
    }
    copy(e) {
        return (
            super.copy(e),
            (this.fragmentShader = e.fragmentShader),
            (this.vertexShader = e.vertexShader),
            (this.uniforms = hh(e.uniforms)),
            (this.uniformsGroups = Ck(e.uniformsGroups)),
            (this.defines = Object.assign({}, e.defines)),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.fog = e.fog),
            (this.lights = e.lights),
            (this.clipping = e.clipping),
            (this.extensions = Object.assign({}, e.extensions)),
            (this.glslVersion = e.glslVersion),
            this
        );
    }
    toJSON(e) {
        const t = super.toJSON(e);
        (t.glslVersion = this.glslVersion), (t.uniforms = {});
        for (const r in this.uniforms) {
            const a = this.uniforms[r].value;
            a && a.isTexture
                ? (t.uniforms[r] = { type: 't', value: a.toJSON(e).uuid })
                : a && a.isColor
                  ? (t.uniforms[r] = { type: 'c', value: a.getHex() })
                  : a && a.isVector2
                    ? (t.uniforms[r] = { type: 'v2', value: a.toArray() })
                    : a && a.isVector3
                      ? (t.uniforms[r] = { type: 'v3', value: a.toArray() })
                      : a && a.isVector4
                        ? (t.uniforms[r] = { type: 'v4', value: a.toArray() })
                        : a && a.isMatrix3
                          ? (t.uniforms[r] = { type: 'm3', value: a.toArray() })
                          : a && a.isMatrix4
                            ? (t.uniforms[r] = {
                                  type: 'm4',
                                  value: a.toArray(),
                              })
                            : (t.uniforms[r] = { value: a });
        }
        Object.keys(this.defines).length > 0 && (t.defines = this.defines),
            (t.vertexShader = this.vertexShader),
            (t.fragmentShader = this.fragmentShader),
            (t.lights = this.lights),
            (t.clipping = this.clipping);
        const n = {};
        for (const r in this.extensions)
            this.extensions[r] === !0 && (n[r] = !0);
        return Object.keys(n).length > 0 && (t.extensions = n), t;
    }
}
class Kp extends ln {
    constructor() {
        super(),
            (this.isCamera = !0),
            (this.type = 'Camera'),
            (this.matrixWorldInverse = new Pt()),
            (this.projectionMatrix = new Pt()),
            (this.projectionMatrixInverse = new Pt()),
            (this.coordinateSystem = Do);
    }
    copy(e, t) {
        return (
            super.copy(e, t),
            this.matrixWorldInverse.copy(e.matrixWorldInverse),
            this.projectionMatrix.copy(e.projectionMatrix),
            this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
            (this.coordinateSystem = e.coordinateSystem),
            this
        );
    }
    getWorldDirection(e) {
        return super.getWorldDirection(e).negate();
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e),
            this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    updateWorldMatrix(e, t) {
        super.updateWorldMatrix(e, t),
            this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    clone() {
        return new this.constructor().copy(this);
    }
}
const Tl = new j(),
    j1 = new Ce(),
    q1 = new Ce();
class Pi extends Kp {
    constructor(e = 50, t = 1, n = 0.1, r = 2e3) {
        super(),
            (this.isPerspectiveCamera = !0),
            (this.type = 'PerspectiveCamera'),
            (this.fov = e),
            (this.zoom = 1),
            (this.near = n),
            (this.far = r),
            (this.focus = 10),
            (this.aspect = t),
            (this.view = null),
            (this.filmGauge = 35),
            (this.filmOffset = 0),
            this.updateProjectionMatrix();
    }
    copy(e, t) {
        return (
            super.copy(e, t),
            (this.fov = e.fov),
            (this.zoom = e.zoom),
            (this.near = e.near),
            (this.far = e.far),
            (this.focus = e.focus),
            (this.aspect = e.aspect),
            (this.view = e.view === null ? null : Object.assign({}, e.view)),
            (this.filmGauge = e.filmGauge),
            (this.filmOffset = e.filmOffset),
            this
        );
    }
    setFocalLength(e) {
        const t = (0.5 * this.getFilmHeight()) / e;
        (this.fov = fh * 2 * Math.atan(t)), this.updateProjectionMatrix();
    }
    getFocalLength() {
        const e = Math.tan(rc * 0.5 * this.fov);
        return (0.5 * this.getFilmHeight()) / e;
    }
    getEffectiveFOV() {
        return fh * 2 * Math.atan(Math.tan(rc * 0.5 * this.fov) / this.zoom);
    }
    getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1);
    }
    getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1);
    }
    getViewBounds(e, t, n) {
        Tl.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse),
            t.set(Tl.x, Tl.y).multiplyScalar(-e / Tl.z),
            Tl.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse),
            n.set(Tl.x, Tl.y).multiplyScalar(-e / Tl.z);
    }
    getViewSize(e, t) {
        return this.getViewBounds(e, j1, q1), t.subVectors(q1, j1);
    }
    setViewOffset(e, t, n, r, s, a) {
        (this.aspect = e / t),
            this.view === null &&
                (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1,
                }),
            (this.view.enabled = !0),
            (this.view.fullWidth = e),
            (this.view.fullHeight = t),
            (this.view.offsetX = n),
            (this.view.offsetY = r),
            (this.view.width = s),
            (this.view.height = a),
            this.updateProjectionMatrix();
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1),
            this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
        const e = this.near;
        let t = (e * Math.tan(rc * 0.5 * this.fov)) / this.zoom,
            n = 2 * t,
            r = this.aspect * n,
            s = -0.5 * r;
        const a = this.view;
        if (this.view !== null && this.view.enabled) {
            const c = a.fullWidth,
                d = a.fullHeight;
            (s += (a.offsetX * r) / c),
                (t -= (a.offsetY * n) / d),
                (r *= a.width / c),
                (n *= a.height / d);
        }
        const l = this.filmOffset;
        l !== 0 && (s += (e * l) / this.getFilmWidth()),
            this.projectionMatrix.makePerspective(
                s,
                s + r,
                t,
                t - n,
                e,
                this.far,
                this.coordinateSystem
            ),
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return (
            (t.object.fov = this.fov),
            (t.object.zoom = this.zoom),
            (t.object.near = this.near),
            (t.object.far = this.far),
            (t.object.focus = this.focus),
            (t.object.aspect = this.aspect),
            this.view !== null &&
                (t.object.view = Object.assign({}, this.view)),
            (t.object.filmGauge = this.filmGauge),
            (t.object.filmOffset = this.filmOffset),
            t
        );
    }
}
const Pf = -90,
    Lf = 1;
class KR extends ln {
    constructor(e, t, n) {
        super(),
            (this.type = 'CubeCamera'),
            (this.renderTarget = n),
            (this.coordinateSystem = null),
            (this.activeMipmapLevel = 0);
        const r = new Pi(Pf, Lf, e, t);
        (r.layers = this.layers), this.add(r);
        const s = new Pi(Pf, Lf, e, t);
        (s.layers = this.layers), this.add(s);
        const a = new Pi(Pf, Lf, e, t);
        (a.layers = this.layers), this.add(a);
        const l = new Pi(Pf, Lf, e, t);
        (l.layers = this.layers), this.add(l);
        const c = new Pi(Pf, Lf, e, t);
        (c.layers = this.layers), this.add(c);
        const d = new Pi(Pf, Lf, e, t);
        (d.layers = this.layers), this.add(d);
    }
    updateCoordinateSystem() {
        const e = this.coordinateSystem,
            t = this.children.concat(),
            [n, r, s, a, l, c] = t;
        for (const d of t) this.remove(d);
        if (e === Do)
            n.up.set(0, 1, 0),
                n.lookAt(1, 0, 0),
                r.up.set(0, 1, 0),
                r.lookAt(-1, 0, 0),
                s.up.set(0, 0, -1),
                s.lookAt(0, 1, 0),
                a.up.set(0, 0, 1),
                a.lookAt(0, -1, 0),
                l.up.set(0, 1, 0),
                l.lookAt(0, 0, 1),
                c.up.set(0, 1, 0),
                c.lookAt(0, 0, -1);
        else if (e === Rp)
            n.up.set(0, -1, 0),
                n.lookAt(-1, 0, 0),
                r.up.set(0, -1, 0),
                r.lookAt(1, 0, 0),
                s.up.set(0, 0, 1),
                s.lookAt(0, 1, 0),
                a.up.set(0, 0, -1),
                a.lookAt(0, -1, 0),
                l.up.set(0, -1, 0),
                l.lookAt(0, 0, 1),
                c.up.set(0, -1, 0),
                c.lookAt(0, 0, -1);
        else
            throw new Error(
                'THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: ' +
                    e
            );
        for (const d of t) this.add(d), d.updateMatrixWorld();
    }
    update(e, t) {
        this.parent === null && this.updateMatrixWorld();
        const { renderTarget: n, activeMipmapLevel: r } = this;
        this.coordinateSystem !== e.coordinateSystem &&
            ((this.coordinateSystem = e.coordinateSystem),
            this.updateCoordinateSystem());
        const [s, a, l, c, d, p] = this.children,
            g = e.getRenderTarget(),
            y = e.getActiveCubeFace(),
            v = e.getActiveMipmapLevel(),
            S = e.xr.enabled;
        e.xr.enabled = !1;
        const T = n.texture.generateMipmaps;
        (n.texture.generateMipmaps = !1),
            e.setRenderTarget(n, 0, r),
            e.render(t, s),
            e.setRenderTarget(n, 1, r),
            e.render(t, a),
            e.setRenderTarget(n, 2, r),
            e.render(t, l),
            e.setRenderTarget(n, 3, r),
            e.render(t, c),
            e.setRenderTarget(n, 4, r),
            e.render(t, d),
            (n.texture.generateMipmaps = T),
            e.setRenderTarget(n, 5, r),
            e.render(t, p),
            e.setRenderTarget(g, y, v),
            (e.xr.enabled = S),
            (n.texture.needsPMREMUpdate = !0);
    }
}
class Zp extends Qn {
    constructor(e, t, n, r, s, a, l, c, d, p) {
        (e = e !== void 0 ? e : []),
            (t = t !== void 0 ? t : Ua),
            super(e, t, n, r, s, a, l, c, d, p),
            (this.isCubeTexture = !0),
            (this.flipY = !1);
    }
    get images() {
        return this.image;
    }
    set images(e) {
        this.image = e;
    }
}
class ZR extends lo {
    constructor(e = 1, t = {}) {
        super(e, e, t), (this.isWebGLCubeRenderTarget = !0);
        const n = { width: e, height: e, depth: 1 },
            r = [n, n, n, n, n, n];
        (this.texture = new Zp(
            r,
            t.mapping,
            t.wrapS,
            t.wrapT,
            t.magFilter,
            t.minFilter,
            t.format,
            t.type,
            t.anisotropy,
            t.colorSpace
        )),
            (this.texture.isRenderTargetTexture = !0),
            (this.texture.generateMipmaps =
                t.generateMipmaps !== void 0 ? t.generateMipmaps : !1),
            (this.texture.minFilter =
                t.minFilter !== void 0 ? t.minFilter : hi);
    }
    fromEquirectangularTexture(e, t) {
        (this.texture.type = t.type),
            (this.texture.colorSpace = t.colorSpace),
            (this.texture.generateMipmaps = t.generateMipmaps),
            (this.texture.minFilter = t.minFilter),
            (this.texture.magFilter = t.magFilter);
        const n = {
                uniforms: { tEquirect: { value: null } },
                vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
                fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
            },
            r = new dc(5, 5, 5),
            s = new Ts({
                name: 'CubemapFromEquirect',
                uniforms: hh(n.uniforms),
                vertexShader: n.vertexShader,
                fragmentShader: n.fragmentShader,
                side: Er,
                blending: Pa,
            });
        s.uniforms.tEquirect.value = t;
        const a = new di(r, s),
            l = t.minFilter;
        return (
            t.minFilter === Io && (t.minFilter = hi),
            new KR(1, 10, this).update(e, a),
            (t.minFilter = l),
            a.geometry.dispose(),
            a.material.dispose(),
            this
        );
    }
    clear(e, t, n, r) {
        const s = e.getRenderTarget();
        for (let a = 0; a < 6; a++)
            e.setRenderTarget(this, a), e.clear(t, n, r);
        e.setRenderTarget(s);
    }
}
const ix = new j(),
    Pk = new j(),
    Lk = new Wt();
class Pl {
    constructor(e = new j(1, 0, 0), t = 0) {
        (this.isPlane = !0), (this.normal = e), (this.constant = t);
    }
    set(e, t) {
        return this.normal.copy(e), (this.constant = t), this;
    }
    setComponents(e, t, n, r) {
        return this.normal.set(e, t, n), (this.constant = r), this;
    }
    setFromNormalAndCoplanarPoint(e, t) {
        return this.normal.copy(e), (this.constant = -t.dot(this.normal)), this;
    }
    setFromCoplanarPoints(e, t, n) {
        const r = ix.subVectors(n, t).cross(Pk.subVectors(e, t)).normalize();
        return this.setFromNormalAndCoplanarPoint(r, e), this;
    }
    copy(e) {
        return this.normal.copy(e.normal), (this.constant = e.constant), this;
    }
    normalize() {
        const e = 1 / this.normal.length();
        return this.normal.multiplyScalar(e), (this.constant *= e), this;
    }
    negate() {
        return (this.constant *= -1), this.normal.negate(), this;
    }
    distanceToPoint(e) {
        return this.normal.dot(e) + this.constant;
    }
    distanceToSphere(e) {
        return this.distanceToPoint(e.center) - e.radius;
    }
    projectPoint(e, t) {
        return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
    }
    intersectLine(e, t) {
        const n = e.delta(ix),
            r = this.normal.dot(n);
        if (r === 0)
            return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
        const s = -(e.start.dot(this.normal) + this.constant) / r;
        return s < 0 || s > 1 ? null : t.copy(e.start).addScaledVector(n, s);
    }
    intersectsLine(e) {
        const t = this.distanceToPoint(e.start),
            n = this.distanceToPoint(e.end);
        return (t < 0 && n > 0) || (n < 0 && t > 0);
    }
    intersectsBox(e) {
        return e.intersectsPlane(this);
    }
    intersectsSphere(e) {
        return e.intersectsPlane(this);
    }
    coplanarPoint(e) {
        return e.copy(this.normal).multiplyScalar(-this.constant);
    }
    applyMatrix4(e, t) {
        const n = t || Lk.getNormalMatrix(e),
            r = this.coplanarPoint(ix).applyMatrix4(e),
            s = this.normal.applyMatrix3(n).normalize();
        return (this.constant = -r.dot(s)), this;
    }
    translate(e) {
        return (this.constant -= e.dot(this.normal)), this;
    }
    equals(e) {
        return e.normal.equals(this.normal) && e.constant === this.constant;
    }
    clone() {
        return new this.constructor().copy(this);
    }
}
const Nu = new or(),
    wg = new j();
class Jp {
    constructor(
        e = new Pl(),
        t = new Pl(),
        n = new Pl(),
        r = new Pl(),
        s = new Pl(),
        a = new Pl()
    ) {
        this.planes = [e, t, n, r, s, a];
    }
    set(e, t, n, r, s, a) {
        const l = this.planes;
        return (
            l[0].copy(e),
            l[1].copy(t),
            l[2].copy(n),
            l[3].copy(r),
            l[4].copy(s),
            l[5].copy(a),
            this
        );
    }
    copy(e) {
        const t = this.planes;
        for (let n = 0; n < 6; n++) t[n].copy(e.planes[n]);
        return this;
    }
    setFromProjectionMatrix(e, t = Do) {
        const n = this.planes,
            r = e.elements,
            s = r[0],
            a = r[1],
            l = r[2],
            c = r[3],
            d = r[4],
            p = r[5],
            g = r[6],
            y = r[7],
            v = r[8],
            S = r[9],
            T = r[10],
            M = r[11],
            w = r[12],
            b = r[13],
            C = r[14],
            L = r[15];
        if (
            (n[0].setComponents(c - s, y - d, M - v, L - w).normalize(),
            n[1].setComponents(c + s, y + d, M + v, L + w).normalize(),
            n[2].setComponents(c + a, y + p, M + S, L + b).normalize(),
            n[3].setComponents(c - a, y - p, M - S, L - b).normalize(),
            n[4].setComponents(c - l, y - g, M - T, L - C).normalize(),
            t === Do)
        )
            n[5].setComponents(c + l, y + g, M + T, L + C).normalize();
        else if (t === Rp) n[5].setComponents(l, g, T, C).normalize();
        else
            throw new Error(
                'THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: ' +
                    t
            );
        return this;
    }
    intersectsObject(e) {
        if (e.boundingSphere !== void 0)
            e.boundingSphere === null && e.computeBoundingSphere(),
                Nu.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
        else {
            const t = e.geometry;
            t.boundingSphere === null && t.computeBoundingSphere(),
                Nu.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
        }
        return this.intersectsSphere(Nu);
    }
    intersectsSprite(e) {
        return (
            Nu.center.set(0, 0, 0),
            (Nu.radius = 0.7071067811865476),
            Nu.applyMatrix4(e.matrixWorld),
            this.intersectsSphere(Nu)
        );
    }
    intersectsSphere(e) {
        const t = this.planes,
            n = e.center,
            r = -e.radius;
        for (let s = 0; s < 6; s++) if (t[s].distanceToPoint(n) < r) return !1;
        return !0;
    }
    intersectsBox(e) {
        const t = this.planes;
        for (let n = 0; n < 6; n++) {
            const r = t[n];
            if (
                ((wg.x = r.normal.x > 0 ? e.max.x : e.min.x),
                (wg.y = r.normal.y > 0 ? e.max.y : e.min.y),
                (wg.z = r.normal.z > 0 ? e.max.z : e.min.z),
                r.distanceToPoint(wg) < 0)
            )
                return !1;
        }
        return !0;
    }
    containsPoint(e) {
        const t = this.planes;
        for (let n = 0; n < 6; n++) if (t[n].distanceToPoint(e) < 0) return !1;
        return !0;
    }
    clone() {
        return new this.constructor().copy(this);
    }
}
function JR() {
    let i = null,
        e = !1,
        t = null,
        n = null;
    function r(s, a) {
        t(s, a), (n = i.requestAnimationFrame(r));
    }
    return {
        start: function () {
            e !== !0 &&
                t !== null &&
                ((n = i.requestAnimationFrame(r)), (e = !0));
        },
        stop: function () {
            i.cancelAnimationFrame(n), (e = !1);
        },
        setAnimationLoop: function (s) {
            t = s;
        },
        setContext: function (s) {
            i = s;
        },
    };
}
function Ik(i) {
    const e = new WeakMap();
    function t(l, c) {
        const d = l.array,
            p = l.usage,
            g = d.byteLength,
            y = i.createBuffer();
        i.bindBuffer(c, y), i.bufferData(c, d, p), l.onUploadCallback();
        let v;
        if (d instanceof Float32Array) v = i.FLOAT;
        else if (d instanceof Uint16Array)
            l.isFloat16BufferAttribute
                ? (v = i.HALF_FLOAT)
                : (v = i.UNSIGNED_SHORT);
        else if (d instanceof Int16Array) v = i.SHORT;
        else if (d instanceof Uint32Array) v = i.UNSIGNED_INT;
        else if (d instanceof Int32Array) v = i.INT;
        else if (d instanceof Int8Array) v = i.BYTE;
        else if (d instanceof Uint8Array) v = i.UNSIGNED_BYTE;
        else if (d instanceof Uint8ClampedArray) v = i.UNSIGNED_BYTE;
        else
            throw new Error(
                'THREE.WebGLAttributes: Unsupported buffer data format: ' + d
            );
        return {
            buffer: y,
            type: v,
            bytesPerElement: d.BYTES_PER_ELEMENT,
            version: l.version,
            size: g,
        };
    }
    function n(l, c, d) {
        const p = c.array,
            g = c._updateRange,
            y = c.updateRanges;
        if (
            (i.bindBuffer(d, l),
            g.count === -1 && y.length === 0 && i.bufferSubData(d, 0, p),
            y.length !== 0)
        ) {
            for (let v = 0, S = y.length; v < S; v++) {
                const T = y[v];
                i.bufferSubData(
                    d,
                    T.start * p.BYTES_PER_ELEMENT,
                    p,
                    T.start,
                    T.count
                );
            }
            c.clearUpdateRanges();
        }
        g.count !== -1 &&
            (i.bufferSubData(
                d,
                g.offset * p.BYTES_PER_ELEMENT,
                p,
                g.offset,
                g.count
            ),
            (g.count = -1)),
            c.onUploadCallback();
    }
    function r(l) {
        return l.isInterleavedBufferAttribute && (l = l.data), e.get(l);
    }
    function s(l) {
        l.isInterleavedBufferAttribute && (l = l.data);
        const c = e.get(l);
        c && (i.deleteBuffer(c.buffer), e.delete(l));
    }
    function a(l, c) {
        if (l.isGLBufferAttribute) {
            const p = e.get(l);
            (!p || p.version < l.version) &&
                e.set(l, {
                    buffer: l.buffer,
                    type: l.type,
                    bytesPerElement: l.elementSize,
                    version: l.version,
                });
            return;
        }
        l.isInterleavedBufferAttribute && (l = l.data);
        const d = e.get(l);
        if (d === void 0) e.set(l, t(l, c));
        else if (d.version < l.version) {
            if (d.size !== l.array.byteLength)
                throw new Error(
                    "THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported."
                );
            n(d.buffer, l, c), (d.version = l.version);
        }
    }
    return { get: r, remove: s, update: a };
}
class Th extends $t {
    constructor(e = 1, t = 1, n = 1, r = 1) {
        super(),
            (this.type = 'PlaneGeometry'),
            (this.parameters = {
                width: e,
                height: t,
                widthSegments: n,
                heightSegments: r,
            });
        const s = e / 2,
            a = t / 2,
            l = Math.floor(n),
            c = Math.floor(r),
            d = l + 1,
            p = c + 1,
            g = e / l,
            y = t / c,
            v = [],
            S = [],
            T = [],
            M = [];
        for (let w = 0; w < p; w++) {
            const b = w * y - a;
            for (let C = 0; C < d; C++) {
                const L = C * g - s;
                S.push(L, -b, 0),
                    T.push(0, 0, 1),
                    M.push(C / l),
                    M.push(1 - w / c);
            }
        }
        for (let w = 0; w < c; w++)
            for (let b = 0; b < l; b++) {
                const C = b + d * w,
                    L = b + d * (w + 1),
                    F = b + 1 + d * (w + 1),
                    N = b + 1 + d * w;
                v.push(C, L, N), v.push(L, F, N);
            }
        this.setIndex(v),
            this.setAttribute('position', new vt(S, 3)),
            this.setAttribute('normal', new vt(T, 3)),
            this.setAttribute('uv', new vt(M, 2));
    }
    copy(e) {
        return (
            super.copy(e),
            (this.parameters = Object.assign({}, e.parameters)),
            this
        );
    }
    static fromJSON(e) {
        return new Th(e.width, e.height, e.widthSegments, e.heightSegments);
    }
}
var Dk = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,
    Nk = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,
    Uk = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
    Ok = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
    kk = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,
    Fk = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
    Bk = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
    zk = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
    Vk = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`,
    Hk = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`,
    Gk = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,
    Wk = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
    Xk = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
    jk = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
    qk = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
    $k = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,
    Yk = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
    Kk = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
    Zk = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
    Jk = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
    Qk = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
    eF = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`,
    tF = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`,
    nF = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
    iF = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
    rF = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
    sF = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
    oF = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
    aF = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
    lF = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
    uF = 'gl_FragColor = linearToOutputTexel( gl_FragColor );',
    cF = `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}`,
    fF = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
    hF = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
    dF = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
    pF = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
    mF = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
    gF = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
    yF = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
    vF = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
    xF = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
    _F = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
    SF = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
    wF = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
    MF = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
    EF = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
    TF = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
    AF = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
    CF = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
    RF = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
    bF = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
    PF = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,
    LF = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
    IF = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
    DF = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
    NF = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,
    UF = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
    OF = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
    kF = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
    FF = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,
    BF = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
    zF = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
    VF = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
    HF = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
    GF = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
    WF = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
    XF = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,
    jF = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
    qF = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
    $F = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`,
    YF = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
    KF = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,
    ZF = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
    JF = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
    QF = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
    eB = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
    tB = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
    nB = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,
    iB = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
    rB = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
    sB = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
    oB = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
    aB = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
    lB = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
    uB = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
    cB = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
    fB = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
    hB = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
    dB = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
    pB = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`,
    mB = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
    gB = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
    yB = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
    vB = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
    xB = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,
    _B = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
    SB = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
    wB = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
    MB = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
    EB = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
    TB = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
    AB = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
    CB = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
		
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
		
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		
		#else
		
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
    RB = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
    bB = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
    PB = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
    LB = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const IB = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
    DB = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
    NB = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
    UB = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
    OB = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
    kB = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
    FB = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
    BB = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,
    zB = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
    VB = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
    HB = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
    GB = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
    WB = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
    XB = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
    jB = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
    qB = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    $B = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
    YB = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    KB = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
    ZB = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    JB = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
    QB = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
    ez = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
    tz = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    nz = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
    iz = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    rz = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
    sz = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    oz = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
    az = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
    lz = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
    uz = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
    cz = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
    fz = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
    qt = {
        alphahash_fragment: Dk,
        alphahash_pars_fragment: Nk,
        alphamap_fragment: Uk,
        alphamap_pars_fragment: Ok,
        alphatest_fragment: kk,
        alphatest_pars_fragment: Fk,
        aomap_fragment: Bk,
        aomap_pars_fragment: zk,
        batching_pars_vertex: Vk,
        batching_vertex: Hk,
        begin_vertex: Gk,
        beginnormal_vertex: Wk,
        bsdfs: Xk,
        iridescence_fragment: jk,
        bumpmap_pars_fragment: qk,
        clipping_planes_fragment: $k,
        clipping_planes_pars_fragment: Yk,
        clipping_planes_pars_vertex: Kk,
        clipping_planes_vertex: Zk,
        color_fragment: Jk,
        color_pars_fragment: Qk,
        color_pars_vertex: eF,
        color_vertex: tF,
        common: nF,
        cube_uv_reflection_fragment: iF,
        defaultnormal_vertex: rF,
        displacementmap_pars_vertex: sF,
        displacementmap_vertex: oF,
        emissivemap_fragment: aF,
        emissivemap_pars_fragment: lF,
        colorspace_fragment: uF,
        colorspace_pars_fragment: cF,
        envmap_fragment: fF,
        envmap_common_pars_fragment: hF,
        envmap_pars_fragment: dF,
        envmap_pars_vertex: pF,
        envmap_physical_pars_fragment: TF,
        envmap_vertex: mF,
        fog_vertex: gF,
        fog_pars_vertex: yF,
        fog_fragment: vF,
        fog_pars_fragment: xF,
        gradientmap_pars_fragment: _F,
        lightmap_pars_fragment: SF,
        lights_lambert_fragment: wF,
        lights_lambert_pars_fragment: MF,
        lights_pars_begin: EF,
        lights_toon_fragment: AF,
        lights_toon_pars_fragment: CF,
        lights_phong_fragment: RF,
        lights_phong_pars_fragment: bF,
        lights_physical_fragment: PF,
        lights_physical_pars_fragment: LF,
        lights_fragment_begin: IF,
        lights_fragment_maps: DF,
        lights_fragment_end: NF,
        logdepthbuf_fragment: UF,
        logdepthbuf_pars_fragment: OF,
        logdepthbuf_pars_vertex: kF,
        logdepthbuf_vertex: FF,
        map_fragment: BF,
        map_pars_fragment: zF,
        map_particle_fragment: VF,
        map_particle_pars_fragment: HF,
        metalnessmap_fragment: GF,
        metalnessmap_pars_fragment: WF,
        morphinstance_vertex: XF,
        morphcolor_vertex: jF,
        morphnormal_vertex: qF,
        morphtarget_pars_vertex: $F,
        morphtarget_vertex: YF,
        normal_fragment_begin: KF,
        normal_fragment_maps: ZF,
        normal_pars_fragment: JF,
        normal_pars_vertex: QF,
        normal_vertex: eB,
        normalmap_pars_fragment: tB,
        clearcoat_normal_fragment_begin: nB,
        clearcoat_normal_fragment_maps: iB,
        clearcoat_pars_fragment: rB,
        iridescence_pars_fragment: sB,
        opaque_fragment: oB,
        packing: aB,
        premultiplied_alpha_fragment: lB,
        project_vertex: uB,
        dithering_fragment: cB,
        dithering_pars_fragment: fB,
        roughnessmap_fragment: hB,
        roughnessmap_pars_fragment: dB,
        shadowmap_pars_fragment: pB,
        shadowmap_pars_vertex: mB,
        shadowmap_vertex: gB,
        shadowmask_pars_fragment: yB,
        skinbase_vertex: vB,
        skinning_pars_vertex: xB,
        skinning_vertex: _B,
        skinnormal_vertex: SB,
        specularmap_fragment: wB,
        specularmap_pars_fragment: MB,
        tonemapping_fragment: EB,
        tonemapping_pars_fragment: TB,
        transmission_fragment: AB,
        transmission_pars_fragment: CB,
        uv_pars_fragment: RB,
        uv_pars_vertex: bB,
        uv_vertex: PB,
        worldpos_vertex: LB,
        background_vert: IB,
        background_frag: DB,
        backgroundCube_vert: NB,
        backgroundCube_frag: UB,
        cube_vert: OB,
        cube_frag: kB,
        depth_vert: FB,
        depth_frag: BB,
        distanceRGBA_vert: zB,
        distanceRGBA_frag: VB,
        equirect_vert: HB,
        equirect_frag: GB,
        linedashed_vert: WB,
        linedashed_frag: XB,
        meshbasic_vert: jB,
        meshbasic_frag: qB,
        meshlambert_vert: $B,
        meshlambert_frag: YB,
        meshmatcap_vert: KB,
        meshmatcap_frag: ZB,
        meshnormal_vert: JB,
        meshnormal_frag: QB,
        meshphong_vert: ez,
        meshphong_frag: tz,
        meshphysical_vert: nz,
        meshphysical_frag: iz,
        meshtoon_vert: rz,
        meshtoon_frag: sz,
        points_vert: oz,
        points_frag: az,
        shadow_vert: lz,
        shadow_frag: uz,
        sprite_vert: cz,
        sprite_frag: fz,
    },
    et = {
        common: {
            diffuse: { value: new st(16777215) },
            opacity: { value: 1 },
            map: { value: null },
            mapTransform: { value: new Wt() },
            alphaMap: { value: null },
            alphaMapTransform: { value: new Wt() },
            alphaTest: { value: 0 },
        },
        specularmap: {
            specularMap: { value: null },
            specularMapTransform: { value: new Wt() },
        },
        envmap: {
            envMap: { value: null },
            envMapRotation: { value: new Wt() },
            flipEnvMap: { value: -1 },
            reflectivity: { value: 1 },
            ior: { value: 1.5 },
            refractionRatio: { value: 0.98 },
        },
        aomap: {
            aoMap: { value: null },
            aoMapIntensity: { value: 1 },
            aoMapTransform: { value: new Wt() },
        },
        lightmap: {
            lightMap: { value: null },
            lightMapIntensity: { value: 1 },
            lightMapTransform: { value: new Wt() },
        },
        bumpmap: {
            bumpMap: { value: null },
            bumpMapTransform: { value: new Wt() },
            bumpScale: { value: 1 },
        },
        normalmap: {
            normalMap: { value: null },
            normalMapTransform: { value: new Wt() },
            normalScale: { value: new Ce(1, 1) },
        },
        displacementmap: {
            displacementMap: { value: null },
            displacementMapTransform: { value: new Wt() },
            displacementScale: { value: 1 },
            displacementBias: { value: 0 },
        },
        emissivemap: {
            emissiveMap: { value: null },
            emissiveMapTransform: { value: new Wt() },
        },
        metalnessmap: {
            metalnessMap: { value: null },
            metalnessMapTransform: { value: new Wt() },
        },
        roughnessmap: {
            roughnessMap: { value: null },
            roughnessMapTransform: { value: new Wt() },
        },
        gradientmap: { gradientMap: { value: null } },
        fog: {
            fogDensity: { value: 25e-5 },
            fogNear: { value: 1 },
            fogFar: { value: 2e3 },
            fogColor: { value: new st(16777215) },
        },
        lights: {
            ambientLightColor: { value: [] },
            lightProbe: { value: [] },
            directionalLights: {
                value: [],
                properties: { direction: {}, color: {} },
            },
            directionalLightShadows: {
                value: [],
                properties: {
                    shadowIntensity: 1,
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {},
                },
            },
            directionalShadowMap: { value: [] },
            directionalShadowMatrix: { value: [] },
            spotLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    direction: {},
                    distance: {},
                    coneCos: {},
                    penumbraCos: {},
                    decay: {},
                },
            },
            spotLightShadows: {
                value: [],
                properties: {
                    shadowIntensity: 1,
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {},
                },
            },
            spotLightMap: { value: [] },
            spotShadowMap: { value: [] },
            spotLightMatrix: { value: [] },
            pointLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    decay: {},
                    distance: {},
                },
            },
            pointLightShadows: {
                value: [],
                properties: {
                    shadowIntensity: 1,
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {},
                    shadowCameraNear: {},
                    shadowCameraFar: {},
                },
            },
            pointShadowMap: { value: [] },
            pointShadowMatrix: { value: [] },
            hemisphereLights: {
                value: [],
                properties: { direction: {}, skyColor: {}, groundColor: {} },
            },
            rectAreaLights: {
                value: [],
                properties: { color: {}, position: {}, width: {}, height: {} },
            },
            ltc_1: { value: null },
            ltc_2: { value: null },
        },
        points: {
            diffuse: { value: new st(16777215) },
            opacity: { value: 1 },
            size: { value: 1 },
            scale: { value: 1 },
            map: { value: null },
            alphaMap: { value: null },
            alphaMapTransform: { value: new Wt() },
            alphaTest: { value: 0 },
            uvTransform: { value: new Wt() },
        },
        sprite: {
            diffuse: { value: new st(16777215) },
            opacity: { value: 1 },
            center: { value: new Ce(0.5, 0.5) },
            rotation: { value: 0 },
            map: { value: null },
            mapTransform: { value: new Wt() },
            alphaMap: { value: null },
            alphaMapTransform: { value: new Wt() },
            alphaTest: { value: 0 },
        },
    },
    ro = {
        basic: {
            uniforms: Sr([
                et.common,
                et.specularmap,
                et.envmap,
                et.aomap,
                et.lightmap,
                et.fog,
            ]),
            vertexShader: qt.meshbasic_vert,
            fragmentShader: qt.meshbasic_frag,
        },
        lambert: {
            uniforms: Sr([
                et.common,
                et.specularmap,
                et.envmap,
                et.aomap,
                et.lightmap,
                et.emissivemap,
                et.bumpmap,
                et.normalmap,
                et.displacementmap,
                et.fog,
                et.lights,
                { emissive: { value: new st(0) } },
            ]),
            vertexShader: qt.meshlambert_vert,
            fragmentShader: qt.meshlambert_frag,
        },
        phong: {
            uniforms: Sr([
                et.common,
                et.specularmap,
                et.envmap,
                et.aomap,
                et.lightmap,
                et.emissivemap,
                et.bumpmap,
                et.normalmap,
                et.displacementmap,
                et.fog,
                et.lights,
                {
                    emissive: { value: new st(0) },
                    specular: { value: new st(1118481) },
                    shininess: { value: 30 },
                },
            ]),
            vertexShader: qt.meshphong_vert,
            fragmentShader: qt.meshphong_frag,
        },
        standard: {
            uniforms: Sr([
                et.common,
                et.envmap,
                et.aomap,
                et.lightmap,
                et.emissivemap,
                et.bumpmap,
                et.normalmap,
                et.displacementmap,
                et.roughnessmap,
                et.metalnessmap,
                et.fog,
                et.lights,
                {
                    emissive: { value: new st(0) },
                    roughness: { value: 1 },
                    metalness: { value: 0 },
                    envMapIntensity: { value: 1 },
                },
            ]),
            vertexShader: qt.meshphysical_vert,
            fragmentShader: qt.meshphysical_frag,
        },
        toon: {
            uniforms: Sr([
                et.common,
                et.aomap,
                et.lightmap,
                et.emissivemap,
                et.bumpmap,
                et.normalmap,
                et.displacementmap,
                et.gradientmap,
                et.fog,
                et.lights,
                { emissive: { value: new st(0) } },
            ]),
            vertexShader: qt.meshtoon_vert,
            fragmentShader: qt.meshtoon_frag,
        },
        matcap: {
            uniforms: Sr([
                et.common,
                et.bumpmap,
                et.normalmap,
                et.displacementmap,
                et.fog,
                { matcap: { value: null } },
            ]),
            vertexShader: qt.meshmatcap_vert,
            fragmentShader: qt.meshmatcap_frag,
        },
        points: {
            uniforms: Sr([et.points, et.fog]),
            vertexShader: qt.points_vert,
            fragmentShader: qt.points_frag,
        },
        dashed: {
            uniforms: Sr([
                et.common,
                et.fog,
                {
                    scale: { value: 1 },
                    dashSize: { value: 1 },
                    totalSize: { value: 2 },
                },
            ]),
            vertexShader: qt.linedashed_vert,
            fragmentShader: qt.linedashed_frag,
        },
        depth: {
            uniforms: Sr([et.common, et.displacementmap]),
            vertexShader: qt.depth_vert,
            fragmentShader: qt.depth_frag,
        },
        normal: {
            uniforms: Sr([
                et.common,
                et.bumpmap,
                et.normalmap,
                et.displacementmap,
                { opacity: { value: 1 } },
            ]),
            vertexShader: qt.meshnormal_vert,
            fragmentShader: qt.meshnormal_frag,
        },
        sprite: {
            uniforms: Sr([et.sprite, et.fog]),
            vertexShader: qt.sprite_vert,
            fragmentShader: qt.sprite_frag,
        },
        background: {
            uniforms: {
                uvTransform: { value: new Wt() },
                t2D: { value: null },
                backgroundIntensity: { value: 1 },
            },
            vertexShader: qt.background_vert,
            fragmentShader: qt.background_frag,
        },
        backgroundCube: {
            uniforms: {
                envMap: { value: null },
                flipEnvMap: { value: -1 },
                backgroundBlurriness: { value: 0 },
                backgroundIntensity: { value: 1 },
                backgroundRotation: { value: new Wt() },
            },
            vertexShader: qt.backgroundCube_vert,
            fragmentShader: qt.backgroundCube_frag,
        },
        cube: {
            uniforms: {
                tCube: { value: null },
                tFlip: { value: -1 },
                opacity: { value: 1 },
            },
            vertexShader: qt.cube_vert,
            fragmentShader: qt.cube_frag,
        },
        equirect: {
            uniforms: { tEquirect: { value: null } },
            vertexShader: qt.equirect_vert,
            fragmentShader: qt.equirect_frag,
        },
        distanceRGBA: {
            uniforms: Sr([
                et.common,
                et.displacementmap,
                {
                    referencePosition: { value: new j() },
                    nearDistance: { value: 1 },
                    farDistance: { value: 1e3 },
                },
            ]),
            vertexShader: qt.distanceRGBA_vert,
            fragmentShader: qt.distanceRGBA_frag,
        },
        shadow: {
            uniforms: Sr([
                et.lights,
                et.fog,
                { color: { value: new st(0) }, opacity: { value: 1 } },
            ]),
            vertexShader: qt.shadow_vert,
            fragmentShader: qt.shadow_frag,
        },
    };
ro.physical = {
    uniforms: Sr([
        ro.standard.uniforms,
        {
            clearcoat: { value: 0 },
            clearcoatMap: { value: null },
            clearcoatMapTransform: { value: new Wt() },
            clearcoatNormalMap: { value: null },
            clearcoatNormalMapTransform: { value: new Wt() },
            clearcoatNormalScale: { value: new Ce(1, 1) },
            clearcoatRoughness: { value: 0 },
            clearcoatRoughnessMap: { value: null },
            clearcoatRoughnessMapTransform: { value: new Wt() },
            dispersion: { value: 0 },
            iridescence: { value: 0 },
            iridescenceMap: { value: null },
            iridescenceMapTransform: { value: new Wt() },
            iridescenceIOR: { value: 1.3 },
            iridescenceThicknessMinimum: { value: 100 },
            iridescenceThicknessMaximum: { value: 400 },
            iridescenceThicknessMap: { value: null },
            iridescenceThicknessMapTransform: { value: new Wt() },
            sheen: { value: 0 },
            sheenColor: { value: new st(0) },
            sheenColorMap: { value: null },
            sheenColorMapTransform: { value: new Wt() },
            sheenRoughness: { value: 1 },
            sheenRoughnessMap: { value: null },
            sheenRoughnessMapTransform: { value: new Wt() },
            transmission: { value: 0 },
            transmissionMap: { value: null },
            transmissionMapTransform: { value: new Wt() },
            transmissionSamplerSize: { value: new Ce() },
            transmissionSamplerMap: { value: null },
            thickness: { value: 0 },
            thicknessMap: { value: null },
            thicknessMapTransform: { value: new Wt() },
            attenuationDistance: { value: 0 },
            attenuationColor: { value: new st(0) },
            specularColor: { value: new st(1, 1, 1) },
            specularColorMap: { value: null },
            specularColorMapTransform: { value: new Wt() },
            specularIntensity: { value: 1 },
            specularIntensityMap: { value: null },
            specularIntensityMapTransform: { value: new Wt() },
            anisotropyVector: { value: new Ce() },
            anisotropyMap: { value: null },
            anisotropyMapTransform: { value: new Wt() },
        },
    ]),
    vertexShader: qt.meshphysical_vert,
    fragmentShader: qt.meshphysical_frag,
};
const Mg = { r: 0, b: 0, g: 0 },
    Uu = new as(),
    hz = new Pt();
function dz(i, e, t, n, r, s, a) {
    const l = new st(0);
    let c = s === !0 ? 0 : 1,
        d,
        p,
        g = null,
        y = 0,
        v = null;
    function S(b) {
        let C = b.isScene === !0 ? b.background : null;
        return (
            C &&
                C.isTexture &&
                (C = (b.backgroundBlurriness > 0 ? t : e).get(C)),
            C
        );
    }
    function T(b) {
        let C = !1;
        const L = S(b);
        L === null ? w(l, c) : L && L.isColor && (w(L, 1), (C = !0));
        const F = i.xr.getEnvironmentBlendMode();
        F === 'additive'
            ? n.buffers.color.setClear(0, 0, 0, 1, a)
            : F === 'alpha-blend' && n.buffers.color.setClear(0, 0, 0, 0, a),
            (i.autoClear || C) &&
                (n.buffers.depth.setTest(!0),
                n.buffers.depth.setMask(!0),
                n.buffers.color.setMask(!0),
                i.clear(
                    i.autoClearColor,
                    i.autoClearDepth,
                    i.autoClearStencil
                ));
    }
    function M(b, C) {
        const L = S(C);
        L && (L.isCubeTexture || L.mapping === wh)
            ? (p === void 0 &&
                  ((p = new di(
                      new dc(1, 1, 1),
                      new Ts({
                          name: 'BackgroundCubeMaterial',
                          uniforms: hh(ro.backgroundCube.uniforms),
                          vertexShader: ro.backgroundCube.vertexShader,
                          fragmentShader: ro.backgroundCube.fragmentShader,
                          side: Er,
                          depthTest: !1,
                          depthWrite: !1,
                          fog: !1,
                      })
                  )),
                  p.geometry.deleteAttribute('normal'),
                  p.geometry.deleteAttribute('uv'),
                  (p.onBeforeRender = function (F, N, B) {
                      this.matrixWorld.copyPosition(B.matrixWorld);
                  }),
                  Object.defineProperty(p.material, 'envMap', {
                      get: function () {
                          return this.uniforms.envMap.value;
                      },
                  }),
                  r.update(p)),
              Uu.copy(C.backgroundRotation),
              (Uu.x *= -1),
              (Uu.y *= -1),
              (Uu.z *= -1),
              L.isCubeTexture &&
                  L.isRenderTargetTexture === !1 &&
                  ((Uu.y *= -1), (Uu.z *= -1)),
              (p.material.uniforms.envMap.value = L),
              (p.material.uniforms.flipEnvMap.value =
                  L.isCubeTexture && L.isRenderTargetTexture === !1 ? -1 : 1),
              (p.material.uniforms.backgroundBlurriness.value =
                  C.backgroundBlurriness),
              (p.material.uniforms.backgroundIntensity.value =
                  C.backgroundIntensity),
              p.material.uniforms.backgroundRotation.value.setFromMatrix4(
                  hz.makeRotationFromEuler(Uu)
              ),
              (p.material.toneMapped = hn.getTransfer(L.colorSpace) !== Pn),
              (g !== L || y !== L.version || v !== i.toneMapping) &&
                  ((p.material.needsUpdate = !0),
                  (g = L),
                  (y = L.version),
                  (v = i.toneMapping)),
              p.layers.enableAll(),
              b.unshift(p, p.geometry, p.material, 0, 0, null))
            : L &&
              L.isTexture &&
              (d === void 0 &&
                  ((d = new di(
                      new Th(2, 2),
                      new Ts({
                          name: 'BackgroundMaterial',
                          uniforms: hh(ro.background.uniforms),
                          vertexShader: ro.background.vertexShader,
                          fragmentShader: ro.background.fragmentShader,
                          side: Na,
                          depthTest: !1,
                          depthWrite: !1,
                          fog: !1,
                      })
                  )),
                  d.geometry.deleteAttribute('normal'),
                  Object.defineProperty(d.material, 'map', {
                      get: function () {
                          return this.uniforms.t2D.value;
                      },
                  }),
                  r.update(d)),
              (d.material.uniforms.t2D.value = L),
              (d.material.uniforms.backgroundIntensity.value =
                  C.backgroundIntensity),
              (d.material.toneMapped = hn.getTransfer(L.colorSpace) !== Pn),
              L.matrixAutoUpdate === !0 && L.updateMatrix(),
              d.material.uniforms.uvTransform.value.copy(L.matrix),
              (g !== L || y !== L.version || v !== i.toneMapping) &&
                  ((d.material.needsUpdate = !0),
                  (g = L),
                  (y = L.version),
                  (v = i.toneMapping)),
              d.layers.enableAll(),
              b.unshift(d, d.geometry, d.material, 0, 0, null));
    }
    function w(b, C) {
        b.getRGB(Mg, YR(i)), n.buffers.color.setClear(Mg.r, Mg.g, Mg.b, C, a);
    }
    return {
        getClearColor: function () {
            return l;
        },
        setClearColor: function (b, C = 1) {
            l.set(b), (c = C), w(l, c);
        },
        getClearAlpha: function () {
            return c;
        },
        setClearAlpha: function (b) {
            (c = b), w(l, c);
        },
        render: T,
        addToRenderList: M,
    };
}
function pz(i, e) {
    const t = i.getParameter(i.MAX_VERTEX_ATTRIBS),
        n = {},
        r = y(null);
    let s = r,
        a = !1;
    function l(D, H, ie, ee, ue) {
        let Se = !1;
        const ce = g(ee, ie, H);
        s !== ce && ((s = ce), d(s.object)),
            (Se = v(D, ee, ie, ue)),
            Se && S(D, ee, ie, ue),
            ue !== null && e.update(ue, i.ELEMENT_ARRAY_BUFFER),
            (Se || a) &&
                ((a = !1),
                L(D, H, ie, ee),
                ue !== null &&
                    i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, e.get(ue).buffer));
    }
    function c() {
        return i.createVertexArray();
    }
    function d(D) {
        return i.bindVertexArray(D);
    }
    function p(D) {
        return i.deleteVertexArray(D);
    }
    function g(D, H, ie) {
        const ee = ie.wireframe === !0;
        let ue = n[D.id];
        ue === void 0 && ((ue = {}), (n[D.id] = ue));
        let Se = ue[H.id];
        Se === void 0 && ((Se = {}), (ue[H.id] = Se));
        let ce = Se[ee];
        return ce === void 0 && ((ce = y(c())), (Se[ee] = ce)), ce;
    }
    function y(D) {
        const H = [],
            ie = [],
            ee = [];
        for (let ue = 0; ue < t; ue++) (H[ue] = 0), (ie[ue] = 0), (ee[ue] = 0);
        return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: H,
            enabledAttributes: ie,
            attributeDivisors: ee,
            object: D,
            attributes: {},
            index: null,
        };
    }
    function v(D, H, ie, ee) {
        const ue = s.attributes,
            Se = H.attributes;
        let ce = 0;
        const me = ie.getAttributes();
        for (const X in me)
            if (me[X].location >= 0) {
                const Q = ue[X];
                let G = Se[X];
                if (
                    (G === void 0 &&
                        (X === 'instanceMatrix' &&
                            D.instanceMatrix &&
                            (G = D.instanceMatrix),
                        X === 'instanceColor' &&
                            D.instanceColor &&
                            (G = D.instanceColor)),
                    Q === void 0 ||
                        Q.attribute !== G ||
                        (G && Q.data !== G.data))
                )
                    return !0;
                ce++;
            }
        return s.attributesNum !== ce || s.index !== ee;
    }
    function S(D, H, ie, ee) {
        const ue = {},
            Se = H.attributes;
        let ce = 0;
        const me = ie.getAttributes();
        for (const X in me)
            if (me[X].location >= 0) {
                let Q = Se[X];
                Q === void 0 &&
                    (X === 'instanceMatrix' &&
                        D.instanceMatrix &&
                        (Q = D.instanceMatrix),
                    X === 'instanceColor' &&
                        D.instanceColor &&
                        (Q = D.instanceColor));
                const G = {};
                (G.attribute = Q),
                    Q && Q.data && (G.data = Q.data),
                    (ue[X] = G),
                    ce++;
            }
        (s.attributes = ue), (s.attributesNum = ce), (s.index = ee);
    }
    function T() {
        const D = s.newAttributes;
        for (let H = 0, ie = D.length; H < ie; H++) D[H] = 0;
    }
    function M(D) {
        w(D, 0);
    }
    function w(D, H) {
        const ie = s.newAttributes,
            ee = s.enabledAttributes,
            ue = s.attributeDivisors;
        (ie[D] = 1),
            ee[D] === 0 && (i.enableVertexAttribArray(D), (ee[D] = 1)),
            ue[D] !== H && (i.vertexAttribDivisor(D, H), (ue[D] = H));
    }
    function b() {
        const D = s.newAttributes,
            H = s.enabledAttributes;
        for (let ie = 0, ee = H.length; ie < ee; ie++)
            H[ie] !== D[ie] && (i.disableVertexAttribArray(ie), (H[ie] = 0));
    }
    function C(D, H, ie, ee, ue, Se, ce) {
        ce === !0
            ? i.vertexAttribIPointer(D, H, ie, ue, Se)
            : i.vertexAttribPointer(D, H, ie, ee, ue, Se);
    }
    function L(D, H, ie, ee) {
        T();
        const ue = ee.attributes,
            Se = ie.getAttributes(),
            ce = H.defaultAttributeValues;
        for (const me in Se) {
            const X = Se[me];
            if (X.location >= 0) {
                let oe = ue[me];
                if (
                    (oe === void 0 &&
                        (me === 'instanceMatrix' &&
                            D.instanceMatrix &&
                            (oe = D.instanceMatrix),
                        me === 'instanceColor' &&
                            D.instanceColor &&
                            (oe = D.instanceColor)),
                    oe !== void 0)
                ) {
                    const Q = oe.normalized,
                        G = oe.itemSize,
                        ae = e.get(oe);
                    if (ae === void 0) continue;
                    const Oe = ae.buffer,
                        fe = ae.type,
                        we = ae.bytesPerElement,
                        Pe =
                            fe === i.INT ||
                            fe === i.UNSIGNED_INT ||
                            oe.gpuType === uv;
                    if (oe.isInterleavedBufferAttribute) {
                        const Re = oe.data,
                            Ye = Re.stride,
                            lt = oe.offset;
                        if (Re.isInstancedInterleavedBuffer) {
                            for (let dt = 0; dt < X.locationSize; dt++)
                                w(X.location + dt, Re.meshPerAttribute);
                            D.isInstancedMesh !== !0 &&
                                ee._maxInstanceCount === void 0 &&
                                (ee._maxInstanceCount =
                                    Re.meshPerAttribute * Re.count);
                        } else
                            for (let dt = 0; dt < X.locationSize; dt++)
                                M(X.location + dt);
                        i.bindBuffer(i.ARRAY_BUFFER, Oe);
                        for (let dt = 0; dt < X.locationSize; dt++)
                            C(
                                X.location + dt,
                                G / X.locationSize,
                                fe,
                                Q,
                                Ye * we,
                                (lt + (G / X.locationSize) * dt) * we,
                                Pe
                            );
                    } else {
                        if (oe.isInstancedBufferAttribute) {
                            for (let Re = 0; Re < X.locationSize; Re++)
                                w(X.location + Re, oe.meshPerAttribute);
                            D.isInstancedMesh !== !0 &&
                                ee._maxInstanceCount === void 0 &&
                                (ee._maxInstanceCount =
                                    oe.meshPerAttribute * oe.count);
                        } else
                            for (let Re = 0; Re < X.locationSize; Re++)
                                M(X.location + Re);
                        i.bindBuffer(i.ARRAY_BUFFER, Oe);
                        for (let Re = 0; Re < X.locationSize; Re++)
                            C(
                                X.location + Re,
                                G / X.locationSize,
                                fe,
                                Q,
                                G * we,
                                (G / X.locationSize) * Re * we,
                                Pe
                            );
                    }
                } else if (ce !== void 0) {
                    const Q = ce[me];
                    if (Q !== void 0)
                        switch (Q.length) {
                            case 2:
                                i.vertexAttrib2fv(X.location, Q);
                                break;
                            case 3:
                                i.vertexAttrib3fv(X.location, Q);
                                break;
                            case 4:
                                i.vertexAttrib4fv(X.location, Q);
                                break;
                            default:
                                i.vertexAttrib1fv(X.location, Q);
                        }
                }
            }
        }
        b();
    }
    function F() {
        z();
        for (const D in n) {
            const H = n[D];
            for (const ie in H) {
                const ee = H[ie];
                for (const ue in ee) p(ee[ue].object), delete ee[ue];
                delete H[ie];
            }
            delete n[D];
        }
    }
    function N(D) {
        if (n[D.id] === void 0) return;
        const H = n[D.id];
        for (const ie in H) {
            const ee = H[ie];
            for (const ue in ee) p(ee[ue].object), delete ee[ue];
            delete H[ie];
        }
        delete n[D.id];
    }
    function B(D) {
        for (const H in n) {
            const ie = n[H];
            if (ie[D.id] === void 0) continue;
            const ee = ie[D.id];
            for (const ue in ee) p(ee[ue].object), delete ee[ue];
            delete ie[D.id];
        }
    }
    function z() {
        U(), (a = !0), s !== r && ((s = r), d(s.object));
    }
    function U() {
        (r.geometry = null), (r.program = null), (r.wireframe = !1);
    }
    return {
        setup: l,
        reset: z,
        resetDefaultState: U,
        dispose: F,
        releaseStatesOfGeometry: N,
        releaseStatesOfProgram: B,
        initAttributes: T,
        enableAttribute: M,
        disableUnusedAttributes: b,
    };
}
function mz(i, e, t) {
    let n;
    function r(d) {
        n = d;
    }
    function s(d, p) {
        i.drawArrays(n, d, p), t.update(p, n, 1);
    }
    function a(d, p, g) {
        g !== 0 && (i.drawArraysInstanced(n, d, p, g), t.update(p, n, g));
    }
    function l(d, p, g) {
        if (g === 0) return;
        e.get('WEBGL_multi_draw').multiDrawArraysWEBGL(n, d, 0, p, 0, g);
        let v = 0;
        for (let S = 0; S < g; S++) v += p[S];
        t.update(v, n, 1);
    }
    function c(d, p, g, y) {
        if (g === 0) return;
        const v = e.get('WEBGL_multi_draw');
        if (v === null) for (let S = 0; S < d.length; S++) a(d[S], p[S], y[S]);
        else {
            v.multiDrawArraysInstancedWEBGL(n, d, 0, p, 0, y, 0, g);
            let S = 0;
            for (let T = 0; T < g; T++) S += p[T];
            for (let T = 0; T < y.length; T++) t.update(S, n, y[T]);
        }
    }
    (this.setMode = r),
        (this.render = s),
        (this.renderInstances = a),
        (this.renderMultiDraw = l),
        (this.renderMultiDrawInstances = c);
}
function gz(i, e, t, n) {
    let r;
    function s() {
        if (r !== void 0) return r;
        if (e.has('EXT_texture_filter_anisotropic') === !0) {
            const N = e.get('EXT_texture_filter_anisotropic');
            r = i.getParameter(N.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
        } else r = 0;
        return r;
    }
    function a(N) {
        return !(
            N !== sr &&
            n.convert(N) !== i.getParameter(i.IMPLEMENTATION_COLOR_READ_FORMAT)
        );
    }
    function l(N) {
        const B =
            N === Mh &&
            (e.has('EXT_color_buffer_half_float') ||
                e.has('EXT_color_buffer_float'));
        return !(
            N !== ao &&
            n.convert(N) !== i.getParameter(i.IMPLEMENTATION_COLOR_READ_TYPE) &&
            N !== Vr &&
            !B
        );
    }
    function c(N) {
        if (N === 'highp') {
            if (
                i.getShaderPrecisionFormat(i.VERTEX_SHADER, i.HIGH_FLOAT)
                    .precision > 0 &&
                i.getShaderPrecisionFormat(i.FRAGMENT_SHADER, i.HIGH_FLOAT)
                    .precision > 0
            )
                return 'highp';
            N = 'mediump';
        }
        return N === 'mediump' &&
            i.getShaderPrecisionFormat(i.VERTEX_SHADER, i.MEDIUM_FLOAT)
                .precision > 0 &&
            i.getShaderPrecisionFormat(i.FRAGMENT_SHADER, i.MEDIUM_FLOAT)
                .precision > 0
            ? 'mediump'
            : 'lowp';
    }
    let d = t.precision !== void 0 ? t.precision : 'highp';
    const p = c(d);
    p !== d &&
        (console.warn(
            'THREE.WebGLRenderer:',
            d,
            'not supported, using',
            p,
            'instead.'
        ),
        (d = p));
    const g = t.logarithmicDepthBuffer === !0,
        y = i.getParameter(i.MAX_TEXTURE_IMAGE_UNITS),
        v = i.getParameter(i.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
        S = i.getParameter(i.MAX_TEXTURE_SIZE),
        T = i.getParameter(i.MAX_CUBE_MAP_TEXTURE_SIZE),
        M = i.getParameter(i.MAX_VERTEX_ATTRIBS),
        w = i.getParameter(i.MAX_VERTEX_UNIFORM_VECTORS),
        b = i.getParameter(i.MAX_VARYING_VECTORS),
        C = i.getParameter(i.MAX_FRAGMENT_UNIFORM_VECTORS),
        L = v > 0,
        F = i.getParameter(i.MAX_SAMPLES);
    return {
        isWebGL2: !0,
        getMaxAnisotropy: s,
        getMaxPrecision: c,
        textureFormatReadable: a,
        textureTypeReadable: l,
        precision: d,
        logarithmicDepthBuffer: g,
        maxTextures: y,
        maxVertexTextures: v,
        maxTextureSize: S,
        maxCubemapSize: T,
        maxAttributes: M,
        maxVertexUniforms: w,
        maxVaryings: b,
        maxFragmentUniforms: C,
        vertexTextures: L,
        maxSamples: F,
    };
}
function yz(i) {
    const e = this;
    let t = null,
        n = 0,
        r = !1,
        s = !1;
    const a = new Pl(),
        l = new Wt(),
        c = { value: null, needsUpdate: !1 };
    (this.uniform = c),
        (this.numPlanes = 0),
        (this.numIntersection = 0),
        (this.init = function (g, y) {
            const v = g.length !== 0 || y || n !== 0 || r;
            return (r = y), (n = g.length), v;
        }),
        (this.beginShadows = function () {
            (s = !0), p(null);
        }),
        (this.endShadows = function () {
            s = !1;
        }),
        (this.setGlobalState = function (g, y) {
            t = p(g, y, 0);
        }),
        (this.setState = function (g, y, v) {
            const S = g.clippingPlanes,
                T = g.clipIntersection,
                M = g.clipShadows,
                w = i.get(g);
            if (!r || S === null || S.length === 0 || (s && !M))
                s ? p(null) : d();
            else {
                const b = s ? 0 : n,
                    C = b * 4;
                let L = w.clippingState || null;
                (c.value = L), (L = p(S, y, C, v));
                for (let F = 0; F !== C; ++F) L[F] = t[F];
                (w.clippingState = L),
                    (this.numIntersection = T ? this.numPlanes : 0),
                    (this.numPlanes += b);
            }
        });
    function d() {
        c.value !== t && ((c.value = t), (c.needsUpdate = n > 0)),
            (e.numPlanes = n),
            (e.numIntersection = 0);
    }
    function p(g, y, v, S) {
        const T = g !== null ? g.length : 0;
        let M = null;
        if (T !== 0) {
            if (((M = c.value), S !== !0 || M === null)) {
                const w = v + T * 4,
                    b = y.matrixWorldInverse;
                l.getNormalMatrix(b),
                    (M === null || M.length < w) && (M = new Float32Array(w));
                for (let C = 0, L = v; C !== T; ++C, L += 4)
                    a.copy(g[C]).applyMatrix4(b, l),
                        a.normal.toArray(M, L),
                        (M[L + 3] = a.constant);
            }
            (c.value = M), (c.needsUpdate = !0);
        }
        return (e.numPlanes = T), (e.numIntersection = 0), M;
    }
}
function vz(i) {
    let e = new WeakMap();
    function t(a, l) {
        return l === vp ? (a.mapping = Ua) : l === xp && (a.mapping = Nl), a;
    }
    function n(a) {
        if (a && a.isTexture) {
            const l = a.mapping;
            if (l === vp || l === xp)
                if (e.has(a)) {
                    const c = e.get(a).texture;
                    return t(c, a.mapping);
                } else {
                    const c = a.image;
                    if (c && c.height > 0) {
                        const d = new ZR(c.height);
                        return (
                            d.fromEquirectangularTexture(i, a),
                            e.set(a, d),
                            a.addEventListener('dispose', r),
                            t(d.texture, a.mapping)
                        );
                    } else return null;
                }
        }
        return a;
    }
    function r(a) {
        const l = a.target;
        l.removeEventListener('dispose', r);
        const c = e.get(l);
        c !== void 0 && (e.delete(l), c.dispose());
    }
    function s() {
        e = new WeakMap();
    }
    return { get: n, dispose: s };
}
class Qp extends Kp {
    constructor(e = -1, t = 1, n = 1, r = -1, s = 0.1, a = 2e3) {
        super(),
            (this.isOrthographicCamera = !0),
            (this.type = 'OrthographicCamera'),
            (this.zoom = 1),
            (this.view = null),
            (this.left = e),
            (this.right = t),
            (this.top = n),
            (this.bottom = r),
            (this.near = s),
            (this.far = a),
            this.updateProjectionMatrix();
    }
    copy(e, t) {
        return (
            super.copy(e, t),
            (this.left = e.left),
            (this.right = e.right),
            (this.top = e.top),
            (this.bottom = e.bottom),
            (this.near = e.near),
            (this.far = e.far),
            (this.zoom = e.zoom),
            (this.view = e.view === null ? null : Object.assign({}, e.view)),
            this
        );
    }
    setViewOffset(e, t, n, r, s, a) {
        this.view === null &&
            (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1,
            }),
            (this.view.enabled = !0),
            (this.view.fullWidth = e),
            (this.view.fullHeight = t),
            (this.view.offsetX = n),
            (this.view.offsetY = r),
            (this.view.width = s),
            (this.view.height = a),
            this.updateProjectionMatrix();
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1),
            this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
        const e = (this.right - this.left) / (2 * this.zoom),
            t = (this.top - this.bottom) / (2 * this.zoom),
            n = (this.right + this.left) / 2,
            r = (this.top + this.bottom) / 2;
        let s = n - e,
            a = n + e,
            l = r + t,
            c = r - t;
        if (this.view !== null && this.view.enabled) {
            const d =
                    (this.right - this.left) / this.view.fullWidth / this.zoom,
                p = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            (s += d * this.view.offsetX),
                (a = s + d * this.view.width),
                (l -= p * this.view.offsetY),
                (c = l - p * this.view.height);
        }
        this.projectionMatrix.makeOrthographic(
            s,
            a,
            l,
            c,
            this.near,
            this.far,
            this.coordinateSystem
        ),
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return (
            (t.object.zoom = this.zoom),
            (t.object.left = this.left),
            (t.object.right = this.right),
            (t.object.top = this.top),
            (t.object.bottom = this.bottom),
            (t.object.near = this.near),
            (t.object.far = this.far),
            this.view !== null &&
                (t.object.view = Object.assign({}, this.view)),
            t
        );
    }
}
const eh = 4,
    $1 = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
    ju = 20,
    rx = new Qp(),
    Y1 = new st();
let sx = null,
    ox = 0,
    ax = 0,
    lx = !1;
const Xu = (1 + Math.sqrt(5)) / 2,
    If = 1 / Xu,
    K1 = [
        new j(-Xu, If, 0),
        new j(Xu, If, 0),
        new j(-If, 0, Xu),
        new j(If, 0, Xu),
        new j(0, Xu, -If),
        new j(0, Xu, If),
        new j(-1, 1, -1),
        new j(1, 1, -1),
        new j(-1, 1, 1),
        new j(1, 1, 1),
    ];
class v_ {
    constructor(e) {
        (this._renderer = e),
            (this._pingPongRenderTarget = null),
            (this._lodMax = 0),
            (this._cubeSize = 0),
            (this._lodPlanes = []),
            (this._sizeLods = []),
            (this._sigmas = []),
            (this._blurMaterial = null),
            (this._cubemapMaterial = null),
            (this._equirectMaterial = null),
            this._compileMaterial(this._blurMaterial);
    }
    fromScene(e, t = 0, n = 0.1, r = 100) {
        (sx = this._renderer.getRenderTarget()),
            (ox = this._renderer.getActiveCubeFace()),
            (ax = this._renderer.getActiveMipmapLevel()),
            (lx = this._renderer.xr.enabled),
            (this._renderer.xr.enabled = !1),
            this._setSize(256);
        const s = this._allocateTargets();
        return (
            (s.depthBuffer = !0),
            this._sceneToCubeUV(e, n, r, s),
            t > 0 && this._blur(s, 0, 0, t),
            this._applyPMREM(s),
            this._cleanup(s),
            s
        );
    }
    fromEquirectangular(e, t = null) {
        return this._fromTexture(e, t);
    }
    fromCubemap(e, t = null) {
        return this._fromTexture(e, t);
    }
    compileCubemapShader() {
        this._cubemapMaterial === null &&
            ((this._cubemapMaterial = Q1()),
            this._compileMaterial(this._cubemapMaterial));
    }
    compileEquirectangularShader() {
        this._equirectMaterial === null &&
            ((this._equirectMaterial = J1()),
            this._compileMaterial(this._equirectMaterial));
    }
    dispose() {
        this._dispose(),
            this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
            this._equirectMaterial !== null && this._equirectMaterial.dispose();
    }
    _setSize(e) {
        (this._lodMax = Math.floor(Math.log2(e))),
            (this._cubeSize = Math.pow(2, this._lodMax));
    }
    _dispose() {
        this._blurMaterial !== null && this._blurMaterial.dispose(),
            this._pingPongRenderTarget !== null &&
                this._pingPongRenderTarget.dispose();
        for (let e = 0; e < this._lodPlanes.length; e++)
            this._lodPlanes[e].dispose();
    }
    _cleanup(e) {
        this._renderer.setRenderTarget(sx, ox, ax),
            (this._renderer.xr.enabled = lx),
            (e.scissorTest = !1),
            Eg(e, 0, 0, e.width, e.height);
    }
    _fromTexture(e, t) {
        e.mapping === Ua || e.mapping === Nl
            ? this._setSize(
                  e.image.length === 0
                      ? 16
                      : e.image[0].width || e.image[0].image.width
              )
            : this._setSize(e.image.width / 4),
            (sx = this._renderer.getRenderTarget()),
            (ox = this._renderer.getActiveCubeFace()),
            (ax = this._renderer.getActiveMipmapLevel()),
            (lx = this._renderer.xr.enabled),
            (this._renderer.xr.enabled = !1);
        const n = t || this._allocateTargets();
        return (
            this._textureToCubeUV(e, n),
            this._applyPMREM(n),
            this._cleanup(n),
            n
        );
    }
    _allocateTargets() {
        const e = 3 * Math.max(this._cubeSize, 112),
            t = 4 * this._cubeSize,
            n = {
                magFilter: hi,
                minFilter: hi,
                generateMipmaps: !1,
                type: Mh,
                format: sr,
                colorSpace: Fa,
                depthBuffer: !1,
            },
            r = Z1(e, t, n);
        if (
            this._pingPongRenderTarget === null ||
            this._pingPongRenderTarget.width !== e ||
            this._pingPongRenderTarget.height !== t
        ) {
            this._pingPongRenderTarget !== null && this._dispose(),
                (this._pingPongRenderTarget = Z1(e, t, n));
            const { _lodMax: s } = this;
            ({
                sizeLods: this._sizeLods,
                lodPlanes: this._lodPlanes,
                sigmas: this._sigmas,
            } = xz(s)),
                (this._blurMaterial = _z(s, e, t));
        }
        return r;
    }
    _compileMaterial(e) {
        const t = new di(this._lodPlanes[0], e);
        this._renderer.compile(t, rx);
    }
    _sceneToCubeUV(e, t, n, r) {
        const l = new Pi(90, 1, t, n),
            c = [1, -1, 1, 1, 1, 1],
            d = [1, 1, 1, -1, -1, -1],
            p = this._renderer,
            g = p.autoClear,
            y = p.toneMapping;
        p.getClearColor(Y1), (p.toneMapping = Fo), (p.autoClear = !1);
        const v = new zl({
                name: 'PMREM.Background',
                side: Er,
                depthWrite: !1,
                depthTest: !1,
            }),
            S = new di(new dc(), v);
        let T = !1;
        const M = e.background;
        M
            ? M.isColor && (v.color.copy(M), (e.background = null), (T = !0))
            : (v.color.copy(Y1), (T = !0));
        for (let w = 0; w < 6; w++) {
            const b = w % 3;
            b === 0
                ? (l.up.set(0, c[w], 0), l.lookAt(d[w], 0, 0))
                : b === 1
                  ? (l.up.set(0, 0, c[w]), l.lookAt(0, d[w], 0))
                  : (l.up.set(0, c[w], 0), l.lookAt(0, 0, d[w]));
            const C = this._cubeSize;
            Eg(r, b * C, w > 2 ? C : 0, C, C),
                p.setRenderTarget(r),
                T && p.render(S, l),
                p.render(e, l);
        }
        S.geometry.dispose(),
            S.material.dispose(),
            (p.toneMapping = y),
            (p.autoClear = g),
            (e.background = M);
    }
    _textureToCubeUV(e, t) {
        const n = this._renderer,
            r = e.mapping === Ua || e.mapping === Nl;
        r
            ? (this._cubemapMaterial === null && (this._cubemapMaterial = Q1()),
              (this._cubemapMaterial.uniforms.flipEnvMap.value =
                  e.isRenderTargetTexture === !1 ? -1 : 1))
            : this._equirectMaterial === null &&
              (this._equirectMaterial = J1());
        const s = r ? this._cubemapMaterial : this._equirectMaterial,
            a = new di(this._lodPlanes[0], s),
            l = s.uniforms;
        l.envMap.value = e;
        const c = this._cubeSize;
        Eg(t, 0, 0, 3 * c, 2 * c), n.setRenderTarget(t), n.render(a, rx);
    }
    _applyPMREM(e) {
        const t = this._renderer,
            n = t.autoClear;
        t.autoClear = !1;
        const r = this._lodPlanes.length;
        for (let s = 1; s < r; s++) {
            const a = Math.sqrt(
                    this._sigmas[s] * this._sigmas[s] -
                        this._sigmas[s - 1] * this._sigmas[s - 1]
                ),
                l = K1[(r - s - 1) % K1.length];
            this._blur(e, s - 1, s, a, l);
        }
        t.autoClear = n;
    }
    _blur(e, t, n, r, s) {
        const a = this._pingPongRenderTarget;
        this._halfBlur(e, a, t, n, r, 'latitudinal', s),
            this._halfBlur(a, e, n, n, r, 'longitudinal', s);
    }
    _halfBlur(e, t, n, r, s, a, l) {
        const c = this._renderer,
            d = this._blurMaterial;
        a !== 'latitudinal' &&
            a !== 'longitudinal' &&
            console.error(
                'blur direction must be either latitudinal or longitudinal!'
            );
        const p = 3,
            g = new di(this._lodPlanes[r], d),
            y = d.uniforms,
            v = this._sizeLods[n] - 1,
            S = isFinite(s) ? Math.PI / (2 * v) : (2 * Math.PI) / (2 * ju - 1),
            T = s / S,
            M = isFinite(s) ? 1 + Math.floor(p * T) : ju;
        M > ju &&
            console.warn(
                `sigmaRadians, ${s}, is too large and will clip, as it requested ${M} samples when the maximum is set to ${ju}`
            );
        const w = [];
        let b = 0;
        for (let B = 0; B < ju; ++B) {
            const z = B / T,
                U = Math.exp((-z * z) / 2);
            w.push(U), B === 0 ? (b += U) : B < M && (b += 2 * U);
        }
        for (let B = 0; B < w.length; B++) w[B] = w[B] / b;
        (y.envMap.value = e.texture),
            (y.samples.value = M),
            (y.weights.value = w),
            (y.latitudinal.value = a === 'latitudinal'),
            l && (y.poleAxis.value = l);
        const { _lodMax: C } = this;
        (y.dTheta.value = S), (y.mipInt.value = C - n);
        const L = this._sizeLods[r],
            F = 3 * L * (r > C - eh ? r - C + eh : 0),
            N = 4 * (this._cubeSize - L);
        Eg(t, F, N, 3 * L, 2 * L), c.setRenderTarget(t), c.render(g, rx);
    }
}
function xz(i) {
    const e = [],
        t = [],
        n = [];
    let r = i;
    const s = i - eh + 1 + $1.length;
    for (let a = 0; a < s; a++) {
        const l = Math.pow(2, r);
        t.push(l);
        let c = 1 / l;
        a > i - eh ? (c = $1[a - i + eh - 1]) : a === 0 && (c = 0), n.push(c);
        const d = 1 / (l - 2),
            p = -d,
            g = 1 + d,
            y = [p, p, g, p, g, g, p, p, g, g, p, g],
            v = 6,
            S = 6,
            T = 3,
            M = 2,
            w = 1,
            b = new Float32Array(T * S * v),
            C = new Float32Array(M * S * v),
            L = new Float32Array(w * S * v);
        for (let N = 0; N < v; N++) {
            const B = ((N % 3) * 2) / 3 - 1,
                z = N > 2 ? 0 : -1,
                U = [
                    B,
                    z,
                    0,
                    B + 2 / 3,
                    z,
                    0,
                    B + 2 / 3,
                    z + 1,
                    0,
                    B,
                    z,
                    0,
                    B + 2 / 3,
                    z + 1,
                    0,
                    B,
                    z + 1,
                    0,
                ];
            b.set(U, T * S * N), C.set(y, M * S * N);
            const D = [N, N, N, N, N, N];
            L.set(D, w * S * N);
        }
        const F = new $t();
        F.setAttribute('position', new Mn(b, T)),
            F.setAttribute('uv', new Mn(C, M)),
            F.setAttribute('faceIndex', new Mn(L, w)),
            e.push(F),
            r > eh && r--;
    }
    return { lodPlanes: e, sizeLods: t, sigmas: n };
}
function Z1(i, e, t) {
    const n = new lo(i, e, t);
    return (
        (n.texture.mapping = wh),
        (n.texture.name = 'PMREM.cubeUv'),
        (n.scissorTest = !0),
        n
    );
}
function Eg(i, e, t, n, r) {
    i.viewport.set(e, t, n, r), i.scissor.set(e, t, n, r);
}
function _z(i, e, t) {
    const n = new Float32Array(ju),
        r = new j(0, 1, 0);
    return new Ts({
        name: 'SphericalGaussianBlur',
        defines: {
            n: ju,
            CUBEUV_TEXEL_WIDTH: 1 / e,
            CUBEUV_TEXEL_HEIGHT: 1 / t,
            CUBEUV_MAX_MIP: `${i}.0`,
        },
        uniforms: {
            envMap: { value: null },
            samples: { value: 1 },
            weights: { value: n },
            latitudinal: { value: !1 },
            dTheta: { value: 0 },
            mipInt: { value: 0 },
            poleAxis: { value: r },
        },
        vertexShader: XS(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
        blending: Pa,
        depthTest: !1,
        depthWrite: !1,
    });
}
function J1() {
    return new Ts({
        name: 'EquirectangularToCubeUV',
        uniforms: { envMap: { value: null } },
        vertexShader: XS(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
        blending: Pa,
        depthTest: !1,
        depthWrite: !1,
    });
}
function Q1() {
    return new Ts({
        name: 'CubemapToCubeUV',
        uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
        vertexShader: XS(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
        blending: Pa,
        depthTest: !1,
        depthWrite: !1,
    });
}
function XS() {
    return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function Sz(i) {
    let e = new WeakMap(),
        t = null;
    function n(l) {
        if (l && l.isTexture) {
            const c = l.mapping,
                d = c === vp || c === xp,
                p = c === Ua || c === Nl;
            if (d || p) {
                let g = e.get(l);
                const y = g !== void 0 ? g.texture.pmremVersion : 0;
                if (l.isRenderTargetTexture && l.pmremVersion !== y)
                    return (
                        t === null && (t = new v_(i)),
                        (g = d
                            ? t.fromEquirectangular(l, g)
                            : t.fromCubemap(l, g)),
                        (g.texture.pmremVersion = l.pmremVersion),
                        e.set(l, g),
                        g.texture
                    );
                if (g !== void 0) return g.texture;
                {
                    const v = l.image;
                    return (d && v && v.height > 0) || (p && v && r(v))
                        ? (t === null && (t = new v_(i)),
                          (g = d ? t.fromEquirectangular(l) : t.fromCubemap(l)),
                          (g.texture.pmremVersion = l.pmremVersion),
                          e.set(l, g),
                          l.addEventListener('dispose', s),
                          g.texture)
                        : null;
                }
            }
        }
        return l;
    }
    function r(l) {
        let c = 0;
        const d = 6;
        for (let p = 0; p < d; p++) l[p] !== void 0 && c++;
        return c === d;
    }
    function s(l) {
        const c = l.target;
        c.removeEventListener('dispose', s);
        const d = e.get(c);
        d !== void 0 && (e.delete(c), d.dispose());
    }
    function a() {
        (e = new WeakMap()), t !== null && (t.dispose(), (t = null));
    }
    return { get: n, dispose: a };
}
function wz(i) {
    const e = {};
    function t(n) {
        if (e[n] !== void 0) return e[n];
        let r;
        switch (n) {
            case 'WEBGL_depth_texture':
                r =
                    i.getExtension('WEBGL_depth_texture') ||
                    i.getExtension('MOZ_WEBGL_depth_texture') ||
                    i.getExtension('WEBKIT_WEBGL_depth_texture');
                break;
            case 'EXT_texture_filter_anisotropic':
                r =
                    i.getExtension('EXT_texture_filter_anisotropic') ||
                    i.getExtension('MOZ_EXT_texture_filter_anisotropic') ||
                    i.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
                break;
            case 'WEBGL_compressed_texture_s3tc':
                r =
                    i.getExtension('WEBGL_compressed_texture_s3tc') ||
                    i.getExtension('MOZ_WEBGL_compressed_texture_s3tc') ||
                    i.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
                break;
            case 'WEBGL_compressed_texture_pvrtc':
                r =
                    i.getExtension('WEBGL_compressed_texture_pvrtc') ||
                    i.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
                break;
            default:
                r = i.getExtension(n);
        }
        return (e[n] = r), r;
    }
    return {
        has: function (n) {
            return t(n) !== null;
        },
        init: function () {
            t('EXT_color_buffer_float'),
                t('WEBGL_clip_cull_distance'),
                t('OES_texture_float_linear'),
                t('EXT_color_buffer_half_float'),
                t('WEBGL_multisampled_render_to_texture'),
                t('WEBGL_render_shared_exponent');
        },
        get: function (n) {
            const r = t(n);
            return (
                r === null &&
                    zS(
                        'THREE.WebGLRenderer: ' +
                            n +
                            ' extension not supported.'
                    ),
                r
            );
        },
    };
}
function Mz(i, e, t, n) {
    const r = {},
        s = new WeakMap();
    function a(g) {
        const y = g.target;
        y.index !== null && e.remove(y.index);
        for (const S in y.attributes) e.remove(y.attributes[S]);
        for (const S in y.morphAttributes) {
            const T = y.morphAttributes[S];
            for (let M = 0, w = T.length; M < w; M++) e.remove(T[M]);
        }
        y.removeEventListener('dispose', a), delete r[y.id];
        const v = s.get(y);
        v && (e.remove(v), s.delete(y)),
            n.releaseStatesOfGeometry(y),
            y.isInstancedBufferGeometry === !0 && delete y._maxInstanceCount,
            t.memory.geometries--;
    }
    function l(g, y) {
        return (
            r[y.id] === !0 ||
                (y.addEventListener('dispose', a),
                (r[y.id] = !0),
                t.memory.geometries++),
            y
        );
    }
    function c(g) {
        const y = g.attributes;
        for (const S in y) e.update(y[S], i.ARRAY_BUFFER);
        const v = g.morphAttributes;
        for (const S in v) {
            const T = v[S];
            for (let M = 0, w = T.length; M < w; M++)
                e.update(T[M], i.ARRAY_BUFFER);
        }
    }
    function d(g) {
        const y = [],
            v = g.index,
            S = g.attributes.position;
        let T = 0;
        if (v !== null) {
            const b = v.array;
            T = v.version;
            for (let C = 0, L = b.length; C < L; C += 3) {
                const F = b[C + 0],
                    N = b[C + 1],
                    B = b[C + 2];
                y.push(F, N, N, B, B, F);
            }
        } else if (S !== void 0) {
            const b = S.array;
            T = S.version;
            for (let C = 0, L = b.length / 3 - 1; C < L; C += 3) {
                const F = C + 0,
                    N = C + 1,
                    B = C + 2;
                y.push(F, N, N, B, B, F);
            }
        } else return;
        const M = new (WR(y) ? GS : HS)(y, 1);
        M.version = T;
        const w = s.get(g);
        w && e.remove(w), s.set(g, M);
    }
    function p(g) {
        const y = s.get(g);
        if (y) {
            const v = g.index;
            v !== null && y.version < v.version && d(g);
        } else d(g);
        return s.get(g);
    }
    return { get: l, update: c, getWireframeAttribute: p };
}
function Ez(i, e, t) {
    let n;
    function r(y) {
        n = y;
    }
    let s, a;
    function l(y) {
        (s = y.type), (a = y.bytesPerElement);
    }
    function c(y, v) {
        i.drawElements(n, v, s, y * a), t.update(v, n, 1);
    }
    function d(y, v, S) {
        S !== 0 &&
            (i.drawElementsInstanced(n, v, s, y * a, S), t.update(v, n, S));
    }
    function p(y, v, S) {
        if (S === 0) return;
        e.get('WEBGL_multi_draw').multiDrawElementsWEBGL(n, v, 0, s, y, 0, S);
        let M = 0;
        for (let w = 0; w < S; w++) M += v[w];
        t.update(M, n, 1);
    }
    function g(y, v, S, T) {
        if (S === 0) return;
        const M = e.get('WEBGL_multi_draw');
        if (M === null)
            for (let w = 0; w < y.length; w++) d(y[w] / a, v[w], T[w]);
        else {
            M.multiDrawElementsInstancedWEBGL(n, v, 0, s, y, 0, T, 0, S);
            let w = 0;
            for (let b = 0; b < S; b++) w += v[b];
            for (let b = 0; b < T.length; b++) t.update(w, n, T[b]);
        }
    }
    (this.setMode = r),
        (this.setIndex = l),
        (this.render = c),
        (this.renderInstances = d),
        (this.renderMultiDraw = p),
        (this.renderMultiDrawInstances = g);
}
function Tz(i) {
    const e = { geometries: 0, textures: 0 },
        t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
    function n(s, a, l) {
        switch ((t.calls++, a)) {
            case i.TRIANGLES:
                t.triangles += l * (s / 3);
                break;
            case i.LINES:
                t.lines += l * (s / 2);
                break;
            case i.LINE_STRIP:
                t.lines += l * (s - 1);
                break;
            case i.LINE_LOOP:
                t.lines += l * s;
                break;
            case i.POINTS:
                t.points += l * s;
                break;
            default:
                console.error('THREE.WebGLInfo: Unknown draw mode:', a);
                break;
        }
    }
    function r() {
        (t.calls = 0), (t.triangles = 0), (t.points = 0), (t.lines = 0);
    }
    return {
        memory: e,
        render: t,
        programs: null,
        autoReset: !0,
        reset: r,
        update: n,
    };
}
function Az(i, e, t) {
    const n = new WeakMap(),
        r = new gn();
    function s(a, l, c) {
        const d = a.morphTargetInfluences,
            p =
                l.morphAttributes.position ||
                l.morphAttributes.normal ||
                l.morphAttributes.color,
            g = p !== void 0 ? p.length : 0;
        let y = n.get(l);
        if (y === void 0 || y.count !== g) {
            let U = function () {
                B.dispose(), n.delete(l), l.removeEventListener('dispose', U);
            };
            y !== void 0 && y.texture.dispose();
            const v = l.morphAttributes.position !== void 0,
                S = l.morphAttributes.normal !== void 0,
                T = l.morphAttributes.color !== void 0,
                M = l.morphAttributes.position || [],
                w = l.morphAttributes.normal || [],
                b = l.morphAttributes.color || [];
            let C = 0;
            v === !0 && (C = 1), S === !0 && (C = 2), T === !0 && (C = 3);
            let L = l.attributes.position.count * C,
                F = 1;
            L > e.maxTextureSize &&
                ((F = Math.ceil(L / e.maxTextureSize)), (L = e.maxTextureSize));
            const N = new Float32Array(L * F * 4 * g),
                B = new yv(N, L, F, g);
            (B.type = Vr), (B.needsUpdate = !0);
            const z = C * 4;
            for (let D = 0; D < g; D++) {
                const H = M[D],
                    ie = w[D],
                    ee = b[D],
                    ue = L * F * 4 * D;
                for (let Se = 0; Se < H.count; Se++) {
                    const ce = Se * z;
                    v === !0 &&
                        (r.fromBufferAttribute(H, Se),
                        (N[ue + ce + 0] = r.x),
                        (N[ue + ce + 1] = r.y),
                        (N[ue + ce + 2] = r.z),
                        (N[ue + ce + 3] = 0)),
                        S === !0 &&
                            (r.fromBufferAttribute(ie, Se),
                            (N[ue + ce + 4] = r.x),
                            (N[ue + ce + 5] = r.y),
                            (N[ue + ce + 6] = r.z),
                            (N[ue + ce + 7] = 0)),
                        T === !0 &&
                            (r.fromBufferAttribute(ee, Se),
                            (N[ue + ce + 8] = r.x),
                            (N[ue + ce + 9] = r.y),
                            (N[ue + ce + 10] = r.z),
                            (N[ue + ce + 11] = ee.itemSize === 4 ? r.w : 1));
                }
            }
            (y = { count: g, texture: B, size: new Ce(L, F) }),
                n.set(l, y),
                l.addEventListener('dispose', U);
        }
        if (a.isInstancedMesh === !0 && a.morphTexture !== null)
            c.getUniforms().setValue(i, 'morphTexture', a.morphTexture, t);
        else {
            let v = 0;
            for (let T = 0; T < d.length; T++) v += d[T];
            const S = l.morphTargetsRelative ? 1 : 1 - v;
            c.getUniforms().setValue(i, 'morphTargetBaseInfluence', S),
                c.getUniforms().setValue(i, 'morphTargetInfluences', d);
        }
        c.getUniforms().setValue(i, 'morphTargetsTexture', y.texture, t),
            c.getUniforms().setValue(i, 'morphTargetsTextureSize', y.size);
    }
    return { update: s };
}
function Cz(i, e, t, n) {
    let r = new WeakMap();
    function s(c) {
        const d = n.render.frame,
            p = c.geometry,
            g = e.get(c, p);
        if (
            (r.get(g) !== d && (e.update(g), r.set(g, d)),
            c.isInstancedMesh &&
                (c.hasEventListener('dispose', l) === !1 &&
                    c.addEventListener('dispose', l),
                r.get(c) !== d &&
                    (t.update(c.instanceMatrix, i.ARRAY_BUFFER),
                    c.instanceColor !== null &&
                        t.update(c.instanceColor, i.ARRAY_BUFFER),
                    r.set(c, d))),
            c.isSkinnedMesh)
        ) {
            const y = c.skeleton;
            r.get(y) !== d && (y.update(), r.set(y, d));
        }
        return g;
    }
    function a() {
        r = new WeakMap();
    }
    function l(c) {
        const d = c.target;
        d.removeEventListener('dispose', l),
            t.remove(d.instanceMatrix),
            d.instanceColor !== null && t.remove(d.instanceColor);
    }
    return { update: s, dispose: a };
}
class jS extends Qn {
    constructor(e, t, n, r, s, a, l, c, d, p = ic) {
        if (p !== ic && p !== lc)
            throw new Error(
                'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat'
            );
        n === void 0 && p === ic && (n = Oa),
            n === void 0 && p === lc && (n = ac),
            super(null, r, s, a, l, c, p, n, d),
            (this.isDepthTexture = !0),
            (this.image = { width: e, height: t }),
            (this.magFilter = l !== void 0 ? l : Li),
            (this.minFilter = c !== void 0 ? c : Li),
            (this.flipY = !1),
            (this.generateMipmaps = !1),
            (this.compareFunction = null);
    }
    copy(e) {
        return super.copy(e), (this.compareFunction = e.compareFunction), this;
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return (
            this.compareFunction !== null &&
                (t.compareFunction = this.compareFunction),
            t
        );
    }
}
const QR = new Qn(),
    eE = new jS(1, 1),
    eb = new yv(),
    tb = new VS(),
    nb = new Zp(),
    tE = [],
    nE = [],
    iE = new Float32Array(16),
    rE = new Float32Array(9),
    sE = new Float32Array(4);
function Ah(i, e, t) {
    const n = i[0];
    if (n <= 0 || n > 0) return i;
    const r = e * t;
    let s = tE[r];
    if ((s === void 0 && ((s = new Float32Array(r)), (tE[r] = s)), e !== 0)) {
        n.toArray(s, 0);
        for (let a = 1, l = 0; a !== e; ++a) (l += t), i[a].toArray(s, l);
    }
    return s;
}
function wi(i, e) {
    if (i.length !== e.length) return !1;
    for (let t = 0, n = i.length; t < n; t++) if (i[t] !== e[t]) return !1;
    return !0;
}
function Mi(i, e) {
    for (let t = 0, n = e.length; t < n; t++) i[t] = e[t];
}
function vv(i, e) {
    let t = nE[e];
    t === void 0 && ((t = new Int32Array(e)), (nE[e] = t));
    for (let n = 0; n !== e; ++n) t[n] = i.allocateTextureUnit();
    return t;
}
function Rz(i, e) {
    const t = this.cache;
    t[0] !== e && (i.uniform1f(this.addr, e), (t[0] = e));
}
function bz(i, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) &&
            (i.uniform2f(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
    else {
        if (wi(t, e)) return;
        i.uniform2fv(this.addr, e), Mi(t, e);
    }
}
function Pz(i, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
            (i.uniform3f(this.addr, e.x, e.y, e.z),
            (t[0] = e.x),
            (t[1] = e.y),
            (t[2] = e.z));
    else if (e.r !== void 0)
        (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) &&
            (i.uniform3f(this.addr, e.r, e.g, e.b),
            (t[0] = e.r),
            (t[1] = e.g),
            (t[2] = e.b));
    else {
        if (wi(t, e)) return;
        i.uniform3fv(this.addr, e), Mi(t, e);
    }
}
function Lz(i, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
            (i.uniform4f(this.addr, e.x, e.y, e.z, e.w),
            (t[0] = e.x),
            (t[1] = e.y),
            (t[2] = e.z),
            (t[3] = e.w));
    else {
        if (wi(t, e)) return;
        i.uniform4fv(this.addr, e), Mi(t, e);
    }
}
function Iz(i, e) {
    const t = this.cache,
        n = e.elements;
    if (n === void 0) {
        if (wi(t, e)) return;
        i.uniformMatrix2fv(this.addr, !1, e), Mi(t, e);
    } else {
        if (wi(t, n)) return;
        sE.set(n), i.uniformMatrix2fv(this.addr, !1, sE), Mi(t, n);
    }
}
function Dz(i, e) {
    const t = this.cache,
        n = e.elements;
    if (n === void 0) {
        if (wi(t, e)) return;
        i.uniformMatrix3fv(this.addr, !1, e), Mi(t, e);
    } else {
        if (wi(t, n)) return;
        rE.set(n), i.uniformMatrix3fv(this.addr, !1, rE), Mi(t, n);
    }
}
function Nz(i, e) {
    const t = this.cache,
        n = e.elements;
    if (n === void 0) {
        if (wi(t, e)) return;
        i.uniformMatrix4fv(this.addr, !1, e), Mi(t, e);
    } else {
        if (wi(t, n)) return;
        iE.set(n), i.uniformMatrix4fv(this.addr, !1, iE), Mi(t, n);
    }
}
function Uz(i, e) {
    const t = this.cache;
    t[0] !== e && (i.uniform1i(this.addr, e), (t[0] = e));
}
function Oz(i, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) &&
            (i.uniform2i(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
    else {
        if (wi(t, e)) return;
        i.uniform2iv(this.addr, e), Mi(t, e);
    }
}
function kz(i, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
            (i.uniform3i(this.addr, e.x, e.y, e.z),
            (t[0] = e.x),
            (t[1] = e.y),
            (t[2] = e.z));
    else {
        if (wi(t, e)) return;
        i.uniform3iv(this.addr, e), Mi(t, e);
    }
}
function Fz(i, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
            (i.uniform4i(this.addr, e.x, e.y, e.z, e.w),
            (t[0] = e.x),
            (t[1] = e.y),
            (t[2] = e.z),
            (t[3] = e.w));
    else {
        if (wi(t, e)) return;
        i.uniform4iv(this.addr, e), Mi(t, e);
    }
}
function Bz(i, e) {
    const t = this.cache;
    t[0] !== e && (i.uniform1ui(this.addr, e), (t[0] = e));
}
function zz(i, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) &&
            (i.uniform2ui(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
    else {
        if (wi(t, e)) return;
        i.uniform2uiv(this.addr, e), Mi(t, e);
    }
}
function Vz(i, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
            (i.uniform3ui(this.addr, e.x, e.y, e.z),
            (t[0] = e.x),
            (t[1] = e.y),
            (t[2] = e.z));
    else {
        if (wi(t, e)) return;
        i.uniform3uiv(this.addr, e), Mi(t, e);
    }
}
function Hz(i, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
            (i.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
            (t[0] = e.x),
            (t[1] = e.y),
            (t[2] = e.z),
            (t[3] = e.w));
    else {
        if (wi(t, e)) return;
        i.uniform4uiv(this.addr, e), Mi(t, e);
    }
}
function Gz(i, e, t) {
    const n = this.cache,
        r = t.allocateTextureUnit();
    n[0] !== r && (i.uniform1i(this.addr, r), (n[0] = r));
    let s;
    this.type === i.SAMPLER_2D_SHADOW
        ? ((eE.compareFunction = FS), (s = eE))
        : (s = QR),
        t.setTexture2D(e || s, r);
}
function Wz(i, e, t) {
    const n = this.cache,
        r = t.allocateTextureUnit();
    n[0] !== r && (i.uniform1i(this.addr, r), (n[0] = r)),
        t.setTexture3D(e || tb, r);
}
function Xz(i, e, t) {
    const n = this.cache,
        r = t.allocateTextureUnit();
    n[0] !== r && (i.uniform1i(this.addr, r), (n[0] = r)),
        t.setTextureCube(e || nb, r);
}
function jz(i, e, t) {
    const n = this.cache,
        r = t.allocateTextureUnit();
    n[0] !== r && (i.uniform1i(this.addr, r), (n[0] = r)),
        t.setTexture2DArray(e || eb, r);
}
function qz(i) {
    switch (i) {
        case 5126:
            return Rz;
        case 35664:
            return bz;
        case 35665:
            return Pz;
        case 35666:
            return Lz;
        case 35674:
            return Iz;
        case 35675:
            return Dz;
        case 35676:
            return Nz;
        case 5124:
        case 35670:
            return Uz;
        case 35667:
        case 35671:
            return Oz;
        case 35668:
        case 35672:
            return kz;
        case 35669:
        case 35673:
            return Fz;
        case 5125:
            return Bz;
        case 36294:
            return zz;
        case 36295:
            return Vz;
        case 36296:
            return Hz;
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
            return Gz;
        case 35679:
        case 36299:
        case 36307:
            return Wz;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
            return Xz;
        case 36289:
        case 36303:
        case 36311:
        case 36292:
            return jz;
    }
}
function $z(i, e) {
    i.uniform1fv(this.addr, e);
}
function Yz(i, e) {
    const t = Ah(e, this.size, 2);
    i.uniform2fv(this.addr, t);
}
function Kz(i, e) {
    const t = Ah(e, this.size, 3);
    i.uniform3fv(this.addr, t);
}
function Zz(i, e) {
    const t = Ah(e, this.size, 4);
    i.uniform4fv(this.addr, t);
}
function Jz(i, e) {
    const t = Ah(e, this.size, 4);
    i.uniformMatrix2fv(this.addr, !1, t);
}
function Qz(i, e) {
    const t = Ah(e, this.size, 9);
    i.uniformMatrix3fv(this.addr, !1, t);
}
function e4(i, e) {
    const t = Ah(e, this.size, 16);
    i.uniformMatrix4fv(this.addr, !1, t);
}
function t4(i, e) {
    i.uniform1iv(this.addr, e);
}
function n4(i, e) {
    i.uniform2iv(this.addr, e);
}
function i4(i, e) {
    i.uniform3iv(this.addr, e);
}
function r4(i, e) {
    i.uniform4iv(this.addr, e);
}
function s4(i, e) {
    i.uniform1uiv(this.addr, e);
}
function o4(i, e) {
    i.uniform2uiv(this.addr, e);
}
function a4(i, e) {
    i.uniform3uiv(this.addr, e);
}
function l4(i, e) {
    i.uniform4uiv(this.addr, e);
}
function u4(i, e, t) {
    const n = this.cache,
        r = e.length,
        s = vv(t, r);
    wi(n, s) || (i.uniform1iv(this.addr, s), Mi(n, s));
    for (let a = 0; a !== r; ++a) t.setTexture2D(e[a] || QR, s[a]);
}
function c4(i, e, t) {
    const n = this.cache,
        r = e.length,
        s = vv(t, r);
    wi(n, s) || (i.uniform1iv(this.addr, s), Mi(n, s));
    for (let a = 0; a !== r; ++a) t.setTexture3D(e[a] || tb, s[a]);
}
function f4(i, e, t) {
    const n = this.cache,
        r = e.length,
        s = vv(t, r);
    wi(n, s) || (i.uniform1iv(this.addr, s), Mi(n, s));
    for (let a = 0; a !== r; ++a) t.setTextureCube(e[a] || nb, s[a]);
}
function h4(i, e, t) {
    const n = this.cache,
        r = e.length,
        s = vv(t, r);
    wi(n, s) || (i.uniform1iv(this.addr, s), Mi(n, s));
    for (let a = 0; a !== r; ++a) t.setTexture2DArray(e[a] || eb, s[a]);
}
function d4(i) {
    switch (i) {
        case 5126:
            return $z;
        case 35664:
            return Yz;
        case 35665:
            return Kz;
        case 35666:
            return Zz;
        case 35674:
            return Jz;
        case 35675:
            return Qz;
        case 35676:
            return e4;
        case 5124:
        case 35670:
            return t4;
        case 35667:
        case 35671:
            return n4;
        case 35668:
        case 35672:
            return i4;
        case 35669:
        case 35673:
            return r4;
        case 5125:
            return s4;
        case 36294:
            return o4;
        case 36295:
            return a4;
        case 36296:
            return l4;
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
            return u4;
        case 35679:
        case 36299:
        case 36307:
            return c4;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
            return f4;
        case 36289:
        case 36303:
        case 36311:
        case 36292:
            return h4;
    }
}
class p4 {
    constructor(e, t, n) {
        (this.id = e),
            (this.addr = n),
            (this.cache = []),
            (this.type = t.type),
            (this.setValue = qz(t.type));
    }
}
class m4 {
    constructor(e, t, n) {
        (this.id = e),
            (this.addr = n),
            (this.cache = []),
            (this.type = t.type),
            (this.size = t.size),
            (this.setValue = d4(t.type));
    }
}
class g4 {
    constructor(e) {
        (this.id = e), (this.seq = []), (this.map = {});
    }
    setValue(e, t, n) {
        const r = this.seq;
        for (let s = 0, a = r.length; s !== a; ++s) {
            const l = r[s];
            l.setValue(e, t[l.id], n);
        }
    }
}
const ux = /(\w+)(\])?(\[|\.)?/g;
function oE(i, e) {
    i.seq.push(e), (i.map[e.id] = e);
}
function y4(i, e, t) {
    const n = i.name,
        r = n.length;
    for (ux.lastIndex = 0; ; ) {
        const s = ux.exec(n),
            a = ux.lastIndex;
        let l = s[1];
        const c = s[2] === ']',
            d = s[3];
        if ((c && (l = l | 0), d === void 0 || (d === '[' && a + 2 === r))) {
            oE(t, d === void 0 ? new p4(l, i, e) : new m4(l, i, e));
            break;
        } else {
            let g = t.map[l];
            g === void 0 && ((g = new g4(l)), oE(t, g)), (t = g);
        }
    }
}
class ay {
    constructor(e, t) {
        (this.seq = []), (this.map = {});
        const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
        for (let r = 0; r < n; ++r) {
            const s = e.getActiveUniform(t, r),
                a = e.getUniformLocation(t, s.name);
            y4(s, a, this);
        }
    }
    setValue(e, t, n, r) {
        const s = this.map[t];
        s !== void 0 && s.setValue(e, n, r);
    }
    setOptional(e, t, n) {
        const r = t[n];
        r !== void 0 && this.setValue(e, n, r);
    }
    static upload(e, t, n, r) {
        for (let s = 0, a = t.length; s !== a; ++s) {
            const l = t[s],
                c = n[l.id];
            c.needsUpdate !== !1 && l.setValue(e, c.value, r);
        }
    }
    static seqWithValue(e, t) {
        const n = [];
        for (let r = 0, s = e.length; r !== s; ++r) {
            const a = e[r];
            a.id in t && n.push(a);
        }
        return n;
    }
}
function aE(i, e, t) {
    const n = i.createShader(e);
    return i.shaderSource(n, t), i.compileShader(n), n;
}
const v4 = 37297;
let x4 = 0;
function _4(i, e) {
    const t = i.split(`
`),
        n = [],
        r = Math.max(e - 6, 0),
        s = Math.min(e + 6, t.length);
    for (let a = r; a < s; a++) {
        const l = a + 1;
        n.push(`${l === e ? '>' : ' '} ${l}: ${t[a]}`);
    }
    return n.join(`
`);
}
function S4(i) {
    const e = hn.getPrimaries(hn.workingColorSpace),
        t = hn.getPrimaries(i);
    let n;
    switch (
        (e === t
            ? (n = '')
            : e === Ap && t === Tp
              ? (n = 'LinearDisplayP3ToLinearSRGB')
              : e === Tp && t === Ap && (n = 'LinearSRGBToLinearDisplayP3'),
        i)
    ) {
        case Fa:
        case Yp:
            return [n, 'LinearTransferOETF'];
        case ws:
        case gv:
            return [n, 'sRGBTransferOETF'];
        default:
            return (
                console.warn('THREE.WebGLProgram: Unsupported color space:', i),
                [n, 'LinearTransferOETF']
            );
    }
}
function lE(i, e, t) {
    const n = i.getShaderParameter(e, i.COMPILE_STATUS),
        r = i.getShaderInfoLog(e).trim();
    if (n && r === '') return '';
    const s = /ERROR: 0:(\d+)/.exec(r);
    if (s) {
        const a = parseInt(s[1]);
        return (
            t.toUpperCase() +
            `

` +
            r +
            `

` +
            _4(i.getShaderSource(e), a)
        );
    } else return r;
}
function w4(i, e) {
    const t = S4(e);
    return `vec4 ${i}( vec4 value ) { return ${t[0]}( ${t[1]}( value ) ); }`;
}
function M4(i, e) {
    let t;
    switch (e) {
        case MR:
            t = 'Linear';
            break;
        case ER:
            t = 'Reinhard';
            break;
        case TR:
            t = 'OptimizedCineon';
            break;
        case AS:
            t = 'ACESFilmic';
            break;
        case CR:
            t = 'AgX';
            break;
        case RR:
            t = 'Neutral';
            break;
        case AR:
            t = 'Custom';
            break;
        default:
            console.warn('THREE.WebGLProgram: Unsupported toneMapping:', e),
                (t = 'Linear');
    }
    return (
        'vec3 ' + i + '( vec3 color ) { return ' + t + 'ToneMapping( color ); }'
    );
}
function E4(i) {
    return [
        i.extensionClipCullDistance
            ? '#extension GL_ANGLE_clip_cull_distance : require'
            : '',
        i.extensionMultiDraw ? '#extension GL_ANGLE_multi_draw : require' : '',
    ].filter(Xd).join(`
`);
}
function T4(i) {
    const e = [];
    for (const t in i) {
        const n = i[t];
        n !== !1 && e.push('#define ' + t + ' ' + n);
    }
    return e.join(`
`);
}
function A4(i, e) {
    const t = {},
        n = i.getProgramParameter(e, i.ACTIVE_ATTRIBUTES);
    for (let r = 0; r < n; r++) {
        const s = i.getActiveAttrib(e, r),
            a = s.name;
        let l = 1;
        s.type === i.FLOAT_MAT2 && (l = 2),
            s.type === i.FLOAT_MAT3 && (l = 3),
            s.type === i.FLOAT_MAT4 && (l = 4),
            (t[a] = {
                type: s.type,
                location: i.getAttribLocation(e, a),
                locationSize: l,
            });
    }
    return t;
}
function Xd(i) {
    return i !== '';
}
function uE(i, e) {
    const t =
        e.numSpotLightShadows +
        e.numSpotLightMaps -
        e.numSpotLightShadowsWithMaps;
    return i
        .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
        .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
        .replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
        .replace(/NUM_SPOT_LIGHT_COORDS/g, t)
        .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
        .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
        .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
        .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
        .replace(
            /NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,
            e.numSpotLightShadowsWithMaps
        )
        .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
        .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function cE(i, e) {
    return i
        .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
        .replace(
            /UNION_CLIPPING_PLANES/g,
            e.numClippingPlanes - e.numClipIntersection
        );
}
const C4 = /^[ \t]*#include +<([\w\d./]+)>/gm;
function x_(i) {
    return i.replace(C4, b4);
}
const R4 = new Map();
function b4(i, e) {
    let t = qt[e];
    if (t === void 0) {
        const n = R4.get(e);
        if (n !== void 0)
            (t = qt[n]),
                console.warn(
                    'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',
                    e,
                    n
                );
        else throw new Error('Can not resolve #include <' + e + '>');
    }
    return x_(t);
}
const P4 =
    /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function fE(i) {
    return i.replace(P4, L4);
}
function L4(i, e, t, n) {
    let r = '';
    for (let s = parseInt(e); s < parseInt(t); s++)
        r += n
            .replace(/\[\s*i\s*\]/g, '[ ' + s + ' ]')
            .replace(/UNROLLED_LOOP_INDEX/g, s);
    return r;
}
function hE(i) {
    let e = `precision ${i.precision} float;
	precision ${i.precision} int;
	precision ${i.precision} sampler2D;
	precision ${i.precision} samplerCube;
	precision ${i.precision} sampler3D;
	precision ${i.precision} sampler2DArray;
	precision ${i.precision} sampler2DShadow;
	precision ${i.precision} samplerCubeShadow;
	precision ${i.precision} sampler2DArrayShadow;
	precision ${i.precision} isampler2D;
	precision ${i.precision} isampler3D;
	precision ${i.precision} isamplerCube;
	precision ${i.precision} isampler2DArray;
	precision ${i.precision} usampler2D;
	precision ${i.precision} usampler3D;
	precision ${i.precision} usamplerCube;
	precision ${i.precision} usampler2DArray;
	`;
    return (
        i.precision === 'highp'
            ? (e += `
#define HIGH_PRECISION`)
            : i.precision === 'mediump'
              ? (e += `
#define MEDIUM_PRECISION`)
              : i.precision === 'lowp' &&
                (e += `
#define LOW_PRECISION`),
        e
    );
}
function I4(i) {
    let e = 'SHADOWMAP_TYPE_BASIC';
    return (
        i.shadowMapType === av
            ? (e = 'SHADOWMAP_TYPE_PCF')
            : i.shadowMapType === Zd
              ? (e = 'SHADOWMAP_TYPE_PCF_SOFT')
              : i.shadowMapType === io && (e = 'SHADOWMAP_TYPE_VSM'),
        e
    );
}
function D4(i) {
    let e = 'ENVMAP_TYPE_CUBE';
    if (i.envMap)
        switch (i.envMapMode) {
            case Ua:
            case Nl:
                e = 'ENVMAP_TYPE_CUBE';
                break;
            case wh:
                e = 'ENVMAP_TYPE_CUBE_UV';
                break;
        }
    return e;
}
function N4(i) {
    let e = 'ENVMAP_MODE_REFLECTION';
    if (i.envMap)
        switch (i.envMapMode) {
            case Nl:
                e = 'ENVMAP_MODE_REFRACTION';
                break;
        }
    return e;
}
function U4(i) {
    let e = 'ENVMAP_BLENDING_NONE';
    if (i.envMap)
        switch (i.combine) {
            case qp:
                e = 'ENVMAP_BLENDING_MULTIPLY';
                break;
            case SR:
                e = 'ENVMAP_BLENDING_MIX';
                break;
            case wR:
                e = 'ENVMAP_BLENDING_ADD';
                break;
        }
    return e;
}
function O4(i) {
    const e = i.envMapCubeUVHeight;
    if (e === null) return null;
    const t = Math.log2(e) - 2,
        n = 1 / e;
    return {
        texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
        texelHeight: n,
        maxMip: t,
    };
}
function k4(i, e, t, n) {
    const r = i.getContext(),
        s = t.defines;
    let a = t.vertexShader,
        l = t.fragmentShader;
    const c = I4(t),
        d = D4(t),
        p = N4(t),
        g = U4(t),
        y = O4(t),
        v = E4(t),
        S = T4(s),
        T = r.createProgram();
    let M,
        w,
        b = t.glslVersion
            ? '#version ' +
              t.glslVersion +
              `
`
            : '';
    t.isRawShaderMaterial
        ? ((M = [
              '#define SHADER_TYPE ' + t.shaderType,
              '#define SHADER_NAME ' + t.shaderName,
              S,
          ].filter(Xd).join(`
`)),
          M.length > 0 &&
              (M += `
`),
          (w = [
              '#define SHADER_TYPE ' + t.shaderType,
              '#define SHADER_NAME ' + t.shaderName,
              S,
          ].filter(Xd).join(`
`)),
          w.length > 0 &&
              (w += `
`))
        : ((M = [
              hE(t),
              '#define SHADER_TYPE ' + t.shaderType,
              '#define SHADER_NAME ' + t.shaderName,
              S,
              t.extensionClipCullDistance ? '#define USE_CLIP_DISTANCE' : '',
              t.batching ? '#define USE_BATCHING' : '',
              t.batchingColor ? '#define USE_BATCHING_COLOR' : '',
              t.instancing ? '#define USE_INSTANCING' : '',
              t.instancingColor ? '#define USE_INSTANCING_COLOR' : '',
              t.instancingMorph ? '#define USE_INSTANCING_MORPH' : '',
              t.useFog && t.fog ? '#define USE_FOG' : '',
              t.useFog && t.fogExp2 ? '#define FOG_EXP2' : '',
              t.map ? '#define USE_MAP' : '',
              t.envMap ? '#define USE_ENVMAP' : '',
              t.envMap ? '#define ' + p : '',
              t.lightMap ? '#define USE_LIGHTMAP' : '',
              t.aoMap ? '#define USE_AOMAP' : '',
              t.bumpMap ? '#define USE_BUMPMAP' : '',
              t.normalMap ? '#define USE_NORMALMAP' : '',
              t.normalMapObjectSpace ? '#define USE_NORMALMAP_OBJECTSPACE' : '',
              t.normalMapTangentSpace
                  ? '#define USE_NORMALMAP_TANGENTSPACE'
                  : '',
              t.displacementMap ? '#define USE_DISPLACEMENTMAP' : '',
              t.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
              t.anisotropy ? '#define USE_ANISOTROPY' : '',
              t.anisotropyMap ? '#define USE_ANISOTROPYMAP' : '',
              t.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
              t.clearcoatRoughnessMap
                  ? '#define USE_CLEARCOAT_ROUGHNESSMAP'
                  : '',
              t.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
              t.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',
              t.iridescenceThicknessMap
                  ? '#define USE_IRIDESCENCE_THICKNESSMAP'
                  : '',
              t.specularMap ? '#define USE_SPECULARMAP' : '',
              t.specularColorMap ? '#define USE_SPECULAR_COLORMAP' : '',
              t.specularIntensityMap ? '#define USE_SPECULAR_INTENSITYMAP' : '',
              t.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
              t.metalnessMap ? '#define USE_METALNESSMAP' : '',
              t.alphaMap ? '#define USE_ALPHAMAP' : '',
              t.alphaHash ? '#define USE_ALPHAHASH' : '',
              t.transmission ? '#define USE_TRANSMISSION' : '',
              t.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
              t.thicknessMap ? '#define USE_THICKNESSMAP' : '',
              t.sheenColorMap ? '#define USE_SHEEN_COLORMAP' : '',
              t.sheenRoughnessMap ? '#define USE_SHEEN_ROUGHNESSMAP' : '',
              t.mapUv ? '#define MAP_UV ' + t.mapUv : '',
              t.alphaMapUv ? '#define ALPHAMAP_UV ' + t.alphaMapUv : '',
              t.lightMapUv ? '#define LIGHTMAP_UV ' + t.lightMapUv : '',
              t.aoMapUv ? '#define AOMAP_UV ' + t.aoMapUv : '',
              t.emissiveMapUv
                  ? '#define EMISSIVEMAP_UV ' + t.emissiveMapUv
                  : '',
              t.bumpMapUv ? '#define BUMPMAP_UV ' + t.bumpMapUv : '',
              t.normalMapUv ? '#define NORMALMAP_UV ' + t.normalMapUv : '',
              t.displacementMapUv
                  ? '#define DISPLACEMENTMAP_UV ' + t.displacementMapUv
                  : '',
              t.metalnessMapUv
                  ? '#define METALNESSMAP_UV ' + t.metalnessMapUv
                  : '',
              t.roughnessMapUv
                  ? '#define ROUGHNESSMAP_UV ' + t.roughnessMapUv
                  : '',
              t.anisotropyMapUv
                  ? '#define ANISOTROPYMAP_UV ' + t.anisotropyMapUv
                  : '',
              t.clearcoatMapUv
                  ? '#define CLEARCOATMAP_UV ' + t.clearcoatMapUv
                  : '',
              t.clearcoatNormalMapUv
                  ? '#define CLEARCOAT_NORMALMAP_UV ' + t.clearcoatNormalMapUv
                  : '',
              t.clearcoatRoughnessMapUv
                  ? '#define CLEARCOAT_ROUGHNESSMAP_UV ' +
                    t.clearcoatRoughnessMapUv
                  : '',
              t.iridescenceMapUv
                  ? '#define IRIDESCENCEMAP_UV ' + t.iridescenceMapUv
                  : '',
              t.iridescenceThicknessMapUv
                  ? '#define IRIDESCENCE_THICKNESSMAP_UV ' +
                    t.iridescenceThicknessMapUv
                  : '',
              t.sheenColorMapUv
                  ? '#define SHEEN_COLORMAP_UV ' + t.sheenColorMapUv
                  : '',
              t.sheenRoughnessMapUv
                  ? '#define SHEEN_ROUGHNESSMAP_UV ' + t.sheenRoughnessMapUv
                  : '',
              t.specularMapUv
                  ? '#define SPECULARMAP_UV ' + t.specularMapUv
                  : '',
              t.specularColorMapUv
                  ? '#define SPECULAR_COLORMAP_UV ' + t.specularColorMapUv
                  : '',
              t.specularIntensityMapUv
                  ? '#define SPECULAR_INTENSITYMAP_UV ' +
                    t.specularIntensityMapUv
                  : '',
              t.transmissionMapUv
                  ? '#define TRANSMISSIONMAP_UV ' + t.transmissionMapUv
                  : '',
              t.thicknessMapUv
                  ? '#define THICKNESSMAP_UV ' + t.thicknessMapUv
                  : '',
              t.vertexTangents && t.flatShading === !1
                  ? '#define USE_TANGENT'
                  : '',
              t.vertexColors ? '#define USE_COLOR' : '',
              t.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
              t.vertexUv1s ? '#define USE_UV1' : '',
              t.vertexUv2s ? '#define USE_UV2' : '',
              t.vertexUv3s ? '#define USE_UV3' : '',
              t.pointsUvs ? '#define USE_POINTS_UV' : '',
              t.flatShading ? '#define FLAT_SHADED' : '',
              t.skinning ? '#define USE_SKINNING' : '',
              t.morphTargets ? '#define USE_MORPHTARGETS' : '',
              t.morphNormals && t.flatShading === !1
                  ? '#define USE_MORPHNORMALS'
                  : '',
              t.morphColors ? '#define USE_MORPHCOLORS' : '',
              t.morphTargetsCount > 0
                  ? '#define MORPHTARGETS_TEXTURE_STRIDE ' +
                    t.morphTextureStride
                  : '',
              t.morphTargetsCount > 0
                  ? '#define MORPHTARGETS_COUNT ' + t.morphTargetsCount
                  : '',
              t.doubleSided ? '#define DOUBLE_SIDED' : '',
              t.flipSided ? '#define FLIP_SIDED' : '',
              t.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
              t.shadowMapEnabled ? '#define ' + c : '',
              t.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
              t.numLightProbes > 0 ? '#define USE_LIGHT_PROBES' : '',
              t.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
              'uniform mat4 modelMatrix;',
              'uniform mat4 modelViewMatrix;',
              'uniform mat4 projectionMatrix;',
              'uniform mat4 viewMatrix;',
              'uniform mat3 normalMatrix;',
              'uniform vec3 cameraPosition;',
              'uniform bool isOrthographic;',
              '#ifdef USE_INSTANCING',
              '	attribute mat4 instanceMatrix;',
              '#endif',
              '#ifdef USE_INSTANCING_COLOR',
              '	attribute vec3 instanceColor;',
              '#endif',
              '#ifdef USE_INSTANCING_MORPH',
              '	uniform sampler2D morphTexture;',
              '#endif',
              'attribute vec3 position;',
              'attribute vec3 normal;',
              'attribute vec2 uv;',
              '#ifdef USE_UV1',
              '	attribute vec2 uv1;',
              '#endif',
              '#ifdef USE_UV2',
              '	attribute vec2 uv2;',
              '#endif',
              '#ifdef USE_UV3',
              '	attribute vec2 uv3;',
              '#endif',
              '#ifdef USE_TANGENT',
              '	attribute vec4 tangent;',
              '#endif',
              '#if defined( USE_COLOR_ALPHA )',
              '	attribute vec4 color;',
              '#elif defined( USE_COLOR )',
              '	attribute vec3 color;',
              '#endif',
              '#ifdef USE_SKINNING',
              '	attribute vec4 skinIndex;',
              '	attribute vec4 skinWeight;',
              '#endif',
              `
`,
          ].filter(Xd).join(`
`)),
          (w = [
              hE(t),
              '#define SHADER_TYPE ' + t.shaderType,
              '#define SHADER_NAME ' + t.shaderName,
              S,
              t.useFog && t.fog ? '#define USE_FOG' : '',
              t.useFog && t.fogExp2 ? '#define FOG_EXP2' : '',
              t.alphaToCoverage ? '#define ALPHA_TO_COVERAGE' : '',
              t.map ? '#define USE_MAP' : '',
              t.matcap ? '#define USE_MATCAP' : '',
              t.envMap ? '#define USE_ENVMAP' : '',
              t.envMap ? '#define ' + d : '',
              t.envMap ? '#define ' + p : '',
              t.envMap ? '#define ' + g : '',
              y ? '#define CUBEUV_TEXEL_WIDTH ' + y.texelWidth : '',
              y ? '#define CUBEUV_TEXEL_HEIGHT ' + y.texelHeight : '',
              y ? '#define CUBEUV_MAX_MIP ' + y.maxMip + '.0' : '',
              t.lightMap ? '#define USE_LIGHTMAP' : '',
              t.aoMap ? '#define USE_AOMAP' : '',
              t.bumpMap ? '#define USE_BUMPMAP' : '',
              t.normalMap ? '#define USE_NORMALMAP' : '',
              t.normalMapObjectSpace ? '#define USE_NORMALMAP_OBJECTSPACE' : '',
              t.normalMapTangentSpace
                  ? '#define USE_NORMALMAP_TANGENTSPACE'
                  : '',
              t.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
              t.anisotropy ? '#define USE_ANISOTROPY' : '',
              t.anisotropyMap ? '#define USE_ANISOTROPYMAP' : '',
              t.clearcoat ? '#define USE_CLEARCOAT' : '',
              t.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
              t.clearcoatRoughnessMap
                  ? '#define USE_CLEARCOAT_ROUGHNESSMAP'
                  : '',
              t.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
              t.dispersion ? '#define USE_DISPERSION' : '',
              t.iridescence ? '#define USE_IRIDESCENCE' : '',
              t.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',
              t.iridescenceThicknessMap
                  ? '#define USE_IRIDESCENCE_THICKNESSMAP'
                  : '',
              t.specularMap ? '#define USE_SPECULARMAP' : '',
              t.specularColorMap ? '#define USE_SPECULAR_COLORMAP' : '',
              t.specularIntensityMap ? '#define USE_SPECULAR_INTENSITYMAP' : '',
              t.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
              t.metalnessMap ? '#define USE_METALNESSMAP' : '',
              t.alphaMap ? '#define USE_ALPHAMAP' : '',
              t.alphaTest ? '#define USE_ALPHATEST' : '',
              t.alphaHash ? '#define USE_ALPHAHASH' : '',
              t.sheen ? '#define USE_SHEEN' : '',
              t.sheenColorMap ? '#define USE_SHEEN_COLORMAP' : '',
              t.sheenRoughnessMap ? '#define USE_SHEEN_ROUGHNESSMAP' : '',
              t.transmission ? '#define USE_TRANSMISSION' : '',
              t.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
              t.thicknessMap ? '#define USE_THICKNESSMAP' : '',
              t.vertexTangents && t.flatShading === !1
                  ? '#define USE_TANGENT'
                  : '',
              t.vertexColors || t.instancingColor || t.batchingColor
                  ? '#define USE_COLOR'
                  : '',
              t.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
              t.vertexUv1s ? '#define USE_UV1' : '',
              t.vertexUv2s ? '#define USE_UV2' : '',
              t.vertexUv3s ? '#define USE_UV3' : '',
              t.pointsUvs ? '#define USE_POINTS_UV' : '',
              t.gradientMap ? '#define USE_GRADIENTMAP' : '',
              t.flatShading ? '#define FLAT_SHADED' : '',
              t.doubleSided ? '#define DOUBLE_SIDED' : '',
              t.flipSided ? '#define FLIP_SIDED' : '',
              t.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
              t.shadowMapEnabled ? '#define ' + c : '',
              t.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',
              t.numLightProbes > 0 ? '#define USE_LIGHT_PROBES' : '',
              t.decodeVideoTexture ? '#define DECODE_VIDEO_TEXTURE' : '',
              t.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
              'uniform mat4 viewMatrix;',
              'uniform vec3 cameraPosition;',
              'uniform bool isOrthographic;',
              t.toneMapping !== Fo ? '#define TONE_MAPPING' : '',
              t.toneMapping !== Fo ? qt.tonemapping_pars_fragment : '',
              t.toneMapping !== Fo ? M4('toneMapping', t.toneMapping) : '',
              t.dithering ? '#define DITHERING' : '',
              t.opaque ? '#define OPAQUE' : '',
              qt.colorspace_pars_fragment,
              w4('linearToOutputTexel', t.outputColorSpace),
              t.useDepthPacking
                  ? '#define DEPTH_PACKING ' + t.depthPacking
                  : '',
              `
`,
          ].filter(Xd).join(`
`))),
        (a = x_(a)),
        (a = uE(a, t)),
        (a = cE(a, t)),
        (l = x_(l)),
        (l = uE(l, t)),
        (l = cE(l, t)),
        (a = fE(a)),
        (l = fE(l)),
        t.isRawShaderMaterial !== !0 &&
            ((b = `#version 300 es
`),
            (M =
                [
                    v,
                    '#define attribute in',
                    '#define varying out',
                    '#define texture2D texture',
                ].join(`
`) +
                `
` +
                M),
            (w =
                [
                    '#define varying in',
                    t.glslVersion === y_
                        ? ''
                        : 'layout(location = 0) out highp vec4 pc_fragColor;',
                    t.glslVersion === y_
                        ? ''
                        : '#define gl_FragColor pc_fragColor',
                    '#define gl_FragDepthEXT gl_FragDepth',
                    '#define texture2D texture',
                    '#define textureCube texture',
                    '#define texture2DProj textureProj',
                    '#define texture2DLodEXT textureLod',
                    '#define texture2DProjLodEXT textureProjLod',
                    '#define textureCubeLodEXT textureLod',
                    '#define texture2DGradEXT textureGrad',
                    '#define texture2DProjGradEXT textureProjGrad',
                    '#define textureCubeGradEXT textureGrad',
                ].join(`
`) +
                `
` +
                w));
    const C = b + M + a,
        L = b + w + l,
        F = aE(r, r.VERTEX_SHADER, C),
        N = aE(r, r.FRAGMENT_SHADER, L);
    r.attachShader(T, F),
        r.attachShader(T, N),
        t.index0AttributeName !== void 0
            ? r.bindAttribLocation(T, 0, t.index0AttributeName)
            : t.morphTargets === !0 && r.bindAttribLocation(T, 0, 'position'),
        r.linkProgram(T);
    function B(H) {
        if (i.debug.checkShaderErrors) {
            const ie = r.getProgramInfoLog(T).trim(),
                ee = r.getShaderInfoLog(F).trim(),
                ue = r.getShaderInfoLog(N).trim();
            let Se = !0,
                ce = !0;
            if (r.getProgramParameter(T, r.LINK_STATUS) === !1)
                if (((Se = !1), typeof i.debug.onShaderError == 'function'))
                    i.debug.onShaderError(r, T, F, N);
                else {
                    const me = lE(r, F, 'vertex'),
                        X = lE(r, N, 'fragment');
                    console.error(
                        'THREE.WebGLProgram: Shader Error ' +
                            r.getError() +
                            ' - VALIDATE_STATUS ' +
                            r.getProgramParameter(T, r.VALIDATE_STATUS) +
                            `

Material Name: ` +
                            H.name +
                            `
Material Type: ` +
                            H.type +
                            `

Program Info Log: ` +
                            ie +
                            `
` +
                            me +
                            `
` +
                            X
                    );
                }
            else
                ie !== ''
                    ? console.warn('THREE.WebGLProgram: Program Info Log:', ie)
                    : (ee === '' || ue === '') && (ce = !1);
            ce &&
                (H.diagnostics = {
                    runnable: Se,
                    programLog: ie,
                    vertexShader: { log: ee, prefix: M },
                    fragmentShader: { log: ue, prefix: w },
                });
        }
        r.deleteShader(F),
            r.deleteShader(N),
            (z = new ay(r, T)),
            (U = A4(r, T));
    }
    let z;
    this.getUniforms = function () {
        return z === void 0 && B(this), z;
    };
    let U;
    this.getAttributes = function () {
        return U === void 0 && B(this), U;
    };
    let D = t.rendererExtensionParallelShaderCompile === !1;
    return (
        (this.isReady = function () {
            return D === !1 && (D = r.getProgramParameter(T, v4)), D;
        }),
        (this.destroy = function () {
            n.releaseStatesOfProgram(this),
                r.deleteProgram(T),
                (this.program = void 0);
        }),
        (this.type = t.shaderType),
        (this.name = t.shaderName),
        (this.id = x4++),
        (this.cacheKey = e),
        (this.usedTimes = 1),
        (this.program = T),
        (this.vertexShader = F),
        (this.fragmentShader = N),
        this
    );
}
let F4 = 0;
class B4 {
    constructor() {
        (this.shaderCache = new Map()), (this.materialCache = new Map());
    }
    update(e) {
        const t = e.vertexShader,
            n = e.fragmentShader,
            r = this._getShaderStage(t),
            s = this._getShaderStage(n),
            a = this._getShaderCacheForMaterial(e);
        return (
            a.has(r) === !1 && (a.add(r), r.usedTimes++),
            a.has(s) === !1 && (a.add(s), s.usedTimes++),
            this
        );
    }
    remove(e) {
        const t = this.materialCache.get(e);
        for (const n of t)
            n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n.code);
        return this.materialCache.delete(e), this;
    }
    getVertexShaderID(e) {
        return this._getShaderStage(e.vertexShader).id;
    }
    getFragmentShaderID(e) {
        return this._getShaderStage(e.fragmentShader).id;
    }
    dispose() {
        this.shaderCache.clear(), this.materialCache.clear();
    }
    _getShaderCacheForMaterial(e) {
        const t = this.materialCache;
        let n = t.get(e);
        return n === void 0 && ((n = new Set()), t.set(e, n)), n;
    }
    _getShaderStage(e) {
        const t = this.shaderCache;
        let n = t.get(e);
        return n === void 0 && ((n = new z4(e)), t.set(e, n)), n;
    }
}
class z4 {
    constructor(e) {
        (this.id = F4++), (this.code = e), (this.usedTimes = 0);
    }
}
function V4(i, e, t, n, r, s, a) {
    const l = new sc(),
        c = new B4(),
        d = new Set(),
        p = [],
        g = r.logarithmicDepthBuffer,
        y = r.vertexTextures;
    let v = r.precision;
    const S = {
        MeshDepthMaterial: 'depth',
        MeshDistanceMaterial: 'distanceRGBA',
        MeshNormalMaterial: 'normal',
        MeshBasicMaterial: 'basic',
        MeshLambertMaterial: 'lambert',
        MeshPhongMaterial: 'phong',
        MeshToonMaterial: 'toon',
        MeshStandardMaterial: 'physical',
        MeshPhysicalMaterial: 'physical',
        MeshMatcapMaterial: 'matcap',
        LineBasicMaterial: 'basic',
        LineDashedMaterial: 'dashed',
        PointsMaterial: 'points',
        ShadowMaterial: 'shadow',
        SpriteMaterial: 'sprite',
    };
    function T(U) {
        return d.add(U), U === 0 ? 'uv' : `uv${U}`;
    }
    function M(U, D, H, ie, ee) {
        const ue = ie.fog,
            Se = ee.geometry,
            ce = U.isMeshStandardMaterial ? ie.environment : null,
            me = (U.isMeshStandardMaterial ? t : e).get(U.envMap || ce),
            X = me && me.mapping === wh ? me.image.height : null,
            oe = S[U.type];
        U.precision !== null &&
            ((v = r.getMaxPrecision(U.precision)),
            v !== U.precision &&
                console.warn(
                    'THREE.WebGLProgram.getParameters:',
                    U.precision,
                    'not supported, using',
                    v,
                    'instead.'
                ));
        const Q =
                Se.morphAttributes.position ||
                Se.morphAttributes.normal ||
                Se.morphAttributes.color,
            G = Q !== void 0 ? Q.length : 0;
        let ae = 0;
        Se.morphAttributes.position !== void 0 && (ae = 1),
            Se.morphAttributes.normal !== void 0 && (ae = 2),
            Se.morphAttributes.color !== void 0 && (ae = 3);
        let Oe, fe, we, Pe;
        if (oe) {
            const en = ro[oe];
            (Oe = en.vertexShader), (fe = en.fragmentShader);
        } else
            (Oe = U.vertexShader),
                (fe = U.fragmentShader),
                c.update(U),
                (we = c.getVertexShaderID(U)),
                (Pe = c.getFragmentShaderID(U));
        const Re = i.getRenderTarget(),
            Ye = ee.isInstancedMesh === !0,
            lt = ee.isBatchedMesh === !0,
            dt = !!U.map,
            Lt = !!U.matcap,
            W = !!me,
            Ie = !!U.aoMap,
            ke = !!U.lightMap,
            Ke = !!U.bumpMap,
            Ee = !!U.normalMap,
            St = !!U.displacementMap,
            Ze = !!U.emissiveMap,
            ot = !!U.metalnessMap,
            $ = !!U.roughnessMap,
            k = U.anisotropy > 0,
            ge = U.clearcoat > 0,
            De = U.dispersion > 0,
            be = U.iridescence > 0,
            Le = U.sheen > 0,
            _t = U.transmission > 0,
            $e = k && !!U.anisotropyMap,
            tt = ge && !!U.clearcoatMap,
            Nt = ge && !!U.clearcoatNormalMap,
            Be = ge && !!U.clearcoatRoughnessMap,
            Je = be && !!U.iridescenceMap,
            Kt = be && !!U.iridescenceThicknessMap,
            bt = Le && !!U.sheenColorMap,
            ut = Le && !!U.sheenRoughnessMap,
            Ut = !!U.specularMap,
            zt = !!U.specularColorMap,
            dn = !!U.specularIntensityMap,
            ne = _t && !!U.transmissionMap,
            Ve = _t && !!U.thicknessMap,
            Te = !!U.gradientMap,
            Ae = !!U.alphaMap,
            Ge = U.alphaTest > 0,
            At = !!U.alphaHash,
            Yt = !!U.extensions;
        let Cn = Fo;
        U.toneMapped &&
            (Re === null || Re.isXRRenderTarget === !0) &&
            (Cn = i.toneMapping);
        const jn = {
            shaderID: oe,
            shaderType: U.type,
            shaderName: U.name,
            vertexShader: Oe,
            fragmentShader: fe,
            defines: U.defines,
            customVertexShaderID: we,
            customFragmentShaderID: Pe,
            isRawShaderMaterial: U.isRawShaderMaterial === !0,
            glslVersion: U.glslVersion,
            precision: v,
            batching: lt,
            batchingColor: lt && ee._colorsTexture !== null,
            instancing: Ye,
            instancingColor: Ye && ee.instanceColor !== null,
            instancingMorph: Ye && ee.morphTexture !== null,
            supportsVertexTextures: y,
            outputColorSpace:
                Re === null
                    ? i.outputColorSpace
                    : Re.isXRRenderTarget === !0
                      ? Re.texture.colorSpace
                      : Fa,
            alphaToCoverage: !!U.alphaToCoverage,
            map: dt,
            matcap: Lt,
            envMap: W,
            envMapMode: W && me.mapping,
            envMapCubeUVHeight: X,
            aoMap: Ie,
            lightMap: ke,
            bumpMap: Ke,
            normalMap: Ee,
            displacementMap: y && St,
            emissiveMap: Ze,
            normalMapObjectSpace: Ee && U.normalMapType === UR,
            normalMapTangentSpace: Ee && U.normalMapType === Bl,
            metalnessMap: ot,
            roughnessMap: $,
            anisotropy: k,
            anisotropyMap: $e,
            clearcoat: ge,
            clearcoatMap: tt,
            clearcoatNormalMap: Nt,
            clearcoatRoughnessMap: Be,
            dispersion: De,
            iridescence: be,
            iridescenceMap: Je,
            iridescenceThicknessMap: Kt,
            sheen: Le,
            sheenColorMap: bt,
            sheenRoughnessMap: ut,
            specularMap: Ut,
            specularColorMap: zt,
            specularIntensityMap: dn,
            transmission: _t,
            transmissionMap: ne,
            thicknessMap: Ve,
            gradientMap: Te,
            opaque:
                U.transparent === !1 &&
                U.blending === nc &&
                U.alphaToCoverage === !1,
            alphaMap: Ae,
            alphaTest: Ge,
            alphaHash: At,
            combine: U.combine,
            mapUv: dt && T(U.map.channel),
            aoMapUv: Ie && T(U.aoMap.channel),
            lightMapUv: ke && T(U.lightMap.channel),
            bumpMapUv: Ke && T(U.bumpMap.channel),
            normalMapUv: Ee && T(U.normalMap.channel),
            displacementMapUv: St && T(U.displacementMap.channel),
            emissiveMapUv: Ze && T(U.emissiveMap.channel),
            metalnessMapUv: ot && T(U.metalnessMap.channel),
            roughnessMapUv: $ && T(U.roughnessMap.channel),
            anisotropyMapUv: $e && T(U.anisotropyMap.channel),
            clearcoatMapUv: tt && T(U.clearcoatMap.channel),
            clearcoatNormalMapUv: Nt && T(U.clearcoatNormalMap.channel),
            clearcoatRoughnessMapUv: Be && T(U.clearcoatRoughnessMap.channel),
            iridescenceMapUv: Je && T(U.iridescenceMap.channel),
            iridescenceThicknessMapUv:
                Kt && T(U.iridescenceThicknessMap.channel),
            sheenColorMapUv: bt && T(U.sheenColorMap.channel),
            sheenRoughnessMapUv: ut && T(U.sheenRoughnessMap.channel),
            specularMapUv: Ut && T(U.specularMap.channel),
            specularColorMapUv: zt && T(U.specularColorMap.channel),
            specularIntensityMapUv: dn && T(U.specularIntensityMap.channel),
            transmissionMapUv: ne && T(U.transmissionMap.channel),
            thicknessMapUv: Ve && T(U.thicknessMap.channel),
            alphaMapUv: Ae && T(U.alphaMap.channel),
            vertexTangents: !!Se.attributes.tangent && (Ee || k),
            vertexColors: U.vertexColors,
            vertexAlphas:
                U.vertexColors === !0 &&
                !!Se.attributes.color &&
                Se.attributes.color.itemSize === 4,
            pointsUvs: ee.isPoints === !0 && !!Se.attributes.uv && (dt || Ae),
            fog: !!ue,
            useFog: U.fog === !0,
            fogExp2: !!ue && ue.isFogExp2,
            flatShading: U.flatShading === !0,
            sizeAttenuation: U.sizeAttenuation === !0,
            logarithmicDepthBuffer: g,
            skinning: ee.isSkinnedMesh === !0,
            morphTargets: Se.morphAttributes.position !== void 0,
            morphNormals: Se.morphAttributes.normal !== void 0,
            morphColors: Se.morphAttributes.color !== void 0,
            morphTargetsCount: G,
            morphTextureStride: ae,
            numDirLights: D.directional.length,
            numPointLights: D.point.length,
            numSpotLights: D.spot.length,
            numSpotLightMaps: D.spotLightMap.length,
            numRectAreaLights: D.rectArea.length,
            numHemiLights: D.hemi.length,
            numDirLightShadows: D.directionalShadowMap.length,
            numPointLightShadows: D.pointShadowMap.length,
            numSpotLightShadows: D.spotShadowMap.length,
            numSpotLightShadowsWithMaps: D.numSpotLightShadowsWithMaps,
            numLightProbes: D.numLightProbes,
            numClippingPlanes: a.numPlanes,
            numClipIntersection: a.numIntersection,
            dithering: U.dithering,
            shadowMapEnabled: i.shadowMap.enabled && H.length > 0,
            shadowMapType: i.shadowMap.type,
            toneMapping: Cn,
            decodeVideoTexture:
                dt &&
                U.map.isVideoTexture === !0 &&
                hn.getTransfer(U.map.colorSpace) === Pn,
            premultipliedAlpha: U.premultipliedAlpha,
            doubleSided: U.side === Lo,
            flipSided: U.side === Er,
            useDepthPacking: U.depthPacking >= 0,
            depthPacking: U.depthPacking || 0,
            index0AttributeName: U.index0AttributeName,
            extensionClipCullDistance:
                Yt &&
                U.extensions.clipCullDistance === !0 &&
                n.has('WEBGL_clip_cull_distance'),
            extensionMultiDraw:
                ((Yt && U.extensions.multiDraw === !0) || lt) &&
                n.has('WEBGL_multi_draw'),
            rendererExtensionParallelShaderCompile: n.has(
                'KHR_parallel_shader_compile'
            ),
            customProgramCacheKey: U.customProgramCacheKey(),
        };
        return (
            (jn.vertexUv1s = d.has(1)),
            (jn.vertexUv2s = d.has(2)),
            (jn.vertexUv3s = d.has(3)),
            d.clear(),
            jn
        );
    }
    function w(U) {
        const D = [];
        if (
            (U.shaderID
                ? D.push(U.shaderID)
                : (D.push(U.customVertexShaderID),
                  D.push(U.customFragmentShaderID)),
            U.defines !== void 0)
        )
            for (const H in U.defines) D.push(H), D.push(U.defines[H]);
        return (
            U.isRawShaderMaterial === !1 &&
                (b(D, U), C(D, U), D.push(i.outputColorSpace)),
            D.push(U.customProgramCacheKey),
            D.join()
        );
    }
    function b(U, D) {
        U.push(D.precision),
            U.push(D.outputColorSpace),
            U.push(D.envMapMode),
            U.push(D.envMapCubeUVHeight),
            U.push(D.mapUv),
            U.push(D.alphaMapUv),
            U.push(D.lightMapUv),
            U.push(D.aoMapUv),
            U.push(D.bumpMapUv),
            U.push(D.normalMapUv),
            U.push(D.displacementMapUv),
            U.push(D.emissiveMapUv),
            U.push(D.metalnessMapUv),
            U.push(D.roughnessMapUv),
            U.push(D.anisotropyMapUv),
            U.push(D.clearcoatMapUv),
            U.push(D.clearcoatNormalMapUv),
            U.push(D.clearcoatRoughnessMapUv),
            U.push(D.iridescenceMapUv),
            U.push(D.iridescenceThicknessMapUv),
            U.push(D.sheenColorMapUv),
            U.push(D.sheenRoughnessMapUv),
            U.push(D.specularMapUv),
            U.push(D.specularColorMapUv),
            U.push(D.specularIntensityMapUv),
            U.push(D.transmissionMapUv),
            U.push(D.thicknessMapUv),
            U.push(D.combine),
            U.push(D.fogExp2),
            U.push(D.sizeAttenuation),
            U.push(D.morphTargetsCount),
            U.push(D.morphAttributeCount),
            U.push(D.numDirLights),
            U.push(D.numPointLights),
            U.push(D.numSpotLights),
            U.push(D.numSpotLightMaps),
            U.push(D.numHemiLights),
            U.push(D.numRectAreaLights),
            U.push(D.numDirLightShadows),
            U.push(D.numPointLightShadows),
            U.push(D.numSpotLightShadows),
            U.push(D.numSpotLightShadowsWithMaps),
            U.push(D.numLightProbes),
            U.push(D.shadowMapType),
            U.push(D.toneMapping),
            U.push(D.numClippingPlanes),
            U.push(D.numClipIntersection),
            U.push(D.depthPacking);
    }
    function C(U, D) {
        l.disableAll(),
            D.supportsVertexTextures && l.enable(0),
            D.instancing && l.enable(1),
            D.instancingColor && l.enable(2),
            D.instancingMorph && l.enable(3),
            D.matcap && l.enable(4),
            D.envMap && l.enable(5),
            D.normalMapObjectSpace && l.enable(6),
            D.normalMapTangentSpace && l.enable(7),
            D.clearcoat && l.enable(8),
            D.iridescence && l.enable(9),
            D.alphaTest && l.enable(10),
            D.vertexColors && l.enable(11),
            D.vertexAlphas && l.enable(12),
            D.vertexUv1s && l.enable(13),
            D.vertexUv2s && l.enable(14),
            D.vertexUv3s && l.enable(15),
            D.vertexTangents && l.enable(16),
            D.anisotropy && l.enable(17),
            D.alphaHash && l.enable(18),
            D.batching && l.enable(19),
            D.dispersion && l.enable(20),
            D.batchingColor && l.enable(21),
            U.push(l.mask),
            l.disableAll(),
            D.fog && l.enable(0),
            D.useFog && l.enable(1),
            D.flatShading && l.enable(2),
            D.logarithmicDepthBuffer && l.enable(3),
            D.skinning && l.enable(4),
            D.morphTargets && l.enable(5),
            D.morphNormals && l.enable(6),
            D.morphColors && l.enable(7),
            D.premultipliedAlpha && l.enable(8),
            D.shadowMapEnabled && l.enable(9),
            D.doubleSided && l.enable(10),
            D.flipSided && l.enable(11),
            D.useDepthPacking && l.enable(12),
            D.dithering && l.enable(13),
            D.transmission && l.enable(14),
            D.sheen && l.enable(15),
            D.opaque && l.enable(16),
            D.pointsUvs && l.enable(17),
            D.decodeVideoTexture && l.enable(18),
            D.alphaToCoverage && l.enable(19),
            U.push(l.mask);
    }
    function L(U) {
        const D = S[U.type];
        let H;
        if (D) {
            const ie = ro[D];
            H = WS.clone(ie.uniforms);
        } else H = U.uniforms;
        return H;
    }
    function F(U, D) {
        let H;
        for (let ie = 0, ee = p.length; ie < ee; ie++) {
            const ue = p[ie];
            if (ue.cacheKey === D) {
                (H = ue), ++H.usedTimes;
                break;
            }
        }
        return H === void 0 && ((H = new k4(i, D, U, s)), p.push(H)), H;
    }
    function N(U) {
        if (--U.usedTimes === 0) {
            const D = p.indexOf(U);
            (p[D] = p[p.length - 1]), p.pop(), U.destroy();
        }
    }
    function B(U) {
        c.remove(U);
    }
    function z() {
        c.dispose();
    }
    return {
        getParameters: M,
        getProgramCacheKey: w,
        getUniforms: L,
        acquireProgram: F,
        releaseProgram: N,
        releaseShaderCache: B,
        programs: p,
        dispose: z,
    };
}
function H4() {
    let i = new WeakMap();
    function e(s) {
        let a = i.get(s);
        return a === void 0 && ((a = {}), i.set(s, a)), a;
    }
    function t(s) {
        i.delete(s);
    }
    function n(s, a, l) {
        i.get(s)[a] = l;
    }
    function r() {
        i = new WeakMap();
    }
    return { get: e, remove: t, update: n, dispose: r };
}
function G4(i, e) {
    return i.groupOrder !== e.groupOrder
        ? i.groupOrder - e.groupOrder
        : i.renderOrder !== e.renderOrder
          ? i.renderOrder - e.renderOrder
          : i.material.id !== e.material.id
            ? i.material.id - e.material.id
            : i.z !== e.z
              ? i.z - e.z
              : i.id - e.id;
}
function dE(i, e) {
    return i.groupOrder !== e.groupOrder
        ? i.groupOrder - e.groupOrder
        : i.renderOrder !== e.renderOrder
          ? i.renderOrder - e.renderOrder
          : i.z !== e.z
            ? e.z - i.z
            : i.id - e.id;
}
function pE() {
    const i = [];
    let e = 0;
    const t = [],
        n = [],
        r = [];
    function s() {
        (e = 0), (t.length = 0), (n.length = 0), (r.length = 0);
    }
    function a(g, y, v, S, T, M) {
        let w = i[e];
        return (
            w === void 0
                ? ((w = {
                      id: g.id,
                      object: g,
                      geometry: y,
                      material: v,
                      groupOrder: S,
                      renderOrder: g.renderOrder,
                      z: T,
                      group: M,
                  }),
                  (i[e] = w))
                : ((w.id = g.id),
                  (w.object = g),
                  (w.geometry = y),
                  (w.material = v),
                  (w.groupOrder = S),
                  (w.renderOrder = g.renderOrder),
                  (w.z = T),
                  (w.group = M)),
            e++,
            w
        );
    }
    function l(g, y, v, S, T, M) {
        const w = a(g, y, v, S, T, M);
        v.transmission > 0
            ? n.push(w)
            : v.transparent === !0
              ? r.push(w)
              : t.push(w);
    }
    function c(g, y, v, S, T, M) {
        const w = a(g, y, v, S, T, M);
        v.transmission > 0
            ? n.unshift(w)
            : v.transparent === !0
              ? r.unshift(w)
              : t.unshift(w);
    }
    function d(g, y) {
        t.length > 1 && t.sort(g || G4),
            n.length > 1 && n.sort(y || dE),
            r.length > 1 && r.sort(y || dE);
    }
    function p() {
        for (let g = e, y = i.length; g < y; g++) {
            const v = i[g];
            if (v.id === null) break;
            (v.id = null),
                (v.object = null),
                (v.geometry = null),
                (v.material = null),
                (v.group = null);
        }
    }
    return {
        opaque: t,
        transmissive: n,
        transparent: r,
        init: s,
        push: l,
        unshift: c,
        finish: p,
        sort: d,
    };
}
function W4() {
    let i = new WeakMap();
    function e(n, r) {
        const s = i.get(n);
        let a;
        return (
            s === void 0
                ? ((a = new pE()), i.set(n, [a]))
                : r >= s.length
                  ? ((a = new pE()), s.push(a))
                  : (a = s[r]),
            a
        );
    }
    function t() {
        i = new WeakMap();
    }
    return { get: e, dispose: t };
}
function X4() {
    const i = {};
    return {
        get: function (e) {
            if (i[e.id] !== void 0) return i[e.id];
            let t;
            switch (e.type) {
                case 'DirectionalLight':
                    t = { direction: new j(), color: new st() };
                    break;
                case 'SpotLight':
                    t = {
                        position: new j(),
                        direction: new j(),
                        color: new st(),
                        distance: 0,
                        coneCos: 0,
                        penumbraCos: 0,
                        decay: 0,
                    };
                    break;
                case 'PointLight':
                    t = {
                        position: new j(),
                        color: new st(),
                        distance: 0,
                        decay: 0,
                    };
                    break;
                case 'HemisphereLight':
                    t = {
                        direction: new j(),
                        skyColor: new st(),
                        groundColor: new st(),
                    };
                    break;
                case 'RectAreaLight':
                    t = {
                        color: new st(),
                        position: new j(),
                        halfWidth: new j(),
                        halfHeight: new j(),
                    };
                    break;
            }
            return (i[e.id] = t), t;
        },
    };
}
function j4() {
    const i = {};
    return {
        get: function (e) {
            if (i[e.id] !== void 0) return i[e.id];
            let t;
            switch (e.type) {
                case 'DirectionalLight':
                    t = {
                        shadowIntensity: 1,
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Ce(),
                    };
                    break;
                case 'SpotLight':
                    t = {
                        shadowIntensity: 1,
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Ce(),
                    };
                    break;
                case 'PointLight':
                    t = {
                        shadowIntensity: 1,
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Ce(),
                        shadowCameraNear: 1,
                        shadowCameraFar: 1e3,
                    };
                    break;
            }
            return (i[e.id] = t), t;
        },
    };
}
let q4 = 0;
function $4(i, e) {
    return (
        (e.castShadow ? 2 : 0) -
        (i.castShadow ? 2 : 0) +
        (e.map ? 1 : 0) -
        (i.map ? 1 : 0)
    );
}
function Y4(i) {
    const e = new X4(),
        t = j4(),
        n = {
            version: 0,
            hash: {
                directionalLength: -1,
                pointLength: -1,
                spotLength: -1,
                rectAreaLength: -1,
                hemiLength: -1,
                numDirectionalShadows: -1,
                numPointShadows: -1,
                numSpotShadows: -1,
                numSpotMaps: -1,
                numLightProbes: -1,
            },
            ambient: [0, 0, 0],
            probe: [],
            directional: [],
            directionalShadow: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotLightMap: [],
            spotShadow: [],
            spotShadowMap: [],
            spotLightMatrix: [],
            rectArea: [],
            rectAreaLTC1: null,
            rectAreaLTC2: null,
            point: [],
            pointShadow: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: [],
            numSpotLightShadowsWithMaps: 0,
            numLightProbes: 0,
        };
    for (let d = 0; d < 9; d++) n.probe.push(new j());
    const r = new j(),
        s = new Pt(),
        a = new Pt();
    function l(d) {
        let p = 0,
            g = 0,
            y = 0;
        for (let U = 0; U < 9; U++) n.probe[U].set(0, 0, 0);
        let v = 0,
            S = 0,
            T = 0,
            M = 0,
            w = 0,
            b = 0,
            C = 0,
            L = 0,
            F = 0,
            N = 0,
            B = 0;
        d.sort($4);
        for (let U = 0, D = d.length; U < D; U++) {
            const H = d[U],
                ie = H.color,
                ee = H.intensity,
                ue = H.distance,
                Se = H.shadow && H.shadow.map ? H.shadow.map.texture : null;
            if (H.isAmbientLight)
                (p += ie.r * ee), (g += ie.g * ee), (y += ie.b * ee);
            else if (H.isLightProbe) {
                for (let ce = 0; ce < 9; ce++)
                    n.probe[ce].addScaledVector(H.sh.coefficients[ce], ee);
                B++;
            } else if (H.isDirectionalLight) {
                const ce = e.get(H);
                if (
                    (ce.color.copy(H.color).multiplyScalar(H.intensity),
                    H.castShadow)
                ) {
                    const me = H.shadow,
                        X = t.get(H);
                    (X.shadowIntensity = me.intensity),
                        (X.shadowBias = me.bias),
                        (X.shadowNormalBias = me.normalBias),
                        (X.shadowRadius = me.radius),
                        (X.shadowMapSize = me.mapSize),
                        (n.directionalShadow[v] = X),
                        (n.directionalShadowMap[v] = Se),
                        (n.directionalShadowMatrix[v] = H.shadow.matrix),
                        b++;
                }
                (n.directional[v] = ce), v++;
            } else if (H.isSpotLight) {
                const ce = e.get(H);
                ce.position.setFromMatrixPosition(H.matrixWorld),
                    ce.color.copy(ie).multiplyScalar(ee),
                    (ce.distance = ue),
                    (ce.coneCos = Math.cos(H.angle)),
                    (ce.penumbraCos = Math.cos(H.angle * (1 - H.penumbra))),
                    (ce.decay = H.decay),
                    (n.spot[T] = ce);
                const me = H.shadow;
                if (
                    (H.map &&
                        ((n.spotLightMap[F] = H.map),
                        F++,
                        me.updateMatrices(H),
                        H.castShadow && N++),
                    (n.spotLightMatrix[T] = me.matrix),
                    H.castShadow)
                ) {
                    const X = t.get(H);
                    (X.shadowIntensity = me.intensity),
                        (X.shadowBias = me.bias),
                        (X.shadowNormalBias = me.normalBias),
                        (X.shadowRadius = me.radius),
                        (X.shadowMapSize = me.mapSize),
                        (n.spotShadow[T] = X),
                        (n.spotShadowMap[T] = Se),
                        L++;
                }
                T++;
            } else if (H.isRectAreaLight) {
                const ce = e.get(H);
                ce.color.copy(ie).multiplyScalar(ee),
                    ce.halfWidth.set(H.width * 0.5, 0, 0),
                    ce.halfHeight.set(0, H.height * 0.5, 0),
                    (n.rectArea[M] = ce),
                    M++;
            } else if (H.isPointLight) {
                const ce = e.get(H);
                if (
                    (ce.color.copy(H.color).multiplyScalar(H.intensity),
                    (ce.distance = H.distance),
                    (ce.decay = H.decay),
                    H.castShadow)
                ) {
                    const me = H.shadow,
                        X = t.get(H);
                    (X.shadowIntensity = me.intensity),
                        (X.shadowBias = me.bias),
                        (X.shadowNormalBias = me.normalBias),
                        (X.shadowRadius = me.radius),
                        (X.shadowMapSize = me.mapSize),
                        (X.shadowCameraNear = me.camera.near),
                        (X.shadowCameraFar = me.camera.far),
                        (n.pointShadow[S] = X),
                        (n.pointShadowMap[S] = Se),
                        (n.pointShadowMatrix[S] = H.shadow.matrix),
                        C++;
                }
                (n.point[S] = ce), S++;
            } else if (H.isHemisphereLight) {
                const ce = e.get(H);
                ce.skyColor.copy(H.color).multiplyScalar(ee),
                    ce.groundColor.copy(H.groundColor).multiplyScalar(ee),
                    (n.hemi[w] = ce),
                    w++;
            }
        }
        M > 0 &&
            (i.has('OES_texture_float_linear') === !0
                ? ((n.rectAreaLTC1 = et.LTC_FLOAT_1),
                  (n.rectAreaLTC2 = et.LTC_FLOAT_2))
                : ((n.rectAreaLTC1 = et.LTC_HALF_1),
                  (n.rectAreaLTC2 = et.LTC_HALF_2))),
            (n.ambient[0] = p),
            (n.ambient[1] = g),
            (n.ambient[2] = y);
        const z = n.hash;
        (z.directionalLength !== v ||
            z.pointLength !== S ||
            z.spotLength !== T ||
            z.rectAreaLength !== M ||
            z.hemiLength !== w ||
            z.numDirectionalShadows !== b ||
            z.numPointShadows !== C ||
            z.numSpotShadows !== L ||
            z.numSpotMaps !== F ||
            z.numLightProbes !== B) &&
            ((n.directional.length = v),
            (n.spot.length = T),
            (n.rectArea.length = M),
            (n.point.length = S),
            (n.hemi.length = w),
            (n.directionalShadow.length = b),
            (n.directionalShadowMap.length = b),
            (n.pointShadow.length = C),
            (n.pointShadowMap.length = C),
            (n.spotShadow.length = L),
            (n.spotShadowMap.length = L),
            (n.directionalShadowMatrix.length = b),
            (n.pointShadowMatrix.length = C),
            (n.spotLightMatrix.length = L + F - N),
            (n.spotLightMap.length = F),
            (n.numSpotLightShadowsWithMaps = N),
            (n.numLightProbes = B),
            (z.directionalLength = v),
            (z.pointLength = S),
            (z.spotLength = T),
            (z.rectAreaLength = M),
            (z.hemiLength = w),
            (z.numDirectionalShadows = b),
            (z.numPointShadows = C),
            (z.numSpotShadows = L),
            (z.numSpotMaps = F),
            (z.numLightProbes = B),
            (n.version = q4++));
    }
    function c(d, p) {
        let g = 0,
            y = 0,
            v = 0,
            S = 0,
            T = 0;
        const M = p.matrixWorldInverse;
        for (let w = 0, b = d.length; w < b; w++) {
            const C = d[w];
            if (C.isDirectionalLight) {
                const L = n.directional[g];
                L.direction.setFromMatrixPosition(C.matrixWorld),
                    r.setFromMatrixPosition(C.target.matrixWorld),
                    L.direction.sub(r),
                    L.direction.transformDirection(M),
                    g++;
            } else if (C.isSpotLight) {
                const L = n.spot[v];
                L.position.setFromMatrixPosition(C.matrixWorld),
                    L.position.applyMatrix4(M),
                    L.direction.setFromMatrixPosition(C.matrixWorld),
                    r.setFromMatrixPosition(C.target.matrixWorld),
                    L.direction.sub(r),
                    L.direction.transformDirection(M),
                    v++;
            } else if (C.isRectAreaLight) {
                const L = n.rectArea[S];
                L.position.setFromMatrixPosition(C.matrixWorld),
                    L.position.applyMatrix4(M),
                    a.identity(),
                    s.copy(C.matrixWorld),
                    s.premultiply(M),
                    a.extractRotation(s),
                    L.halfWidth.set(C.width * 0.5, 0, 0),
                    L.halfHeight.set(0, C.height * 0.5, 0),
                    L.halfWidth.applyMatrix4(a),
                    L.halfHeight.applyMatrix4(a),
                    S++;
            } else if (C.isPointLight) {
                const L = n.point[y];
                L.position.setFromMatrixPosition(C.matrixWorld),
                    L.position.applyMatrix4(M),
                    y++;
            } else if (C.isHemisphereLight) {
                const L = n.hemi[T];
                L.direction.setFromMatrixPosition(C.matrixWorld),
                    L.direction.transformDirection(M),
                    T++;
            }
        }
    }
    return { setup: l, setupView: c, state: n };
}
function mE(i) {
    const e = new Y4(i),
        t = [],
        n = [];
    function r(p) {
        (d.camera = p), (t.length = 0), (n.length = 0);
    }
    function s(p) {
        t.push(p);
    }
    function a(p) {
        n.push(p);
    }
    function l() {
        e.setup(t);
    }
    function c(p) {
        e.setupView(t, p);
    }
    const d = {
        lightsArray: t,
        shadowsArray: n,
        camera: null,
        lights: e,
        transmissionRenderTarget: {},
    };
    return {
        init: r,
        state: d,
        setupLights: l,
        setupLightsView: c,
        pushLight: s,
        pushShadow: a,
    };
}
function K4(i) {
    let e = new WeakMap();
    function t(r, s = 0) {
        const a = e.get(r);
        let l;
        return (
            a === void 0
                ? ((l = new mE(i)), e.set(r, [l]))
                : s >= a.length
                  ? ((l = new mE(i)), a.push(l))
                  : (l = a[s]),
            l
        );
    }
    function n() {
        e = new WeakMap();
    }
    return { get: t, dispose: n };
}
class qS extends lr {
    constructor(e) {
        super(),
            (this.isMeshDepthMaterial = !0),
            (this.type = 'MeshDepthMaterial'),
            (this.depthPacking = DR),
            (this.map = null),
            (this.alphaMap = null),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            this.setValues(e);
    }
    copy(e) {
        return (
            super.copy(e),
            (this.depthPacking = e.depthPacking),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            this
        );
    }
}
class $S extends lr {
    constructor(e) {
        super(),
            (this.isMeshDistanceMaterial = !0),
            (this.type = 'MeshDistanceMaterial'),
            (this.map = null),
            (this.alphaMap = null),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            this.setValues(e);
    }
    copy(e) {
        return (
            super.copy(e),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            this
        );
    }
}
const Z4 = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
    J4 = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function Q4(i, e, t) {
    let n = new Jp();
    const r = new Ce(),
        s = new Ce(),
        a = new gn(),
        l = new qS({ depthPacking: NR }),
        c = new $S(),
        d = {},
        p = t.maxTextureSize,
        g = { [Na]: Er, [Er]: Na, [Lo]: Lo },
        y = new Ts({
            defines: { VSM_SAMPLES: 8 },
            uniforms: {
                shadow_pass: { value: null },
                resolution: { value: new Ce() },
                radius: { value: 4 },
            },
            vertexShader: Z4,
            fragmentShader: J4,
        }),
        v = y.clone();
    v.defines.HORIZONTAL_PASS = 1;
    const S = new $t();
    S.setAttribute(
        'position',
        new Mn(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
    );
    const T = new di(S, y),
        M = this;
    (this.enabled = !1),
        (this.autoUpdate = !0),
        (this.needsUpdate = !1),
        (this.type = av);
    let w = this.type;
    this.render = function (N, B, z) {
        if (
            M.enabled === !1 ||
            (M.autoUpdate === !1 && M.needsUpdate === !1) ||
            N.length === 0
        )
            return;
        const U = i.getRenderTarget(),
            D = i.getActiveCubeFace(),
            H = i.getActiveMipmapLevel(),
            ie = i.state;
        ie.setBlending(Pa),
            ie.buffers.color.setClear(1, 1, 1, 1),
            ie.buffers.depth.setTest(!0),
            ie.setScissorTest(!1);
        const ee = w !== io && this.type === io,
            ue = w === io && this.type !== io;
        for (let Se = 0, ce = N.length; Se < ce; Se++) {
            const me = N[Se],
                X = me.shadow;
            if (X === void 0) {
                console.warn('THREE.WebGLShadowMap:', me, 'has no shadow.');
                continue;
            }
            if (X.autoUpdate === !1 && X.needsUpdate === !1) continue;
            r.copy(X.mapSize);
            const oe = X.getFrameExtents();
            if (
                (r.multiply(oe),
                s.copy(X.mapSize),
                (r.x > p || r.y > p) &&
                    (r.x > p &&
                        ((s.x = Math.floor(p / oe.x)),
                        (r.x = s.x * oe.x),
                        (X.mapSize.x = s.x)),
                    r.y > p &&
                        ((s.y = Math.floor(p / oe.y)),
                        (r.y = s.y * oe.y),
                        (X.mapSize.y = s.y))),
                X.map === null || ee === !0 || ue === !0)
            ) {
                const G =
                    this.type !== io ? { minFilter: Li, magFilter: Li } : {};
                X.map !== null && X.map.dispose(),
                    (X.map = new lo(r.x, r.y, G)),
                    (X.map.texture.name = me.name + '.shadowMap'),
                    X.camera.updateProjectionMatrix();
            }
            i.setRenderTarget(X.map), i.clear();
            const Q = X.getViewportCount();
            for (let G = 0; G < Q; G++) {
                const ae = X.getViewport(G);
                a.set(s.x * ae.x, s.y * ae.y, s.x * ae.z, s.y * ae.w),
                    ie.viewport(a),
                    X.updateMatrices(me, G),
                    (n = X.getFrustum()),
                    L(B, z, X.camera, me, this.type);
            }
            X.isPointLightShadow !== !0 && this.type === io && b(X, z),
                (X.needsUpdate = !1);
        }
        (w = this.type), (M.needsUpdate = !1), i.setRenderTarget(U, D, H);
    };
    function b(N, B) {
        const z = e.update(T);
        y.defines.VSM_SAMPLES !== N.blurSamples &&
            ((y.defines.VSM_SAMPLES = N.blurSamples),
            (v.defines.VSM_SAMPLES = N.blurSamples),
            (y.needsUpdate = !0),
            (v.needsUpdate = !0)),
            N.mapPass === null && (N.mapPass = new lo(r.x, r.y)),
            (y.uniforms.shadow_pass.value = N.map.texture),
            (y.uniforms.resolution.value = N.mapSize),
            (y.uniforms.radius.value = N.radius),
            i.setRenderTarget(N.mapPass),
            i.clear(),
            i.renderBufferDirect(B, null, z, y, T, null),
            (v.uniforms.shadow_pass.value = N.mapPass.texture),
            (v.uniforms.resolution.value = N.mapSize),
            (v.uniforms.radius.value = N.radius),
            i.setRenderTarget(N.map),
            i.clear(),
            i.renderBufferDirect(B, null, z, v, T, null);
    }
    function C(N, B, z, U) {
        let D = null;
        const H =
            z.isPointLight === !0
                ? N.customDistanceMaterial
                : N.customDepthMaterial;
        if (H !== void 0) D = H;
        else if (
            ((D = z.isPointLight === !0 ? c : l),
            (i.localClippingEnabled &&
                B.clipShadows === !0 &&
                Array.isArray(B.clippingPlanes) &&
                B.clippingPlanes.length !== 0) ||
                (B.displacementMap && B.displacementScale !== 0) ||
                (B.alphaMap && B.alphaTest > 0) ||
                (B.map && B.alphaTest > 0))
        ) {
            const ie = D.uuid,
                ee = B.uuid;
            let ue = d[ie];
            ue === void 0 && ((ue = {}), (d[ie] = ue));
            let Se = ue[ee];
            Se === void 0 &&
                ((Se = D.clone()),
                (ue[ee] = Se),
                B.addEventListener('dispose', F)),
                (D = Se);
        }
        if (
            ((D.visible = B.visible),
            (D.wireframe = B.wireframe),
            U === io
                ? (D.side = B.shadowSide !== null ? B.shadowSide : B.side)
                : (D.side = B.shadowSide !== null ? B.shadowSide : g[B.side]),
            (D.alphaMap = B.alphaMap),
            (D.alphaTest = B.alphaTest),
            (D.map = B.map),
            (D.clipShadows = B.clipShadows),
            (D.clippingPlanes = B.clippingPlanes),
            (D.clipIntersection = B.clipIntersection),
            (D.displacementMap = B.displacementMap),
            (D.displacementScale = B.displacementScale),
            (D.displacementBias = B.displacementBias),
            (D.wireframeLinewidth = B.wireframeLinewidth),
            (D.linewidth = B.linewidth),
            z.isPointLight === !0 && D.isMeshDistanceMaterial === !0)
        ) {
            const ie = i.properties.get(D);
            ie.light = z;
        }
        return D;
    }
    function L(N, B, z, U, D) {
        if (N.visible === !1) return;
        if (
            N.layers.test(B.layers) &&
            (N.isMesh || N.isLine || N.isPoints) &&
            (N.castShadow || (N.receiveShadow && D === io)) &&
            (!N.frustumCulled || n.intersectsObject(N))
        ) {
            N.modelViewMatrix.multiplyMatrices(
                z.matrixWorldInverse,
                N.matrixWorld
            );
            const ee = e.update(N),
                ue = N.material;
            if (Array.isArray(ue)) {
                const Se = ee.groups;
                for (let ce = 0, me = Se.length; ce < me; ce++) {
                    const X = Se[ce],
                        oe = ue[X.materialIndex];
                    if (oe && oe.visible) {
                        const Q = C(N, oe, U, D);
                        N.onBeforeShadow(i, N, B, z, ee, Q, X),
                            i.renderBufferDirect(z, null, ee, Q, N, X),
                            N.onAfterShadow(i, N, B, z, ee, Q, X);
                    }
                }
            } else if (ue.visible) {
                const Se = C(N, ue, U, D);
                N.onBeforeShadow(i, N, B, z, ee, Se, null),
                    i.renderBufferDirect(z, null, ee, Se, N, null),
                    N.onAfterShadow(i, N, B, z, ee, Se, null);
            }
        }
        const ie = N.children;
        for (let ee = 0, ue = ie.length; ee < ue; ee++) L(ie[ee], B, z, U, D);
    }
    function F(N) {
        N.target.removeEventListener('dispose', F);
        for (const z in d) {
            const U = d[z],
                D = N.target.uuid;
            D in U && (U[D].dispose(), delete U[D]);
        }
    }
}
function eV(i) {
    function e() {
        let ne = !1;
        const Ve = new gn();
        let Te = null;
        const Ae = new gn(0, 0, 0, 0);
        return {
            setMask: function (Ge) {
                Te !== Ge && !ne && (i.colorMask(Ge, Ge, Ge, Ge), (Te = Ge));
            },
            setLocked: function (Ge) {
                ne = Ge;
            },
            setClear: function (Ge, At, Yt, Cn, jn) {
                jn === !0 && ((Ge *= Cn), (At *= Cn), (Yt *= Cn)),
                    Ve.set(Ge, At, Yt, Cn),
                    Ae.equals(Ve) === !1 &&
                        (i.clearColor(Ge, At, Yt, Cn), Ae.copy(Ve));
            },
            reset: function () {
                (ne = !1), (Te = null), Ae.set(-1, 0, 0, 0);
            },
        };
    }
    function t() {
        let ne = !1,
            Ve = null,
            Te = null,
            Ae = null;
        return {
            setTest: function (Ge) {
                Ge ? Pe(i.DEPTH_TEST) : Re(i.DEPTH_TEST);
            },
            setMask: function (Ge) {
                Ve !== Ge && !ne && (i.depthMask(Ge), (Ve = Ge));
            },
            setFunc: function (Ge) {
                if (Te !== Ge) {
                    switch (Ge) {
                        case pR:
                            i.depthFunc(i.NEVER);
                            break;
                        case mR:
                            i.depthFunc(i.ALWAYS);
                            break;
                        case gR:
                            i.depthFunc(i.LESS);
                            break;
                        case yp:
                            i.depthFunc(i.LEQUAL);
                            break;
                        case yR:
                            i.depthFunc(i.EQUAL);
                            break;
                        case vR:
                            i.depthFunc(i.GEQUAL);
                            break;
                        case xR:
                            i.depthFunc(i.GREATER);
                            break;
                        case _R:
                            i.depthFunc(i.NOTEQUAL);
                            break;
                        default:
                            i.depthFunc(i.LEQUAL);
                    }
                    Te = Ge;
                }
            },
            setLocked: function (Ge) {
                ne = Ge;
            },
            setClear: function (Ge) {
                Ae !== Ge && (i.clearDepth(Ge), (Ae = Ge));
            },
            reset: function () {
                (ne = !1), (Ve = null), (Te = null), (Ae = null);
            },
        };
    }
    function n() {
        let ne = !1,
            Ve = null,
            Te = null,
            Ae = null,
            Ge = null,
            At = null,
            Yt = null,
            Cn = null,
            jn = null;
        return {
            setTest: function (en) {
                ne || (en ? Pe(i.STENCIL_TEST) : Re(i.STENCIL_TEST));
            },
            setMask: function (en) {
                Ve !== en && !ne && (i.stencilMask(en), (Ve = en));
            },
            setFunc: function (en, Hi, Gi) {
                (Te !== en || Ae !== Hi || Ge !== Gi) &&
                    (i.stencilFunc(en, Hi, Gi),
                    (Te = en),
                    (Ae = Hi),
                    (Ge = Gi));
            },
            setOp: function (en, Hi, Gi) {
                (At !== en || Yt !== Hi || Cn !== Gi) &&
                    (i.stencilOp(en, Hi, Gi), (At = en), (Yt = Hi), (Cn = Gi));
            },
            setLocked: function (en) {
                ne = en;
            },
            setClear: function (en) {
                jn !== en && (i.clearStencil(en), (jn = en));
            },
            reset: function () {
                (ne = !1),
                    (Ve = null),
                    (Te = null),
                    (Ae = null),
                    (Ge = null),
                    (At = null),
                    (Yt = null),
                    (Cn = null),
                    (jn = null);
            },
        };
    }
    const r = new e(),
        s = new t(),
        a = new n(),
        l = new WeakMap(),
        c = new WeakMap();
    let d = {},
        p = {},
        g = new WeakMap(),
        y = [],
        v = null,
        S = !1,
        T = null,
        M = null,
        w = null,
        b = null,
        C = null,
        L = null,
        F = null,
        N = new st(0, 0, 0),
        B = 0,
        z = !1,
        U = null,
        D = null,
        H = null,
        ie = null,
        ee = null;
    const ue = i.getParameter(i.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
    let Se = !1,
        ce = 0;
    const me = i.getParameter(i.VERSION);
    me.indexOf('WebGL') !== -1
        ? ((ce = parseFloat(/^WebGL (\d)/.exec(me)[1])), (Se = ce >= 1))
        : me.indexOf('OpenGL ES') !== -1 &&
          ((ce = parseFloat(/^OpenGL ES (\d)/.exec(me)[1])), (Se = ce >= 2));
    let X = null,
        oe = {};
    const Q = i.getParameter(i.SCISSOR_BOX),
        G = i.getParameter(i.VIEWPORT),
        ae = new gn().fromArray(Q),
        Oe = new gn().fromArray(G);
    function fe(ne, Ve, Te, Ae) {
        const Ge = new Uint8Array(4),
            At = i.createTexture();
        i.bindTexture(ne, At),
            i.texParameteri(ne, i.TEXTURE_MIN_FILTER, i.NEAREST),
            i.texParameteri(ne, i.TEXTURE_MAG_FILTER, i.NEAREST);
        for (let Yt = 0; Yt < Te; Yt++)
            ne === i.TEXTURE_3D || ne === i.TEXTURE_2D_ARRAY
                ? i.texImage3D(
                      Ve,
                      0,
                      i.RGBA,
                      1,
                      1,
                      Ae,
                      0,
                      i.RGBA,
                      i.UNSIGNED_BYTE,
                      Ge
                  )
                : i.texImage2D(
                      Ve + Yt,
                      0,
                      i.RGBA,
                      1,
                      1,
                      0,
                      i.RGBA,
                      i.UNSIGNED_BYTE,
                      Ge
                  );
        return At;
    }
    const we = {};
    (we[i.TEXTURE_2D] = fe(i.TEXTURE_2D, i.TEXTURE_2D, 1)),
        (we[i.TEXTURE_CUBE_MAP] = fe(
            i.TEXTURE_CUBE_MAP,
            i.TEXTURE_CUBE_MAP_POSITIVE_X,
            6
        )),
        (we[i.TEXTURE_2D_ARRAY] = fe(
            i.TEXTURE_2D_ARRAY,
            i.TEXTURE_2D_ARRAY,
            1,
            1
        )),
        (we[i.TEXTURE_3D] = fe(i.TEXTURE_3D, i.TEXTURE_3D, 1, 1)),
        r.setClear(0, 0, 0, 1),
        s.setClear(1),
        a.setClear(0),
        Pe(i.DEPTH_TEST),
        s.setFunc(yp),
        Ke(!1),
        Ee(f_),
        Pe(i.CULL_FACE),
        Ie(Pa);
    function Pe(ne) {
        d[ne] !== !0 && (i.enable(ne), (d[ne] = !0));
    }
    function Re(ne) {
        d[ne] !== !1 && (i.disable(ne), (d[ne] = !1));
    }
    function Ye(ne, Ve) {
        return p[ne] !== Ve
            ? (i.bindFramebuffer(ne, Ve),
              (p[ne] = Ve),
              ne === i.DRAW_FRAMEBUFFER && (p[i.FRAMEBUFFER] = Ve),
              ne === i.FRAMEBUFFER && (p[i.DRAW_FRAMEBUFFER] = Ve),
              !0)
            : !1;
    }
    function lt(ne, Ve) {
        let Te = y,
            Ae = !1;
        if (ne) {
            (Te = g.get(Ve)), Te === void 0 && ((Te = []), g.set(Ve, Te));
            const Ge = ne.textures;
            if (Te.length !== Ge.length || Te[0] !== i.COLOR_ATTACHMENT0) {
                for (let At = 0, Yt = Ge.length; At < Yt; At++)
                    Te[At] = i.COLOR_ATTACHMENT0 + At;
                (Te.length = Ge.length), (Ae = !0);
            }
        } else Te[0] !== i.BACK && ((Te[0] = i.BACK), (Ae = !0));
        Ae && i.drawBuffers(Te);
    }
    function dt(ne) {
        return v !== ne ? (i.useProgram(ne), (v = ne), !0) : !1;
    }
    const Lt = {
        [Ll]: i.FUNC_ADD,
        [ZC]: i.FUNC_SUBTRACT,
        [JC]: i.FUNC_REVERSE_SUBTRACT,
    };
    (Lt[QC] = i.MIN), (Lt[eR] = i.MAX);
    const W = {
        [tR]: i.ZERO,
        [nR]: i.ONE,
        [iR]: i.SRC_COLOR,
        [gy]: i.SRC_ALPHA,
        [uR]: i.SRC_ALPHA_SATURATE,
        [aR]: i.DST_COLOR,
        [sR]: i.DST_ALPHA,
        [rR]: i.ONE_MINUS_SRC_COLOR,
        [yy]: i.ONE_MINUS_SRC_ALPHA,
        [lR]: i.ONE_MINUS_DST_COLOR,
        [oR]: i.ONE_MINUS_DST_ALPHA,
        [cR]: i.CONSTANT_COLOR,
        [fR]: i.ONE_MINUS_CONSTANT_COLOR,
        [hR]: i.CONSTANT_ALPHA,
        [dR]: i.ONE_MINUS_CONSTANT_ALPHA,
    };
    function Ie(ne, Ve, Te, Ae, Ge, At, Yt, Cn, jn, en) {
        if (ne === Pa) {
            S === !0 && (Re(i.BLEND), (S = !1));
            return;
        }
        if ((S === !1 && (Pe(i.BLEND), (S = !0)), ne !== KC)) {
            if (ne !== T || en !== z) {
                if (
                    ((M !== Ll || C !== Ll) &&
                        (i.blendEquation(i.FUNC_ADD), (M = Ll), (C = Ll)),
                    en)
                )
                    switch (ne) {
                        case nc:
                            i.blendFuncSeparate(
                                i.ONE,
                                i.ONE_MINUS_SRC_ALPHA,
                                i.ONE,
                                i.ONE_MINUS_SRC_ALPHA
                            );
                            break;
                        case h_:
                            i.blendFunc(i.ONE, i.ONE);
                            break;
                        case d_:
                            i.blendFuncSeparate(
                                i.ZERO,
                                i.ONE_MINUS_SRC_COLOR,
                                i.ZERO,
                                i.ONE
                            );
                            break;
                        case p_:
                            i.blendFuncSeparate(
                                i.ZERO,
                                i.SRC_COLOR,
                                i.ZERO,
                                i.SRC_ALPHA
                            );
                            break;
                        default:
                            console.error(
                                'THREE.WebGLState: Invalid blending: ',
                                ne
                            );
                            break;
                    }
                else
                    switch (ne) {
                        case nc:
                            i.blendFuncSeparate(
                                i.SRC_ALPHA,
                                i.ONE_MINUS_SRC_ALPHA,
                                i.ONE,
                                i.ONE_MINUS_SRC_ALPHA
                            );
                            break;
                        case h_:
                            i.blendFunc(i.SRC_ALPHA, i.ONE);
                            break;
                        case d_:
                            i.blendFuncSeparate(
                                i.ZERO,
                                i.ONE_MINUS_SRC_COLOR,
                                i.ZERO,
                                i.ONE
                            );
                            break;
                        case p_:
                            i.blendFunc(i.ZERO, i.SRC_COLOR);
                            break;
                        default:
                            console.error(
                                'THREE.WebGLState: Invalid blending: ',
                                ne
                            );
                            break;
                    }
                (w = null),
                    (b = null),
                    (L = null),
                    (F = null),
                    N.set(0, 0, 0),
                    (B = 0),
                    (T = ne),
                    (z = en);
            }
            return;
        }
        (Ge = Ge || Ve),
            (At = At || Te),
            (Yt = Yt || Ae),
            (Ve !== M || Ge !== C) &&
                (i.blendEquationSeparate(Lt[Ve], Lt[Ge]), (M = Ve), (C = Ge)),
            (Te !== w || Ae !== b || At !== L || Yt !== F) &&
                (i.blendFuncSeparate(W[Te], W[Ae], W[At], W[Yt]),
                (w = Te),
                (b = Ae),
                (L = At),
                (F = Yt)),
            (Cn.equals(N) === !1 || jn !== B) &&
                (i.blendColor(Cn.r, Cn.g, Cn.b, jn), N.copy(Cn), (B = jn)),
            (T = ne),
            (z = !1);
    }
    function ke(ne, Ve) {
        ne.side === Lo ? Re(i.CULL_FACE) : Pe(i.CULL_FACE);
        let Te = ne.side === Er;
        Ve && (Te = !Te),
            Ke(Te),
            ne.blending === nc && ne.transparent === !1
                ? Ie(Pa)
                : Ie(
                      ne.blending,
                      ne.blendEquation,
                      ne.blendSrc,
                      ne.blendDst,
                      ne.blendEquationAlpha,
                      ne.blendSrcAlpha,
                      ne.blendDstAlpha,
                      ne.blendColor,
                      ne.blendAlpha,
                      ne.premultipliedAlpha
                  ),
            s.setFunc(ne.depthFunc),
            s.setTest(ne.depthTest),
            s.setMask(ne.depthWrite),
            r.setMask(ne.colorWrite);
        const Ae = ne.stencilWrite;
        a.setTest(Ae),
            Ae &&
                (a.setMask(ne.stencilWriteMask),
                a.setFunc(ne.stencilFunc, ne.stencilRef, ne.stencilFuncMask),
                a.setOp(ne.stencilFail, ne.stencilZFail, ne.stencilZPass)),
            Ze(ne.polygonOffset, ne.polygonOffsetFactor, ne.polygonOffsetUnits),
            ne.alphaToCoverage === !0
                ? Pe(i.SAMPLE_ALPHA_TO_COVERAGE)
                : Re(i.SAMPLE_ALPHA_TO_COVERAGE);
    }
    function Ke(ne) {
        U !== ne && (ne ? i.frontFace(i.CW) : i.frontFace(i.CCW), (U = ne));
    }
    function Ee(ne) {
        ne !== qC
            ? (Pe(i.CULL_FACE),
              ne !== D &&
                  (ne === f_
                      ? i.cullFace(i.BACK)
                      : ne === $C
                        ? i.cullFace(i.FRONT)
                        : i.cullFace(i.FRONT_AND_BACK)))
            : Re(i.CULL_FACE),
            (D = ne);
    }
    function St(ne) {
        ne !== H && (Se && i.lineWidth(ne), (H = ne));
    }
    function Ze(ne, Ve, Te) {
        ne
            ? (Pe(i.POLYGON_OFFSET_FILL),
              (ie !== Ve || ee !== Te) &&
                  (i.polygonOffset(Ve, Te), (ie = Ve), (ee = Te)))
            : Re(i.POLYGON_OFFSET_FILL);
    }
    function ot(ne) {
        ne ? Pe(i.SCISSOR_TEST) : Re(i.SCISSOR_TEST);
    }
    function $(ne) {
        ne === void 0 && (ne = i.TEXTURE0 + ue - 1),
            X !== ne && (i.activeTexture(ne), (X = ne));
    }
    function k(ne, Ve, Te) {
        Te === void 0 && (X === null ? (Te = i.TEXTURE0 + ue - 1) : (Te = X));
        let Ae = oe[Te];
        Ae === void 0 &&
            ((Ae = { type: void 0, texture: void 0 }), (oe[Te] = Ae)),
            (Ae.type !== ne || Ae.texture !== Ve) &&
                (X !== Te && (i.activeTexture(Te), (X = Te)),
                i.bindTexture(ne, Ve || we[ne]),
                (Ae.type = ne),
                (Ae.texture = Ve));
    }
    function ge() {
        const ne = oe[X];
        ne !== void 0 &&
            ne.type !== void 0 &&
            (i.bindTexture(ne.type, null),
            (ne.type = void 0),
            (ne.texture = void 0));
    }
    function De() {
        try {
            i.compressedTexImage2D.apply(i, arguments);
        } catch (ne) {
            console.error('THREE.WebGLState:', ne);
        }
    }
    function be() {
        try {
            i.compressedTexImage3D.apply(i, arguments);
        } catch (ne) {
            console.error('THREE.WebGLState:', ne);
        }
    }
    function Le() {
        try {
            i.texSubImage2D.apply(i, arguments);
        } catch (ne) {
            console.error('THREE.WebGLState:', ne);
        }
    }
    function _t() {
        try {
            i.texSubImage3D.apply(i, arguments);
        } catch (ne) {
            console.error('THREE.WebGLState:', ne);
        }
    }
    function $e() {
        try {
            i.compressedTexSubImage2D.apply(i, arguments);
        } catch (ne) {
            console.error('THREE.WebGLState:', ne);
        }
    }
    function tt() {
        try {
            i.compressedTexSubImage3D.apply(i, arguments);
        } catch (ne) {
            console.error('THREE.WebGLState:', ne);
        }
    }
    function Nt() {
        try {
            i.texStorage2D.apply(i, arguments);
        } catch (ne) {
            console.error('THREE.WebGLState:', ne);
        }
    }
    function Be() {
        try {
            i.texStorage3D.apply(i, arguments);
        } catch (ne) {
            console.error('THREE.WebGLState:', ne);
        }
    }
    function Je() {
        try {
            i.texImage2D.apply(i, arguments);
        } catch (ne) {
            console.error('THREE.WebGLState:', ne);
        }
    }
    function Kt() {
        try {
            i.texImage3D.apply(i, arguments);
        } catch (ne) {
            console.error('THREE.WebGLState:', ne);
        }
    }
    function bt(ne) {
        ae.equals(ne) === !1 &&
            (i.scissor(ne.x, ne.y, ne.z, ne.w), ae.copy(ne));
    }
    function ut(ne) {
        Oe.equals(ne) === !1 &&
            (i.viewport(ne.x, ne.y, ne.z, ne.w), Oe.copy(ne));
    }
    function Ut(ne, Ve) {
        let Te = c.get(Ve);
        Te === void 0 && ((Te = new WeakMap()), c.set(Ve, Te));
        let Ae = Te.get(ne);
        Ae === void 0 &&
            ((Ae = i.getUniformBlockIndex(Ve, ne.name)), Te.set(ne, Ae));
    }
    function zt(ne, Ve) {
        const Ae = c.get(Ve).get(ne);
        l.get(Ve) !== Ae &&
            (i.uniformBlockBinding(Ve, Ae, ne.__bindingPointIndex),
            l.set(Ve, Ae));
    }
    function dn() {
        i.disable(i.BLEND),
            i.disable(i.CULL_FACE),
            i.disable(i.DEPTH_TEST),
            i.disable(i.POLYGON_OFFSET_FILL),
            i.disable(i.SCISSOR_TEST),
            i.disable(i.STENCIL_TEST),
            i.disable(i.SAMPLE_ALPHA_TO_COVERAGE),
            i.blendEquation(i.FUNC_ADD),
            i.blendFunc(i.ONE, i.ZERO),
            i.blendFuncSeparate(i.ONE, i.ZERO, i.ONE, i.ZERO),
            i.blendColor(0, 0, 0, 0),
            i.colorMask(!0, !0, !0, !0),
            i.clearColor(0, 0, 0, 0),
            i.depthMask(!0),
            i.depthFunc(i.LESS),
            i.clearDepth(1),
            i.stencilMask(4294967295),
            i.stencilFunc(i.ALWAYS, 0, 4294967295),
            i.stencilOp(i.KEEP, i.KEEP, i.KEEP),
            i.clearStencil(0),
            i.cullFace(i.BACK),
            i.frontFace(i.CCW),
            i.polygonOffset(0, 0),
            i.activeTexture(i.TEXTURE0),
            i.bindFramebuffer(i.FRAMEBUFFER, null),
            i.bindFramebuffer(i.DRAW_FRAMEBUFFER, null),
            i.bindFramebuffer(i.READ_FRAMEBUFFER, null),
            i.useProgram(null),
            i.lineWidth(1),
            i.scissor(0, 0, i.canvas.width, i.canvas.height),
            i.viewport(0, 0, i.canvas.width, i.canvas.height),
            (d = {}),
            (X = null),
            (oe = {}),
            (p = {}),
            (g = new WeakMap()),
            (y = []),
            (v = null),
            (S = !1),
            (T = null),
            (M = null),
            (w = null),
            (b = null),
            (C = null),
            (L = null),
            (F = null),
            (N = new st(0, 0, 0)),
            (B = 0),
            (z = !1),
            (U = null),
            (D = null),
            (H = null),
            (ie = null),
            (ee = null),
            ae.set(0, 0, i.canvas.width, i.canvas.height),
            Oe.set(0, 0, i.canvas.width, i.canvas.height),
            r.reset(),
            s.reset(),
            a.reset();
    }
    return {
        buffers: { color: r, depth: s, stencil: a },
        enable: Pe,
        disable: Re,
        bindFramebuffer: Ye,
        drawBuffers: lt,
        useProgram: dt,
        setBlending: Ie,
        setMaterial: ke,
        setFlipSided: Ke,
        setCullFace: Ee,
        setLineWidth: St,
        setPolygonOffset: Ze,
        setScissorTest: ot,
        activeTexture: $,
        bindTexture: k,
        unbindTexture: ge,
        compressedTexImage2D: De,
        compressedTexImage3D: be,
        texImage2D: Je,
        texImage3D: Kt,
        updateUBOMapping: Ut,
        uniformBlockBinding: zt,
        texStorage2D: Nt,
        texStorage3D: Be,
        texSubImage2D: Le,
        texSubImage3D: _t,
        compressedTexSubImage2D: $e,
        compressedTexSubImage3D: tt,
        scissor: bt,
        viewport: ut,
        reset: dn,
    };
}
function tV(i, e) {
    const t = i.image && i.image.width ? i.image.width / i.image.height : 1;
    return (
        t > e
            ? ((i.repeat.x = 1),
              (i.repeat.y = t / e),
              (i.offset.x = 0),
              (i.offset.y = (1 - i.repeat.y) / 2))
            : ((i.repeat.x = e / t),
              (i.repeat.y = 1),
              (i.offset.x = (1 - i.repeat.x) / 2),
              (i.offset.y = 0)),
        i
    );
}
function nV(i, e) {
    const t = i.image && i.image.width ? i.image.width / i.image.height : 1;
    return (
        t > e
            ? ((i.repeat.x = e / t),
              (i.repeat.y = 1),
              (i.offset.x = (1 - i.repeat.x) / 2),
              (i.offset.y = 0))
            : ((i.repeat.x = 1),
              (i.repeat.y = t / e),
              (i.offset.x = 0),
              (i.offset.y = (1 - i.repeat.y) / 2)),
        i
    );
}
function iV(i) {
    return (
        (i.repeat.x = 1),
        (i.repeat.y = 1),
        (i.offset.x = 0),
        (i.offset.y = 0),
        i
    );
}
function __(i, e, t, n) {
    const r = rV(n);
    switch (t) {
        case LS:
            return i * e;
        case DS:
            return i * e;
        case NS:
            return i * e * 2;
        case hv:
            return ((i * e) / r.components) * r.byteLength;
        case $p:
            return ((i * e) / r.components) * r.byteLength;
        case US:
            return ((i * e * 2) / r.components) * r.byteLength;
        case dv:
            return ((i * e * 2) / r.components) * r.byteLength;
        case IS:
            return ((i * e * 3) / r.components) * r.byteLength;
        case sr:
            return ((i * e * 4) / r.components) * r.byteLength;
        case pv:
            return ((i * e * 4) / r.components) * r.byteLength;
        case Qd:
        case ep:
            return Math.floor((i + 3) / 4) * Math.floor((e + 3) / 4) * 8;
        case tp:
        case np:
            return Math.floor((i + 3) / 4) * Math.floor((e + 3) / 4) * 16;
        case xy:
        case Sy:
            return (Math.max(i, 16) * Math.max(e, 8)) / 4;
        case vy:
        case _y:
            return (Math.max(i, 8) * Math.max(e, 8)) / 2;
        case wy:
        case My:
            return Math.floor((i + 3) / 4) * Math.floor((e + 3) / 4) * 8;
        case Ey:
            return Math.floor((i + 3) / 4) * Math.floor((e + 3) / 4) * 16;
        case Ty:
            return Math.floor((i + 3) / 4) * Math.floor((e + 3) / 4) * 16;
        case Ay:
            return Math.floor((i + 4) / 5) * Math.floor((e + 3) / 4) * 16;
        case Cy:
            return Math.floor((i + 4) / 5) * Math.floor((e + 4) / 5) * 16;
        case Ry:
            return Math.floor((i + 5) / 6) * Math.floor((e + 4) / 5) * 16;
        case by:
            return Math.floor((i + 5) / 6) * Math.floor((e + 5) / 6) * 16;
        case Py:
            return Math.floor((i + 7) / 8) * Math.floor((e + 4) / 5) * 16;
        case Ly:
            return Math.floor((i + 7) / 8) * Math.floor((e + 5) / 6) * 16;
        case Iy:
            return Math.floor((i + 7) / 8) * Math.floor((e + 7) / 8) * 16;
        case Dy:
            return Math.floor((i + 9) / 10) * Math.floor((e + 4) / 5) * 16;
        case Ny:
            return Math.floor((i + 9) / 10) * Math.floor((e + 5) / 6) * 16;
        case Uy:
            return Math.floor((i + 9) / 10) * Math.floor((e + 7) / 8) * 16;
        case Oy:
            return Math.floor((i + 9) / 10) * Math.floor((e + 9) / 10) * 16;
        case ky:
            return Math.floor((i + 11) / 12) * Math.floor((e + 9) / 10) * 16;
        case Fy:
            return Math.floor((i + 11) / 12) * Math.floor((e + 11) / 12) * 16;
        case ip:
        case By:
        case zy:
            return Math.ceil(i / 4) * Math.ceil(e / 4) * 16;
        case OS:
        case Vy:
            return Math.ceil(i / 4) * Math.ceil(e / 4) * 8;
        case Hy:
        case Gy:
            return Math.ceil(i / 4) * Math.ceil(e / 4) * 16;
    }
    throw new Error(`Unable to determine texture byte length for ${t} format.`);
}
function rV(i) {
    switch (i) {
        case ao:
        case RS:
            return { byteLength: 1, components: 1 };
        case ch:
        case bS:
        case Mh:
            return { byteLength: 2, components: 1 };
        case cv:
        case fv:
            return { byteLength: 2, components: 4 };
        case Oa:
        case uv:
        case Vr:
            return { byteLength: 4, components: 1 };
        case PS:
            return { byteLength: 4, components: 3 };
    }
    throw new Error(`Unknown texture type ${i}.`);
}
const sV = { contain: tV, cover: nV, fill: iV, getByteLength: __ };
function oV(i, e, t, n, r, s, a) {
    const l = e.has('WEBGL_multisampled_render_to_texture')
            ? e.get('WEBGL_multisampled_render_to_texture')
            : null,
        c =
            typeof navigator > 'u'
                ? !1
                : /OculusBrowser/g.test(navigator.userAgent),
        d = new Ce(),
        p = new WeakMap();
    let g;
    const y = new WeakMap();
    let v = !1;
    try {
        v =
            typeof OffscreenCanvas < 'u' &&
            new OffscreenCanvas(1, 1).getContext('2d') !== null;
    } catch {}
    function S($, k) {
        return v ? new OffscreenCanvas($, k) : bp('canvas');
    }
    function T($, k, ge) {
        let De = 1;
        const be = ot($);
        if (
            ((be.width > ge || be.height > ge) &&
                (De = ge / Math.max(be.width, be.height)),
            De < 1)
        )
            if (
                (typeof HTMLImageElement < 'u' &&
                    $ instanceof HTMLImageElement) ||
                (typeof HTMLCanvasElement < 'u' &&
                    $ instanceof HTMLCanvasElement) ||
                (typeof ImageBitmap < 'u' && $ instanceof ImageBitmap) ||
                (typeof VideoFrame < 'u' && $ instanceof VideoFrame)
            ) {
                const Le = Math.floor(De * be.width),
                    _t = Math.floor(De * be.height);
                g === void 0 && (g = S(Le, _t));
                const $e = k ? S(Le, _t) : g;
                return (
                    ($e.width = Le),
                    ($e.height = _t),
                    $e.getContext('2d').drawImage($, 0, 0, Le, _t),
                    console.warn(
                        'THREE.WebGLRenderer: Texture has been resized from (' +
                            be.width +
                            'x' +
                            be.height +
                            ') to (' +
                            Le +
                            'x' +
                            _t +
                            ').'
                    ),
                    $e
                );
            } else
                return (
                    'data' in $ &&
                        console.warn(
                            'THREE.WebGLRenderer: Image in DataTexture is too big (' +
                                be.width +
                                'x' +
                                be.height +
                                ').'
                        ),
                    $
                );
        return $;
    }
    function M($) {
        return $.generateMipmaps && $.minFilter !== Li && $.minFilter !== hi;
    }
    function w($) {
        i.generateMipmap($);
    }
    function b($, k, ge, De, be = !1) {
        if ($ !== null) {
            if (i[$] !== void 0) return i[$];
            console.warn(
                "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
                    $ +
                    "'"
            );
        }
        let Le = k;
        if (
            (k === i.RED &&
                (ge === i.FLOAT && (Le = i.R32F),
                ge === i.HALF_FLOAT && (Le = i.R16F),
                ge === i.UNSIGNED_BYTE && (Le = i.R8)),
            k === i.RED_INTEGER &&
                (ge === i.UNSIGNED_BYTE && (Le = i.R8UI),
                ge === i.UNSIGNED_SHORT && (Le = i.R16UI),
                ge === i.UNSIGNED_INT && (Le = i.R32UI),
                ge === i.BYTE && (Le = i.R8I),
                ge === i.SHORT && (Le = i.R16I),
                ge === i.INT && (Le = i.R32I)),
            k === i.RG &&
                (ge === i.FLOAT && (Le = i.RG32F),
                ge === i.HALF_FLOAT && (Le = i.RG16F),
                ge === i.UNSIGNED_BYTE && (Le = i.RG8)),
            k === i.RG_INTEGER &&
                (ge === i.UNSIGNED_BYTE && (Le = i.RG8UI),
                ge === i.UNSIGNED_SHORT && (Le = i.RG16UI),
                ge === i.UNSIGNED_INT && (Le = i.RG32UI),
                ge === i.BYTE && (Le = i.RG8I),
                ge === i.SHORT && (Le = i.RG16I),
                ge === i.INT && (Le = i.RG32I)),
            k === i.RGB &&
                ge === i.UNSIGNED_INT_5_9_9_9_REV &&
                (Le = i.RGB9_E5),
            k === i.RGBA)
        ) {
            const _t = be ? Ep : hn.getTransfer(De);
            ge === i.FLOAT && (Le = i.RGBA32F),
                ge === i.HALF_FLOAT && (Le = i.RGBA16F),
                ge === i.UNSIGNED_BYTE &&
                    (Le = _t === Pn ? i.SRGB8_ALPHA8 : i.RGBA8),
                ge === i.UNSIGNED_SHORT_4_4_4_4 && (Le = i.RGBA4),
                ge === i.UNSIGNED_SHORT_5_5_5_1 && (Le = i.RGB5_A1);
        }
        return (
            (Le === i.R16F ||
                Le === i.R32F ||
                Le === i.RG16F ||
                Le === i.RG32F ||
                Le === i.RGBA16F ||
                Le === i.RGBA32F) &&
                e.get('EXT_color_buffer_float'),
            Le
        );
    }
    function C($, k) {
        let ge;
        return (
            $
                ? k === null || k === Oa || k === ac
                    ? (ge = i.DEPTH24_STENCIL8)
                    : k === Vr
                      ? (ge = i.DEPTH32F_STENCIL8)
                      : k === ch &&
                        ((ge = i.DEPTH24_STENCIL8),
                        console.warn(
                            'DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.'
                        ))
                : k === null || k === Oa || k === ac
                  ? (ge = i.DEPTH_COMPONENT24)
                  : k === Vr
                    ? (ge = i.DEPTH_COMPONENT32F)
                    : k === ch && (ge = i.DEPTH_COMPONENT16),
            ge
        );
    }
    function L($, k) {
        return M($) === !0 ||
            ($.isFramebufferTexture && $.minFilter !== Li && $.minFilter !== hi)
            ? Math.log2(Math.max(k.width, k.height)) + 1
            : $.mipmaps !== void 0 && $.mipmaps.length > 0
              ? $.mipmaps.length
              : $.isCompressedTexture && Array.isArray($.image)
                ? k.mipmaps.length
                : 1;
    }
    function F($) {
        const k = $.target;
        k.removeEventListener('dispose', F),
            B(k),
            k.isVideoTexture && p.delete(k);
    }
    function N($) {
        const k = $.target;
        k.removeEventListener('dispose', N), U(k);
    }
    function B($) {
        const k = n.get($);
        if (k.__webglInit === void 0) return;
        const ge = $.source,
            De = y.get(ge);
        if (De) {
            const be = De[k.__cacheKey];
            be.usedTimes--,
                be.usedTimes === 0 && z($),
                Object.keys(De).length === 0 && y.delete(ge);
        }
        n.remove($);
    }
    function z($) {
        const k = n.get($);
        i.deleteTexture(k.__webglTexture);
        const ge = $.source,
            De = y.get(ge);
        delete De[k.__cacheKey], a.memory.textures--;
    }
    function U($) {
        const k = n.get($);
        if (
            ($.depthTexture && $.depthTexture.dispose(),
            $.isWebGLCubeRenderTarget)
        )
            for (let De = 0; De < 6; De++) {
                if (Array.isArray(k.__webglFramebuffer[De]))
                    for (let be = 0; be < k.__webglFramebuffer[De].length; be++)
                        i.deleteFramebuffer(k.__webglFramebuffer[De][be]);
                else i.deleteFramebuffer(k.__webglFramebuffer[De]);
                k.__webglDepthbuffer &&
                    i.deleteRenderbuffer(k.__webglDepthbuffer[De]);
            }
        else {
            if (Array.isArray(k.__webglFramebuffer))
                for (let De = 0; De < k.__webglFramebuffer.length; De++)
                    i.deleteFramebuffer(k.__webglFramebuffer[De]);
            else i.deleteFramebuffer(k.__webglFramebuffer);
            if (
                (k.__webglDepthbuffer &&
                    i.deleteRenderbuffer(k.__webglDepthbuffer),
                k.__webglMultisampledFramebuffer &&
                    i.deleteFramebuffer(k.__webglMultisampledFramebuffer),
                k.__webglColorRenderbuffer)
            )
                for (let De = 0; De < k.__webglColorRenderbuffer.length; De++)
                    k.__webglColorRenderbuffer[De] &&
                        i.deleteRenderbuffer(k.__webglColorRenderbuffer[De]);
            k.__webglDepthRenderbuffer &&
                i.deleteRenderbuffer(k.__webglDepthRenderbuffer);
        }
        const ge = $.textures;
        for (let De = 0, be = ge.length; De < be; De++) {
            const Le = n.get(ge[De]);
            Le.__webglTexture &&
                (i.deleteTexture(Le.__webglTexture), a.memory.textures--),
                n.remove(ge[De]);
        }
        n.remove($);
    }
    let D = 0;
    function H() {
        D = 0;
    }
    function ie() {
        const $ = D;
        return (
            $ >= r.maxTextures &&
                console.warn(
                    'THREE.WebGLTextures: Trying to use ' +
                        $ +
                        ' texture units while this GPU supports only ' +
                        r.maxTextures
                ),
            (D += 1),
            $
        );
    }
    function ee($) {
        const k = [];
        return (
            k.push($.wrapS),
            k.push($.wrapT),
            k.push($.wrapR || 0),
            k.push($.magFilter),
            k.push($.minFilter),
            k.push($.anisotropy),
            k.push($.internalFormat),
            k.push($.format),
            k.push($.type),
            k.push($.generateMipmaps),
            k.push($.premultiplyAlpha),
            k.push($.flipY),
            k.push($.unpackAlignment),
            k.push($.colorSpace),
            k.join()
        );
    }
    function ue($, k) {
        const ge = n.get($);
        if (
            ($.isVideoTexture && St($),
            $.isRenderTargetTexture === !1 &&
                $.version > 0 &&
                ge.__version !== $.version)
        ) {
            const De = $.image;
            if (De === null)
                console.warn(
                    'THREE.WebGLRenderer: Texture marked for update but no image data found.'
                );
            else if (De.complete === !1)
                console.warn(
                    'THREE.WebGLRenderer: Texture marked for update but image is incomplete'
                );
            else {
                Oe(ge, $, k);
                return;
            }
        }
        t.bindTexture(i.TEXTURE_2D, ge.__webglTexture, i.TEXTURE0 + k);
    }
    function Se($, k) {
        const ge = n.get($);
        if ($.version > 0 && ge.__version !== $.version) {
            Oe(ge, $, k);
            return;
        }
        t.bindTexture(i.TEXTURE_2D_ARRAY, ge.__webglTexture, i.TEXTURE0 + k);
    }
    function ce($, k) {
        const ge = n.get($);
        if ($.version > 0 && ge.__version !== $.version) {
            Oe(ge, $, k);
            return;
        }
        t.bindTexture(i.TEXTURE_3D, ge.__webglTexture, i.TEXTURE0 + k);
    }
    function me($, k) {
        const ge = n.get($);
        if ($.version > 0 && ge.__version !== $.version) {
            fe(ge, $, k);
            return;
        }
        t.bindTexture(i.TEXTURE_CUBE_MAP, ge.__webglTexture, i.TEXTURE0 + k);
    }
    const X = {
            [_p]: i.REPEAT,
            [Ms]: i.CLAMP_TO_EDGE,
            [Sp]: i.MIRRORED_REPEAT,
        },
        oe = {
            [Li]: i.NEAREST,
            [CS]: i.NEAREST_MIPMAP_NEAREST,
            [Jf]: i.NEAREST_MIPMAP_LINEAR,
            [hi]: i.LINEAR,
            [Jd]: i.LINEAR_MIPMAP_NEAREST,
            [Io]: i.LINEAR_MIPMAP_LINEAR,
        },
        Q = {
            [OR]: i.NEVER,
            [HR]: i.ALWAYS,
            [kR]: i.LESS,
            [FS]: i.LEQUAL,
            [FR]: i.EQUAL,
            [VR]: i.GEQUAL,
            [BR]: i.GREATER,
            [zR]: i.NOTEQUAL,
        };
    function G($, k) {
        if (
            (k.type === Vr &&
                e.has('OES_texture_float_linear') === !1 &&
                (k.magFilter === hi ||
                    k.magFilter === Jd ||
                    k.magFilter === Jf ||
                    k.magFilter === Io ||
                    k.minFilter === hi ||
                    k.minFilter === Jd ||
                    k.minFilter === Jf ||
                    k.minFilter === Io) &&
                console.warn(
                    'THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device.'
                ),
            i.texParameteri($, i.TEXTURE_WRAP_S, X[k.wrapS]),
            i.texParameteri($, i.TEXTURE_WRAP_T, X[k.wrapT]),
            ($ === i.TEXTURE_3D || $ === i.TEXTURE_2D_ARRAY) &&
                i.texParameteri($, i.TEXTURE_WRAP_R, X[k.wrapR]),
            i.texParameteri($, i.TEXTURE_MAG_FILTER, oe[k.magFilter]),
            i.texParameteri($, i.TEXTURE_MIN_FILTER, oe[k.minFilter]),
            k.compareFunction &&
                (i.texParameteri(
                    $,
                    i.TEXTURE_COMPARE_MODE,
                    i.COMPARE_REF_TO_TEXTURE
                ),
                i.texParameteri(
                    $,
                    i.TEXTURE_COMPARE_FUNC,
                    Q[k.compareFunction]
                )),
            e.has('EXT_texture_filter_anisotropic') === !0)
        ) {
            if (
                k.magFilter === Li ||
                (k.minFilter !== Jf && k.minFilter !== Io) ||
                (k.type === Vr && e.has('OES_texture_float_linear') === !1)
            )
                return;
            if (k.anisotropy > 1 || n.get(k).__currentAnisotropy) {
                const ge = e.get('EXT_texture_filter_anisotropic');
                i.texParameterf(
                    $,
                    ge.TEXTURE_MAX_ANISOTROPY_EXT,
                    Math.min(k.anisotropy, r.getMaxAnisotropy())
                ),
                    (n.get(k).__currentAnisotropy = k.anisotropy);
            }
        }
    }
    function ae($, k) {
        let ge = !1;
        $.__webglInit === void 0 &&
            (($.__webglInit = !0), k.addEventListener('dispose', F));
        const De = k.source;
        let be = y.get(De);
        be === void 0 && ((be = {}), y.set(De, be));
        const Le = ee(k);
        if (Le !== $.__cacheKey) {
            be[Le] === void 0 &&
                ((be[Le] = { texture: i.createTexture(), usedTimes: 0 }),
                a.memory.textures++,
                (ge = !0)),
                be[Le].usedTimes++;
            const _t = be[$.__cacheKey];
            _t !== void 0 &&
                (be[$.__cacheKey].usedTimes--, _t.usedTimes === 0 && z(k)),
                ($.__cacheKey = Le),
                ($.__webglTexture = be[Le].texture);
        }
        return ge;
    }
    function Oe($, k, ge) {
        let De = i.TEXTURE_2D;
        (k.isDataArrayTexture || k.isCompressedArrayTexture) &&
            (De = i.TEXTURE_2D_ARRAY),
            k.isData3DTexture && (De = i.TEXTURE_3D);
        const be = ae($, k),
            Le = k.source;
        t.bindTexture(De, $.__webglTexture, i.TEXTURE0 + ge);
        const _t = n.get(Le);
        if (Le.version !== _t.__version || be === !0) {
            t.activeTexture(i.TEXTURE0 + ge);
            const $e = hn.getPrimaries(hn.workingColorSpace),
                tt = k.colorSpace === Aa ? null : hn.getPrimaries(k.colorSpace),
                Nt =
                    k.colorSpace === Aa || $e === tt
                        ? i.NONE
                        : i.BROWSER_DEFAULT_WEBGL;
            i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, k.flipY),
                i.pixelStorei(
                    i.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
                    k.premultiplyAlpha
                ),
                i.pixelStorei(i.UNPACK_ALIGNMENT, k.unpackAlignment),
                i.pixelStorei(i.UNPACK_COLORSPACE_CONVERSION_WEBGL, Nt);
            let Be = T(k.image, !1, r.maxTextureSize);
            Be = Ze(k, Be);
            const Je = s.convert(k.format, k.colorSpace),
                Kt = s.convert(k.type);
            let bt = b(
                k.internalFormat,
                Je,
                Kt,
                k.colorSpace,
                k.isVideoTexture
            );
            G(De, k);
            let ut;
            const Ut = k.mipmaps,
                zt = k.isVideoTexture !== !0,
                dn = _t.__version === void 0 || be === !0,
                ne = Le.dataReady,
                Ve = L(k, Be);
            if (k.isDepthTexture)
                (bt = C(k.format === lc, k.type)),
                    dn &&
                        (zt
                            ? t.texStorage2D(
                                  i.TEXTURE_2D,
                                  1,
                                  bt,
                                  Be.width,
                                  Be.height
                              )
                            : t.texImage2D(
                                  i.TEXTURE_2D,
                                  0,
                                  bt,
                                  Be.width,
                                  Be.height,
                                  0,
                                  Je,
                                  Kt,
                                  null
                              ));
            else if (k.isDataTexture)
                if (Ut.length > 0) {
                    zt &&
                        dn &&
                        t.texStorage2D(
                            i.TEXTURE_2D,
                            Ve,
                            bt,
                            Ut[0].width,
                            Ut[0].height
                        );
                    for (let Te = 0, Ae = Ut.length; Te < Ae; Te++)
                        (ut = Ut[Te]),
                            zt
                                ? ne &&
                                  t.texSubImage2D(
                                      i.TEXTURE_2D,
                                      Te,
                                      0,
                                      0,
                                      ut.width,
                                      ut.height,
                                      Je,
                                      Kt,
                                      ut.data
                                  )
                                : t.texImage2D(
                                      i.TEXTURE_2D,
                                      Te,
                                      bt,
                                      ut.width,
                                      ut.height,
                                      0,
                                      Je,
                                      Kt,
                                      ut.data
                                  );
                    k.generateMipmaps = !1;
                } else
                    zt
                        ? (dn &&
                              t.texStorage2D(
                                  i.TEXTURE_2D,
                                  Ve,
                                  bt,
                                  Be.width,
                                  Be.height
                              ),
                          ne &&
                              t.texSubImage2D(
                                  i.TEXTURE_2D,
                                  0,
                                  0,
                                  0,
                                  Be.width,
                                  Be.height,
                                  Je,
                                  Kt,
                                  Be.data
                              ))
                        : t.texImage2D(
                              i.TEXTURE_2D,
                              0,
                              bt,
                              Be.width,
                              Be.height,
                              0,
                              Je,
                              Kt,
                              Be.data
                          );
            else if (k.isCompressedTexture)
                if (k.isCompressedArrayTexture) {
                    zt &&
                        dn &&
                        t.texStorage3D(
                            i.TEXTURE_2D_ARRAY,
                            Ve,
                            bt,
                            Ut[0].width,
                            Ut[0].height,
                            Be.depth
                        );
                    for (let Te = 0, Ae = Ut.length; Te < Ae; Te++)
                        if (((ut = Ut[Te]), k.format !== sr))
                            if (Je !== null)
                                if (zt) {
                                    if (ne)
                                        if (k.layerUpdates.size > 0) {
                                            const Ge = __(
                                                ut.width,
                                                ut.height,
                                                k.format,
                                                k.type
                                            );
                                            for (const At of k.layerUpdates) {
                                                const Yt = ut.data.subarray(
                                                    (At * Ge) /
                                                        ut.data
                                                            .BYTES_PER_ELEMENT,
                                                    ((At + 1) * Ge) /
                                                        ut.data
                                                            .BYTES_PER_ELEMENT
                                                );
                                                t.compressedTexSubImage3D(
                                                    i.TEXTURE_2D_ARRAY,
                                                    Te,
                                                    0,
                                                    0,
                                                    At,
                                                    ut.width,
                                                    ut.height,
                                                    1,
                                                    Je,
                                                    Yt,
                                                    0,
                                                    0
                                                );
                                            }
                                            k.clearLayerUpdates();
                                        } else
                                            t.compressedTexSubImage3D(
                                                i.TEXTURE_2D_ARRAY,
                                                Te,
                                                0,
                                                0,
                                                0,
                                                ut.width,
                                                ut.height,
                                                Be.depth,
                                                Je,
                                                ut.data,
                                                0,
                                                0
                                            );
                                } else
                                    t.compressedTexImage3D(
                                        i.TEXTURE_2D_ARRAY,
                                        Te,
                                        bt,
                                        ut.width,
                                        ut.height,
                                        Be.depth,
                                        0,
                                        ut.data,
                                        0,
                                        0
                                    );
                            else
                                console.warn(
                                    'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()'
                                );
                        else
                            zt
                                ? ne &&
                                  t.texSubImage3D(
                                      i.TEXTURE_2D_ARRAY,
                                      Te,
                                      0,
                                      0,
                                      0,
                                      ut.width,
                                      ut.height,
                                      Be.depth,
                                      Je,
                                      Kt,
                                      ut.data
                                  )
                                : t.texImage3D(
                                      i.TEXTURE_2D_ARRAY,
                                      Te,
                                      bt,
                                      ut.width,
                                      ut.height,
                                      Be.depth,
                                      0,
                                      Je,
                                      Kt,
                                      ut.data
                                  );
                } else {
                    zt &&
                        dn &&
                        t.texStorage2D(
                            i.TEXTURE_2D,
                            Ve,
                            bt,
                            Ut[0].width,
                            Ut[0].height
                        );
                    for (let Te = 0, Ae = Ut.length; Te < Ae; Te++)
                        (ut = Ut[Te]),
                            k.format !== sr
                                ? Je !== null
                                    ? zt
                                        ? ne &&
                                          t.compressedTexSubImage2D(
                                              i.TEXTURE_2D,
                                              Te,
                                              0,
                                              0,
                                              ut.width,
                                              ut.height,
                                              Je,
                                              ut.data
                                          )
                                        : t.compressedTexImage2D(
                                              i.TEXTURE_2D,
                                              Te,
                                              bt,
                                              ut.width,
                                              ut.height,
                                              0,
                                              ut.data
                                          )
                                    : console.warn(
                                          'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()'
                                      )
                                : zt
                                  ? ne &&
                                    t.texSubImage2D(
                                        i.TEXTURE_2D,
                                        Te,
                                        0,
                                        0,
                                        ut.width,
                                        ut.height,
                                        Je,
                                        Kt,
                                        ut.data
                                    )
                                  : t.texImage2D(
                                        i.TEXTURE_2D,
                                        Te,
                                        bt,
                                        ut.width,
                                        ut.height,
                                        0,
                                        Je,
                                        Kt,
                                        ut.data
                                    );
                }
            else if (k.isDataArrayTexture)
                if (zt) {
                    if (
                        (dn &&
                            t.texStorage3D(
                                i.TEXTURE_2D_ARRAY,
                                Ve,
                                bt,
                                Be.width,
                                Be.height,
                                Be.depth
                            ),
                        ne)
                    )
                        if (k.layerUpdates.size > 0) {
                            const Te = __(
                                Be.width,
                                Be.height,
                                k.format,
                                k.type
                            );
                            for (const Ae of k.layerUpdates) {
                                const Ge = Be.data.subarray(
                                    (Ae * Te) / Be.data.BYTES_PER_ELEMENT,
                                    ((Ae + 1) * Te) / Be.data.BYTES_PER_ELEMENT
                                );
                                t.texSubImage3D(
                                    i.TEXTURE_2D_ARRAY,
                                    0,
                                    0,
                                    0,
                                    Ae,
                                    Be.width,
                                    Be.height,
                                    1,
                                    Je,
                                    Kt,
                                    Ge
                                );
                            }
                            k.clearLayerUpdates();
                        } else
                            t.texSubImage3D(
                                i.TEXTURE_2D_ARRAY,
                                0,
                                0,
                                0,
                                0,
                                Be.width,
                                Be.height,
                                Be.depth,
                                Je,
                                Kt,
                                Be.data
                            );
                } else
                    t.texImage3D(
                        i.TEXTURE_2D_ARRAY,
                        0,
                        bt,
                        Be.width,
                        Be.height,
                        Be.depth,
                        0,
                        Je,
                        Kt,
                        Be.data
                    );
            else if (k.isData3DTexture)
                zt
                    ? (dn &&
                          t.texStorage3D(
                              i.TEXTURE_3D,
                              Ve,
                              bt,
                              Be.width,
                              Be.height,
                              Be.depth
                          ),
                      ne &&
                          t.texSubImage3D(
                              i.TEXTURE_3D,
                              0,
                              0,
                              0,
                              0,
                              Be.width,
                              Be.height,
                              Be.depth,
                              Je,
                              Kt,
                              Be.data
                          ))
                    : t.texImage3D(
                          i.TEXTURE_3D,
                          0,
                          bt,
                          Be.width,
                          Be.height,
                          Be.depth,
                          0,
                          Je,
                          Kt,
                          Be.data
                      );
            else if (k.isFramebufferTexture) {
                if (dn)
                    if (zt)
                        t.texStorage2D(
                            i.TEXTURE_2D,
                            Ve,
                            bt,
                            Be.width,
                            Be.height
                        );
                    else {
                        let Te = Be.width,
                            Ae = Be.height;
                        for (let Ge = 0; Ge < Ve; Ge++)
                            t.texImage2D(
                                i.TEXTURE_2D,
                                Ge,
                                bt,
                                Te,
                                Ae,
                                0,
                                Je,
                                Kt,
                                null
                            ),
                                (Te >>= 1),
                                (Ae >>= 1);
                    }
            } else if (Ut.length > 0) {
                if (zt && dn) {
                    const Te = ot(Ut[0]);
                    t.texStorage2D(i.TEXTURE_2D, Ve, bt, Te.width, Te.height);
                }
                for (let Te = 0, Ae = Ut.length; Te < Ae; Te++)
                    (ut = Ut[Te]),
                        zt
                            ? ne &&
                              t.texSubImage2D(
                                  i.TEXTURE_2D,
                                  Te,
                                  0,
                                  0,
                                  Je,
                                  Kt,
                                  ut
                              )
                            : t.texImage2D(i.TEXTURE_2D, Te, bt, Je, Kt, ut);
                k.generateMipmaps = !1;
            } else if (zt) {
                if (dn) {
                    const Te = ot(Be);
                    t.texStorage2D(i.TEXTURE_2D, Ve, bt, Te.width, Te.height);
                }
                ne && t.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, Je, Kt, Be);
            } else t.texImage2D(i.TEXTURE_2D, 0, bt, Je, Kt, Be);
            M(k) && w(De),
                (_t.__version = Le.version),
                k.onUpdate && k.onUpdate(k);
        }
        $.__version = k.version;
    }
    function fe($, k, ge) {
        if (k.image.length !== 6) return;
        const De = ae($, k),
            be = k.source;
        t.bindTexture(i.TEXTURE_CUBE_MAP, $.__webglTexture, i.TEXTURE0 + ge);
        const Le = n.get(be);
        if (be.version !== Le.__version || De === !0) {
            t.activeTexture(i.TEXTURE0 + ge);
            const _t = hn.getPrimaries(hn.workingColorSpace),
                $e = k.colorSpace === Aa ? null : hn.getPrimaries(k.colorSpace),
                tt =
                    k.colorSpace === Aa || _t === $e
                        ? i.NONE
                        : i.BROWSER_DEFAULT_WEBGL;
            i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, k.flipY),
                i.pixelStorei(
                    i.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
                    k.premultiplyAlpha
                ),
                i.pixelStorei(i.UNPACK_ALIGNMENT, k.unpackAlignment),
                i.pixelStorei(i.UNPACK_COLORSPACE_CONVERSION_WEBGL, tt);
            const Nt = k.isCompressedTexture || k.image[0].isCompressedTexture,
                Be = k.image[0] && k.image[0].isDataTexture,
                Je = [];
            for (let Ae = 0; Ae < 6; Ae++)
                !Nt && !Be
                    ? (Je[Ae] = T(k.image[Ae], !0, r.maxCubemapSize))
                    : (Je[Ae] = Be ? k.image[Ae].image : k.image[Ae]),
                    (Je[Ae] = Ze(k, Je[Ae]));
            const Kt = Je[0],
                bt = s.convert(k.format, k.colorSpace),
                ut = s.convert(k.type),
                Ut = b(k.internalFormat, bt, ut, k.colorSpace),
                zt = k.isVideoTexture !== !0,
                dn = Le.__version === void 0 || De === !0,
                ne = be.dataReady;
            let Ve = L(k, Kt);
            G(i.TEXTURE_CUBE_MAP, k);
            let Te;
            if (Nt) {
                zt &&
                    dn &&
                    t.texStorage2D(
                        i.TEXTURE_CUBE_MAP,
                        Ve,
                        Ut,
                        Kt.width,
                        Kt.height
                    );
                for (let Ae = 0; Ae < 6; Ae++) {
                    Te = Je[Ae].mipmaps;
                    for (let Ge = 0; Ge < Te.length; Ge++) {
                        const At = Te[Ge];
                        k.format !== sr
                            ? bt !== null
                                ? zt
                                    ? ne &&
                                      t.compressedTexSubImage2D(
                                          i.TEXTURE_CUBE_MAP_POSITIVE_X + Ae,
                                          Ge,
                                          0,
                                          0,
                                          At.width,
                                          At.height,
                                          bt,
                                          At.data
                                      )
                                    : t.compressedTexImage2D(
                                          i.TEXTURE_CUBE_MAP_POSITIVE_X + Ae,
                                          Ge,
                                          Ut,
                                          At.width,
                                          At.height,
                                          0,
                                          At.data
                                      )
                                : console.warn(
                                      'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()'
                                  )
                            : zt
                              ? ne &&
                                t.texSubImage2D(
                                    i.TEXTURE_CUBE_MAP_POSITIVE_X + Ae,
                                    Ge,
                                    0,
                                    0,
                                    At.width,
                                    At.height,
                                    bt,
                                    ut,
                                    At.data
                                )
                              : t.texImage2D(
                                    i.TEXTURE_CUBE_MAP_POSITIVE_X + Ae,
                                    Ge,
                                    Ut,
                                    At.width,
                                    At.height,
                                    0,
                                    bt,
                                    ut,
                                    At.data
                                );
                    }
                }
            } else {
                if (((Te = k.mipmaps), zt && dn)) {
                    Te.length > 0 && Ve++;
                    const Ae = ot(Je[0]);
                    t.texStorage2D(
                        i.TEXTURE_CUBE_MAP,
                        Ve,
                        Ut,
                        Ae.width,
                        Ae.height
                    );
                }
                for (let Ae = 0; Ae < 6; Ae++)
                    if (Be) {
                        zt
                            ? ne &&
                              t.texSubImage2D(
                                  i.TEXTURE_CUBE_MAP_POSITIVE_X + Ae,
                                  0,
                                  0,
                                  0,
                                  Je[Ae].width,
                                  Je[Ae].height,
                                  bt,
                                  ut,
                                  Je[Ae].data
                              )
                            : t.texImage2D(
                                  i.TEXTURE_CUBE_MAP_POSITIVE_X + Ae,
                                  0,
                                  Ut,
                                  Je[Ae].width,
                                  Je[Ae].height,
                                  0,
                                  bt,
                                  ut,
                                  Je[Ae].data
                              );
                        for (let Ge = 0; Ge < Te.length; Ge++) {
                            const Yt = Te[Ge].image[Ae].image;
                            zt
                                ? ne &&
                                  t.texSubImage2D(
                                      i.TEXTURE_CUBE_MAP_POSITIVE_X + Ae,
                                      Ge + 1,
                                      0,
                                      0,
                                      Yt.width,
                                      Yt.height,
                                      bt,
                                      ut,
                                      Yt.data
                                  )
                                : t.texImage2D(
                                      i.TEXTURE_CUBE_MAP_POSITIVE_X + Ae,
                                      Ge + 1,
                                      Ut,
                                      Yt.width,
                                      Yt.height,
                                      0,
                                      bt,
                                      ut,
                                      Yt.data
                                  );
                        }
                    } else {
                        zt
                            ? ne &&
                              t.texSubImage2D(
                                  i.TEXTURE_CUBE_MAP_POSITIVE_X + Ae,
                                  0,
                                  0,
                                  0,
                                  bt,
                                  ut,
                                  Je[Ae]
                              )
                            : t.texImage2D(
                                  i.TEXTURE_CUBE_MAP_POSITIVE_X + Ae,
                                  0,
                                  Ut,
                                  bt,
                                  ut,
                                  Je[Ae]
                              );
                        for (let Ge = 0; Ge < Te.length; Ge++) {
                            const At = Te[Ge];
                            zt
                                ? ne &&
                                  t.texSubImage2D(
                                      i.TEXTURE_CUBE_MAP_POSITIVE_X + Ae,
                                      Ge + 1,
                                      0,
                                      0,
                                      bt,
                                      ut,
                                      At.image[Ae]
                                  )
                                : t.texImage2D(
                                      i.TEXTURE_CUBE_MAP_POSITIVE_X + Ae,
                                      Ge + 1,
                                      Ut,
                                      bt,
                                      ut,
                                      At.image[Ae]
                                  );
                        }
                    }
            }
            M(k) && w(i.TEXTURE_CUBE_MAP),
                (Le.__version = be.version),
                k.onUpdate && k.onUpdate(k);
        }
        $.__version = k.version;
    }
    function we($, k, ge, De, be, Le) {
        const _t = s.convert(ge.format, ge.colorSpace),
            $e = s.convert(ge.type),
            tt = b(ge.internalFormat, _t, $e, ge.colorSpace);
        if (!n.get(k).__hasExternalTextures) {
            const Be = Math.max(1, k.width >> Le),
                Je = Math.max(1, k.height >> Le);
            be === i.TEXTURE_3D || be === i.TEXTURE_2D_ARRAY
                ? t.texImage3D(be, Le, tt, Be, Je, k.depth, 0, _t, $e, null)
                : t.texImage2D(be, Le, tt, Be, Je, 0, _t, $e, null);
        }
        t.bindFramebuffer(i.FRAMEBUFFER, $),
            Ee(k)
                ? l.framebufferTexture2DMultisampleEXT(
                      i.FRAMEBUFFER,
                      De,
                      be,
                      n.get(ge).__webglTexture,
                      0,
                      Ke(k)
                  )
                : (be === i.TEXTURE_2D ||
                      (be >= i.TEXTURE_CUBE_MAP_POSITIVE_X &&
                          be <= i.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
                  i.framebufferTexture2D(
                      i.FRAMEBUFFER,
                      De,
                      be,
                      n.get(ge).__webglTexture,
                      Le
                  ),
            t.bindFramebuffer(i.FRAMEBUFFER, null);
    }
    function Pe($, k, ge) {
        if ((i.bindRenderbuffer(i.RENDERBUFFER, $), k.depthBuffer)) {
            const De = k.depthTexture,
                be = De && De.isDepthTexture ? De.type : null,
                Le = C(k.stencilBuffer, be),
                _t = k.stencilBuffer
                    ? i.DEPTH_STENCIL_ATTACHMENT
                    : i.DEPTH_ATTACHMENT,
                $e = Ke(k);
            Ee(k)
                ? l.renderbufferStorageMultisampleEXT(
                      i.RENDERBUFFER,
                      $e,
                      Le,
                      k.width,
                      k.height
                  )
                : ge
                  ? i.renderbufferStorageMultisample(
                        i.RENDERBUFFER,
                        $e,
                        Le,
                        k.width,
                        k.height
                    )
                  : i.renderbufferStorage(
                        i.RENDERBUFFER,
                        Le,
                        k.width,
                        k.height
                    ),
                i.framebufferRenderbuffer(i.FRAMEBUFFER, _t, i.RENDERBUFFER, $);
        } else {
            const De = k.textures;
            for (let be = 0; be < De.length; be++) {
                const Le = De[be],
                    _t = s.convert(Le.format, Le.colorSpace),
                    $e = s.convert(Le.type),
                    tt = b(Le.internalFormat, _t, $e, Le.colorSpace),
                    Nt = Ke(k);
                ge && Ee(k) === !1
                    ? i.renderbufferStorageMultisample(
                          i.RENDERBUFFER,
                          Nt,
                          tt,
                          k.width,
                          k.height
                      )
                    : Ee(k)
                      ? l.renderbufferStorageMultisampleEXT(
                            i.RENDERBUFFER,
                            Nt,
                            tt,
                            k.width,
                            k.height
                        )
                      : i.renderbufferStorage(
                            i.RENDERBUFFER,
                            tt,
                            k.width,
                            k.height
                        );
            }
        }
        i.bindRenderbuffer(i.RENDERBUFFER, null);
    }
    function Re($, k) {
        if (k && k.isWebGLCubeRenderTarget)
            throw new Error(
                'Depth Texture with cube render targets is not supported'
            );
        if (
            (t.bindFramebuffer(i.FRAMEBUFFER, $),
            !(k.depthTexture && k.depthTexture.isDepthTexture))
        )
            throw new Error(
                'renderTarget.depthTexture must be an instance of THREE.DepthTexture'
            );
        (!n.get(k.depthTexture).__webglTexture ||
            k.depthTexture.image.width !== k.width ||
            k.depthTexture.image.height !== k.height) &&
            ((k.depthTexture.image.width = k.width),
            (k.depthTexture.image.height = k.height),
            (k.depthTexture.needsUpdate = !0)),
            ue(k.depthTexture, 0);
        const De = n.get(k.depthTexture).__webglTexture,
            be = Ke(k);
        if (k.depthTexture.format === ic)
            Ee(k)
                ? l.framebufferTexture2DMultisampleEXT(
                      i.FRAMEBUFFER,
                      i.DEPTH_ATTACHMENT,
                      i.TEXTURE_2D,
                      De,
                      0,
                      be
                  )
                : i.framebufferTexture2D(
                      i.FRAMEBUFFER,
                      i.DEPTH_ATTACHMENT,
                      i.TEXTURE_2D,
                      De,
                      0
                  );
        else if (k.depthTexture.format === lc)
            Ee(k)
                ? l.framebufferTexture2DMultisampleEXT(
                      i.FRAMEBUFFER,
                      i.DEPTH_STENCIL_ATTACHMENT,
                      i.TEXTURE_2D,
                      De,
                      0,
                      be
                  )
                : i.framebufferTexture2D(
                      i.FRAMEBUFFER,
                      i.DEPTH_STENCIL_ATTACHMENT,
                      i.TEXTURE_2D,
                      De,
                      0
                  );
        else throw new Error('Unknown depthTexture format');
    }
    function Ye($) {
        const k = n.get($),
            ge = $.isWebGLCubeRenderTarget === !0;
        if ($.depthTexture && !k.__autoAllocateDepthBuffer) {
            if (ge)
                throw new Error(
                    'target.depthTexture not supported in Cube render targets'
                );
            Re(k.__webglFramebuffer, $);
        } else if (ge) {
            k.__webglDepthbuffer = [];
            for (let De = 0; De < 6; De++)
                t.bindFramebuffer(i.FRAMEBUFFER, k.__webglFramebuffer[De]),
                    (k.__webglDepthbuffer[De] = i.createRenderbuffer()),
                    Pe(k.__webglDepthbuffer[De], $, !1);
        } else
            t.bindFramebuffer(i.FRAMEBUFFER, k.__webglFramebuffer),
                (k.__webglDepthbuffer = i.createRenderbuffer()),
                Pe(k.__webglDepthbuffer, $, !1);
        t.bindFramebuffer(i.FRAMEBUFFER, null);
    }
    function lt($, k, ge) {
        const De = n.get($);
        k !== void 0 &&
            we(
                De.__webglFramebuffer,
                $,
                $.texture,
                i.COLOR_ATTACHMENT0,
                i.TEXTURE_2D,
                0
            ),
            ge !== void 0 && Ye($);
    }
    function dt($) {
        const k = $.texture,
            ge = n.get($),
            De = n.get(k);
        $.addEventListener('dispose', N);
        const be = $.textures,
            Le = $.isWebGLCubeRenderTarget === !0,
            _t = be.length > 1;
        if (
            (_t ||
                (De.__webglTexture === void 0 &&
                    (De.__webglTexture = i.createTexture()),
                (De.__version = k.version),
                a.memory.textures++),
            Le)
        ) {
            ge.__webglFramebuffer = [];
            for (let $e = 0; $e < 6; $e++)
                if (k.mipmaps && k.mipmaps.length > 0) {
                    ge.__webglFramebuffer[$e] = [];
                    for (let tt = 0; tt < k.mipmaps.length; tt++)
                        ge.__webglFramebuffer[$e][tt] = i.createFramebuffer();
                } else ge.__webglFramebuffer[$e] = i.createFramebuffer();
        } else {
            if (k.mipmaps && k.mipmaps.length > 0) {
                ge.__webglFramebuffer = [];
                for (let $e = 0; $e < k.mipmaps.length; $e++)
                    ge.__webglFramebuffer[$e] = i.createFramebuffer();
            } else ge.__webglFramebuffer = i.createFramebuffer();
            if (_t)
                for (let $e = 0, tt = be.length; $e < tt; $e++) {
                    const Nt = n.get(be[$e]);
                    Nt.__webglTexture === void 0 &&
                        ((Nt.__webglTexture = i.createTexture()),
                        a.memory.textures++);
                }
            if ($.samples > 0 && Ee($) === !1) {
                (ge.__webglMultisampledFramebuffer = i.createFramebuffer()),
                    (ge.__webglColorRenderbuffer = []),
                    t.bindFramebuffer(
                        i.FRAMEBUFFER,
                        ge.__webglMultisampledFramebuffer
                    );
                for (let $e = 0; $e < be.length; $e++) {
                    const tt = be[$e];
                    (ge.__webglColorRenderbuffer[$e] = i.createRenderbuffer()),
                        i.bindRenderbuffer(
                            i.RENDERBUFFER,
                            ge.__webglColorRenderbuffer[$e]
                        );
                    const Nt = s.convert(tt.format, tt.colorSpace),
                        Be = s.convert(tt.type),
                        Je = b(
                            tt.internalFormat,
                            Nt,
                            Be,
                            tt.colorSpace,
                            $.isXRRenderTarget === !0
                        ),
                        Kt = Ke($);
                    i.renderbufferStorageMultisample(
                        i.RENDERBUFFER,
                        Kt,
                        Je,
                        $.width,
                        $.height
                    ),
                        i.framebufferRenderbuffer(
                            i.FRAMEBUFFER,
                            i.COLOR_ATTACHMENT0 + $e,
                            i.RENDERBUFFER,
                            ge.__webglColorRenderbuffer[$e]
                        );
                }
                i.bindRenderbuffer(i.RENDERBUFFER, null),
                    $.depthBuffer &&
                        ((ge.__webglDepthRenderbuffer = i.createRenderbuffer()),
                        Pe(ge.__webglDepthRenderbuffer, $, !0)),
                    t.bindFramebuffer(i.FRAMEBUFFER, null);
            }
        }
        if (Le) {
            t.bindTexture(i.TEXTURE_CUBE_MAP, De.__webglTexture),
                G(i.TEXTURE_CUBE_MAP, k);
            for (let $e = 0; $e < 6; $e++)
                if (k.mipmaps && k.mipmaps.length > 0)
                    for (let tt = 0; tt < k.mipmaps.length; tt++)
                        we(
                            ge.__webglFramebuffer[$e][tt],
                            $,
                            k,
                            i.COLOR_ATTACHMENT0,
                            i.TEXTURE_CUBE_MAP_POSITIVE_X + $e,
                            tt
                        );
                else
                    we(
                        ge.__webglFramebuffer[$e],
                        $,
                        k,
                        i.COLOR_ATTACHMENT0,
                        i.TEXTURE_CUBE_MAP_POSITIVE_X + $e,
                        0
                    );
            M(k) && w(i.TEXTURE_CUBE_MAP), t.unbindTexture();
        } else if (_t) {
            for (let $e = 0, tt = be.length; $e < tt; $e++) {
                const Nt = be[$e],
                    Be = n.get(Nt);
                t.bindTexture(i.TEXTURE_2D, Be.__webglTexture),
                    G(i.TEXTURE_2D, Nt),
                    we(
                        ge.__webglFramebuffer,
                        $,
                        Nt,
                        i.COLOR_ATTACHMENT0 + $e,
                        i.TEXTURE_2D,
                        0
                    ),
                    M(Nt) && w(i.TEXTURE_2D);
            }
            t.unbindTexture();
        } else {
            let $e = i.TEXTURE_2D;
            if (
                (($.isWebGL3DRenderTarget || $.isWebGLArrayRenderTarget) &&
                    ($e = $.isWebGL3DRenderTarget
                        ? i.TEXTURE_3D
                        : i.TEXTURE_2D_ARRAY),
                t.bindTexture($e, De.__webglTexture),
                G($e, k),
                k.mipmaps && k.mipmaps.length > 0)
            )
                for (let tt = 0; tt < k.mipmaps.length; tt++)
                    we(
                        ge.__webglFramebuffer[tt],
                        $,
                        k,
                        i.COLOR_ATTACHMENT0,
                        $e,
                        tt
                    );
            else we(ge.__webglFramebuffer, $, k, i.COLOR_ATTACHMENT0, $e, 0);
            M(k) && w($e), t.unbindTexture();
        }
        $.depthBuffer && Ye($);
    }
    function Lt($) {
        const k = $.textures;
        for (let ge = 0, De = k.length; ge < De; ge++) {
            const be = k[ge];
            if (M(be)) {
                const Le = $.isWebGLCubeRenderTarget
                        ? i.TEXTURE_CUBE_MAP
                        : i.TEXTURE_2D,
                    _t = n.get(be).__webglTexture;
                t.bindTexture(Le, _t), w(Le), t.unbindTexture();
            }
        }
    }
    const W = [],
        Ie = [];
    function ke($) {
        if ($.samples > 0) {
            if (Ee($) === !1) {
                const k = $.textures,
                    ge = $.width,
                    De = $.height;
                let be = i.COLOR_BUFFER_BIT;
                const Le = $.stencilBuffer
                        ? i.DEPTH_STENCIL_ATTACHMENT
                        : i.DEPTH_ATTACHMENT,
                    _t = n.get($),
                    $e = k.length > 1;
                if ($e)
                    for (let tt = 0; tt < k.length; tt++)
                        t.bindFramebuffer(
                            i.FRAMEBUFFER,
                            _t.__webglMultisampledFramebuffer
                        ),
                            i.framebufferRenderbuffer(
                                i.FRAMEBUFFER,
                                i.COLOR_ATTACHMENT0 + tt,
                                i.RENDERBUFFER,
                                null
                            ),
                            t.bindFramebuffer(
                                i.FRAMEBUFFER,
                                _t.__webglFramebuffer
                            ),
                            i.framebufferTexture2D(
                                i.DRAW_FRAMEBUFFER,
                                i.COLOR_ATTACHMENT0 + tt,
                                i.TEXTURE_2D,
                                null,
                                0
                            );
                t.bindFramebuffer(
                    i.READ_FRAMEBUFFER,
                    _t.__webglMultisampledFramebuffer
                ),
                    t.bindFramebuffer(
                        i.DRAW_FRAMEBUFFER,
                        _t.__webglFramebuffer
                    );
                for (let tt = 0; tt < k.length; tt++) {
                    if (
                        ($.resolveDepthBuffer &&
                            ($.depthBuffer && (be |= i.DEPTH_BUFFER_BIT),
                            $.stencilBuffer &&
                                $.resolveStencilBuffer &&
                                (be |= i.STENCIL_BUFFER_BIT)),
                        $e)
                    ) {
                        i.framebufferRenderbuffer(
                            i.READ_FRAMEBUFFER,
                            i.COLOR_ATTACHMENT0,
                            i.RENDERBUFFER,
                            _t.__webglColorRenderbuffer[tt]
                        );
                        const Nt = n.get(k[tt]).__webglTexture;
                        i.framebufferTexture2D(
                            i.DRAW_FRAMEBUFFER,
                            i.COLOR_ATTACHMENT0,
                            i.TEXTURE_2D,
                            Nt,
                            0
                        );
                    }
                    i.blitFramebuffer(
                        0,
                        0,
                        ge,
                        De,
                        0,
                        0,
                        ge,
                        De,
                        be,
                        i.NEAREST
                    ),
                        c === !0 &&
                            ((W.length = 0),
                            (Ie.length = 0),
                            W.push(i.COLOR_ATTACHMENT0 + tt),
                            $.depthBuffer &&
                                $.resolveDepthBuffer === !1 &&
                                (W.push(Le),
                                Ie.push(Le),
                                i.invalidateFramebuffer(
                                    i.DRAW_FRAMEBUFFER,
                                    Ie
                                )),
                            i.invalidateFramebuffer(i.READ_FRAMEBUFFER, W));
                }
                if (
                    (t.bindFramebuffer(i.READ_FRAMEBUFFER, null),
                    t.bindFramebuffer(i.DRAW_FRAMEBUFFER, null),
                    $e)
                )
                    for (let tt = 0; tt < k.length; tt++) {
                        t.bindFramebuffer(
                            i.FRAMEBUFFER,
                            _t.__webglMultisampledFramebuffer
                        ),
                            i.framebufferRenderbuffer(
                                i.FRAMEBUFFER,
                                i.COLOR_ATTACHMENT0 + tt,
                                i.RENDERBUFFER,
                                _t.__webglColorRenderbuffer[tt]
                            );
                        const Nt = n.get(k[tt]).__webglTexture;
                        t.bindFramebuffer(i.FRAMEBUFFER, _t.__webglFramebuffer),
                            i.framebufferTexture2D(
                                i.DRAW_FRAMEBUFFER,
                                i.COLOR_ATTACHMENT0 + tt,
                                i.TEXTURE_2D,
                                Nt,
                                0
                            );
                    }
                t.bindFramebuffer(
                    i.DRAW_FRAMEBUFFER,
                    _t.__webglMultisampledFramebuffer
                );
            } else if ($.depthBuffer && $.resolveDepthBuffer === !1 && c) {
                const k = $.stencilBuffer
                    ? i.DEPTH_STENCIL_ATTACHMENT
                    : i.DEPTH_ATTACHMENT;
                i.invalidateFramebuffer(i.DRAW_FRAMEBUFFER, [k]);
            }
        }
    }
    function Ke($) {
        return Math.min(r.maxSamples, $.samples);
    }
    function Ee($) {
        const k = n.get($);
        return (
            $.samples > 0 &&
            e.has('WEBGL_multisampled_render_to_texture') === !0 &&
            k.__useRenderToTexture !== !1
        );
    }
    function St($) {
        const k = a.render.frame;
        p.get($) !== k && (p.set($, k), $.update());
    }
    function Ze($, k) {
        const ge = $.colorSpace,
            De = $.format,
            be = $.type;
        return (
            $.isCompressedTexture === !0 ||
                $.isVideoTexture === !0 ||
                (ge !== Fa &&
                    ge !== Aa &&
                    (hn.getTransfer(ge) === Pn
                        ? (De !== sr || be !== ao) &&
                          console.warn(
                              'THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.'
                          )
                        : console.error(
                              'THREE.WebGLTextures: Unsupported texture color space:',
                              ge
                          ))),
            k
        );
    }
    function ot($) {
        return (
            typeof HTMLImageElement < 'u' && $ instanceof HTMLImageElement
                ? ((d.width = $.naturalWidth || $.width),
                  (d.height = $.naturalHeight || $.height))
                : typeof VideoFrame < 'u' && $ instanceof VideoFrame
                  ? ((d.width = $.displayWidth), (d.height = $.displayHeight))
                  : ((d.width = $.width), (d.height = $.height)),
            d
        );
    }
    (this.allocateTextureUnit = ie),
        (this.resetTextureUnits = H),
        (this.setTexture2D = ue),
        (this.setTexture2DArray = Se),
        (this.setTexture3D = ce),
        (this.setTextureCube = me),
        (this.rebindTextures = lt),
        (this.setupRenderTarget = dt),
        (this.updateRenderTargetMipmap = Lt),
        (this.updateMultisampleRenderTarget = ke),
        (this.setupDepthRenderbuffer = Ye),
        (this.setupFrameBufferTexture = we),
        (this.useMultisampledRTT = Ee);
}
function ib(i, e) {
    function t(n, r = Aa) {
        let s;
        const a = hn.getTransfer(r);
        if (n === ao) return i.UNSIGNED_BYTE;
        if (n === cv) return i.UNSIGNED_SHORT_4_4_4_4;
        if (n === fv) return i.UNSIGNED_SHORT_5_5_5_1;
        if (n === PS) return i.UNSIGNED_INT_5_9_9_9_REV;
        if (n === RS) return i.BYTE;
        if (n === bS) return i.SHORT;
        if (n === ch) return i.UNSIGNED_SHORT;
        if (n === uv) return i.INT;
        if (n === Oa) return i.UNSIGNED_INT;
        if (n === Vr) return i.FLOAT;
        if (n === Mh) return i.HALF_FLOAT;
        if (n === LS) return i.ALPHA;
        if (n === IS) return i.RGB;
        if (n === sr) return i.RGBA;
        if (n === DS) return i.LUMINANCE;
        if (n === NS) return i.LUMINANCE_ALPHA;
        if (n === ic) return i.DEPTH_COMPONENT;
        if (n === lc) return i.DEPTH_STENCIL;
        if (n === hv) return i.RED;
        if (n === $p) return i.RED_INTEGER;
        if (n === US) return i.RG;
        if (n === dv) return i.RG_INTEGER;
        if (n === pv) return i.RGBA_INTEGER;
        if (n === Qd || n === ep || n === tp || n === np)
            if (a === Pn)
                if (
                    ((s = e.get('WEBGL_compressed_texture_s3tc_srgb')),
                    s !== null)
                ) {
                    if (n === Qd) return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                    if (n === ep) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                    if (n === tp) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                    if (n === np) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
                } else return null;
            else if (
                ((s = e.get('WEBGL_compressed_texture_s3tc')), s !== null)
            ) {
                if (n === Qd) return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (n === ep) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (n === tp) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (n === np) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT;
            } else return null;
        if (n === vy || n === xy || n === _y || n === Sy)
            if (((s = e.get('WEBGL_compressed_texture_pvrtc')), s !== null)) {
                if (n === vy) return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (n === xy) return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (n === _y) return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (n === Sy) return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
            } else return null;
        if (n === wy || n === My || n === Ey)
            if (((s = e.get('WEBGL_compressed_texture_etc')), s !== null)) {
                if (n === wy || n === My)
                    return a === Pn
                        ? s.COMPRESSED_SRGB8_ETC2
                        : s.COMPRESSED_RGB8_ETC2;
                if (n === Ey)
                    return a === Pn
                        ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
                        : s.COMPRESSED_RGBA8_ETC2_EAC;
            } else return null;
        if (
            n === Ty ||
            n === Ay ||
            n === Cy ||
            n === Ry ||
            n === by ||
            n === Py ||
            n === Ly ||
            n === Iy ||
            n === Dy ||
            n === Ny ||
            n === Uy ||
            n === Oy ||
            n === ky ||
            n === Fy
        )
            if (((s = e.get('WEBGL_compressed_texture_astc')), s !== null)) {
                if (n === Ty)
                    return a === Pn
                        ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
                        : s.COMPRESSED_RGBA_ASTC_4x4_KHR;
                if (n === Ay)
                    return a === Pn
                        ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
                        : s.COMPRESSED_RGBA_ASTC_5x4_KHR;
                if (n === Cy)
                    return a === Pn
                        ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
                        : s.COMPRESSED_RGBA_ASTC_5x5_KHR;
                if (n === Ry)
                    return a === Pn
                        ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
                        : s.COMPRESSED_RGBA_ASTC_6x5_KHR;
                if (n === by)
                    return a === Pn
                        ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
                        : s.COMPRESSED_RGBA_ASTC_6x6_KHR;
                if (n === Py)
                    return a === Pn
                        ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
                        : s.COMPRESSED_RGBA_ASTC_8x5_KHR;
                if (n === Ly)
                    return a === Pn
                        ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
                        : s.COMPRESSED_RGBA_ASTC_8x6_KHR;
                if (n === Iy)
                    return a === Pn
                        ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
                        : s.COMPRESSED_RGBA_ASTC_8x8_KHR;
                if (n === Dy)
                    return a === Pn
                        ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
                        : s.COMPRESSED_RGBA_ASTC_10x5_KHR;
                if (n === Ny)
                    return a === Pn
                        ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
                        : s.COMPRESSED_RGBA_ASTC_10x6_KHR;
                if (n === Uy)
                    return a === Pn
                        ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
                        : s.COMPRESSED_RGBA_ASTC_10x8_KHR;
                if (n === Oy)
                    return a === Pn
                        ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
                        : s.COMPRESSED_RGBA_ASTC_10x10_KHR;
                if (n === ky)
                    return a === Pn
                        ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
                        : s.COMPRESSED_RGBA_ASTC_12x10_KHR;
                if (n === Fy)
                    return a === Pn
                        ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
                        : s.COMPRESSED_RGBA_ASTC_12x12_KHR;
            } else return null;
        if (n === ip || n === By || n === zy)
            if (((s = e.get('EXT_texture_compression_bptc')), s !== null)) {
                if (n === ip)
                    return a === Pn
                        ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
                        : s.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                if (n === By) return s.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                if (n === zy) return s.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
            } else return null;
        if (n === OS || n === Vy || n === Hy || n === Gy)
            if (((s = e.get('EXT_texture_compression_rgtc')), s !== null)) {
                if (n === ip) return s.COMPRESSED_RED_RGTC1_EXT;
                if (n === Vy) return s.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                if (n === Hy) return s.COMPRESSED_RED_GREEN_RGTC2_EXT;
                if (n === Gy) return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
            } else return null;
        return n === ac ? i.UNSIGNED_INT_24_8 : i[n] !== void 0 ? i[n] : null;
    }
    return { convert: t };
}
class rb extends Pi {
    constructor(e = []) {
        super(), (this.isArrayCamera = !0), (this.cameras = e);
    }
}
class th extends ln {
    constructor() {
        super(), (this.isGroup = !0), (this.type = 'Group');
    }
}
const aV = { type: 'move' };
class cx {
    constructor() {
        (this._targetRay = null), (this._grip = null), (this._hand = null);
    }
    getHandSpace() {
        return (
            this._hand === null &&
                ((this._hand = new th()),
                (this._hand.matrixAutoUpdate = !1),
                (this._hand.visible = !1),
                (this._hand.joints = {}),
                (this._hand.inputState = { pinching: !1 })),
            this._hand
        );
    }
    getTargetRaySpace() {
        return (
            this._targetRay === null &&
                ((this._targetRay = new th()),
                (this._targetRay.matrixAutoUpdate = !1),
                (this._targetRay.visible = !1),
                (this._targetRay.hasLinearVelocity = !1),
                (this._targetRay.linearVelocity = new j()),
                (this._targetRay.hasAngularVelocity = !1),
                (this._targetRay.angularVelocity = new j())),
            this._targetRay
        );
    }
    getGripSpace() {
        return (
            this._grip === null &&
                ((this._grip = new th()),
                (this._grip.matrixAutoUpdate = !1),
                (this._grip.visible = !1),
                (this._grip.hasLinearVelocity = !1),
                (this._grip.linearVelocity = new j()),
                (this._grip.hasAngularVelocity = !1),
                (this._grip.angularVelocity = new j())),
            this._grip
        );
    }
    dispatchEvent(e) {
        return (
            this._targetRay !== null && this._targetRay.dispatchEvent(e),
            this._grip !== null && this._grip.dispatchEvent(e),
            this._hand !== null && this._hand.dispatchEvent(e),
            this
        );
    }
    connect(e) {
        if (e && e.hand) {
            const t = this._hand;
            if (t) for (const n of e.hand.values()) this._getHandJoint(t, n);
        }
        return this.dispatchEvent({ type: 'connected', data: e }), this;
    }
    disconnect(e) {
        return (
            this.dispatchEvent({ type: 'disconnected', data: e }),
            this._targetRay !== null && (this._targetRay.visible = !1),
            this._grip !== null && (this._grip.visible = !1),
            this._hand !== null && (this._hand.visible = !1),
            this
        );
    }
    update(e, t, n) {
        let r = null,
            s = null,
            a = null;
        const l = this._targetRay,
            c = this._grip,
            d = this._hand;
        if (e && t.session.visibilityState !== 'visible-blurred') {
            if (d && e.hand) {
                a = !0;
                for (const T of e.hand.values()) {
                    const M = t.getJointPose(T, n),
                        w = this._getHandJoint(d, T);
                    M !== null &&
                        (w.matrix.fromArray(M.transform.matrix),
                        w.matrix.decompose(w.position, w.rotation, w.scale),
                        (w.matrixWorldNeedsUpdate = !0),
                        (w.jointRadius = M.radius)),
                        (w.visible = M !== null);
                }
                const p = d.joints['index-finger-tip'],
                    g = d.joints['thumb-tip'],
                    y = p.position.distanceTo(g.position),
                    v = 0.02,
                    S = 0.005;
                d.inputState.pinching && y > v + S
                    ? ((d.inputState.pinching = !1),
                      this.dispatchEvent({
                          type: 'pinchend',
                          handedness: e.handedness,
                          target: this,
                      }))
                    : !d.inputState.pinching &&
                      y <= v - S &&
                      ((d.inputState.pinching = !0),
                      this.dispatchEvent({
                          type: 'pinchstart',
                          handedness: e.handedness,
                          target: this,
                      }));
            } else
                c !== null &&
                    e.gripSpace &&
                    ((s = t.getPose(e.gripSpace, n)),
                    s !== null &&
                        (c.matrix.fromArray(s.transform.matrix),
                        c.matrix.decompose(c.position, c.rotation, c.scale),
                        (c.matrixWorldNeedsUpdate = !0),
                        s.linearVelocity
                            ? ((c.hasLinearVelocity = !0),
                              c.linearVelocity.copy(s.linearVelocity))
                            : (c.hasLinearVelocity = !1),
                        s.angularVelocity
                            ? ((c.hasAngularVelocity = !0),
                              c.angularVelocity.copy(s.angularVelocity))
                            : (c.hasAngularVelocity = !1)));
            l !== null &&
                ((r = t.getPose(e.targetRaySpace, n)),
                r === null && s !== null && (r = s),
                r !== null &&
                    (l.matrix.fromArray(r.transform.matrix),
                    l.matrix.decompose(l.position, l.rotation, l.scale),
                    (l.matrixWorldNeedsUpdate = !0),
                    r.linearVelocity
                        ? ((l.hasLinearVelocity = !0),
                          l.linearVelocity.copy(r.linearVelocity))
                        : (l.hasLinearVelocity = !1),
                    r.angularVelocity
                        ? ((l.hasAngularVelocity = !0),
                          l.angularVelocity.copy(r.angularVelocity))
                        : (l.hasAngularVelocity = !1),
                    this.dispatchEvent(aV)));
        }
        return (
            l !== null && (l.visible = r !== null),
            c !== null && (c.visible = s !== null),
            d !== null && (d.visible = a !== null),
            this
        );
    }
    _getHandJoint(e, t) {
        if (e.joints[t.jointName] === void 0) {
            const n = new th();
            (n.matrixAutoUpdate = !1),
                (n.visible = !1),
                (e.joints[t.jointName] = n),
                e.add(n);
        }
        return e.joints[t.jointName];
    }
}
const lV = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`,
    uV = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class cV {
    constructor() {
        (this.texture = null),
            (this.mesh = null),
            (this.depthNear = 0),
            (this.depthFar = 0);
    }
    init(e, t, n) {
        if (this.texture === null) {
            const r = new Qn(),
                s = e.properties.get(r);
            (s.__webglTexture = t.texture),
                (t.depthNear != n.depthNear || t.depthFar != n.depthFar) &&
                    ((this.depthNear = t.depthNear),
                    (this.depthFar = t.depthFar)),
                (this.texture = r);
        }
    }
    getMesh(e) {
        if (this.texture !== null && this.mesh === null) {
            const t = e.cameras[0].viewport,
                n = new Ts({
                    vertexShader: lV,
                    fragmentShader: uV,
                    uniforms: {
                        depthColor: { value: this.texture },
                        depthWidth: { value: t.z },
                        depthHeight: { value: t.w },
                    },
                });
            this.mesh = new di(new Th(20, 20), n);
        }
        return this.mesh;
    }
    reset() {
        (this.texture = null), (this.mesh = null);
    }
    getDepthTexture() {
        return this.texture;
    }
}
class fV extends Ba {
    constructor(e, t) {
        super();
        const n = this;
        let r = null,
            s = 1,
            a = null,
            l = 'local-floor',
            c = 1,
            d = null,
            p = null,
            g = null,
            y = null,
            v = null,
            S = null;
        const T = new cV(),
            M = t.getContextAttributes();
        let w = null,
            b = null;
        const C = [],
            L = [],
            F = new Ce();
        let N = null;
        const B = new Pi();
        B.layers.enable(1), (B.viewport = new gn());
        const z = new Pi();
        z.layers.enable(2), (z.viewport = new gn());
        const U = [B, z],
            D = new rb();
        D.layers.enable(1), D.layers.enable(2);
        let H = null,
            ie = null;
        (this.cameraAutoUpdate = !0),
            (this.enabled = !1),
            (this.isPresenting = !1),
            (this.getController = function (fe) {
                let we = C[fe];
                return (
                    we === void 0 && ((we = new cx()), (C[fe] = we)),
                    we.getTargetRaySpace()
                );
            }),
            (this.getControllerGrip = function (fe) {
                let we = C[fe];
                return (
                    we === void 0 && ((we = new cx()), (C[fe] = we)),
                    we.getGripSpace()
                );
            }),
            (this.getHand = function (fe) {
                let we = C[fe];
                return (
                    we === void 0 && ((we = new cx()), (C[fe] = we)),
                    we.getHandSpace()
                );
            });
        function ee(fe) {
            const we = L.indexOf(fe.inputSource);
            if (we === -1) return;
            const Pe = C[we];
            Pe !== void 0 &&
                (Pe.update(fe.inputSource, fe.frame, d || a),
                Pe.dispatchEvent({ type: fe.type, data: fe.inputSource }));
        }
        function ue() {
            r.removeEventListener('select', ee),
                r.removeEventListener('selectstart', ee),
                r.removeEventListener('selectend', ee),
                r.removeEventListener('squeeze', ee),
                r.removeEventListener('squeezestart', ee),
                r.removeEventListener('squeezeend', ee),
                r.removeEventListener('end', ue),
                r.removeEventListener('inputsourceschange', Se);
            for (let fe = 0; fe < C.length; fe++) {
                const we = L[fe];
                we !== null && ((L[fe] = null), C[fe].disconnect(we));
            }
            (H = null),
                (ie = null),
                T.reset(),
                e.setRenderTarget(w),
                (v = null),
                (y = null),
                (g = null),
                (r = null),
                (b = null),
                Oe.stop(),
                (n.isPresenting = !1),
                e.setPixelRatio(N),
                e.setSize(F.width, F.height, !1),
                n.dispatchEvent({ type: 'sessionend' });
        }
        (this.setFramebufferScaleFactor = function (fe) {
            (s = fe),
                n.isPresenting === !0 &&
                    console.warn(
                        'THREE.WebXRManager: Cannot change framebuffer scale while presenting.'
                    );
        }),
            (this.setReferenceSpaceType = function (fe) {
                (l = fe),
                    n.isPresenting === !0 &&
                        console.warn(
                            'THREE.WebXRManager: Cannot change reference space type while presenting.'
                        );
            }),
            (this.getReferenceSpace = function () {
                return d || a;
            }),
            (this.setReferenceSpace = function (fe) {
                d = fe;
            }),
            (this.getBaseLayer = function () {
                return y !== null ? y : v;
            }),
            (this.getBinding = function () {
                return g;
            }),
            (this.getFrame = function () {
                return S;
            }),
            (this.getSession = function () {
                return r;
            }),
            (this.setSession = async function (fe) {
                if (((r = fe), r !== null)) {
                    if (
                        ((w = e.getRenderTarget()),
                        r.addEventListener('select', ee),
                        r.addEventListener('selectstart', ee),
                        r.addEventListener('selectend', ee),
                        r.addEventListener('squeeze', ee),
                        r.addEventListener('squeezestart', ee),
                        r.addEventListener('squeezeend', ee),
                        r.addEventListener('end', ue),
                        r.addEventListener('inputsourceschange', Se),
                        M.xrCompatible !== !0 && (await t.makeXRCompatible()),
                        (N = e.getPixelRatio()),
                        e.getSize(F),
                        r.renderState.layers === void 0)
                    ) {
                        const we = {
                            antialias: M.antialias,
                            alpha: !0,
                            depth: M.depth,
                            stencil: M.stencil,
                            framebufferScaleFactor: s,
                        };
                        (v = new XRWebGLLayer(r, t, we)),
                            r.updateRenderState({ baseLayer: v }),
                            e.setPixelRatio(1),
                            e.setSize(
                                v.framebufferWidth,
                                v.framebufferHeight,
                                !1
                            ),
                            (b = new lo(
                                v.framebufferWidth,
                                v.framebufferHeight,
                                {
                                    format: sr,
                                    type: ao,
                                    colorSpace: e.outputColorSpace,
                                    stencilBuffer: M.stencil,
                                }
                            ));
                    } else {
                        let we = null,
                            Pe = null,
                            Re = null;
                        M.depth &&
                            ((Re = M.stencil
                                ? t.DEPTH24_STENCIL8
                                : t.DEPTH_COMPONENT24),
                            (we = M.stencil ? lc : ic),
                            (Pe = M.stencil ? ac : Oa));
                        const Ye = {
                            colorFormat: t.RGBA8,
                            depthFormat: Re,
                            scaleFactor: s,
                        };
                        (g = new XRWebGLBinding(r, t)),
                            (y = g.createProjectionLayer(Ye)),
                            r.updateRenderState({ layers: [y] }),
                            e.setPixelRatio(1),
                            e.setSize(y.textureWidth, y.textureHeight, !1),
                            (b = new lo(y.textureWidth, y.textureHeight, {
                                format: sr,
                                type: ao,
                                depthTexture: new jS(
                                    y.textureWidth,
                                    y.textureHeight,
                                    Pe,
                                    void 0,
                                    void 0,
                                    void 0,
                                    void 0,
                                    void 0,
                                    void 0,
                                    we
                                ),
                                stencilBuffer: M.stencil,
                                colorSpace: e.outputColorSpace,
                                samples: M.antialias ? 4 : 0,
                                resolveDepthBuffer: y.ignoreDepthValues === !1,
                            }));
                    }
                    (b.isXRRenderTarget = !0),
                        this.setFoveation(c),
                        (d = null),
                        (a = await r.requestReferenceSpace(l)),
                        Oe.setContext(r),
                        Oe.start(),
                        (n.isPresenting = !0),
                        n.dispatchEvent({ type: 'sessionstart' });
                }
            }),
            (this.getEnvironmentBlendMode = function () {
                if (r !== null) return r.environmentBlendMode;
            }),
            (this.getDepthTexture = function () {
                return T.getDepthTexture();
            });
        function Se(fe) {
            for (let we = 0; we < fe.removed.length; we++) {
                const Pe = fe.removed[we],
                    Re = L.indexOf(Pe);
                Re >= 0 && ((L[Re] = null), C[Re].disconnect(Pe));
            }
            for (let we = 0; we < fe.added.length; we++) {
                const Pe = fe.added[we];
                let Re = L.indexOf(Pe);
                if (Re === -1) {
                    for (let lt = 0; lt < C.length; lt++)
                        if (lt >= L.length) {
                            L.push(Pe), (Re = lt);
                            break;
                        } else if (L[lt] === null) {
                            (L[lt] = Pe), (Re = lt);
                            break;
                        }
                    if (Re === -1) break;
                }
                const Ye = C[Re];
                Ye && Ye.connect(Pe);
            }
        }
        const ce = new j(),
            me = new j();
        function X(fe, we, Pe) {
            ce.setFromMatrixPosition(we.matrixWorld),
                me.setFromMatrixPosition(Pe.matrixWorld);
            const Re = ce.distanceTo(me),
                Ye = we.projectionMatrix.elements,
                lt = Pe.projectionMatrix.elements,
                dt = Ye[14] / (Ye[10] - 1),
                Lt = Ye[14] / (Ye[10] + 1),
                W = (Ye[9] + 1) / Ye[5],
                Ie = (Ye[9] - 1) / Ye[5],
                ke = (Ye[8] - 1) / Ye[0],
                Ke = (lt[8] + 1) / lt[0],
                Ee = dt * ke,
                St = dt * Ke,
                Ze = Re / (-ke + Ke),
                ot = Ze * -ke;
            we.matrixWorld.decompose(fe.position, fe.quaternion, fe.scale),
                fe.translateX(ot),
                fe.translateZ(Ze),
                fe.matrixWorld.compose(fe.position, fe.quaternion, fe.scale),
                fe.matrixWorldInverse.copy(fe.matrixWorld).invert();
            const $ = dt + Ze,
                k = Lt + Ze,
                ge = Ee - ot,
                De = St + (Re - ot),
                be = ((W * Lt) / k) * $,
                Le = ((Ie * Lt) / k) * $;
            fe.projectionMatrix.makePerspective(ge, De, be, Le, $, k),
                fe.projectionMatrixInverse.copy(fe.projectionMatrix).invert();
        }
        function oe(fe, we) {
            we === null
                ? fe.matrixWorld.copy(fe.matrix)
                : fe.matrixWorld.multiplyMatrices(we.matrixWorld, fe.matrix),
                fe.matrixWorldInverse.copy(fe.matrixWorld).invert();
        }
        this.updateCamera = function (fe) {
            if (r === null) return;
            T.texture !== null &&
                ((fe.near = T.depthNear), (fe.far = T.depthFar)),
                (D.near = z.near = B.near = fe.near),
                (D.far = z.far = B.far = fe.far),
                (H !== D.near || ie !== D.far) &&
                    (r.updateRenderState({
                        depthNear: D.near,
                        depthFar: D.far,
                    }),
                    (H = D.near),
                    (ie = D.far),
                    (B.near = H),
                    (B.far = ie),
                    (z.near = H),
                    (z.far = ie),
                    B.updateProjectionMatrix(),
                    z.updateProjectionMatrix(),
                    fe.updateProjectionMatrix());
            const we = fe.parent,
                Pe = D.cameras;
            oe(D, we);
            for (let Re = 0; Re < Pe.length; Re++) oe(Pe[Re], we);
            Pe.length === 2
                ? X(D, B, z)
                : D.projectionMatrix.copy(B.projectionMatrix),
                Q(fe, D, we);
        };
        function Q(fe, we, Pe) {
            Pe === null
                ? fe.matrix.copy(we.matrixWorld)
                : (fe.matrix.copy(Pe.matrixWorld),
                  fe.matrix.invert(),
                  fe.matrix.multiply(we.matrixWorld)),
                fe.matrix.decompose(fe.position, fe.quaternion, fe.scale),
                fe.updateMatrixWorld(!0),
                fe.projectionMatrix.copy(we.projectionMatrix),
                fe.projectionMatrixInverse.copy(we.projectionMatrixInverse),
                fe.isPerspectiveCamera &&
                    ((fe.fov =
                        fh *
                        2 *
                        Math.atan(1 / fe.projectionMatrix.elements[5])),
                    (fe.zoom = 1));
        }
        (this.getCamera = function () {
            return D;
        }),
            (this.getFoveation = function () {
                if (!(y === null && v === null)) return c;
            }),
            (this.setFoveation = function (fe) {
                (c = fe),
                    y !== null && (y.fixedFoveation = fe),
                    v !== null &&
                        v.fixedFoveation !== void 0 &&
                        (v.fixedFoveation = fe);
            }),
            (this.hasDepthSensing = function () {
                return T.texture !== null;
            }),
            (this.getDepthSensingMesh = function () {
                return T.getMesh(D);
            });
        let G = null;
        function ae(fe, we) {
            if (((p = we.getViewerPose(d || a)), (S = we), p !== null)) {
                const Pe = p.views;
                v !== null &&
                    (e.setRenderTargetFramebuffer(b, v.framebuffer),
                    e.setRenderTarget(b));
                let Re = !1;
                Pe.length !== D.cameras.length &&
                    ((D.cameras.length = 0), (Re = !0));
                for (let lt = 0; lt < Pe.length; lt++) {
                    const dt = Pe[lt];
                    let Lt = null;
                    if (v !== null) Lt = v.getViewport(dt);
                    else {
                        const Ie = g.getViewSubImage(y, dt);
                        (Lt = Ie.viewport),
                            lt === 0 &&
                                (e.setRenderTargetTextures(
                                    b,
                                    Ie.colorTexture,
                                    y.ignoreDepthValues
                                        ? void 0
                                        : Ie.depthStencilTexture
                                ),
                                e.setRenderTarget(b));
                    }
                    let W = U[lt];
                    W === void 0 &&
                        ((W = new Pi()),
                        W.layers.enable(lt),
                        (W.viewport = new gn()),
                        (U[lt] = W)),
                        W.matrix.fromArray(dt.transform.matrix),
                        W.matrix.decompose(W.position, W.quaternion, W.scale),
                        W.projectionMatrix.fromArray(dt.projectionMatrix),
                        W.projectionMatrixInverse
                            .copy(W.projectionMatrix)
                            .invert(),
                        W.viewport.set(Lt.x, Lt.y, Lt.width, Lt.height),
                        lt === 0 &&
                            (D.matrix.copy(W.matrix),
                            D.matrix.decompose(
                                D.position,
                                D.quaternion,
                                D.scale
                            )),
                        Re === !0 && D.cameras.push(W);
                }
                const Ye = r.enabledFeatures;
                if (Ye && Ye.includes('depth-sensing')) {
                    const lt = g.getDepthInformation(Pe[0]);
                    lt &&
                        lt.isValid &&
                        lt.texture &&
                        T.init(e, lt, r.renderState);
                }
            }
            for (let Pe = 0; Pe < C.length; Pe++) {
                const Re = L[Pe],
                    Ye = C[Pe];
                Re !== null && Ye !== void 0 && Ye.update(Re, we, d || a);
            }
            G && G(fe, we),
                we.detectedPlanes &&
                    n.dispatchEvent({ type: 'planesdetected', data: we }),
                (S = null);
        }
        const Oe = new JR();
        Oe.setAnimationLoop(ae),
            (this.setAnimationLoop = function (fe) {
                G = fe;
            }),
            (this.dispose = function () {});
    }
}
const Ou = new as(),
    hV = new Pt();
function dV(i, e) {
    function t(M, w) {
        M.matrixAutoUpdate === !0 && M.updateMatrix(), w.value.copy(M.matrix);
    }
    function n(M, w) {
        w.color.getRGB(M.fogColor.value, YR(i)),
            w.isFog
                ? ((M.fogNear.value = w.near), (M.fogFar.value = w.far))
                : w.isFogExp2 && (M.fogDensity.value = w.density);
    }
    function r(M, w, b, C, L) {
        w.isMeshBasicMaterial || w.isMeshLambertMaterial
            ? s(M, w)
            : w.isMeshToonMaterial
              ? (s(M, w), g(M, w))
              : w.isMeshPhongMaterial
                ? (s(M, w), p(M, w))
                : w.isMeshStandardMaterial
                  ? (s(M, w), y(M, w), w.isMeshPhysicalMaterial && v(M, w, L))
                  : w.isMeshMatcapMaterial
                    ? (s(M, w), S(M, w))
                    : w.isMeshDepthMaterial
                      ? s(M, w)
                      : w.isMeshDistanceMaterial
                        ? (s(M, w), T(M, w))
                        : w.isMeshNormalMaterial
                          ? s(M, w)
                          : w.isLineBasicMaterial
                            ? (a(M, w), w.isLineDashedMaterial && l(M, w))
                            : w.isPointsMaterial
                              ? c(M, w, b, C)
                              : w.isSpriteMaterial
                                ? d(M, w)
                                : w.isShadowMaterial
                                  ? (M.color.value.copy(w.color),
                                    (M.opacity.value = w.opacity))
                                  : w.isShaderMaterial &&
                                    (w.uniformsNeedUpdate = !1);
    }
    function s(M, w) {
        (M.opacity.value = w.opacity),
            w.color && M.diffuse.value.copy(w.color),
            w.emissive &&
                M.emissive.value
                    .copy(w.emissive)
                    .multiplyScalar(w.emissiveIntensity),
            w.map && ((M.map.value = w.map), t(w.map, M.mapTransform)),
            w.alphaMap &&
                ((M.alphaMap.value = w.alphaMap),
                t(w.alphaMap, M.alphaMapTransform)),
            w.bumpMap &&
                ((M.bumpMap.value = w.bumpMap),
                t(w.bumpMap, M.bumpMapTransform),
                (M.bumpScale.value = w.bumpScale),
                w.side === Er && (M.bumpScale.value *= -1)),
            w.normalMap &&
                ((M.normalMap.value = w.normalMap),
                t(w.normalMap, M.normalMapTransform),
                M.normalScale.value.copy(w.normalScale),
                w.side === Er && M.normalScale.value.negate()),
            w.displacementMap &&
                ((M.displacementMap.value = w.displacementMap),
                t(w.displacementMap, M.displacementMapTransform),
                (M.displacementScale.value = w.displacementScale),
                (M.displacementBias.value = w.displacementBias)),
            w.emissiveMap &&
                ((M.emissiveMap.value = w.emissiveMap),
                t(w.emissiveMap, M.emissiveMapTransform)),
            w.specularMap &&
                ((M.specularMap.value = w.specularMap),
                t(w.specularMap, M.specularMapTransform)),
            w.alphaTest > 0 && (M.alphaTest.value = w.alphaTest);
        const b = e.get(w),
            C = b.envMap,
            L = b.envMapRotation;
        C &&
            ((M.envMap.value = C),
            Ou.copy(L),
            (Ou.x *= -1),
            (Ou.y *= -1),
            (Ou.z *= -1),
            C.isCubeTexture &&
                C.isRenderTargetTexture === !1 &&
                ((Ou.y *= -1), (Ou.z *= -1)),
            M.envMapRotation.value.setFromMatrix4(hV.makeRotationFromEuler(Ou)),
            (M.flipEnvMap.value =
                C.isCubeTexture && C.isRenderTargetTexture === !1 ? -1 : 1),
            (M.reflectivity.value = w.reflectivity),
            (M.ior.value = w.ior),
            (M.refractionRatio.value = w.refractionRatio)),
            w.lightMap &&
                ((M.lightMap.value = w.lightMap),
                (M.lightMapIntensity.value = w.lightMapIntensity),
                t(w.lightMap, M.lightMapTransform)),
            w.aoMap &&
                ((M.aoMap.value = w.aoMap),
                (M.aoMapIntensity.value = w.aoMapIntensity),
                t(w.aoMap, M.aoMapTransform));
    }
    function a(M, w) {
        M.diffuse.value.copy(w.color),
            (M.opacity.value = w.opacity),
            w.map && ((M.map.value = w.map), t(w.map, M.mapTransform));
    }
    function l(M, w) {
        (M.dashSize.value = w.dashSize),
            (M.totalSize.value = w.dashSize + w.gapSize),
            (M.scale.value = w.scale);
    }
    function c(M, w, b, C) {
        M.diffuse.value.copy(w.color),
            (M.opacity.value = w.opacity),
            (M.size.value = w.size * b),
            (M.scale.value = C * 0.5),
            w.map && ((M.map.value = w.map), t(w.map, M.uvTransform)),
            w.alphaMap &&
                ((M.alphaMap.value = w.alphaMap),
                t(w.alphaMap, M.alphaMapTransform)),
            w.alphaTest > 0 && (M.alphaTest.value = w.alphaTest);
    }
    function d(M, w) {
        M.diffuse.value.copy(w.color),
            (M.opacity.value = w.opacity),
            (M.rotation.value = w.rotation),
            w.map && ((M.map.value = w.map), t(w.map, M.mapTransform)),
            w.alphaMap &&
                ((M.alphaMap.value = w.alphaMap),
                t(w.alphaMap, M.alphaMapTransform)),
            w.alphaTest > 0 && (M.alphaTest.value = w.alphaTest);
    }
    function p(M, w) {
        M.specular.value.copy(w.specular),
            (M.shininess.value = Math.max(w.shininess, 1e-4));
    }
    function g(M, w) {
        w.gradientMap && (M.gradientMap.value = w.gradientMap);
    }
    function y(M, w) {
        (M.metalness.value = w.metalness),
            w.metalnessMap &&
                ((M.metalnessMap.value = w.metalnessMap),
                t(w.metalnessMap, M.metalnessMapTransform)),
            (M.roughness.value = w.roughness),
            w.roughnessMap &&
                ((M.roughnessMap.value = w.roughnessMap),
                t(w.roughnessMap, M.roughnessMapTransform)),
            w.envMap && (M.envMapIntensity.value = w.envMapIntensity);
    }
    function v(M, w, b) {
        (M.ior.value = w.ior),
            w.sheen > 0 &&
                (M.sheenColor.value.copy(w.sheenColor).multiplyScalar(w.sheen),
                (M.sheenRoughness.value = w.sheenRoughness),
                w.sheenColorMap &&
                    ((M.sheenColorMap.value = w.sheenColorMap),
                    t(w.sheenColorMap, M.sheenColorMapTransform)),
                w.sheenRoughnessMap &&
                    ((M.sheenRoughnessMap.value = w.sheenRoughnessMap),
                    t(w.sheenRoughnessMap, M.sheenRoughnessMapTransform))),
            w.clearcoat > 0 &&
                ((M.clearcoat.value = w.clearcoat),
                (M.clearcoatRoughness.value = w.clearcoatRoughness),
                w.clearcoatMap &&
                    ((M.clearcoatMap.value = w.clearcoatMap),
                    t(w.clearcoatMap, M.clearcoatMapTransform)),
                w.clearcoatRoughnessMap &&
                    ((M.clearcoatRoughnessMap.value = w.clearcoatRoughnessMap),
                    t(
                        w.clearcoatRoughnessMap,
                        M.clearcoatRoughnessMapTransform
                    )),
                w.clearcoatNormalMap &&
                    ((M.clearcoatNormalMap.value = w.clearcoatNormalMap),
                    t(w.clearcoatNormalMap, M.clearcoatNormalMapTransform),
                    M.clearcoatNormalScale.value.copy(w.clearcoatNormalScale),
                    w.side === Er && M.clearcoatNormalScale.value.negate())),
            w.dispersion > 0 && (M.dispersion.value = w.dispersion),
            w.iridescence > 0 &&
                ((M.iridescence.value = w.iridescence),
                (M.iridescenceIOR.value = w.iridescenceIOR),
                (M.iridescenceThicknessMinimum.value =
                    w.iridescenceThicknessRange[0]),
                (M.iridescenceThicknessMaximum.value =
                    w.iridescenceThicknessRange[1]),
                w.iridescenceMap &&
                    ((M.iridescenceMap.value = w.iridescenceMap),
                    t(w.iridescenceMap, M.iridescenceMapTransform)),
                w.iridescenceThicknessMap &&
                    ((M.iridescenceThicknessMap.value =
                        w.iridescenceThicknessMap),
                    t(
                        w.iridescenceThicknessMap,
                        M.iridescenceThicknessMapTransform
                    ))),
            w.transmission > 0 &&
                ((M.transmission.value = w.transmission),
                (M.transmissionSamplerMap.value = b.texture),
                M.transmissionSamplerSize.value.set(b.width, b.height),
                w.transmissionMap &&
                    ((M.transmissionMap.value = w.transmissionMap),
                    t(w.transmissionMap, M.transmissionMapTransform)),
                (M.thickness.value = w.thickness),
                w.thicknessMap &&
                    ((M.thicknessMap.value = w.thicknessMap),
                    t(w.thicknessMap, M.thicknessMapTransform)),
                (M.attenuationDistance.value = w.attenuationDistance),
                M.attenuationColor.value.copy(w.attenuationColor)),
            w.anisotropy > 0 &&
                (M.anisotropyVector.value.set(
                    w.anisotropy * Math.cos(w.anisotropyRotation),
                    w.anisotropy * Math.sin(w.anisotropyRotation)
                ),
                w.anisotropyMap &&
                    ((M.anisotropyMap.value = w.anisotropyMap),
                    t(w.anisotropyMap, M.anisotropyMapTransform))),
            (M.specularIntensity.value = w.specularIntensity),
            M.specularColor.value.copy(w.specularColor),
            w.specularColorMap &&
                ((M.specularColorMap.value = w.specularColorMap),
                t(w.specularColorMap, M.specularColorMapTransform)),
            w.specularIntensityMap &&
                ((M.specularIntensityMap.value = w.specularIntensityMap),
                t(w.specularIntensityMap, M.specularIntensityMapTransform));
    }
    function S(M, w) {
        w.matcap && (M.matcap.value = w.matcap);
    }
    function T(M, w) {
        const b = e.get(w).light;
        M.referencePosition.value.setFromMatrixPosition(b.matrixWorld),
            (M.nearDistance.value = b.shadow.camera.near),
            (M.farDistance.value = b.shadow.camera.far);
    }
    return { refreshFogUniforms: n, refreshMaterialUniforms: r };
}
function pV(i, e, t, n) {
    let r = {},
        s = {},
        a = [];
    const l = i.getParameter(i.MAX_UNIFORM_BUFFER_BINDINGS);
    function c(b, C) {
        const L = C.program;
        n.uniformBlockBinding(b, L);
    }
    function d(b, C) {
        let L = r[b.id];
        L === void 0 &&
            (S(b), (L = p(b)), (r[b.id] = L), b.addEventListener('dispose', M));
        const F = C.program;
        n.updateUBOMapping(b, F);
        const N = e.render.frame;
        s[b.id] !== N && (y(b), (s[b.id] = N));
    }
    function p(b) {
        const C = g();
        b.__bindingPointIndex = C;
        const L = i.createBuffer(),
            F = b.__size,
            N = b.usage;
        return (
            i.bindBuffer(i.UNIFORM_BUFFER, L),
            i.bufferData(i.UNIFORM_BUFFER, F, N),
            i.bindBuffer(i.UNIFORM_BUFFER, null),
            i.bindBufferBase(i.UNIFORM_BUFFER, C, L),
            L
        );
    }
    function g() {
        for (let b = 0; b < l; b++)
            if (a.indexOf(b) === -1) return a.push(b), b;
        return (
            console.error(
                'THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.'
            ),
            0
        );
    }
    function y(b) {
        const C = r[b.id],
            L = b.uniforms,
            F = b.__cache;
        i.bindBuffer(i.UNIFORM_BUFFER, C);
        for (let N = 0, B = L.length; N < B; N++) {
            const z = Array.isArray(L[N]) ? L[N] : [L[N]];
            for (let U = 0, D = z.length; U < D; U++) {
                const H = z[U];
                if (v(H, N, U, F) === !0) {
                    const ie = H.__offset,
                        ee = Array.isArray(H.value) ? H.value : [H.value];
                    let ue = 0;
                    for (let Se = 0; Se < ee.length; Se++) {
                        const ce = ee[Se],
                            me = T(ce);
                        typeof ce == 'number' || typeof ce == 'boolean'
                            ? ((H.__data[0] = ce),
                              i.bufferSubData(
                                  i.UNIFORM_BUFFER,
                                  ie + ue,
                                  H.__data
                              ))
                            : ce.isMatrix3
                              ? ((H.__data[0] = ce.elements[0]),
                                (H.__data[1] = ce.elements[1]),
                                (H.__data[2] = ce.elements[2]),
                                (H.__data[3] = 0),
                                (H.__data[4] = ce.elements[3]),
                                (H.__data[5] = ce.elements[4]),
                                (H.__data[6] = ce.elements[5]),
                                (H.__data[7] = 0),
                                (H.__data[8] = ce.elements[6]),
                                (H.__data[9] = ce.elements[7]),
                                (H.__data[10] = ce.elements[8]),
                                (H.__data[11] = 0))
                              : (ce.toArray(H.__data, ue),
                                (ue +=
                                    me.storage /
                                    Float32Array.BYTES_PER_ELEMENT));
                    }
                    i.bufferSubData(i.UNIFORM_BUFFER, ie, H.__data);
                }
            }
        }
        i.bindBuffer(i.UNIFORM_BUFFER, null);
    }
    function v(b, C, L, F) {
        const N = b.value,
            B = C + '_' + L;
        if (F[B] === void 0)
            return (
                typeof N == 'number' || typeof N == 'boolean'
                    ? (F[B] = N)
                    : (F[B] = N.clone()),
                !0
            );
        {
            const z = F[B];
            if (typeof N == 'number' || typeof N == 'boolean') {
                if (z !== N) return (F[B] = N), !0;
            } else if (z.equals(N) === !1) return z.copy(N), !0;
        }
        return !1;
    }
    function S(b) {
        const C = b.uniforms;
        let L = 0;
        const F = 16;
        for (let B = 0, z = C.length; B < z; B++) {
            const U = Array.isArray(C[B]) ? C[B] : [C[B]];
            for (let D = 0, H = U.length; D < H; D++) {
                const ie = U[D],
                    ee = Array.isArray(ie.value) ? ie.value : [ie.value];
                for (let ue = 0, Se = ee.length; ue < Se; ue++) {
                    const ce = ee[ue],
                        me = T(ce),
                        X = L % F;
                    X !== 0 && F - X < me.boundary && (L += F - X),
                        (ie.__data = new Float32Array(
                            me.storage / Float32Array.BYTES_PER_ELEMENT
                        )),
                        (ie.__offset = L),
                        (L += me.storage);
                }
            }
        }
        const N = L % F;
        return N > 0 && (L += F - N), (b.__size = L), (b.__cache = {}), this;
    }
    function T(b) {
        const C = { boundary: 0, storage: 0 };
        return (
            typeof b == 'number' || typeof b == 'boolean'
                ? ((C.boundary = 4), (C.storage = 4))
                : b.isVector2
                  ? ((C.boundary = 8), (C.storage = 8))
                  : b.isVector3 || b.isColor
                    ? ((C.boundary = 16), (C.storage = 12))
                    : b.isVector4
                      ? ((C.boundary = 16), (C.storage = 16))
                      : b.isMatrix3
                        ? ((C.boundary = 48), (C.storage = 48))
                        : b.isMatrix4
                          ? ((C.boundary = 64), (C.storage = 64))
                          : b.isTexture
                            ? console.warn(
                                  'THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.'
                              )
                            : console.warn(
                                  'THREE.WebGLRenderer: Unsupported uniform value type.',
                                  b
                              ),
            C
        );
    }
    function M(b) {
        const C = b.target;
        C.removeEventListener('dispose', M);
        const L = a.indexOf(C.__bindingPointIndex);
        a.splice(L, 1), i.deleteBuffer(r[C.id]), delete r[C.id], delete s[C.id];
    }
    function w() {
        for (const b in r) i.deleteBuffer(r[b]);
        (a = []), (r = {}), (s = {});
    }
    return { bind: c, update: d, dispose: w };
}
class sb {
    constructor(e = {}) {
        const {
            canvas: t = XR(),
            context: n = null,
            depth: r = !0,
            stencil: s = !1,
            alpha: a = !1,
            antialias: l = !1,
            premultipliedAlpha: c = !0,
            preserveDrawingBuffer: d = !1,
            powerPreference: p = 'default',
            failIfMajorPerformanceCaveat: g = !1,
        } = e;
        this.isWebGLRenderer = !0;
        let y;
        if (n !== null) {
            if (
                typeof WebGLRenderingContext < 'u' &&
                n instanceof WebGLRenderingContext
            )
                throw new Error(
                    'THREE.WebGLRenderer: WebGL 1 is not supported since r163.'
                );
            y = n.getContextAttributes().alpha;
        } else y = a;
        const v = new Uint32Array(4),
            S = new Int32Array(4);
        let T = null,
            M = null;
        const w = [],
            b = [];
        (this.domElement = t),
            (this.debug = { checkShaderErrors: !0, onShaderError: null }),
            (this.autoClear = !0),
            (this.autoClearColor = !0),
            (this.autoClearDepth = !0),
            (this.autoClearStencil = !0),
            (this.sortObjects = !0),
            (this.clippingPlanes = []),
            (this.localClippingEnabled = !1),
            (this._outputColorSpace = ws),
            (this.toneMapping = Fo),
            (this.toneMappingExposure = 1);
        const C = this;
        let L = !1,
            F = 0,
            N = 0,
            B = null,
            z = -1,
            U = null;
        const D = new gn(),
            H = new gn();
        let ie = null;
        const ee = new st(0);
        let ue = 0,
            Se = t.width,
            ce = t.height,
            me = 1,
            X = null,
            oe = null;
        const Q = new gn(0, 0, Se, ce),
            G = new gn(0, 0, Se, ce);
        let ae = !1;
        const Oe = new Jp();
        let fe = !1,
            we = !1;
        const Pe = new Pt(),
            Re = new j(),
            Ye = new gn(),
            lt = {
                background: null,
                fog: null,
                environment: null,
                overrideMaterial: null,
                isScene: !0,
            };
        let dt = !1;
        function Lt() {
            return B === null ? me : 1;
        }
        let W = n;
        function Ie(V, re) {
            return t.getContext(V, re);
        }
        try {
            const V = {
                alpha: !0,
                depth: r,
                stencil: s,
                antialias: l,
                premultipliedAlpha: c,
                preserveDrawingBuffer: d,
                powerPreference: p,
                failIfMajorPerformanceCaveat: g,
            };
            if (
                ('setAttribute' in t &&
                    t.setAttribute('data-engine', `three.js r${ov}`),
                t.addEventListener('webglcontextlost', Te, !1),
                t.addEventListener('webglcontextrestored', Ae, !1),
                t.addEventListener('webglcontextcreationerror', Ge, !1),
                W === null)
            ) {
                const re = 'webgl2';
                if (((W = Ie(re, V)), W === null))
                    throw Ie(re)
                        ? new Error(
                              'Error creating WebGL context with your selected attributes.'
                          )
                        : new Error('Error creating WebGL context.');
            }
        } catch (V) {
            throw (console.error('THREE.WebGLRenderer: ' + V.message), V);
        }
        let ke,
            Ke,
            Ee,
            St,
            Ze,
            ot,
            $,
            k,
            ge,
            De,
            be,
            Le,
            _t,
            $e,
            tt,
            Nt,
            Be,
            Je,
            Kt,
            bt,
            ut,
            Ut,
            zt,
            dn;
        function ne() {
            (ke = new wz(W)),
                ke.init(),
                (Ut = new ib(W, ke)),
                (Ke = new gz(W, ke, e, Ut)),
                (Ee = new eV(W)),
                (St = new Tz(W)),
                (Ze = new H4()),
                (ot = new oV(W, ke, Ee, Ze, Ke, Ut, St)),
                ($ = new vz(C)),
                (k = new Sz(C)),
                (ge = new Ik(W)),
                (zt = new pz(W, ge)),
                (De = new Mz(W, ge, St, zt)),
                (be = new Cz(W, De, ge, St)),
                (Kt = new Az(W, Ke, ot)),
                (Nt = new yz(Ze)),
                (Le = new V4(C, $, k, ke, Ke, zt, Nt)),
                (_t = new dV(C, Ze)),
                ($e = new W4()),
                (tt = new K4(ke)),
                (Je = new dz(C, $, k, Ee, be, y, c)),
                (Be = new Q4(C, be, Ke)),
                (dn = new pV(W, St, Ke, Ee)),
                (bt = new mz(W, ke, St)),
                (ut = new Ez(W, ke, St)),
                (St.programs = Le.programs),
                (C.capabilities = Ke),
                (C.extensions = ke),
                (C.properties = Ze),
                (C.renderLists = $e),
                (C.shadowMap = Be),
                (C.state = Ee),
                (C.info = St);
        }
        ne();
        const Ve = new fV(C, W);
        (this.xr = Ve),
            (this.getContext = function () {
                return W;
            }),
            (this.getContextAttributes = function () {
                return W.getContextAttributes();
            }),
            (this.forceContextLoss = function () {
                const V = ke.get('WEBGL_lose_context');
                V && V.loseContext();
            }),
            (this.forceContextRestore = function () {
                const V = ke.get('WEBGL_lose_context');
                V && V.restoreContext();
            }),
            (this.getPixelRatio = function () {
                return me;
            }),
            (this.setPixelRatio = function (V) {
                V !== void 0 && ((me = V), this.setSize(Se, ce, !1));
            }),
            (this.getSize = function (V) {
                return V.set(Se, ce);
            }),
            (this.setSize = function (V, re, ye = !0) {
                if (Ve.isPresenting) {
                    console.warn(
                        "THREE.WebGLRenderer: Can't change size while VR device is presenting."
                    );
                    return;
                }
                (Se = V),
                    (ce = re),
                    (t.width = Math.floor(V * me)),
                    (t.height = Math.floor(re * me)),
                    ye === !0 &&
                        ((t.style.width = V + 'px'),
                        (t.style.height = re + 'px')),
                    this.setViewport(0, 0, V, re);
            }),
            (this.getDrawingBufferSize = function (V) {
                return V.set(Se * me, ce * me).floor();
            }),
            (this.setDrawingBufferSize = function (V, re, ye) {
                (Se = V),
                    (ce = re),
                    (me = ye),
                    (t.width = Math.floor(V * ye)),
                    (t.height = Math.floor(re * ye)),
                    this.setViewport(0, 0, V, re);
            }),
            (this.getCurrentViewport = function (V) {
                return V.copy(D);
            }),
            (this.getViewport = function (V) {
                return V.copy(Q);
            }),
            (this.setViewport = function (V, re, ye, ve) {
                V.isVector4 ? Q.set(V.x, V.y, V.z, V.w) : Q.set(V, re, ye, ve),
                    Ee.viewport(D.copy(Q).multiplyScalar(me).round());
            }),
            (this.getScissor = function (V) {
                return V.copy(G);
            }),
            (this.setScissor = function (V, re, ye, ve) {
                V.isVector4 ? G.set(V.x, V.y, V.z, V.w) : G.set(V, re, ye, ve),
                    Ee.scissor(H.copy(G).multiplyScalar(me).round());
            }),
            (this.getScissorTest = function () {
                return ae;
            }),
            (this.setScissorTest = function (V) {
                Ee.setScissorTest((ae = V));
            }),
            (this.setOpaqueSort = function (V) {
                X = V;
            }),
            (this.setTransparentSort = function (V) {
                oe = V;
            }),
            (this.getClearColor = function (V) {
                return V.copy(Je.getClearColor());
            }),
            (this.setClearColor = function () {
                Je.setClearColor.apply(Je, arguments);
            }),
            (this.getClearAlpha = function () {
                return Je.getClearAlpha();
            }),
            (this.setClearAlpha = function () {
                Je.setClearAlpha.apply(Je, arguments);
            }),
            (this.clear = function (V = !0, re = !0, ye = !0) {
                let ve = 0;
                if (V) {
                    let le = !1;
                    if (B !== null) {
                        const We = B.texture.format;
                        le = We === pv || We === dv || We === $p;
                    }
                    if (le) {
                        const We = B.texture.type,
                            nt =
                                We === ao ||
                                We === Oa ||
                                We === ch ||
                                We === ac ||
                                We === cv ||
                                We === fv,
                            pt = Je.getClearColor(),
                            Xe = Je.getClearAlpha(),
                            Mt = pt.r,
                            Et = pt.g,
                            wt = pt.b;
                        nt
                            ? ((v[0] = Mt),
                              (v[1] = Et),
                              (v[2] = wt),
                              (v[3] = Xe),
                              W.clearBufferuiv(W.COLOR, 0, v))
                            : ((S[0] = Mt),
                              (S[1] = Et),
                              (S[2] = wt),
                              (S[3] = Xe),
                              W.clearBufferiv(W.COLOR, 0, S));
                    } else ve |= W.COLOR_BUFFER_BIT;
                }
                re && (ve |= W.DEPTH_BUFFER_BIT),
                    ye &&
                        ((ve |= W.STENCIL_BUFFER_BIT),
                        this.state.buffers.stencil.setMask(4294967295)),
                    W.clear(ve);
            }),
            (this.clearColor = function () {
                this.clear(!0, !1, !1);
            }),
            (this.clearDepth = function () {
                this.clear(!1, !0, !1);
            }),
            (this.clearStencil = function () {
                this.clear(!1, !1, !0);
            }),
            (this.dispose = function () {
                t.removeEventListener('webglcontextlost', Te, !1),
                    t.removeEventListener('webglcontextrestored', Ae, !1),
                    t.removeEventListener('webglcontextcreationerror', Ge, !1),
                    $e.dispose(),
                    tt.dispose(),
                    Ze.dispose(),
                    $.dispose(),
                    k.dispose(),
                    be.dispose(),
                    zt.dispose(),
                    dn.dispose(),
                    Le.dispose(),
                    Ve.dispose(),
                    Ve.removeEventListener('sessionstart', Gi),
                    Ve.removeEventListener('sessionend', mo),
                    Wr.stop();
            });
        function Te(V) {
            V.preventDefault(),
                console.log('THREE.WebGLRenderer: Context Lost.'),
                (L = !0);
        }
        function Ae() {
            console.log('THREE.WebGLRenderer: Context Restored.'), (L = !1);
            const V = St.autoReset,
                re = Be.enabled,
                ye = Be.autoUpdate,
                ve = Be.needsUpdate,
                le = Be.type;
            ne(),
                (St.autoReset = V),
                (Be.enabled = re),
                (Be.autoUpdate = ye),
                (Be.needsUpdate = ve),
                (Be.type = le);
        }
        function Ge(V) {
            console.error(
                'THREE.WebGLRenderer: A WebGL context could not be created. Reason: ',
                V.statusMessage
            );
        }
        function At(V) {
            const re = V.target;
            re.removeEventListener('dispose', At), Yt(re);
        }
        function Yt(V) {
            Cn(V), Ze.remove(V);
        }
        function Cn(V) {
            const re = Ze.get(V).programs;
            re !== void 0 &&
                (re.forEach(function (ye) {
                    Le.releaseProgram(ye);
                }),
                V.isShaderMaterial && Le.releaseShaderCache(V));
        }
        this.renderBufferDirect = function (V, re, ye, ve, le, We) {
            re === null && (re = lt);
            const nt = le.isMesh && le.matrixWorld.determinant() < 0,
                pt = Rh(V, re, ye, ve, le);
            Ee.setMaterial(ve, nt);
            let Xe = ye.index,
                Mt = 1;
            if (ve.wireframe === !0) {
                if (((Xe = De.getWireframeAttribute(ye)), Xe === void 0))
                    return;
                Mt = 2;
            }
            const Et = ye.drawRange,
                wt = ye.attributes.position;
            let Qt = Et.start * Mt,
                vn = (Et.start + Et.count) * Mt;
            We !== null &&
                ((Qt = Math.max(Qt, We.start * Mt)),
                (vn = Math.min(vn, (We.start + We.count) * Mt))),
                Xe !== null
                    ? ((Qt = Math.max(Qt, 0)), (vn = Math.min(vn, Xe.count)))
                    : wt != null &&
                      ((Qt = Math.max(Qt, 0)), (vn = Math.min(vn, wt.count)));
            const un = vn - Qt;
            if (un < 0 || un === 1 / 0) return;
            zt.setup(le, ve, pt, ye, Xe);
            let En,
                ft = bt;
            if (
                (Xe !== null && ((En = ge.get(Xe)), (ft = ut), ft.setIndex(En)),
                le.isMesh)
            )
                ve.wireframe === !0
                    ? (Ee.setLineWidth(ve.wireframeLinewidth * Lt()),
                      ft.setMode(W.LINES))
                    : ft.setMode(W.TRIANGLES);
            else if (le.isLine) {
                let je = ve.linewidth;
                je === void 0 && (je = 1),
                    Ee.setLineWidth(je * Lt()),
                    le.isLineSegments
                        ? ft.setMode(W.LINES)
                        : le.isLineLoop
                          ? ft.setMode(W.LINE_LOOP)
                          : ft.setMode(W.LINE_STRIP);
            } else
                le.isPoints
                    ? ft.setMode(W.POINTS)
                    : le.isSprite && ft.setMode(W.TRIANGLES);
            if (le.isBatchedMesh)
                if (le._multiDrawInstances !== null)
                    ft.renderMultiDrawInstances(
                        le._multiDrawStarts,
                        le._multiDrawCounts,
                        le._multiDrawCount,
                        le._multiDrawInstances
                    );
                else if (ke.get('WEBGL_multi_draw'))
                    ft.renderMultiDraw(
                        le._multiDrawStarts,
                        le._multiDrawCounts,
                        le._multiDrawCount
                    );
                else {
                    const je = le._multiDrawStarts,
                        Zt = le._multiDrawCounts,
                        It = le._multiDrawCount,
                        xn = Xe ? ge.get(Xe).bytesPerElement : 1,
                        Wi = Ze.get(ve).currentProgram.getUniforms();
                    for (let Dn = 0; Dn < It; Dn++)
                        Wi.setValue(W, '_gl_DrawID', Dn),
                            ft.render(je[Dn] / xn, Zt[Dn]);
                }
            else if (le.isInstancedMesh) ft.renderInstances(Qt, un, le.count);
            else if (ye.isInstancedBufferGeometry) {
                const je =
                        ye._maxInstanceCount !== void 0
                            ? ye._maxInstanceCount
                            : 1 / 0,
                    Zt = Math.min(ye.instanceCount, je);
                ft.renderInstances(Qt, un, Zt);
            } else ft.render(Qt, un);
        };
        function jn(V, re, ye) {
            V.transparent === !0 && V.side === Lo && V.forceSinglePass === !1
                ? ((V.side = Er),
                  (V.needsUpdate = !0),
                  go(V, re, ye),
                  (V.side = Na),
                  (V.needsUpdate = !0),
                  go(V, re, ye),
                  (V.side = Lo))
                : go(V, re, ye);
        }
        (this.compile = function (V, re, ye = null) {
            ye === null && (ye = V),
                (M = tt.get(ye)),
                M.init(re),
                b.push(M),
                ye.traverseVisible(function (le) {
                    le.isLight &&
                        le.layers.test(re.layers) &&
                        (M.pushLight(le), le.castShadow && M.pushShadow(le));
                }),
                V !== ye &&
                    V.traverseVisible(function (le) {
                        le.isLight &&
                            le.layers.test(re.layers) &&
                            (M.pushLight(le),
                            le.castShadow && M.pushShadow(le));
                    }),
                M.setupLights();
            const ve = new Set();
            return (
                V.traverse(function (le) {
                    const We = le.material;
                    if (We)
                        if (Array.isArray(We))
                            for (let nt = 0; nt < We.length; nt++) {
                                const pt = We[nt];
                                jn(pt, ye, le), ve.add(pt);
                            }
                        else jn(We, ye, le), ve.add(We);
                }),
                b.pop(),
                (M = null),
                ve
            );
        }),
            (this.compileAsync = function (V, re, ye = null) {
                const ve = this.compile(V, re, ye);
                return new Promise((le) => {
                    function We() {
                        if (
                            (ve.forEach(function (nt) {
                                Ze.get(nt).currentProgram.isReady() &&
                                    ve.delete(nt);
                            }),
                            ve.size === 0)
                        ) {
                            le(V);
                            return;
                        }
                        setTimeout(We, 10);
                    }
                    ke.get('KHR_parallel_shader_compile') !== null
                        ? We()
                        : setTimeout(We, 10);
                });
            });
        let en = null;
        function Hi(V) {
            en && en(V);
        }
        function Gi() {
            Wr.stop();
        }
        function mo() {
            Wr.start();
        }
        const Wr = new JR();
        Wr.setAnimationLoop(Hi),
            typeof self < 'u' && Wr.setContext(self),
            (this.setAnimationLoop = function (V) {
                (en = V),
                    Ve.setAnimationLoop(V),
                    V === null ? Wr.stop() : Wr.start();
            }),
            Ve.addEventListener('sessionstart', Gi),
            Ve.addEventListener('sessionend', mo),
            (this.render = function (V, re) {
                if (re !== void 0 && re.isCamera !== !0) {
                    console.error(
                        'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.'
                    );
                    return;
                }
                if (L === !0) return;
                if (
                    (V.matrixWorldAutoUpdate === !0 && V.updateMatrixWorld(),
                    re.parent === null &&
                        re.matrixWorldAutoUpdate === !0 &&
                        re.updateMatrixWorld(),
                    Ve.enabled === !0 &&
                        Ve.isPresenting === !0 &&
                        (Ve.cameraAutoUpdate === !0 && Ve.updateCamera(re),
                        (re = Ve.getCamera())),
                    V.isScene === !0 && V.onBeforeRender(C, V, re, B),
                    (M = tt.get(V, b.length)),
                    M.init(re),
                    b.push(M),
                    Pe.multiplyMatrices(
                        re.projectionMatrix,
                        re.matrixWorldInverse
                    ),
                    Oe.setFromProjectionMatrix(Pe),
                    (we = this.localClippingEnabled),
                    (fe = Nt.init(this.clippingPlanes, we)),
                    (T = $e.get(V, w.length)),
                    T.init(),
                    w.push(T),
                    Ve.enabled === !0 && Ve.isPresenting === !0)
                ) {
                    const We = C.xr.getDepthSensingMesh();
                    We !== null && Cs(We, re, -1 / 0, C.sortObjects);
                }
                Cs(V, re, 0, C.sortObjects),
                    T.finish(),
                    C.sortObjects === !0 && T.sort(X, oe),
                    (dt =
                        Ve.enabled === !1 ||
                        Ve.isPresenting === !1 ||
                        Ve.hasDepthSensing() === !1),
                    dt && Je.addToRenderList(T, V),
                    this.info.render.frame++,
                    fe === !0 && Nt.beginShadows();
                const ye = M.state.shadowsArray;
                Be.render(ye, V, re),
                    fe === !0 && Nt.endShadows(),
                    this.info.autoReset === !0 && this.info.reset();
                const ve = T.opaque,
                    le = T.transmissive;
                if ((M.setupLights(), re.isArrayCamera)) {
                    const We = re.cameras;
                    if (le.length > 0)
                        for (let nt = 0, pt = We.length; nt < pt; nt++) {
                            const Xe = We[nt];
                            ls(ve, le, V, Xe);
                        }
                    dt && Je.render(V);
                    for (let nt = 0, pt = We.length; nt < pt; nt++) {
                        const Xe = We[nt];
                        Gl(T, V, Xe, Xe.viewport);
                    }
                } else
                    le.length > 0 && ls(ve, le, V, re),
                        dt && Je.render(V),
                        Gl(T, V, re);
                B !== null &&
                    (ot.updateMultisampleRenderTarget(B),
                    ot.updateRenderTargetMipmap(B)),
                    V.isScene === !0 && V.onAfterRender(C, V, re),
                    zt.resetDefaultState(),
                    (z = -1),
                    (U = null),
                    b.pop(),
                    b.length > 0
                        ? ((M = b[b.length - 1]),
                          fe === !0 &&
                              Nt.setGlobalState(
                                  C.clippingPlanes,
                                  M.state.camera
                              ))
                        : (M = null),
                    w.pop(),
                    w.length > 0 ? (T = w[w.length - 1]) : (T = null);
            });
        function Cs(V, re, ye, ve) {
            if (V.visible === !1) return;
            if (V.layers.test(re.layers)) {
                if (V.isGroup) ye = V.renderOrder;
                else if (V.isLOD) V.autoUpdate === !0 && V.update(re);
                else if (V.isLight)
                    M.pushLight(V), V.castShadow && M.pushShadow(V);
                else if (V.isSprite) {
                    if (!V.frustumCulled || Oe.intersectsSprite(V)) {
                        ve &&
                            Ye.setFromMatrixPosition(
                                V.matrixWorld
                            ).applyMatrix4(Pe);
                        const nt = be.update(V),
                            pt = V.material;
                        pt.visible && T.push(V, nt, pt, ye, Ye.z, null);
                    }
                } else if (
                    (V.isMesh || V.isLine || V.isPoints) &&
                    (!V.frustumCulled || Oe.intersectsObject(V))
                ) {
                    const nt = be.update(V),
                        pt = V.material;
                    if (
                        (ve &&
                            (V.boundingSphere !== void 0
                                ? (V.boundingSphere === null &&
                                      V.computeBoundingSphere(),
                                  Ye.copy(V.boundingSphere.center))
                                : (nt.boundingSphere === null &&
                                      nt.computeBoundingSphere(),
                                  Ye.copy(nt.boundingSphere.center)),
                            Ye.applyMatrix4(V.matrixWorld).applyMatrix4(Pe)),
                        Array.isArray(pt))
                    ) {
                        const Xe = nt.groups;
                        for (let Mt = 0, Et = Xe.length; Mt < Et; Mt++) {
                            const wt = Xe[Mt],
                                Qt = pt[wt.materialIndex];
                            Qt && Qt.visible && T.push(V, nt, Qt, ye, Ye.z, wt);
                        }
                    } else pt.visible && T.push(V, nt, pt, ye, Ye.z, null);
                }
            }
            const We = V.children;
            for (let nt = 0, pt = We.length; nt < pt; nt++)
                Cs(We[nt], re, ye, ve);
        }
        function Gl(V, re, ye, ve) {
            const le = V.opaque,
                We = V.transmissive,
                nt = V.transparent;
            M.setupLightsView(ye),
                fe === !0 && Nt.setGlobalState(C.clippingPlanes, ye),
                ve && Ee.viewport(D.copy(ve)),
                le.length > 0 && Rs(le, re, ye),
                We.length > 0 && Rs(We, re, ye),
                nt.length > 0 && Rs(nt, re, ye),
                Ee.buffers.depth.setTest(!0),
                Ee.buffers.depth.setMask(!0),
                Ee.buffers.color.setMask(!0),
                Ee.setPolygonOffset(!1);
        }
        function ls(V, re, ye, ve) {
            if ((ye.isScene === !0 ? ye.overrideMaterial : null) !== null)
                return;
            M.state.transmissionRenderTarget[ve.id] === void 0 &&
                (M.state.transmissionRenderTarget[ve.id] = new lo(1, 1, {
                    generateMipmaps: !0,
                    type:
                        ke.has('EXT_color_buffer_half_float') ||
                        ke.has('EXT_color_buffer_float')
                            ? Mh
                            : ao,
                    minFilter: Io,
                    samples: 4,
                    stencilBuffer: s,
                    resolveDepthBuffer: !1,
                    resolveStencilBuffer: !1,
                    colorSpace: hn.workingColorSpace,
                }));
            const We = M.state.transmissionRenderTarget[ve.id],
                nt = ve.viewport || D;
            We.setSize(nt.z, nt.w);
            const pt = C.getRenderTarget();
            C.setRenderTarget(We),
                C.getClearColor(ee),
                (ue = C.getClearAlpha()),
                ue < 1 && C.setClearColor(16777215, 0.5),
                dt ? Je.render(ye) : C.clear();
            const Xe = C.toneMapping;
            C.toneMapping = Fo;
            const Mt = ve.viewport;
            if (
                (ve.viewport !== void 0 && (ve.viewport = void 0),
                M.setupLightsView(ve),
                fe === !0 && Nt.setGlobalState(C.clippingPlanes, ve),
                Rs(V, ye, ve),
                ot.updateMultisampleRenderTarget(We),
                ot.updateRenderTargetMipmap(We),
                ke.has('WEBGL_multisampled_render_to_texture') === !1)
            ) {
                let Et = !1;
                for (let wt = 0, Qt = re.length; wt < Qt; wt++) {
                    const vn = re[wt],
                        un = vn.object,
                        En = vn.geometry,
                        ft = vn.material,
                        je = vn.group;
                    if (ft.side === Lo && un.layers.test(ve.layers)) {
                        const Zt = ft.side;
                        (ft.side = Er),
                            (ft.needsUpdate = !0),
                            Xr(un, ye, ve, En, ft, je),
                            (ft.side = Zt),
                            (ft.needsUpdate = !0),
                            (Et = !0);
                    }
                }
                Et === !0 &&
                    (ot.updateMultisampleRenderTarget(We),
                    ot.updateRenderTargetMipmap(We));
            }
            C.setRenderTarget(pt),
                C.setClearColor(ee, ue),
                Mt !== void 0 && (ve.viewport = Mt),
                (C.toneMapping = Xe);
        }
        function Rs(V, re, ye) {
            const ve = re.isScene === !0 ? re.overrideMaterial : null;
            for (let le = 0, We = V.length; le < We; le++) {
                const nt = V[le],
                    pt = nt.object,
                    Xe = nt.geometry,
                    Mt = ve === null ? nt.material : ve,
                    Et = nt.group;
                pt.layers.test(ye.layers) && Xr(pt, re, ye, Xe, Mt, Et);
            }
        }
        function Xr(V, re, ye, ve, le, We) {
            V.onBeforeRender(C, re, ye, ve, le, We),
                V.modelViewMatrix.multiplyMatrices(
                    ye.matrixWorldInverse,
                    V.matrixWorld
                ),
                V.normalMatrix.getNormalMatrix(V.modelViewMatrix),
                le.transparent === !0 &&
                le.side === Lo &&
                le.forceSinglePass === !1
                    ? ((le.side = Er),
                      (le.needsUpdate = !0),
                      C.renderBufferDirect(ye, re, ve, le, V, We),
                      (le.side = Na),
                      (le.needsUpdate = !0),
                      C.renderBufferDirect(ye, re, ve, le, V, We),
                      (le.side = Lo))
                    : C.renderBufferDirect(ye, re, ve, le, V, We),
                V.onAfterRender(C, re, ye, ve, le, We);
        }
        function go(V, re, ye) {
            re.isScene !== !0 && (re = lt);
            const ve = Ze.get(V),
                le = M.state.lights,
                We = M.state.shadowsArray,
                nt = le.state.version,
                pt = Le.getParameters(V, le.state, We, re, ye),
                Xe = Le.getProgramCacheKey(pt);
            let Mt = ve.programs;
            (ve.environment = V.isMeshStandardMaterial ? re.environment : null),
                (ve.fog = re.fog),
                (ve.envMap = (V.isMeshStandardMaterial ? k : $).get(
                    V.envMap || ve.environment
                )),
                (ve.envMapRotation =
                    ve.environment !== null && V.envMap === null
                        ? re.environmentRotation
                        : V.envMapRotation),
                Mt === void 0 &&
                    (V.addEventListener('dispose', At),
                    (Mt = new Map()),
                    (ve.programs = Mt));
            let Et = Mt.get(Xe);
            if (Et !== void 0) {
                if (ve.currentProgram === Et && ve.lightsStateVersion === nt)
                    return yc(V, pt), Et;
            } else
                (pt.uniforms = Le.getUniforms(V)),
                    V.onBeforeCompile(pt, C),
                    (Et = Le.acquireProgram(pt, Xe)),
                    Mt.set(Xe, Et),
                    (ve.uniforms = pt.uniforms);
            const wt = ve.uniforms;
            return (
                ((!V.isShaderMaterial && !V.isRawShaderMaterial) ||
                    V.clipping === !0) &&
                    (wt.clippingPlanes = Nt.uniform),
                yc(V, pt),
                (ve.needsLights = vc(V)),
                (ve.lightsStateVersion = nt),
                ve.needsLights &&
                    ((wt.ambientLightColor.value = le.state.ambient),
                    (wt.lightProbe.value = le.state.probe),
                    (wt.directionalLights.value = le.state.directional),
                    (wt.directionalLightShadows.value =
                        le.state.directionalShadow),
                    (wt.spotLights.value = le.state.spot),
                    (wt.spotLightShadows.value = le.state.spotShadow),
                    (wt.rectAreaLights.value = le.state.rectArea),
                    (wt.ltc_1.value = le.state.rectAreaLTC1),
                    (wt.ltc_2.value = le.state.rectAreaLTC2),
                    (wt.pointLights.value = le.state.point),
                    (wt.pointLightShadows.value = le.state.pointShadow),
                    (wt.hemisphereLights.value = le.state.hemi),
                    (wt.directionalShadowMap.value =
                        le.state.directionalShadowMap),
                    (wt.directionalShadowMatrix.value =
                        le.state.directionalShadowMatrix),
                    (wt.spotShadowMap.value = le.state.spotShadowMap),
                    (wt.spotLightMatrix.value = le.state.spotLightMatrix),
                    (wt.spotLightMap.value = le.state.spotLightMap),
                    (wt.pointShadowMap.value = le.state.pointShadowMap),
                    (wt.pointShadowMatrix.value = le.state.pointShadowMatrix)),
                (ve.currentProgram = Et),
                (ve.uniformsList = null),
                Et
            );
        }
        function gc(V) {
            if (V.uniformsList === null) {
                const re = V.currentProgram.getUniforms();
                V.uniformsList = ay.seqWithValue(re.seq, V.uniforms);
            }
            return V.uniformsList;
        }
        function yc(V, re) {
            const ye = Ze.get(V);
            (ye.outputColorSpace = re.outputColorSpace),
                (ye.batching = re.batching),
                (ye.batchingColor = re.batchingColor),
                (ye.instancing = re.instancing),
                (ye.instancingColor = re.instancingColor),
                (ye.instancingMorph = re.instancingMorph),
                (ye.skinning = re.skinning),
                (ye.morphTargets = re.morphTargets),
                (ye.morphNormals = re.morphNormals),
                (ye.morphColors = re.morphColors),
                (ye.morphTargetsCount = re.morphTargetsCount),
                (ye.numClippingPlanes = re.numClippingPlanes),
                (ye.numIntersection = re.numClipIntersection),
                (ye.vertexAlphas = re.vertexAlphas),
                (ye.vertexTangents = re.vertexTangents),
                (ye.toneMapping = re.toneMapping);
        }
        function Rh(V, re, ye, ve, le) {
            re.isScene !== !0 && (re = lt), ot.resetTextureUnits();
            const We = re.fog,
                nt = ve.isMeshStandardMaterial ? re.environment : null,
                pt =
                    B === null
                        ? C.outputColorSpace
                        : B.isXRRenderTarget === !0
                          ? B.texture.colorSpace
                          : Fa,
                Xe = (ve.isMeshStandardMaterial ? k : $).get(ve.envMap || nt),
                Mt =
                    ve.vertexColors === !0 &&
                    !!ye.attributes.color &&
                    ye.attributes.color.itemSize === 4,
                Et =
                    !!ye.attributes.tangent &&
                    (!!ve.normalMap || ve.anisotropy > 0),
                wt = !!ye.morphAttributes.position,
                Qt = !!ye.morphAttributes.normal,
                vn = !!ye.morphAttributes.color;
            let un = Fo;
            ve.toneMapped &&
                (B === null || B.isXRRenderTarget === !0) &&
                (un = C.toneMapping);
            const En =
                    ye.morphAttributes.position ||
                    ye.morphAttributes.normal ||
                    ye.morphAttributes.color,
                ft = En !== void 0 ? En.length : 0,
                je = Ze.get(ve),
                Zt = M.state.lights;
            if (fe === !0 && (we === !0 || V !== U)) {
                const pi = V === U && ve.id === z;
                Nt.setState(ve, V, pi);
            }
            let It = !1;
            ve.version === je.__version
                ? ((je.needsLights &&
                      je.lightsStateVersion !== Zt.state.version) ||
                      je.outputColorSpace !== pt ||
                      (le.isBatchedMesh && je.batching === !1) ||
                      (!le.isBatchedMesh && je.batching === !0) ||
                      (le.isBatchedMesh &&
                          je.batchingColor === !0 &&
                          le.colorTexture === null) ||
                      (le.isBatchedMesh &&
                          je.batchingColor === !1 &&
                          le.colorTexture !== null) ||
                      (le.isInstancedMesh && je.instancing === !1) ||
                      (!le.isInstancedMesh && je.instancing === !0) ||
                      (le.isSkinnedMesh && je.skinning === !1) ||
                      (!le.isSkinnedMesh && je.skinning === !0) ||
                      (le.isInstancedMesh &&
                          je.instancingColor === !0 &&
                          le.instanceColor === null) ||
                      (le.isInstancedMesh &&
                          je.instancingColor === !1 &&
                          le.instanceColor !== null) ||
                      (le.isInstancedMesh &&
                          je.instancingMorph === !0 &&
                          le.morphTexture === null) ||
                      (le.isInstancedMesh &&
                          je.instancingMorph === !1 &&
                          le.morphTexture !== null) ||
                      je.envMap !== Xe ||
                      (ve.fog === !0 && je.fog !== We) ||
                      (je.numClippingPlanes !== void 0 &&
                          (je.numClippingPlanes !== Nt.numPlanes ||
                              je.numIntersection !== Nt.numIntersection)) ||
                      je.vertexAlphas !== Mt ||
                      je.vertexTangents !== Et ||
                      je.morphTargets !== wt ||
                      je.morphNormals !== Qt ||
                      je.morphColors !== vn ||
                      je.toneMapping !== un ||
                      je.morphTargetsCount !== ft) &&
                  (It = !0)
                : ((It = !0), (je.__version = ve.version));
            let xn = je.currentProgram;
            It === !0 && (xn = go(ve, re, le));
            let Wi = !1,
                Dn = !1,
                zn = !1;
            const fn = xn.getUniforms(),
                Xi = je.uniforms;
            if (
                (Ee.useProgram(xn.program) && ((Wi = !0), (Dn = !0), (zn = !0)),
                ve.id !== z && ((z = ve.id), (Dn = !0)),
                Wi || U !== V)
            ) {
                fn.setValue(W, 'projectionMatrix', V.projectionMatrix),
                    fn.setValue(W, 'viewMatrix', V.matrixWorldInverse);
                const pi = fn.map.cameraPosition;
                pi !== void 0 &&
                    pi.setValue(W, Re.setFromMatrixPosition(V.matrixWorld)),
                    Ke.logarithmicDepthBuffer &&
                        fn.setValue(
                            W,
                            'logDepthBufFC',
                            2 / (Math.log(V.far + 1) / Math.LN2)
                        ),
                    (ve.isMeshPhongMaterial ||
                        ve.isMeshToonMaterial ||
                        ve.isMeshLambertMaterial ||
                        ve.isMeshBasicMaterial ||
                        ve.isMeshStandardMaterial ||
                        ve.isShaderMaterial) &&
                        fn.setValue(
                            W,
                            'isOrthographic',
                            V.isOrthographicCamera === !0
                        ),
                    U !== V && ((U = V), (Dn = !0), (zn = !0));
            }
            if (le.isSkinnedMesh) {
                fn.setOptional(W, le, 'bindMatrix'),
                    fn.setOptional(W, le, 'bindMatrixInverse');
                const pi = le.skeleton;
                pi &&
                    (pi.boneTexture === null && pi.computeBoneTexture(),
                    fn.setValue(W, 'boneTexture', pi.boneTexture, ot));
            }
            le.isBatchedMesh &&
                (fn.setOptional(W, le, 'batchingTexture'),
                fn.setValue(W, 'batchingTexture', le._matricesTexture, ot),
                fn.setOptional(W, le, 'batchingIdTexture'),
                fn.setValue(W, 'batchingIdTexture', le._indirectTexture, ot),
                fn.setOptional(W, le, 'batchingColorTexture'),
                le._colorsTexture !== null &&
                    fn.setValue(
                        W,
                        'batchingColorTexture',
                        le._colorsTexture,
                        ot
                    ));
            const za = ye.morphAttributes;
            if (
                ((za.position !== void 0 ||
                    za.normal !== void 0 ||
                    za.color !== void 0) &&
                    Kt.update(le, ye, xn),
                (Dn || je.receiveShadow !== le.receiveShadow) &&
                    ((je.receiveShadow = le.receiveShadow),
                    fn.setValue(W, 'receiveShadow', le.receiveShadow)),
                ve.isMeshGouraudMaterial &&
                    ve.envMap !== null &&
                    ((Xi.envMap.value = Xe),
                    (Xi.flipEnvMap.value =
                        Xe.isCubeTexture && Xe.isRenderTargetTexture === !1
                            ? -1
                            : 1)),
                ve.isMeshStandardMaterial &&
                    ve.envMap === null &&
                    re.environment !== null &&
                    (Xi.envMapIntensity.value = re.environmentIntensity),
                Dn &&
                    (fn.setValue(
                        W,
                        'toneMappingExposure',
                        C.toneMappingExposure
                    ),
                    je.needsLights && bs(Xi, zn),
                    We && ve.fog === !0 && _t.refreshFogUniforms(Xi, We),
                    _t.refreshMaterialUniforms(
                        Xi,
                        ve,
                        me,
                        ce,
                        M.state.transmissionRenderTarget[V.id]
                    ),
                    ay.upload(W, gc(je), Xi, ot)),
                ve.isShaderMaterial &&
                    ve.uniformsNeedUpdate === !0 &&
                    (ay.upload(W, gc(je), Xi, ot),
                    (ve.uniformsNeedUpdate = !1)),
                ve.isSpriteMaterial && fn.setValue(W, 'center', le.center),
                fn.setValue(W, 'modelViewMatrix', le.modelViewMatrix),
                fn.setValue(W, 'normalMatrix', le.normalMatrix),
                fn.setValue(W, 'modelMatrix', le.matrixWorld),
                ve.isShaderMaterial || ve.isRawShaderMaterial)
            ) {
                const pi = ve.uniformsGroups;
                for (let yo = 0, ji = pi.length; yo < ji; yo++) {
                    const Va = pi[yo];
                    dn.update(Va, xn), dn.bind(Va, xn);
                }
            }
            return xn;
        }
        function bs(V, re) {
            (V.ambientLightColor.needsUpdate = re),
                (V.lightProbe.needsUpdate = re),
                (V.directionalLights.needsUpdate = re),
                (V.directionalLightShadows.needsUpdate = re),
                (V.pointLights.needsUpdate = re),
                (V.pointLightShadows.needsUpdate = re),
                (V.spotLights.needsUpdate = re),
                (V.spotLightShadows.needsUpdate = re),
                (V.rectAreaLights.needsUpdate = re),
                (V.hemisphereLights.needsUpdate = re);
        }
        function vc(V) {
            return (
                V.isMeshLambertMaterial ||
                V.isMeshToonMaterial ||
                V.isMeshPhongMaterial ||
                V.isMeshStandardMaterial ||
                V.isShadowMaterial ||
                (V.isShaderMaterial && V.lights === !0)
            );
        }
        (this.getActiveCubeFace = function () {
            return F;
        }),
            (this.getActiveMipmapLevel = function () {
                return N;
            }),
            (this.getRenderTarget = function () {
                return B;
            }),
            (this.setRenderTargetTextures = function (V, re, ye) {
                (Ze.get(V.texture).__webglTexture = re),
                    (Ze.get(V.depthTexture).__webglTexture = ye);
                const ve = Ze.get(V);
                (ve.__hasExternalTextures = !0),
                    (ve.__autoAllocateDepthBuffer = ye === void 0),
                    ve.__autoAllocateDepthBuffer ||
                        (ke.has('WEBGL_multisampled_render_to_texture') ===
                            !0 &&
                            (console.warn(
                                'THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided'
                            ),
                            (ve.__useRenderToTexture = !1)));
            }),
            (this.setRenderTargetFramebuffer = function (V, re) {
                const ye = Ze.get(V);
                (ye.__webglFramebuffer = re),
                    (ye.__useDefaultFramebuffer = re === void 0);
            }),
            (this.setRenderTarget = function (V, re = 0, ye = 0) {
                (B = V), (F = re), (N = ye);
                let ve = !0,
                    le = null,
                    We = !1,
                    nt = !1;
                if (V) {
                    const Xe = Ze.get(V);
                    Xe.__useDefaultFramebuffer !== void 0
                        ? (Ee.bindFramebuffer(W.FRAMEBUFFER, null), (ve = !1))
                        : Xe.__webglFramebuffer === void 0
                          ? ot.setupRenderTarget(V)
                          : Xe.__hasExternalTextures &&
                            ot.rebindTextures(
                                V,
                                Ze.get(V.texture).__webglTexture,
                                Ze.get(V.depthTexture).__webglTexture
                            );
                    const Mt = V.texture;
                    (Mt.isData3DTexture ||
                        Mt.isDataArrayTexture ||
                        Mt.isCompressedArrayTexture) &&
                        (nt = !0);
                    const Et = Ze.get(V).__webglFramebuffer;
                    V.isWebGLCubeRenderTarget
                        ? (Array.isArray(Et[re])
                              ? (le = Et[re][ye])
                              : (le = Et[re]),
                          (We = !0))
                        : V.samples > 0 && ot.useMultisampledRTT(V) === !1
                          ? (le = Ze.get(V).__webglMultisampledFramebuffer)
                          : Array.isArray(Et)
                            ? (le = Et[ye])
                            : (le = Et),
                        D.copy(V.viewport),
                        H.copy(V.scissor),
                        (ie = V.scissorTest);
                } else
                    D.copy(Q).multiplyScalar(me).floor(),
                        H.copy(G).multiplyScalar(me).floor(),
                        (ie = ae);
                if (
                    (Ee.bindFramebuffer(W.FRAMEBUFFER, le) &&
                        ve &&
                        Ee.drawBuffers(V, le),
                    Ee.viewport(D),
                    Ee.scissor(H),
                    Ee.setScissorTest(ie),
                    We)
                ) {
                    const Xe = Ze.get(V.texture);
                    W.framebufferTexture2D(
                        W.FRAMEBUFFER,
                        W.COLOR_ATTACHMENT0,
                        W.TEXTURE_CUBE_MAP_POSITIVE_X + re,
                        Xe.__webglTexture,
                        ye
                    );
                } else if (nt) {
                    const Xe = Ze.get(V.texture),
                        Mt = re || 0;
                    W.framebufferTextureLayer(
                        W.FRAMEBUFFER,
                        W.COLOR_ATTACHMENT0,
                        Xe.__webglTexture,
                        ye || 0,
                        Mt
                    );
                }
                z = -1;
            }),
            (this.readRenderTargetPixels = function (
                V,
                re,
                ye,
                ve,
                le,
                We,
                nt
            ) {
                if (!(V && V.isWebGLRenderTarget)) {
                    console.error(
                        'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.'
                    );
                    return;
                }
                let pt = Ze.get(V).__webglFramebuffer;
                if (
                    (V.isWebGLCubeRenderTarget &&
                        nt !== void 0 &&
                        (pt = pt[nt]),
                    pt)
                ) {
                    Ee.bindFramebuffer(W.FRAMEBUFFER, pt);
                    try {
                        const Xe = V.texture,
                            Mt = Xe.format,
                            Et = Xe.type;
                        if (!Ke.textureFormatReadable(Mt)) {
                            console.error(
                                'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.'
                            );
                            return;
                        }
                        if (!Ke.textureTypeReadable(Et)) {
                            console.error(
                                'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.'
                            );
                            return;
                        }
                        re >= 0 &&
                            re <= V.width - ve &&
                            ye >= 0 &&
                            ye <= V.height - le &&
                            W.readPixels(
                                re,
                                ye,
                                ve,
                                le,
                                Ut.convert(Mt),
                                Ut.convert(Et),
                                We
                            );
                    } finally {
                        const Xe =
                            B !== null ? Ze.get(B).__webglFramebuffer : null;
                        Ee.bindFramebuffer(W.FRAMEBUFFER, Xe);
                    }
                }
            }),
            (this.readRenderTargetPixelsAsync = async function (
                V,
                re,
                ye,
                ve,
                le,
                We,
                nt
            ) {
                if (!(V && V.isWebGLRenderTarget))
                    throw new Error(
                        'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.'
                    );
                let pt = Ze.get(V).__webglFramebuffer;
                if (
                    (V.isWebGLCubeRenderTarget &&
                        nt !== void 0 &&
                        (pt = pt[nt]),
                    pt)
                ) {
                    Ee.bindFramebuffer(W.FRAMEBUFFER, pt);
                    try {
                        const Xe = V.texture,
                            Mt = Xe.format,
                            Et = Xe.type;
                        if (!Ke.textureFormatReadable(Mt))
                            throw new Error(
                                'THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.'
                            );
                        if (!Ke.textureTypeReadable(Et))
                            throw new Error(
                                'THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.'
                            );
                        if (
                            re >= 0 &&
                            re <= V.width - ve &&
                            ye >= 0 &&
                            ye <= V.height - le
                        ) {
                            const wt = W.createBuffer();
                            W.bindBuffer(W.PIXEL_PACK_BUFFER, wt),
                                W.bufferData(
                                    W.PIXEL_PACK_BUFFER,
                                    We.byteLength,
                                    W.STREAM_READ
                                ),
                                W.readPixels(
                                    re,
                                    ye,
                                    ve,
                                    le,
                                    Ut.convert(Mt),
                                    Ut.convert(Et),
                                    0
                                ),
                                W.flush();
                            const Qt = W.fenceSync(
                                W.SYNC_GPU_COMMANDS_COMPLETE,
                                0
                            );
                            await ik(W, Qt, 4);
                            try {
                                W.bindBuffer(W.PIXEL_PACK_BUFFER, wt),
                                    W.getBufferSubData(
                                        W.PIXEL_PACK_BUFFER,
                                        0,
                                        We
                                    );
                            } finally {
                                W.deleteBuffer(wt), W.deleteSync(Qt);
                            }
                            return We;
                        }
                    } finally {
                        const Xe =
                            B !== null ? Ze.get(B).__webglFramebuffer : null;
                        Ee.bindFramebuffer(W.FRAMEBUFFER, Xe);
                    }
                }
            }),
            (this.copyFramebufferToTexture = function (V, re = null, ye = 0) {
                V.isTexture !== !0 &&
                    (console.warn(
                        'WebGLRenderer: copyFramebufferToTexture function signature has changed.'
                    ),
                    (re = arguments[0] || null),
                    (V = arguments[1]));
                const ve = Math.pow(2, -ye),
                    le = Math.floor(V.image.width * ve),
                    We = Math.floor(V.image.height * ve),
                    nt = re !== null ? re.x : 0,
                    pt = re !== null ? re.y : 0;
                ot.setTexture2D(V, 0),
                    W.copyTexSubImage2D(W.TEXTURE_2D, ye, 0, 0, nt, pt, le, We),
                    Ee.unbindTexture();
            }),
            (this.copyTextureToTexture = function (
                V,
                re,
                ye = null,
                ve = null,
                le = 0
            ) {
                V.isTexture !== !0 &&
                    (console.warn(
                        'WebGLRenderer: copyTextureToTexture function signature has changed.'
                    ),
                    (ve = arguments[0] || null),
                    (V = arguments[1]),
                    (re = arguments[2]),
                    (le = arguments[3] || 0),
                    (ye = null));
                let We, nt, pt, Xe, Mt, Et;
                ye !== null
                    ? ((We = ye.max.x - ye.min.x),
                      (nt = ye.max.y - ye.min.y),
                      (pt = ye.min.x),
                      (Xe = ye.min.y))
                    : ((We = V.image.width),
                      (nt = V.image.height),
                      (pt = 0),
                      (Xe = 0)),
                    ve !== null
                        ? ((Mt = ve.x), (Et = ve.y))
                        : ((Mt = 0), (Et = 0));
                const wt = Ut.convert(re.format),
                    Qt = Ut.convert(re.type);
                ot.setTexture2D(re, 0),
                    W.pixelStorei(W.UNPACK_FLIP_Y_WEBGL, re.flipY),
                    W.pixelStorei(
                        W.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
                        re.premultiplyAlpha
                    ),
                    W.pixelStorei(W.UNPACK_ALIGNMENT, re.unpackAlignment);
                const vn = W.getParameter(W.UNPACK_ROW_LENGTH),
                    un = W.getParameter(W.UNPACK_IMAGE_HEIGHT),
                    En = W.getParameter(W.UNPACK_SKIP_PIXELS),
                    ft = W.getParameter(W.UNPACK_SKIP_ROWS),
                    je = W.getParameter(W.UNPACK_SKIP_IMAGES),
                    Zt = V.isCompressedTexture ? V.mipmaps[le] : V.image;
                W.pixelStorei(W.UNPACK_ROW_LENGTH, Zt.width),
                    W.pixelStorei(W.UNPACK_IMAGE_HEIGHT, Zt.height),
                    W.pixelStorei(W.UNPACK_SKIP_PIXELS, pt),
                    W.pixelStorei(W.UNPACK_SKIP_ROWS, Xe),
                    V.isDataTexture
                        ? W.texSubImage2D(
                              W.TEXTURE_2D,
                              le,
                              Mt,
                              Et,
                              We,
                              nt,
                              wt,
                              Qt,
                              Zt.data
                          )
                        : V.isCompressedTexture
                          ? W.compressedTexSubImage2D(
                                W.TEXTURE_2D,
                                le,
                                Mt,
                                Et,
                                Zt.width,
                                Zt.height,
                                wt,
                                Zt.data
                            )
                          : W.texSubImage2D(
                                W.TEXTURE_2D,
                                le,
                                Mt,
                                Et,
                                We,
                                nt,
                                wt,
                                Qt,
                                Zt
                            ),
                    W.pixelStorei(W.UNPACK_ROW_LENGTH, vn),
                    W.pixelStorei(W.UNPACK_IMAGE_HEIGHT, un),
                    W.pixelStorei(W.UNPACK_SKIP_PIXELS, En),
                    W.pixelStorei(W.UNPACK_SKIP_ROWS, ft),
                    W.pixelStorei(W.UNPACK_SKIP_IMAGES, je),
                    le === 0 &&
                        re.generateMipmaps &&
                        W.generateMipmap(W.TEXTURE_2D),
                    Ee.unbindTexture();
            }),
            (this.copyTextureToTexture3D = function (
                V,
                re,
                ye = null,
                ve = null,
                le = 0
            ) {
                V.isTexture !== !0 &&
                    (console.warn(
                        'WebGLRenderer: copyTextureToTexture3D function signature has changed.'
                    ),
                    (ye = arguments[0] || null),
                    (ve = arguments[1] || null),
                    (V = arguments[2]),
                    (re = arguments[3]),
                    (le = arguments[4] || 0));
                let We, nt, pt, Xe, Mt, Et, wt, Qt, vn;
                const un = V.isCompressedTexture ? V.mipmaps[le] : V.image;
                ye !== null
                    ? ((We = ye.max.x - ye.min.x),
                      (nt = ye.max.y - ye.min.y),
                      (pt = ye.max.z - ye.min.z),
                      (Xe = ye.min.x),
                      (Mt = ye.min.y),
                      (Et = ye.min.z))
                    : ((We = un.width),
                      (nt = un.height),
                      (pt = un.depth),
                      (Xe = 0),
                      (Mt = 0),
                      (Et = 0)),
                    ve !== null
                        ? ((wt = ve.x), (Qt = ve.y), (vn = ve.z))
                        : ((wt = 0), (Qt = 0), (vn = 0));
                const En = Ut.convert(re.format),
                    ft = Ut.convert(re.type);
                let je;
                if (re.isData3DTexture)
                    ot.setTexture3D(re, 0), (je = W.TEXTURE_3D);
                else if (re.isDataArrayTexture || re.isCompressedArrayTexture)
                    ot.setTexture2DArray(re, 0), (je = W.TEXTURE_2D_ARRAY);
                else {
                    console.warn(
                        'THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.'
                    );
                    return;
                }
                W.pixelStorei(W.UNPACK_FLIP_Y_WEBGL, re.flipY),
                    W.pixelStorei(
                        W.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
                        re.premultiplyAlpha
                    ),
                    W.pixelStorei(W.UNPACK_ALIGNMENT, re.unpackAlignment);
                const Zt = W.getParameter(W.UNPACK_ROW_LENGTH),
                    It = W.getParameter(W.UNPACK_IMAGE_HEIGHT),
                    xn = W.getParameter(W.UNPACK_SKIP_PIXELS),
                    Wi = W.getParameter(W.UNPACK_SKIP_ROWS),
                    Dn = W.getParameter(W.UNPACK_SKIP_IMAGES);
                W.pixelStorei(W.UNPACK_ROW_LENGTH, un.width),
                    W.pixelStorei(W.UNPACK_IMAGE_HEIGHT, un.height),
                    W.pixelStorei(W.UNPACK_SKIP_PIXELS, Xe),
                    W.pixelStorei(W.UNPACK_SKIP_ROWS, Mt),
                    W.pixelStorei(W.UNPACK_SKIP_IMAGES, Et),
                    V.isDataTexture || V.isData3DTexture
                        ? W.texSubImage3D(
                              je,
                              le,
                              wt,
                              Qt,
                              vn,
                              We,
                              nt,
                              pt,
                              En,
                              ft,
                              un.data
                          )
                        : re.isCompressedArrayTexture
                          ? W.compressedTexSubImage3D(
                                je,
                                le,
                                wt,
                                Qt,
                                vn,
                                We,
                                nt,
                                pt,
                                En,
                                un.data
                            )
                          : W.texSubImage3D(
                                je,
                                le,
                                wt,
                                Qt,
                                vn,
                                We,
                                nt,
                                pt,
                                En,
                                ft,
                                un
                            ),
                    W.pixelStorei(W.UNPACK_ROW_LENGTH, Zt),
                    W.pixelStorei(W.UNPACK_IMAGE_HEIGHT, It),
                    W.pixelStorei(W.UNPACK_SKIP_PIXELS, xn),
                    W.pixelStorei(W.UNPACK_SKIP_ROWS, Wi),
                    W.pixelStorei(W.UNPACK_SKIP_IMAGES, Dn),
                    le === 0 && re.generateMipmaps && W.generateMipmap(je),
                    Ee.unbindTexture();
            }),
            (this.initRenderTarget = function (V) {
                Ze.get(V).__webglFramebuffer === void 0 &&
                    ot.setupRenderTarget(V);
            }),
            (this.initTexture = function (V) {
                V.isCubeTexture
                    ? ot.setTextureCube(V, 0)
                    : V.isData3DTexture
                      ? ot.setTexture3D(V, 0)
                      : V.isDataArrayTexture || V.isCompressedArrayTexture
                        ? ot.setTexture2DArray(V, 0)
                        : ot.setTexture2D(V, 0),
                    Ee.unbindTexture();
            }),
            (this.resetState = function () {
                (F = 0), (N = 0), (B = null), Ee.reset(), zt.reset();
            }),
            typeof __THREE_DEVTOOLS__ < 'u' &&
                __THREE_DEVTOOLS__.dispatchEvent(
                    new CustomEvent('observe', { detail: this })
                );
    }
    get coordinateSystem() {
        return Do;
    }
    get outputColorSpace() {
        return this._outputColorSpace;
    }
    set outputColorSpace(e) {
        this._outputColorSpace = e;
        const t = this.getContext();
        (t.drawingBufferColorSpace = e === gv ? 'display-p3' : 'srgb'),
            (t.unpackColorSpace =
                hn.workingColorSpace === Yp ? 'display-p3' : 'srgb');
    }
}
class xv {
    constructor(e, t = 25e-5) {
        (this.isFogExp2 = !0),
            (this.name = ''),
            (this.color = new st(e)),
            (this.density = t);
    }
    clone() {
        return new xv(this.color, this.density);
    }
    toJSON() {
        return {
            type: 'FogExp2',
            name: this.name,
            color: this.color.getHex(),
            density: this.density,
        };
    }
}
class _v {
    constructor(e, t = 1, n = 1e3) {
        (this.isFog = !0),
            (this.name = ''),
            (this.color = new st(e)),
            (this.near = t),
            (this.far = n);
    }
    clone() {
        return new _v(this.color, this.near, this.far);
    }
    toJSON() {
        return {
            type: 'Fog',
            name: this.name,
            color: this.color.getHex(),
            near: this.near,
            far: this.far,
        };
    }
}
class YS extends ln {
    constructor() {
        super(),
            (this.isScene = !0),
            (this.type = 'Scene'),
            (this.background = null),
            (this.environment = null),
            (this.fog = null),
            (this.backgroundBlurriness = 0),
            (this.backgroundIntensity = 1),
            (this.backgroundRotation = new as()),
            (this.environmentIntensity = 1),
            (this.environmentRotation = new as()),
            (this.overrideMaterial = null),
            typeof __THREE_DEVTOOLS__ < 'u' &&
                __THREE_DEVTOOLS__.dispatchEvent(
                    new CustomEvent('observe', { detail: this })
                );
    }
    copy(e, t) {
        return (
            super.copy(e, t),
            e.background !== null && (this.background = e.background.clone()),
            e.environment !== null &&
                (this.environment = e.environment.clone()),
            e.fog !== null && (this.fog = e.fog.clone()),
            (this.backgroundBlurriness = e.backgroundBlurriness),
            (this.backgroundIntensity = e.backgroundIntensity),
            this.backgroundRotation.copy(e.backgroundRotation),
            (this.environmentIntensity = e.environmentIntensity),
            this.environmentRotation.copy(e.environmentRotation),
            e.overrideMaterial !== null &&
                (this.overrideMaterial = e.overrideMaterial.clone()),
            (this.matrixAutoUpdate = e.matrixAutoUpdate),
            this
        );
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return (
            this.fog !== null && (t.object.fog = this.fog.toJSON()),
            this.backgroundBlurriness > 0 &&
                (t.object.backgroundBlurriness = this.backgroundBlurriness),
            this.backgroundIntensity !== 1 &&
                (t.object.backgroundIntensity = this.backgroundIntensity),
            (t.object.backgroundRotation = this.backgroundRotation.toArray()),
            this.environmentIntensity !== 1 &&
                (t.object.environmentIntensity = this.environmentIntensity),
            (t.object.environmentRotation = this.environmentRotation.toArray()),
            t
        );
    }
}
class Sv {
    constructor(e, t) {
        (this.isInterleavedBuffer = !0),
            (this.array = e),
            (this.stride = t),
            (this.count = e !== void 0 ? e.length / t : 0),
            (this.usage = Cp),
            (this._updateRange = { offset: 0, count: -1 }),
            (this.updateRanges = []),
            (this.version = 0),
            (this.uuid = os());
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        e === !0 && this.version++;
    }
    get updateRange() {
        return (
            zS(
                'THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead.'
            ),
            this._updateRange
        );
    }
    setUsage(e) {
        return (this.usage = e), this;
    }
    addUpdateRange(e, t) {
        this.updateRanges.push({ start: e, count: t });
    }
    clearUpdateRanges() {
        this.updateRanges.length = 0;
    }
    copy(e) {
        return (
            (this.array = new e.array.constructor(e.array)),
            (this.count = e.count),
            (this.stride = e.stride),
            (this.usage = e.usage),
            this
        );
    }
    copyAt(e, t, n) {
        (e *= this.stride), (n *= t.stride);
        for (let r = 0, s = this.stride; r < s; r++)
            this.array[e + r] = t.array[n + r];
        return this;
    }
    set(e, t = 0) {
        return this.array.set(e, t), this;
    }
    clone(e) {
        e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
            this.array.buffer._uuid === void 0 &&
                (this.array.buffer._uuid = os()),
            e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
                (e.arrayBuffers[this.array.buffer._uuid] =
                    this.array.slice(0).buffer);
        const t = new this.array.constructor(
                e.arrayBuffers[this.array.buffer._uuid]
            ),
            n = new this.constructor(t, this.stride);
        return n.setUsage(this.usage), n;
    }
    onUpload(e) {
        return (this.onUploadCallback = e), this;
    }
    toJSON(e) {
        return (
            e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
            this.array.buffer._uuid === void 0 &&
                (this.array.buffer._uuid = os()),
            e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
                (e.arrayBuffers[this.array.buffer._uuid] = Array.from(
                    new Uint32Array(this.array.buffer)
                )),
            {
                uuid: this.uuid,
                buffer: this.array.buffer._uuid,
                type: this.array.constructor.name,
                stride: this.stride,
            }
        );
    }
}
const _r = new j();
class uc {
    constructor(e, t, n, r = !1) {
        (this.isInterleavedBufferAttribute = !0),
            (this.name = ''),
            (this.data = e),
            (this.itemSize = t),
            (this.offset = n),
            (this.normalized = r);
    }
    get count() {
        return this.data.count;
    }
    get array() {
        return this.data.array;
    }
    set needsUpdate(e) {
        this.data.needsUpdate = e;
    }
    applyMatrix4(e) {
        for (let t = 0, n = this.data.count; t < n; t++)
            _r.fromBufferAttribute(this, t),
                _r.applyMatrix4(e),
                this.setXYZ(t, _r.x, _r.y, _r.z);
        return this;
    }
    applyNormalMatrix(e) {
        for (let t = 0, n = this.count; t < n; t++)
            _r.fromBufferAttribute(this, t),
                _r.applyNormalMatrix(e),
                this.setXYZ(t, _r.x, _r.y, _r.z);
        return this;
    }
    transformDirection(e) {
        for (let t = 0, n = this.count; t < n; t++)
            _r.fromBufferAttribute(this, t),
                _r.transformDirection(e),
                this.setXYZ(t, _r.x, _r.y, _r.z);
        return this;
    }
    getComponent(e, t) {
        let n = this.array[e * this.data.stride + this.offset + t];
        return this.normalized && (n = wr(n, this.array)), n;
    }
    setComponent(e, t, n) {
        return (
            this.normalized && (n = Xt(n, this.array)),
            (this.data.array[e * this.data.stride + this.offset + t] = n),
            this
        );
    }
    setX(e, t) {
        return (
            this.normalized && (t = Xt(t, this.array)),
            (this.data.array[e * this.data.stride + this.offset] = t),
            this
        );
    }
    setY(e, t) {
        return (
            this.normalized && (t = Xt(t, this.array)),
            (this.data.array[e * this.data.stride + this.offset + 1] = t),
            this
        );
    }
    setZ(e, t) {
        return (
            this.normalized && (t = Xt(t, this.array)),
            (this.data.array[e * this.data.stride + this.offset + 2] = t),
            this
        );
    }
    setW(e, t) {
        return (
            this.normalized && (t = Xt(t, this.array)),
            (this.data.array[e * this.data.stride + this.offset + 3] = t),
            this
        );
    }
    getX(e) {
        let t = this.data.array[e * this.data.stride + this.offset];
        return this.normalized && (t = wr(t, this.array)), t;
    }
    getY(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 1];
        return this.normalized && (t = wr(t, this.array)), t;
    }
    getZ(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 2];
        return this.normalized && (t = wr(t, this.array)), t;
    }
    getW(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 3];
        return this.normalized && (t = wr(t, this.array)), t;
    }
    setXY(e, t, n) {
        return (
            (e = e * this.data.stride + this.offset),
            this.normalized &&
                ((t = Xt(t, this.array)), (n = Xt(n, this.array))),
            (this.data.array[e + 0] = t),
            (this.data.array[e + 1] = n),
            this
        );
    }
    setXYZ(e, t, n, r) {
        return (
            (e = e * this.data.stride + this.offset),
            this.normalized &&
                ((t = Xt(t, this.array)),
                (n = Xt(n, this.array)),
                (r = Xt(r, this.array))),
            (this.data.array[e + 0] = t),
            (this.data.array[e + 1] = n),
            (this.data.array[e + 2] = r),
            this
        );
    }
    setXYZW(e, t, n, r, s) {
        return (
            (e = e * this.data.stride + this.offset),
            this.normalized &&
                ((t = Xt(t, this.array)),
                (n = Xt(n, this.array)),
                (r = Xt(r, this.array)),
                (s = Xt(s, this.array))),
            (this.data.array[e + 0] = t),
            (this.data.array[e + 1] = n),
            (this.data.array[e + 2] = r),
            (this.data.array[e + 3] = s),
            this
        );
    }
    clone(e) {
        if (e === void 0) {
            console.log(
                'THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.'
            );
            const t = [];
            for (let n = 0; n < this.count; n++) {
                const r = n * this.data.stride + this.offset;
                for (let s = 0; s < this.itemSize; s++)
                    t.push(this.data.array[r + s]);
            }
            return new Mn(
                new this.array.constructor(t),
                this.itemSize,
                this.normalized
            );
        } else
            return (
                e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
                e.interleavedBuffers[this.data.uuid] === void 0 &&
                    (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
                new uc(
                    e.interleavedBuffers[this.data.uuid],
                    this.itemSize,
                    this.offset,
                    this.normalized
                )
            );
    }
    toJSON(e) {
        if (e === void 0) {
            console.log(
                'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.'
            );
            const t = [];
            for (let n = 0; n < this.count; n++) {
                const r = n * this.data.stride + this.offset;
                for (let s = 0; s < this.itemSize; s++)
                    t.push(this.data.array[r + s]);
            }
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: t,
                normalized: this.normalized,
            };
        } else
            return (
                e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
                e.interleavedBuffers[this.data.uuid] === void 0 &&
                    (e.interleavedBuffers[this.data.uuid] =
                        this.data.toJSON(e)),
                {
                    isInterleavedBufferAttribute: !0,
                    itemSize: this.itemSize,
                    data: this.data.uuid,
                    offset: this.offset,
                    normalized: this.normalized,
                }
            );
    }
}
class KS extends lr {
    constructor(e) {
        super(),
            (this.isSpriteMaterial = !0),
            (this.type = 'SpriteMaterial'),
            (this.color = new st(16777215)),
            (this.map = null),
            (this.alphaMap = null),
            (this.rotation = 0),
            (this.sizeAttenuation = !0),
            (this.transparent = !0),
            (this.fog = !0),
            this.setValues(e);
    }
    copy(e) {
        return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.rotation = e.rotation),
            (this.sizeAttenuation = e.sizeAttenuation),
            (this.fog = e.fog),
            this
        );
    }
}
let Df;
const Ld = new j(),
    Nf = new j(),
    Uf = new j(),
    Of = new Ce(),
    Id = new Ce(),
    ob = new Pt(),
    Tg = new j(),
    Dd = new j(),
    Ag = new j(),
    gE = new Ce(),
    fx = new Ce(),
    yE = new Ce();
class ab extends ln {
    constructor(e = new KS()) {
        if (
            (super(),
            (this.isSprite = !0),
            (this.type = 'Sprite'),
            Df === void 0)
        ) {
            Df = new $t();
            const t = new Float32Array([
                    -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1,
                    -0.5, 0.5, 0, 0, 1,
                ]),
                n = new Sv(t, 5);
            Df.setIndex([0, 1, 2, 0, 2, 3]),
                Df.setAttribute('position', new uc(n, 3, 0, !1)),
                Df.setAttribute('uv', new uc(n, 2, 3, !1));
        }
        (this.geometry = Df),
            (this.material = e),
            (this.center = new Ce(0.5, 0.5));
    }
    raycast(e, t) {
        e.camera === null &&
            console.error(
                'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
            ),
            Nf.setFromMatrixScale(this.matrixWorld),
            ob.copy(e.camera.matrixWorld),
            this.modelViewMatrix.multiplyMatrices(
                e.camera.matrixWorldInverse,
                this.matrixWorld
            ),
            Uf.setFromMatrixPosition(this.modelViewMatrix),
            e.camera.isPerspectiveCamera &&
                this.material.sizeAttenuation === !1 &&
                Nf.multiplyScalar(-Uf.z);
        const n = this.material.rotation;
        let r, s;
        n !== 0 && ((s = Math.cos(n)), (r = Math.sin(n)));
        const a = this.center;
        Cg(Tg.set(-0.5, -0.5, 0), Uf, a, Nf, r, s),
            Cg(Dd.set(0.5, -0.5, 0), Uf, a, Nf, r, s),
            Cg(Ag.set(0.5, 0.5, 0), Uf, a, Nf, r, s),
            gE.set(0, 0),
            fx.set(1, 0),
            yE.set(1, 1);
        let l = e.ray.intersectTriangle(Tg, Dd, Ag, !1, Ld);
        if (
            l === null &&
            (Cg(Dd.set(-0.5, 0.5, 0), Uf, a, Nf, r, s),
            fx.set(0, 1),
            (l = e.ray.intersectTriangle(Tg, Ag, Dd, !1, Ld)),
            l === null)
        )
            return;
        const c = e.ray.origin.distanceTo(Ld);
        c < e.near ||
            c > e.far ||
            t.push({
                distance: c,
                point: Ld.clone(),
                uv: ss.getInterpolation(Ld, Tg, Dd, Ag, gE, fx, yE, new Ce()),
                face: null,
                object: this,
            });
    }
    copy(e, t) {
        return (
            super.copy(e, t),
            e.center !== void 0 && this.center.copy(e.center),
            (this.material = e.material),
            this
        );
    }
}
function Cg(i, e, t, n, r, s) {
    Of.subVectors(i, t).addScalar(0.5).multiply(n),
        r !== void 0
            ? ((Id.x = s * Of.x - r * Of.y), (Id.y = r * Of.x + s * Of.y))
            : Id.copy(Of),
        i.copy(e),
        (i.x += Id.x),
        (i.y += Id.y),
        i.applyMatrix4(ob);
}
const Rg = new j(),
    vE = new j();
class lb extends ln {
    constructor() {
        super(),
            (this._currentLevel = 0),
            (this.type = 'LOD'),
            Object.defineProperties(this, {
                levels: { enumerable: !0, value: [] },
                isLOD: { value: !0 },
            }),
            (this.autoUpdate = !0);
    }
    copy(e) {
        super.copy(e, !1);
        const t = e.levels;
        for (let n = 0, r = t.length; n < r; n++) {
            const s = t[n];
            this.addLevel(s.object.clone(), s.distance, s.hysteresis);
        }
        return (this.autoUpdate = e.autoUpdate), this;
    }
    addLevel(e, t = 0, n = 0) {
        t = Math.abs(t);
        const r = this.levels;
        let s;
        for (s = 0; s < r.length && !(t < r[s].distance); s++);
        return (
            r.splice(s, 0, { distance: t, hysteresis: n, object: e }),
            this.add(e),
            this
        );
    }
    getCurrentLevel() {
        return this._currentLevel;
    }
    getObjectForDistance(e) {
        const t = this.levels;
        if (t.length > 0) {
            let n, r;
            for (n = 1, r = t.length; n < r; n++) {
                let s = t[n].distance;
                if ((t[n].object.visible && (s -= s * t[n].hysteresis), e < s))
                    break;
            }
            return t[n - 1].object;
        }
        return null;
    }
    raycast(e, t) {
        if (this.levels.length > 0) {
            Rg.setFromMatrixPosition(this.matrixWorld);
            const r = e.ray.origin.distanceTo(Rg);
            this.getObjectForDistance(r).raycast(e, t);
        }
    }
    update(e) {
        const t = this.levels;
        if (t.length > 1) {
            Rg.setFromMatrixPosition(e.matrixWorld),
                vE.setFromMatrixPosition(this.matrixWorld);
            const n = Rg.distanceTo(vE) / e.zoom;
            t[0].object.visible = !0;
            let r, s;
            for (r = 1, s = t.length; r < s; r++) {
                let a = t[r].distance;
                if ((t[r].object.visible && (a -= a * t[r].hysteresis), n >= a))
                    (t[r - 1].object.visible = !1), (t[r].object.visible = !0);
                else break;
            }
            for (this._currentLevel = r - 1; r < s; r++)
                t[r].object.visible = !1;
        }
    }
    toJSON(e) {
        const t = super.toJSON(e);
        this.autoUpdate === !1 && (t.object.autoUpdate = !1),
            (t.object.levels = []);
        const n = this.levels;
        for (let r = 0, s = n.length; r < s; r++) {
            const a = n[r];
            t.object.levels.push({
                object: a.object.uuid,
                distance: a.distance,
                hysteresis: a.hysteresis,
            });
        }
        return t;
    }
}
const xE = new j(),
    _E = new gn(),
    SE = new gn(),
    mV = new j(),
    wE = new Pt(),
    bg = new j(),
    hx = new or(),
    ME = new Pt(),
    dx = new Eh();
class ub extends di {
    constructor(e, t) {
        super(e, t),
            (this.isSkinnedMesh = !0),
            (this.type = 'SkinnedMesh'),
            (this.bindMode = m_),
            (this.bindMatrix = new Pt()),
            (this.bindMatrixInverse = new Pt()),
            (this.boundingBox = null),
            (this.boundingSphere = null);
    }
    computeBoundingBox() {
        const e = this.geometry;
        this.boundingBox === null && (this.boundingBox = new Tr()),
            this.boundingBox.makeEmpty();
        const t = e.getAttribute('position');
        for (let n = 0; n < t.count; n++)
            this.getVertexPosition(n, bg), this.boundingBox.expandByPoint(bg);
    }
    computeBoundingSphere() {
        const e = this.geometry;
        this.boundingSphere === null && (this.boundingSphere = new or()),
            this.boundingSphere.makeEmpty();
        const t = e.getAttribute('position');
        for (let n = 0; n < t.count; n++)
            this.getVertexPosition(n, bg),
                this.boundingSphere.expandByPoint(bg);
    }
    copy(e, t) {
        return (
            super.copy(e, t),
            (this.bindMode = e.bindMode),
            this.bindMatrix.copy(e.bindMatrix),
            this.bindMatrixInverse.copy(e.bindMatrixInverse),
            (this.skeleton = e.skeleton),
            e.boundingBox !== null &&
                (this.boundingBox = e.boundingBox.clone()),
            e.boundingSphere !== null &&
                (this.boundingSphere = e.boundingSphere.clone()),
            this
        );
    }
    raycast(e, t) {
        const n = this.material,
            r = this.matrixWorld;
        n !== void 0 &&
            (this.boundingSphere === null && this.computeBoundingSphere(),
            hx.copy(this.boundingSphere),
            hx.applyMatrix4(r),
            e.ray.intersectsSphere(hx) !== !1 &&
                (ME.copy(r).invert(),
                dx.copy(e.ray).applyMatrix4(ME),
                !(
                    this.boundingBox !== null &&
                    dx.intersectsBox(this.boundingBox) === !1
                ) && this._computeIntersections(e, t, dx)));
    }
    getVertexPosition(e, t) {
        return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t;
    }
    bind(e, t) {
        (this.skeleton = e),
            t === void 0 &&
                (this.updateMatrixWorld(!0),
                this.skeleton.calculateInverses(),
                (t = this.matrixWorld)),
            this.bindMatrix.copy(t),
            this.bindMatrixInverse.copy(t).invert();
    }
    pose() {
        this.skeleton.pose();
    }
    normalizeSkinWeights() {
        const e = new gn(),
            t = this.geometry.attributes.skinWeight;
        for (let n = 0, r = t.count; n < r; n++) {
            e.fromBufferAttribute(t, n);
            const s = 1 / e.manhattanLength();
            s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0),
                t.setXYZW(n, e.x, e.y, e.z, e.w);
        }
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e),
            this.bindMode === m_
                ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
                : this.bindMode === bR
                  ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
                  : console.warn(
                        'THREE.SkinnedMesh: Unrecognized bindMode: ' +
                            this.bindMode
                    );
    }
    applyBoneTransform(e, t) {
        const n = this.skeleton,
            r = this.geometry;
        _E.fromBufferAttribute(r.attributes.skinIndex, e),
            SE.fromBufferAttribute(r.attributes.skinWeight, e),
            xE.copy(t).applyMatrix4(this.bindMatrix),
            t.set(0, 0, 0);
        for (let s = 0; s < 4; s++) {
            const a = SE.getComponent(s);
            if (a !== 0) {
                const l = _E.getComponent(s);
                wE.multiplyMatrices(n.bones[l].matrixWorld, n.boneInverses[l]),
                    t.addScaledVector(mV.copy(xE).applyMatrix4(wE), a);
            }
        }
        return t.applyMatrix4(this.bindMatrixInverse);
    }
}
class ZS extends ln {
    constructor() {
        super(), (this.isBone = !0), (this.type = 'Bone');
    }
}
class Bo extends Qn {
    constructor(e = null, t = 1, n = 1, r, s, a, l, c, d = Li, p = Li, g, y) {
        super(null, a, l, c, d, p, r, s, g, y),
            (this.isDataTexture = !0),
            (this.image = { data: e, width: t, height: n }),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1);
    }
}
const EE = new Pt(),
    gV = new Pt();
class wv {
    constructor(e = [], t = []) {
        (this.uuid = os()),
            (this.bones = e.slice(0)),
            (this.boneInverses = t),
            (this.boneMatrices = null),
            (this.boneTexture = null),
            this.init();
    }
    init() {
        const e = this.bones,
            t = this.boneInverses;
        if (
            ((this.boneMatrices = new Float32Array(e.length * 16)),
            t.length === 0)
        )
            this.calculateInverses();
        else if (e.length !== t.length) {
            console.warn(
                'THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.'
            ),
                (this.boneInverses = []);
            for (let n = 0, r = this.bones.length; n < r; n++)
                this.boneInverses.push(new Pt());
        }
    }
    calculateInverses() {
        this.boneInverses.length = 0;
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const n = new Pt();
            this.bones[e] && n.copy(this.bones[e].matrixWorld).invert(),
                this.boneInverses.push(n);
        }
    }
    pose() {
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const n = this.bones[e];
            n && n.matrixWorld.copy(this.boneInverses[e]).invert();
        }
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const n = this.bones[e];
            n &&
                (n.parent && n.parent.isBone
                    ? (n.matrix.copy(n.parent.matrixWorld).invert(),
                      n.matrix.multiply(n.matrixWorld))
                    : n.matrix.copy(n.matrixWorld),
                n.matrix.decompose(n.position, n.quaternion, n.scale));
        }
    }
    update() {
        const e = this.bones,
            t = this.boneInverses,
            n = this.boneMatrices,
            r = this.boneTexture;
        for (let s = 0, a = e.length; s < a; s++) {
            const l = e[s] ? e[s].matrixWorld : gV;
            EE.multiplyMatrices(l, t[s]), EE.toArray(n, s * 16);
        }
        r !== null && (r.needsUpdate = !0);
    }
    clone() {
        return new wv(this.bones, this.boneInverses);
    }
    computeBoneTexture() {
        let e = Math.sqrt(this.bones.length * 4);
        (e = Math.ceil(e / 4) * 4), (e = Math.max(e, 4));
        const t = new Float32Array(e * e * 4);
        t.set(this.boneMatrices);
        const n = new Bo(t, e, e, sr, Vr);
        return (
            (n.needsUpdate = !0),
            (this.boneMatrices = t),
            (this.boneTexture = n),
            this
        );
    }
    getBoneByName(e) {
        for (let t = 0, n = this.bones.length; t < n; t++) {
            const r = this.bones[t];
            if (r.name === e) return r;
        }
    }
    dispose() {
        this.boneTexture !== null &&
            (this.boneTexture.dispose(), (this.boneTexture = null));
    }
    fromJSON(e, t) {
        this.uuid = e.uuid;
        for (let n = 0, r = e.bones.length; n < r; n++) {
            const s = e.bones[n];
            let a = t[s];
            a === void 0 &&
                (console.warn('THREE.Skeleton: No bone found with UUID:', s),
                (a = new ZS())),
                this.bones.push(a),
                this.boneInverses.push(new Pt().fromArray(e.boneInverses[n]));
        }
        return this.init(), this;
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.6,
                type: 'Skeleton',
                generator: 'Skeleton.toJSON',
            },
            bones: [],
            boneInverses: [],
        };
        e.uuid = this.uuid;
        const t = this.bones,
            n = this.boneInverses;
        for (let r = 0, s = t.length; r < s; r++) {
            const a = t[r];
            e.bones.push(a.uuid);
            const l = n[r];
            e.boneInverses.push(l.toArray());
        }
        return e;
    }
}
class dh extends Mn {
    constructor(e, t, n, r = 1) {
        super(e, t, n),
            (this.isInstancedBufferAttribute = !0),
            (this.meshPerAttribute = r);
    }
    copy(e) {
        return (
            super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this
        );
    }
    toJSON() {
        const e = super.toJSON();
        return (
            (e.meshPerAttribute = this.meshPerAttribute),
            (e.isInstancedBufferAttribute = !0),
            e
        );
    }
}
const kf = new Pt(),
    TE = new Pt(),
    Pg = [],
    AE = new Tr(),
    yV = new Pt(),
    Nd = new di(),
    Ud = new or();
class cb extends di {
    constructor(e, t, n) {
        super(e, t),
            (this.isInstancedMesh = !0),
            (this.instanceMatrix = new dh(new Float32Array(n * 16), 16)),
            (this.instanceColor = null),
            (this.morphTexture = null),
            (this.count = n),
            (this.boundingBox = null),
            (this.boundingSphere = null);
        for (let r = 0; r < n; r++) this.setMatrixAt(r, yV);
    }
    computeBoundingBox() {
        const e = this.geometry,
            t = this.count;
        this.boundingBox === null && (this.boundingBox = new Tr()),
            e.boundingBox === null && e.computeBoundingBox(),
            this.boundingBox.makeEmpty();
        for (let n = 0; n < t; n++)
            this.getMatrixAt(n, kf),
                AE.copy(e.boundingBox).applyMatrix4(kf),
                this.boundingBox.union(AE);
    }
    computeBoundingSphere() {
        const e = this.geometry,
            t = this.count;
        this.boundingSphere === null && (this.boundingSphere = new or()),
            e.boundingSphere === null && e.computeBoundingSphere(),
            this.boundingSphere.makeEmpty();
        for (let n = 0; n < t; n++)
            this.getMatrixAt(n, kf),
                Ud.copy(e.boundingSphere).applyMatrix4(kf),
                this.boundingSphere.union(Ud);
    }
    copy(e, t) {
        return (
            super.copy(e, t),
            this.instanceMatrix.copy(e.instanceMatrix),
            e.morphTexture !== null &&
                (this.morphTexture = e.morphTexture.clone()),
            e.instanceColor !== null &&
                (this.instanceColor = e.instanceColor.clone()),
            (this.count = e.count),
            e.boundingBox !== null &&
                (this.boundingBox = e.boundingBox.clone()),
            e.boundingSphere !== null &&
                (this.boundingSphere = e.boundingSphere.clone()),
            this
        );
    }
    getColorAt(e, t) {
        t.fromArray(this.instanceColor.array, e * 3);
    }
    getMatrixAt(e, t) {
        t.fromArray(this.instanceMatrix.array, e * 16);
    }
    getMorphAt(e, t) {
        const n = t.morphTargetInfluences,
            r = this.morphTexture.source.data.data,
            s = n.length + 1,
            a = e * s + 1;
        for (let l = 0; l < n.length; l++) n[l] = r[a + l];
    }
    raycast(e, t) {
        const n = this.matrixWorld,
            r = this.count;
        if (
            ((Nd.geometry = this.geometry),
            (Nd.material = this.material),
            Nd.material !== void 0 &&
                (this.boundingSphere === null && this.computeBoundingSphere(),
                Ud.copy(this.boundingSphere),
                Ud.applyMatrix4(n),
                e.ray.intersectsSphere(Ud) !== !1))
        )
            for (let s = 0; s < r; s++) {
                this.getMatrixAt(s, kf),
                    TE.multiplyMatrices(n, kf),
                    (Nd.matrixWorld = TE),
                    Nd.raycast(e, Pg);
                for (let a = 0, l = Pg.length; a < l; a++) {
                    const c = Pg[a];
                    (c.instanceId = s), (c.object = this), t.push(c);
                }
                Pg.length = 0;
            }
    }
    setColorAt(e, t) {
        this.instanceColor === null &&
            (this.instanceColor = new dh(
                new Float32Array(this.instanceMatrix.count * 3),
                3
            )),
            t.toArray(this.instanceColor.array, e * 3);
    }
    setMatrixAt(e, t) {
        t.toArray(this.instanceMatrix.array, e * 16);
    }
    setMorphAt(e, t) {
        const n = t.morphTargetInfluences,
            r = n.length + 1;
        this.morphTexture === null &&
            (this.morphTexture = new Bo(
                new Float32Array(r * this.count),
                r,
                this.count,
                hv,
                Vr
            ));
        const s = this.morphTexture.source.data.data;
        let a = 0;
        for (let d = 0; d < n.length; d++) a += n[d];
        const l = this.geometry.morphTargetsRelative ? 1 : 1 - a,
            c = r * e;
        (s[c] = l), s.set(n, c + 1);
    }
    updateMorphTargets() {}
    dispose() {
        return (
            this.dispatchEvent({ type: 'dispose' }),
            this.morphTexture !== null &&
                (this.morphTexture.dispose(), (this.morphTexture = null)),
            this
        );
    }
}
function vV(i, e) {
    return i.z - e.z;
}
function xV(i, e) {
    return e.z - i.z;
}
class _V {
    constructor() {
        (this.index = 0), (this.pool = []), (this.list = []);
    }
    push(e, t, n) {
        const r = this.pool,
            s = this.list;
        this.index >= r.length &&
            r.push({ start: -1, count: -1, z: -1, index: -1 });
        const a = r[this.index];
        s.push(a),
            this.index++,
            (a.start = e.start),
            (a.count = e.count),
            (a.z = t),
            (a.index = n);
    }
    reset() {
        (this.list.length = 0), (this.index = 0);
    }
}
const Al = new Pt(),
    px = new Pt(),
    SV = new Pt(),
    wV = new st(1, 1, 1),
    CE = new Pt(),
    mx = new Jp(),
    Lg = new Tr(),
    ku = new or(),
    Od = new j(),
    RE = new j(),
    MV = new j(),
    gx = new _V(),
    nr = new di(),
    Ig = [];
function EV(i, e, t = 0) {
    const n = e.itemSize;
    if (
        i.isInterleavedBufferAttribute ||
        i.array.constructor !== e.array.constructor
    ) {
        const r = i.count;
        for (let s = 0; s < r; s++)
            for (let a = 0; a < n; a++)
                e.setComponent(s + t, a, i.getComponent(s, a));
    } else e.array.set(i.array, t * n);
    e.needsUpdate = !0;
}
class fb extends di {
    get maxInstanceCount() {
        return this._maxInstanceCount;
    }
    constructor(e, t, n = t * 2, r) {
        super(new $t(), r),
            (this.isBatchedMesh = !0),
            (this.perObjectFrustumCulled = !0),
            (this.sortObjects = !0),
            (this.boundingBox = null),
            (this.boundingSphere = null),
            (this.customSort = null),
            (this._drawInfo = []),
            (this._drawRanges = []),
            (this._reservedRanges = []),
            (this._bounds = []),
            (this._maxInstanceCount = e),
            (this._maxVertexCount = t),
            (this._maxIndexCount = n),
            (this._geometryInitialized = !1),
            (this._geometryCount = 0),
            (this._multiDrawCounts = new Int32Array(e)),
            (this._multiDrawStarts = new Int32Array(e)),
            (this._multiDrawCount = 0),
            (this._multiDrawInstances = null),
            (this._visibilityChanged = !0),
            (this._matricesTexture = null),
            (this._indirectTexture = null),
            (this._colorsTexture = null),
            this._initMatricesTexture(),
            this._initIndirectTexture();
    }
    _initMatricesTexture() {
        let e = Math.sqrt(this._maxInstanceCount * 4);
        (e = Math.ceil(e / 4) * 4), (e = Math.max(e, 4));
        const t = new Float32Array(e * e * 4),
            n = new Bo(t, e, e, sr, Vr);
        this._matricesTexture = n;
    }
    _initIndirectTexture() {
        let e = Math.sqrt(this._maxInstanceCount);
        e = Math.ceil(e);
        const t = new Uint32Array(e * e),
            n = new Bo(t, e, e, $p, Oa);
        this._indirectTexture = n;
    }
    _initColorsTexture() {
        let e = Math.sqrt(this._maxIndexCount);
        e = Math.ceil(e);
        const t = new Float32Array(e * e * 4).fill(1),
            n = new Bo(t, e, e, sr, Vr);
        (n.colorSpace = hn.workingColorSpace), (this._colorsTexture = n);
    }
    _initializeGeometry(e) {
        const t = this.geometry,
            n = this._maxVertexCount,
            r = this._maxIndexCount;
        if (this._geometryInitialized === !1) {
            for (const s in e.attributes) {
                const a = e.getAttribute(s),
                    { array: l, itemSize: c, normalized: d } = a,
                    p = new l.constructor(n * c),
                    g = new Mn(p, c, d);
                t.setAttribute(s, g);
            }
            if (e.getIndex() !== null) {
                const s = n > 65535 ? new Uint32Array(r) : new Uint16Array(r);
                t.setIndex(new Mn(s, 1));
            }
            this._geometryInitialized = !0;
        }
    }
    _validateGeometry(e) {
        const t = this.geometry;
        if (!!e.getIndex() != !!t.getIndex())
            throw new Error(
                'BatchedMesh: All geometries must consistently have "index".'
            );
        for (const n in t.attributes) {
            if (!e.hasAttribute(n))
                throw new Error(
                    `BatchedMesh: Added geometry missing "${n}". All geometries must have consistent attributes.`
                );
            const r = e.getAttribute(n),
                s = t.getAttribute(n);
            if (r.itemSize !== s.itemSize || r.normalized !== s.normalized)
                throw new Error(
                    'BatchedMesh: All attributes must have a consistent itemSize and normalized value.'
                );
        }
    }
    setCustomSort(e) {
        return (this.customSort = e), this;
    }
    computeBoundingBox() {
        this.boundingBox === null && (this.boundingBox = new Tr());
        const e = this._geometryCount,
            t = this.boundingBox,
            n = this._drawInfo;
        t.makeEmpty();
        for (let r = 0; r < e; r++) {
            if (n[r].active === !1) continue;
            const s = n[r].geometryIndex;
            this.getMatrixAt(r, Al),
                this.getBoundingBoxAt(s, Lg).applyMatrix4(Al),
                t.union(Lg);
        }
    }
    computeBoundingSphere() {
        this.boundingSphere === null && (this.boundingSphere = new or());
        const e = this.boundingSphere,
            t = this._drawInfo;
        e.makeEmpty();
        for (let n = 0, r = t.length; n < r; n++) {
            if (t[n].active === !1) continue;
            const s = t[n].geometryIndex;
            this.getMatrixAt(n, Al),
                this.getBoundingSphereAt(s, ku).applyMatrix4(Al),
                e.union(ku);
        }
    }
    addInstance(e) {
        if (this._drawInfo.length >= this._maxInstanceCount)
            throw new Error('BatchedMesh: Maximum item count reached.');
        this._drawInfo.push({ visible: !0, active: !0, geometryIndex: e });
        const t = this._drawInfo.length - 1,
            n = this._matricesTexture,
            r = n.image.data;
        SV.toArray(r, t * 16), (n.needsUpdate = !0);
        const s = this._colorsTexture;
        return s && (wV.toArray(s.image.data, t * 4), (s.needsUpdate = !0)), t;
    }
    addGeometry(e, t = -1, n = -1) {
        if (
            (this._initializeGeometry(e),
            this._validateGeometry(e),
            this._drawInfo.length >= this._maxInstanceCount)
        )
            throw new Error('BatchedMesh: Maximum item count reached.');
        const r = {
            vertexStart: -1,
            vertexCount: -1,
            indexStart: -1,
            indexCount: -1,
        };
        let s = null;
        const a = this._reservedRanges,
            l = this._drawRanges,
            c = this._bounds;
        this._geometryCount !== 0 && (s = a[a.length - 1]),
            t === -1
                ? (r.vertexCount = e.getAttribute('position').count)
                : (r.vertexCount = t),
            s === null
                ? (r.vertexStart = 0)
                : (r.vertexStart = s.vertexStart + s.vertexCount);
        const d = e.getIndex(),
            p = d !== null;
        if (
            (p &&
                (n === -1 ? (r.indexCount = d.count) : (r.indexCount = n),
                s === null
                    ? (r.indexStart = 0)
                    : (r.indexStart = s.indexStart + s.indexCount)),
            (r.indexStart !== -1 &&
                r.indexStart + r.indexCount > this._maxIndexCount) ||
                r.vertexStart + r.vertexCount > this._maxVertexCount)
        )
            throw new Error(
                'BatchedMesh: Reserved space request exceeds the maximum buffer size.'
            );
        const g = this._geometryCount;
        return (
            this._geometryCount++,
            a.push(r),
            l.push({ start: p ? r.indexStart : r.vertexStart, count: -1 }),
            c.push({
                boxInitialized: !1,
                box: new Tr(),
                sphereInitialized: !1,
                sphere: new or(),
            }),
            this.setGeometryAt(g, e),
            g
        );
    }
    setGeometryAt(e, t) {
        if (e >= this._geometryCount)
            throw new Error('BatchedMesh: Maximum geometry count reached.');
        this._validateGeometry(t);
        const n = this.geometry,
            r = n.getIndex() !== null,
            s = n.getIndex(),
            a = t.getIndex(),
            l = this._reservedRanges[e];
        if (
            (r && a.count > l.indexCount) ||
            t.attributes.position.count > l.vertexCount
        )
            throw new Error(
                'BatchedMesh: Reserved space not large enough for provided geometry.'
            );
        const c = l.vertexStart,
            d = l.vertexCount;
        for (const v in n.attributes) {
            const S = t.getAttribute(v),
                T = n.getAttribute(v);
            EV(S, T, c);
            const M = S.itemSize;
            for (let w = S.count, b = d; w < b; w++) {
                const C = c + w;
                for (let L = 0; L < M; L++) T.setComponent(C, L, 0);
            }
            (T.needsUpdate = !0), T.addUpdateRange(c * M, d * M);
        }
        if (r) {
            const v = l.indexStart;
            for (let S = 0; S < a.count; S++) s.setX(v + S, c + a.getX(S));
            for (let S = a.count, T = l.indexCount; S < T; S++)
                s.setX(v + S, c);
            (s.needsUpdate = !0), s.addUpdateRange(v, l.indexCount);
        }
        const p = this._bounds[e];
        t.boundingBox !== null
            ? (p.box.copy(t.boundingBox), (p.boxInitialized = !0))
            : (p.boxInitialized = !1),
            t.boundingSphere !== null
                ? (p.sphere.copy(t.boundingSphere), (p.sphereInitialized = !0))
                : (p.sphereInitialized = !1);
        const g = this._drawRanges[e],
            y = t.getAttribute('position');
        return (
            (g.count = r ? a.count : y.count), (this._visibilityChanged = !0), e
        );
    }
    getBoundingBoxAt(e, t) {
        if (e >= this._geometryCount) return null;
        const n = this._bounds[e],
            r = n.box,
            s = this.geometry;
        if (n.boxInitialized === !1) {
            r.makeEmpty();
            const a = s.index,
                l = s.attributes.position,
                c = this._drawRanges[e];
            for (let d = c.start, p = c.start + c.count; d < p; d++) {
                let g = d;
                a && (g = a.getX(g)),
                    r.expandByPoint(Od.fromBufferAttribute(l, g));
            }
            n.boxInitialized = !0;
        }
        return t.copy(r), t;
    }
    getBoundingSphereAt(e, t) {
        if (e >= this._geometryCount) return null;
        const n = this._bounds[e],
            r = n.sphere,
            s = this.geometry;
        if (n.sphereInitialized === !1) {
            r.makeEmpty(), this.getBoundingBoxAt(e, Lg), Lg.getCenter(r.center);
            const a = s.index,
                l = s.attributes.position,
                c = this._drawRanges[e];
            let d = 0;
            for (let p = c.start, g = c.start + c.count; p < g; p++) {
                let y = p;
                a && (y = a.getX(y)),
                    Od.fromBufferAttribute(l, y),
                    (d = Math.max(d, r.center.distanceToSquared(Od)));
            }
            (r.radius = Math.sqrt(d)), (n.sphereInitialized = !0);
        }
        return t.copy(r), t;
    }
    setMatrixAt(e, t) {
        const n = this._drawInfo,
            r = this._matricesTexture,
            s = this._matricesTexture.image.data;
        return e >= n.length || n[e].active === !1
            ? this
            : (t.toArray(s, e * 16), (r.needsUpdate = !0), this);
    }
    getMatrixAt(e, t) {
        const n = this._drawInfo,
            r = this._matricesTexture.image.data;
        return e >= n.length || n[e].active === !1
            ? null
            : t.fromArray(r, e * 16);
    }
    setColorAt(e, t) {
        this._colorsTexture === null && this._initColorsTexture();
        const n = this._colorsTexture,
            r = this._colorsTexture.image.data,
            s = this._drawInfo;
        return e >= s.length || s[e].active === !1
            ? this
            : (t.toArray(r, e * 4), (n.needsUpdate = !0), this);
    }
    getColorAt(e, t) {
        const n = this._colorsTexture.image.data,
            r = this._drawInfo;
        return e >= r.length || r[e].active === !1
            ? null
            : t.fromArray(n, e * 4);
    }
    setVisibleAt(e, t) {
        const n = this._drawInfo;
        return e >= n.length || n[e].active === !1 || n[e].visible === t
            ? this
            : ((n[e].visible = t), (this._visibilityChanged = !0), this);
    }
    getVisibleAt(e) {
        const t = this._drawInfo;
        return e >= t.length || t[e].active === !1 ? !1 : t[e].visible;
    }
    raycast(e, t) {
        const n = this._drawInfo,
            r = this._drawRanges,
            s = this.matrixWorld,
            a = this.geometry;
        (nr.material = this.material),
            (nr.geometry.index = a.index),
            (nr.geometry.attributes = a.attributes),
            nr.geometry.boundingBox === null &&
                (nr.geometry.boundingBox = new Tr()),
            nr.geometry.boundingSphere === null &&
                (nr.geometry.boundingSphere = new or());
        for (let l = 0, c = n.length; l < c; l++) {
            if (!n[l].visible || !n[l].active) continue;
            const d = n[l].geometryIndex,
                p = r[d];
            nr.geometry.setDrawRange(p.start, p.count),
                this.getMatrixAt(l, nr.matrixWorld).premultiply(s),
                this.getBoundingBoxAt(d, nr.geometry.boundingBox),
                this.getBoundingSphereAt(d, nr.geometry.boundingSphere),
                nr.raycast(e, Ig);
            for (let g = 0, y = Ig.length; g < y; g++) {
                const v = Ig[g];
                (v.object = this), (v.batchId = l), t.push(v);
            }
            Ig.length = 0;
        }
        (nr.material = null),
            (nr.geometry.index = null),
            (nr.geometry.attributes = {}),
            nr.geometry.setDrawRange(0, 1 / 0);
    }
    copy(e) {
        return (
            super.copy(e),
            (this.geometry = e.geometry.clone()),
            (this.perObjectFrustumCulled = e.perObjectFrustumCulled),
            (this.sortObjects = e.sortObjects),
            (this.boundingBox =
                e.boundingBox !== null ? e.boundingBox.clone() : null),
            (this.boundingSphere =
                e.boundingSphere !== null ? e.boundingSphere.clone() : null),
            (this._drawRanges = e._drawRanges.map((t) => ({ ...t }))),
            (this._reservedRanges = e._reservedRanges.map((t) => ({ ...t }))),
            (this._drawInfo = e._drawInfo.map((t) => ({ ...t }))),
            (this._bounds = e._bounds.map((t) => ({
                boxInitialized: t.boxInitialized,
                box: t.box.clone(),
                sphereInitialized: t.sphereInitialized,
                sphere: t.sphere.clone(),
            }))),
            (this._maxInstanceCount = e._maxInstanceCount),
            (this._maxVertexCount = e._maxVertexCount),
            (this._maxIndexCount = e._maxIndexCount),
            (this._geometryInitialized = e._geometryInitialized),
            (this._geometryCount = e._geometryCount),
            (this._multiDrawCounts = e._multiDrawCounts.slice()),
            (this._multiDrawStarts = e._multiDrawStarts.slice()),
            (this._matricesTexture = e._matricesTexture.clone()),
            (this._matricesTexture.image.data =
                this._matricesTexture.image.slice()),
            this._colorsTexture !== null &&
                ((this._colorsTexture = e._colorsTexture.clone()),
                (this._colorsTexture.image.data =
                    this._colorsTexture.image.slice())),
            this
        );
    }
    dispose() {
        return (
            this.geometry.dispose(),
            this._matricesTexture.dispose(),
            (this._matricesTexture = null),
            this._indirectTexture.dispose(),
            (this._indirectTexture = null),
            this._colorsTexture !== null &&
                (this._colorsTexture.dispose(), (this._colorsTexture = null)),
            this
        );
    }
    onBeforeRender(e, t, n, r, s) {
        if (
            !this._visibilityChanged &&
            !this.perObjectFrustumCulled &&
            !this.sortObjects
        )
            return;
        const a = r.getIndex(),
            l = a === null ? 1 : a.array.BYTES_PER_ELEMENT,
            c = this._drawInfo,
            d = this._multiDrawStarts,
            p = this._multiDrawCounts,
            g = this._drawRanges,
            y = this.perObjectFrustumCulled,
            v = this._indirectTexture,
            S = v.image.data;
        y &&
            (CE.multiplyMatrices(
                n.projectionMatrix,
                n.matrixWorldInverse
            ).multiply(this.matrixWorld),
            mx.setFromProjectionMatrix(CE, e.coordinateSystem));
        let T = 0;
        if (this.sortObjects) {
            px.copy(this.matrixWorld).invert(),
                Od.setFromMatrixPosition(n.matrixWorld).applyMatrix4(px),
                RE.set(0, 0, -1)
                    .transformDirection(n.matrixWorld)
                    .transformDirection(px);
            for (let b = 0, C = c.length; b < C; b++)
                if (c[b].visible && c[b].active) {
                    const L = c[b].geometryIndex;
                    this.getMatrixAt(b, Al),
                        this.getBoundingSphereAt(L, ku).applyMatrix4(Al);
                    let F = !1;
                    if ((y && (F = !mx.intersectsSphere(ku)), !F)) {
                        const N = MV.subVectors(ku.center, Od).dot(RE);
                        gx.push(g[L], N, b);
                    }
                }
            const M = gx.list,
                w = this.customSort;
            w === null ? M.sort(s.transparent ? xV : vV) : w.call(this, M, n);
            for (let b = 0, C = M.length; b < C; b++) {
                const L = M[b];
                (d[T] = L.start * l), (p[T] = L.count), (S[T] = L.index), T++;
            }
            gx.reset();
        } else
            for (let M = 0, w = c.length; M < w; M++)
                if (c[M].visible && c[M].active) {
                    const b = c[M].geometryIndex;
                    let C = !1;
                    if (
                        (y &&
                            (this.getMatrixAt(M, Al),
                            this.getBoundingSphereAt(b, ku).applyMatrix4(Al),
                            (C = !mx.intersectsSphere(ku))),
                        !C)
                    ) {
                        const L = g[b];
                        (d[T] = L.start * l), (p[T] = L.count), (S[T] = M), T++;
                    }
                }
        (v.needsUpdate = !0),
            (this._multiDrawCount = T),
            (this._visibilityChanged = !1);
    }
    onBeforeShadow(e, t, n, r, s, a) {
        this.onBeforeRender(e, null, r, s, a);
    }
}
class Ar extends lr {
    constructor(e) {
        super(),
            (this.isLineBasicMaterial = !0),
            (this.type = 'LineBasicMaterial'),
            (this.color = new st(16777215)),
            (this.map = null),
            (this.linewidth = 1),
            (this.linecap = 'round'),
            (this.linejoin = 'round'),
            (this.fog = !0),
            this.setValues(e);
    }
    copy(e) {
        return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.linewidth = e.linewidth),
            (this.linecap = e.linecap),
            (this.linejoin = e.linejoin),
            (this.fog = e.fog),
            this
        );
    }
}
const Xy = new j(),
    jy = new j(),
    bE = new Pt(),
    kd = new Eh(),
    Dg = new or(),
    yx = new j(),
    PE = new j();
class Ul extends ln {
    constructor(e = new $t(), t = new Ar()) {
        super(),
            (this.isLine = !0),
            (this.type = 'Line'),
            (this.geometry = e),
            (this.material = t),
            this.updateMorphTargets();
    }
    copy(e, t) {
        return (
            super.copy(e, t),
            (this.material = Array.isArray(e.material)
                ? e.material.slice()
                : e.material),
            (this.geometry = e.geometry),
            this
        );
    }
    computeLineDistances() {
        const e = this.geometry;
        if (e.index === null) {
            const t = e.attributes.position,
                n = [0];
            for (let r = 1, s = t.count; r < s; r++)
                Xy.fromBufferAttribute(t, r - 1),
                    jy.fromBufferAttribute(t, r),
                    (n[r] = n[r - 1]),
                    (n[r] += Xy.distanceTo(jy));
            e.setAttribute('lineDistance', new vt(n, 1));
        } else
            console.warn(
                'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.'
            );
        return this;
    }
    raycast(e, t) {
        const n = this.geometry,
            r = this.matrixWorld,
            s = e.params.Line.threshold,
            a = n.drawRange;
        if (
            (n.boundingSphere === null && n.computeBoundingSphere(),
            Dg.copy(n.boundingSphere),
            Dg.applyMatrix4(r),
            (Dg.radius += s),
            e.ray.intersectsSphere(Dg) === !1)
        )
            return;
        bE.copy(r).invert(), kd.copy(e.ray).applyMatrix4(bE);
        const l = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            c = l * l,
            d = this.isLineSegments ? 2 : 1,
            p = n.index,
            y = n.attributes.position;
        if (p !== null) {
            const v = Math.max(0, a.start),
                S = Math.min(p.count, a.start + a.count);
            for (let T = v, M = S - 1; T < M; T += d) {
                const w = p.getX(T),
                    b = p.getX(T + 1),
                    C = Ng(this, e, kd, c, w, b);
                C && t.push(C);
            }
            if (this.isLineLoop) {
                const T = p.getX(S - 1),
                    M = p.getX(v),
                    w = Ng(this, e, kd, c, T, M);
                w && t.push(w);
            }
        } else {
            const v = Math.max(0, a.start),
                S = Math.min(y.count, a.start + a.count);
            for (let T = v, M = S - 1; T < M; T += d) {
                const w = Ng(this, e, kd, c, T, T + 1);
                w && t.push(w);
            }
            if (this.isLineLoop) {
                const T = Ng(this, e, kd, c, S - 1, v);
                T && t.push(T);
            }
        }
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes,
            n = Object.keys(t);
        if (n.length > 0) {
            const r = t[n[0]];
            if (r !== void 0) {
                (this.morphTargetInfluences = []),
                    (this.morphTargetDictionary = {});
                for (let s = 0, a = r.length; s < a; s++) {
                    const l = r[s].name || String(s);
                    this.morphTargetInfluences.push(0),
                        (this.morphTargetDictionary[l] = s);
                }
            }
        }
    }
}
function Ng(i, e, t, n, r, s) {
    const a = i.geometry.attributes.position;
    if (
        (Xy.fromBufferAttribute(a, r),
        jy.fromBufferAttribute(a, s),
        t.distanceSqToSegment(Xy, jy, yx, PE) > n)
    )
        return;
    yx.applyMatrix4(i.matrixWorld);
    const c = e.ray.origin.distanceTo(yx);
    if (!(c < e.near || c > e.far))
        return {
            distance: c,
            point: PE.clone().applyMatrix4(i.matrixWorld),
            index: r,
            face: null,
            faceIndex: null,
            object: i,
        };
}
const LE = new j(),
    IE = new j();
class Vo extends Ul {
    constructor(e, t) {
        super(e, t), (this.isLineSegments = !0), (this.type = 'LineSegments');
    }
    computeLineDistances() {
        const e = this.geometry;
        if (e.index === null) {
            const t = e.attributes.position,
                n = [];
            for (let r = 0, s = t.count; r < s; r += 2)
                LE.fromBufferAttribute(t, r),
                    IE.fromBufferAttribute(t, r + 1),
                    (n[r] = r === 0 ? 0 : n[r - 1]),
                    (n[r + 1] = n[r] + LE.distanceTo(IE));
            e.setAttribute('lineDistance', new vt(n, 1));
        } else
            console.warn(
                'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.'
            );
        return this;
    }
}
class hb extends Ul {
    constructor(e, t) {
        super(e, t), (this.isLineLoop = !0), (this.type = 'LineLoop');
    }
}
class JS extends lr {
    constructor(e) {
        super(),
            (this.isPointsMaterial = !0),
            (this.type = 'PointsMaterial'),
            (this.color = new st(16777215)),
            (this.map = null),
            (this.alphaMap = null),
            (this.size = 1),
            (this.sizeAttenuation = !0),
            (this.fog = !0),
            this.setValues(e);
    }
    copy(e) {
        return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.size = e.size),
            (this.sizeAttenuation = e.sizeAttenuation),
            (this.fog = e.fog),
            this
        );
    }
}
const DE = new Pt(),
    S_ = new Eh(),
    Ug = new or(),
    Og = new j();
class db extends ln {
    constructor(e = new $t(), t = new JS()) {
        super(),
            (this.isPoints = !0),
            (this.type = 'Points'),
            (this.geometry = e),
            (this.material = t),
            this.updateMorphTargets();
    }
    copy(e, t) {
        return (
            super.copy(e, t),
            (this.material = Array.isArray(e.material)
                ? e.material.slice()
                : e.material),
            (this.geometry = e.geometry),
            this
        );
    }
    raycast(e, t) {
        const n = this.geometry,
            r = this.matrixWorld,
            s = e.params.Points.threshold,
            a = n.drawRange;
        if (
            (n.boundingSphere === null && n.computeBoundingSphere(),
            Ug.copy(n.boundingSphere),
            Ug.applyMatrix4(r),
            (Ug.radius += s),
            e.ray.intersectsSphere(Ug) === !1)
        )
            return;
        DE.copy(r).invert(), S_.copy(e.ray).applyMatrix4(DE);
        const l = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            c = l * l,
            d = n.index,
            g = n.attributes.position;
        if (d !== null) {
            const y = Math.max(0, a.start),
                v = Math.min(d.count, a.start + a.count);
            for (let S = y, T = v; S < T; S++) {
                const M = d.getX(S);
                Og.fromBufferAttribute(g, M), NE(Og, M, c, r, e, t, this);
            }
        } else {
            const y = Math.max(0, a.start),
                v = Math.min(g.count, a.start + a.count);
            for (let S = y, T = v; S < T; S++)
                Og.fromBufferAttribute(g, S), NE(Og, S, c, r, e, t, this);
        }
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes,
            n = Object.keys(t);
        if (n.length > 0) {
            const r = t[n[0]];
            if (r !== void 0) {
                (this.morphTargetInfluences = []),
                    (this.morphTargetDictionary = {});
                for (let s = 0, a = r.length; s < a; s++) {
                    const l = r[s].name || String(s);
                    this.morphTargetInfluences.push(0),
                        (this.morphTargetDictionary[l] = s);
                }
            }
        }
    }
}
function NE(i, e, t, n, r, s, a) {
    const l = S_.distanceSqToPoint(i);
    if (l < t) {
        const c = new j();
        S_.closestPointToPoint(i, c), c.applyMatrix4(n);
        const d = r.ray.origin.distanceTo(c);
        if (d < r.near || d > r.far) return;
        s.push({
            distance: d,
            distanceToRay: Math.sqrt(l),
            point: c,
            index: e,
            face: null,
            object: a,
        });
    }
}
class TV extends Qn {
    constructor(e, t, n, r, s, a, l, c, d) {
        super(e, t, n, r, s, a, l, c, d),
            (this.isVideoTexture = !0),
            (this.minFilter = a !== void 0 ? a : hi),
            (this.magFilter = s !== void 0 ? s : hi),
            (this.generateMipmaps = !1);
        const p = this;
        function g() {
            (p.needsUpdate = !0), e.requestVideoFrameCallback(g);
        }
        'requestVideoFrameCallback' in e && e.requestVideoFrameCallback(g);
    }
    clone() {
        return new this.constructor(this.image).copy(this);
    }
    update() {
        const e = this.image;
        'requestVideoFrameCallback' in e === !1 &&
            e.readyState >= e.HAVE_CURRENT_DATA &&
            (this.needsUpdate = !0);
    }
}
class AV extends Qn {
    constructor(e, t) {
        super({ width: e, height: t }),
            (this.isFramebufferTexture = !0),
            (this.magFilter = Li),
            (this.minFilter = Li),
            (this.generateMipmaps = !1),
            (this.needsUpdate = !0);
    }
}
class Mv extends Qn {
    constructor(e, t, n, r, s, a, l, c, d, p, g, y) {
        super(null, a, l, c, d, p, r, s, g, y),
            (this.isCompressedTexture = !0),
            (this.image = { width: t, height: n }),
            (this.mipmaps = e),
            (this.flipY = !1),
            (this.generateMipmaps = !1);
    }
}
class CV extends Mv {
    constructor(e, t, n, r, s, a) {
        super(e, t, n, s, a),
            (this.isCompressedArrayTexture = !0),
            (this.image.depth = r),
            (this.wrapR = Ms),
            (this.layerUpdates = new Set());
    }
    addLayerUpdate(e) {
        this.layerUpdates.add(e);
    }
    clearLayerUpdates() {
        this.layerUpdates.clear();
    }
}
class RV extends Mv {
    constructor(e, t, n) {
        super(void 0, e[0].width, e[0].height, t, n, Ua),
            (this.isCompressedCubeTexture = !0),
            (this.isCubeTexture = !0),
            (this.image = e);
    }
}
class bV extends Qn {
    constructor(e, t, n, r, s, a, l, c, d) {
        super(e, t, n, r, s, a, l, c, d),
            (this.isCanvasTexture = !0),
            (this.needsUpdate = !0);
    }
}
class fo {
    constructor() {
        (this.type = 'Curve'), (this.arcLengthDivisions = 200);
    }
    getPoint() {
        return console.warn('THREE.Curve: .getPoint() not implemented.'), null;
    }
    getPointAt(e, t) {
        const n = this.getUtoTmapping(e);
        return this.getPoint(n, t);
    }
    getPoints(e = 5) {
        const t = [];
        for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
        return t;
    }
    getSpacedPoints(e = 5) {
        const t = [];
        for (let n = 0; n <= e; n++) t.push(this.getPointAt(n / e));
        return t;
    }
    getLength() {
        const e = this.getLengths();
        return e[e.length - 1];
    }
    getLengths(e = this.arcLengthDivisions) {
        if (
            this.cacheArcLengths &&
            this.cacheArcLengths.length === e + 1 &&
            !this.needsUpdate
        )
            return this.cacheArcLengths;
        this.needsUpdate = !1;
        const t = [];
        let n,
            r = this.getPoint(0),
            s = 0;
        t.push(0);
        for (let a = 1; a <= e; a++)
            (n = this.getPoint(a / e)),
                (s += n.distanceTo(r)),
                t.push(s),
                (r = n);
        return (this.cacheArcLengths = t), t;
    }
    updateArcLengths() {
        (this.needsUpdate = !0), this.getLengths();
    }
    getUtoTmapping(e, t) {
        const n = this.getLengths();
        let r = 0;
        const s = n.length;
        let a;
        t ? (a = t) : (a = e * n[s - 1]);
        let l = 0,
            c = s - 1,
            d;
        for (; l <= c; )
            if (((r = Math.floor(l + (c - l) / 2)), (d = n[r] - a), d < 0))
                l = r + 1;
            else if (d > 0) c = r - 1;
            else {
                c = r;
                break;
            }
        if (((r = c), n[r] === a)) return r / (s - 1);
        const p = n[r],
            y = n[r + 1] - p,
            v = (a - p) / y;
        return (r + v) / (s - 1);
    }
    getTangent(e, t) {
        let r = e - 1e-4,
            s = e + 1e-4;
        r < 0 && (r = 0), s > 1 && (s = 1);
        const a = this.getPoint(r),
            l = this.getPoint(s),
            c = t || (a.isVector2 ? new Ce() : new j());
        return c.copy(l).sub(a).normalize(), c;
    }
    getTangentAt(e, t) {
        const n = this.getUtoTmapping(e);
        return this.getTangent(n, t);
    }
    computeFrenetFrames(e, t) {
        const n = new j(),
            r = [],
            s = [],
            a = [],
            l = new j(),
            c = new Pt();
        for (let v = 0; v <= e; v++) {
            const S = v / e;
            r[v] = this.getTangentAt(S, new j());
        }
        (s[0] = new j()), (a[0] = new j());
        let d = Number.MAX_VALUE;
        const p = Math.abs(r[0].x),
            g = Math.abs(r[0].y),
            y = Math.abs(r[0].z);
        p <= d && ((d = p), n.set(1, 0, 0)),
            g <= d && ((d = g), n.set(0, 1, 0)),
            y <= d && n.set(0, 0, 1),
            l.crossVectors(r[0], n).normalize(),
            s[0].crossVectors(r[0], l),
            a[0].crossVectors(r[0], s[0]);
        for (let v = 1; v <= e; v++) {
            if (
                ((s[v] = s[v - 1].clone()),
                (a[v] = a[v - 1].clone()),
                l.crossVectors(r[v - 1], r[v]),
                l.length() > Number.EPSILON)
            ) {
                l.normalize();
                const S = Math.acos(Jn(r[v - 1].dot(r[v]), -1, 1));
                s[v].applyMatrix4(c.makeRotationAxis(l, S));
            }
            a[v].crossVectors(r[v], s[v]);
        }
        if (t === !0) {
            let v = Math.acos(Jn(s[0].dot(s[e]), -1, 1));
            (v /= e), r[0].dot(l.crossVectors(s[0], s[e])) > 0 && (v = -v);
            for (let S = 1; S <= e; S++)
                s[S].applyMatrix4(c.makeRotationAxis(r[S], v * S)),
                    a[S].crossVectors(r[S], s[S]);
        }
        return { tangents: r, normals: s, binormals: a };
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(e) {
        return (this.arcLengthDivisions = e.arcLengthDivisions), this;
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.6,
                type: 'Curve',
                generator: 'Curve.toJSON',
            },
        };
        return (
            (e.arcLengthDivisions = this.arcLengthDivisions),
            (e.type = this.type),
            e
        );
    }
    fromJSON(e) {
        return (this.arcLengthDivisions = e.arcLengthDivisions), this;
    }
}
class Ev extends fo {
    constructor(
        e = 0,
        t = 0,
        n = 1,
        r = 1,
        s = 0,
        a = Math.PI * 2,
        l = !1,
        c = 0
    ) {
        super(),
            (this.isEllipseCurve = !0),
            (this.type = 'EllipseCurve'),
            (this.aX = e),
            (this.aY = t),
            (this.xRadius = n),
            (this.yRadius = r),
            (this.aStartAngle = s),
            (this.aEndAngle = a),
            (this.aClockwise = l),
            (this.aRotation = c);
    }
    getPoint(e, t = new Ce()) {
        const n = t,
            r = Math.PI * 2;
        let s = this.aEndAngle - this.aStartAngle;
        const a = Math.abs(s) < Number.EPSILON;
        for (; s < 0; ) s += r;
        for (; s > r; ) s -= r;
        s < Number.EPSILON && (a ? (s = 0) : (s = r)),
            this.aClockwise === !0 && !a && (s === r ? (s = -r) : (s = s - r));
        const l = this.aStartAngle + e * s;
        let c = this.aX + this.xRadius * Math.cos(l),
            d = this.aY + this.yRadius * Math.sin(l);
        if (this.aRotation !== 0) {
            const p = Math.cos(this.aRotation),
                g = Math.sin(this.aRotation),
                y = c - this.aX,
                v = d - this.aY;
            (c = y * p - v * g + this.aX), (d = y * g + v * p + this.aY);
        }
        return n.set(c, d);
    }
    copy(e) {
        return (
            super.copy(e),
            (this.aX = e.aX),
            (this.aY = e.aY),
            (this.xRadius = e.xRadius),
            (this.yRadius = e.yRadius),
            (this.aStartAngle = e.aStartAngle),
            (this.aEndAngle = e.aEndAngle),
            (this.aClockwise = e.aClockwise),
            (this.aRotation = e.aRotation),
            this
        );
    }
    toJSON() {
        const e = super.toJSON();
        return (
            (e.aX = this.aX),
            (e.aY = this.aY),
            (e.xRadius = this.xRadius),
            (e.yRadius = this.yRadius),
            (e.aStartAngle = this.aStartAngle),
            (e.aEndAngle = this.aEndAngle),
            (e.aClockwise = this.aClockwise),
            (e.aRotation = this.aRotation),
            e
        );
    }
    fromJSON(e) {
        return (
            super.fromJSON(e),
            (this.aX = e.aX),
            (this.aY = e.aY),
            (this.xRadius = e.xRadius),
            (this.yRadius = e.yRadius),
            (this.aStartAngle = e.aStartAngle),
            (this.aEndAngle = e.aEndAngle),
            (this.aClockwise = e.aClockwise),
            (this.aRotation = e.aRotation),
            this
        );
    }
}
class pb extends Ev {
    constructor(e, t, n, r, s, a) {
        super(e, t, n, n, r, s, a),
            (this.isArcCurve = !0),
            (this.type = 'ArcCurve');
    }
}
function QS() {
    let i = 0,
        e = 0,
        t = 0,
        n = 0;
    function r(s, a, l, c) {
        (i = s),
            (e = l),
            (t = -3 * s + 3 * a - 2 * l - c),
            (n = 2 * s - 2 * a + l + c);
    }
    return {
        initCatmullRom: function (s, a, l, c, d) {
            r(a, l, d * (l - s), d * (c - a));
        },
        initNonuniformCatmullRom: function (s, a, l, c, d, p, g) {
            let y = (a - s) / d - (l - s) / (d + p) + (l - a) / p,
                v = (l - a) / p - (c - a) / (p + g) + (c - l) / g;
            (y *= p), (v *= p), r(a, l, y, v);
        },
        calc: function (s) {
            const a = s * s,
                l = a * s;
            return i + e * s + t * a + n * l;
        },
    };
}
const kg = new j(),
    vx = new QS(),
    xx = new QS(),
    _x = new QS();
class mb extends fo {
    constructor(e = [], t = !1, n = 'centripetal', r = 0.5) {
        super(),
            (this.isCatmullRomCurve3 = !0),
            (this.type = 'CatmullRomCurve3'),
            (this.points = e),
            (this.closed = t),
            (this.curveType = n),
            (this.tension = r);
    }
    getPoint(e, t = new j()) {
        const n = t,
            r = this.points,
            s = r.length,
            a = (s - (this.closed ? 0 : 1)) * e;
        let l = Math.floor(a),
            c = a - l;
        this.closed
            ? (l += l > 0 ? 0 : (Math.floor(Math.abs(l) / s) + 1) * s)
            : c === 0 && l === s - 1 && ((l = s - 2), (c = 1));
        let d, p;
        this.closed || l > 0
            ? (d = r[(l - 1) % s])
            : (kg.subVectors(r[0], r[1]).add(r[0]), (d = kg));
        const g = r[l % s],
            y = r[(l + 1) % s];
        if (
            (this.closed || l + 2 < s
                ? (p = r[(l + 2) % s])
                : (kg.subVectors(r[s - 1], r[s - 2]).add(r[s - 1]), (p = kg)),
            this.curveType === 'centripetal' || this.curveType === 'chordal')
        ) {
            const v = this.curveType === 'chordal' ? 0.5 : 0.25;
            let S = Math.pow(d.distanceToSquared(g), v),
                T = Math.pow(g.distanceToSquared(y), v),
                M = Math.pow(y.distanceToSquared(p), v);
            T < 1e-4 && (T = 1),
                S < 1e-4 && (S = T),
                M < 1e-4 && (M = T),
                vx.initNonuniformCatmullRom(d.x, g.x, y.x, p.x, S, T, M),
                xx.initNonuniformCatmullRom(d.y, g.y, y.y, p.y, S, T, M),
                _x.initNonuniformCatmullRom(d.z, g.z, y.z, p.z, S, T, M);
        } else
            this.curveType === 'catmullrom' &&
                (vx.initCatmullRom(d.x, g.x, y.x, p.x, this.tension),
                xx.initCatmullRom(d.y, g.y, y.y, p.y, this.tension),
                _x.initCatmullRom(d.z, g.z, y.z, p.z, this.tension));
        return n.set(vx.calc(c), xx.calc(c), _x.calc(c)), n;
    }
    copy(e) {
        super.copy(e), (this.points = []);
        for (let t = 0, n = e.points.length; t < n; t++) {
            const r = e.points[t];
            this.points.push(r.clone());
        }
        return (
            (this.closed = e.closed),
            (this.curveType = e.curveType),
            (this.tension = e.tension),
            this
        );
    }
    toJSON() {
        const e = super.toJSON();
        e.points = [];
        for (let t = 0, n = this.points.length; t < n; t++) {
            const r = this.points[t];
            e.points.push(r.toArray());
        }
        return (
            (e.closed = this.closed),
            (e.curveType = this.curveType),
            (e.tension = this.tension),
            e
        );
    }
    fromJSON(e) {
        super.fromJSON(e), (this.points = []);
        for (let t = 0, n = e.points.length; t < n; t++) {
            const r = e.points[t];
            this.points.push(new j().fromArray(r));
        }
        return (
            (this.closed = e.closed),
            (this.curveType = e.curveType),
            (this.tension = e.tension),
            this
        );
    }
}
function UE(i, e, t, n, r) {
    const s = (n - e) * 0.5,
        a = (r - t) * 0.5,
        l = i * i,
        c = i * l;
    return (
        (2 * t - 2 * n + s + a) * c +
        (-3 * t + 3 * n - 2 * s - a) * l +
        s * i +
        t
    );
}
function PV(i, e) {
    const t = 1 - i;
    return t * t * e;
}
function LV(i, e) {
    return 2 * (1 - i) * i * e;
}
function IV(i, e) {
    return i * i * e;
}
function sp(i, e, t, n) {
    return PV(i, e) + LV(i, t) + IV(i, n);
}
function DV(i, e) {
    const t = 1 - i;
    return t * t * t * e;
}
function NV(i, e) {
    const t = 1 - i;
    return 3 * t * t * i * e;
}
function UV(i, e) {
    return 3 * (1 - i) * i * i * e;
}
function OV(i, e) {
    return i * i * i * e;
}
function op(i, e, t, n, r) {
    return DV(i, e) + NV(i, t) + UV(i, n) + OV(i, r);
}
class ew extends fo {
    constructor(e = new Ce(), t = new Ce(), n = new Ce(), r = new Ce()) {
        super(),
            (this.isCubicBezierCurve = !0),
            (this.type = 'CubicBezierCurve'),
            (this.v0 = e),
            (this.v1 = t),
            (this.v2 = n),
            (this.v3 = r);
    }
    getPoint(e, t = new Ce()) {
        const n = t,
            r = this.v0,
            s = this.v1,
            a = this.v2,
            l = this.v3;
        return n.set(op(e, r.x, s.x, a.x, l.x), op(e, r.y, s.y, a.y, l.y)), n;
    }
    copy(e) {
        return (
            super.copy(e),
            this.v0.copy(e.v0),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this.v3.copy(e.v3),
            this
        );
    }
    toJSON() {
        const e = super.toJSON();
        return (
            (e.v0 = this.v0.toArray()),
            (e.v1 = this.v1.toArray()),
            (e.v2 = this.v2.toArray()),
            (e.v3 = this.v3.toArray()),
            e
        );
    }
    fromJSON(e) {
        return (
            super.fromJSON(e),
            this.v0.fromArray(e.v0),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this.v3.fromArray(e.v3),
            this
        );
    }
}
class gb extends fo {
    constructor(e = new j(), t = new j(), n = new j(), r = new j()) {
        super(),
            (this.isCubicBezierCurve3 = !0),
            (this.type = 'CubicBezierCurve3'),
            (this.v0 = e),
            (this.v1 = t),
            (this.v2 = n),
            (this.v3 = r);
    }
    getPoint(e, t = new j()) {
        const n = t,
            r = this.v0,
            s = this.v1,
            a = this.v2,
            l = this.v3;
        return (
            n.set(
                op(e, r.x, s.x, a.x, l.x),
                op(e, r.y, s.y, a.y, l.y),
                op(e, r.z, s.z, a.z, l.z)
            ),
            n
        );
    }
    copy(e) {
        return (
            super.copy(e),
            this.v0.copy(e.v0),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this.v3.copy(e.v3),
            this
        );
    }
    toJSON() {
        const e = super.toJSON();
        return (
            (e.v0 = this.v0.toArray()),
            (e.v1 = this.v1.toArray()),
            (e.v2 = this.v2.toArray()),
            (e.v3 = this.v3.toArray()),
            e
        );
    }
    fromJSON(e) {
        return (
            super.fromJSON(e),
            this.v0.fromArray(e.v0),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this.v3.fromArray(e.v3),
            this
        );
    }
}
class tw extends fo {
    constructor(e = new Ce(), t = new Ce()) {
        super(),
            (this.isLineCurve = !0),
            (this.type = 'LineCurve'),
            (this.v1 = e),
            (this.v2 = t);
    }
    getPoint(e, t = new Ce()) {
        const n = t;
        return (
            e === 1
                ? n.copy(this.v2)
                : (n.copy(this.v2).sub(this.v1),
                  n.multiplyScalar(e).add(this.v1)),
            n
        );
    }
    getPointAt(e, t) {
        return this.getPoint(e, t);
    }
    getTangent(e, t = new Ce()) {
        return t.subVectors(this.v2, this.v1).normalize();
    }
    getTangentAt(e, t) {
        return this.getTangent(e, t);
    }
    copy(e) {
        return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
    }
    toJSON() {
        const e = super.toJSON();
        return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
    }
    fromJSON(e) {
        return (
            super.fromJSON(e),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this
        );
    }
}
class yb extends fo {
    constructor(e = new j(), t = new j()) {
        super(),
            (this.isLineCurve3 = !0),
            (this.type = 'LineCurve3'),
            (this.v1 = e),
            (this.v2 = t);
    }
    getPoint(e, t = new j()) {
        const n = t;
        return (
            e === 1
                ? n.copy(this.v2)
                : (n.copy(this.v2).sub(this.v1),
                  n.multiplyScalar(e).add(this.v1)),
            n
        );
    }
    getPointAt(e, t) {
        return this.getPoint(e, t);
    }
    getTangent(e, t = new j()) {
        return t.subVectors(this.v2, this.v1).normalize();
    }
    getTangentAt(e, t) {
        return this.getTangent(e, t);
    }
    copy(e) {
        return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
    }
    toJSON() {
        const e = super.toJSON();
        return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
    }
    fromJSON(e) {
        return (
            super.fromJSON(e),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this
        );
    }
}
class nw extends fo {
    constructor(e = new Ce(), t = new Ce(), n = new Ce()) {
        super(),
            (this.isQuadraticBezierCurve = !0),
            (this.type = 'QuadraticBezierCurve'),
            (this.v0 = e),
            (this.v1 = t),
            (this.v2 = n);
    }
    getPoint(e, t = new Ce()) {
        const n = t,
            r = this.v0,
            s = this.v1,
            a = this.v2;
        return n.set(sp(e, r.x, s.x, a.x), sp(e, r.y, s.y, a.y)), n;
    }
    copy(e) {
        return (
            super.copy(e),
            this.v0.copy(e.v0),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this
        );
    }
    toJSON() {
        const e = super.toJSON();
        return (
            (e.v0 = this.v0.toArray()),
            (e.v1 = this.v1.toArray()),
            (e.v2 = this.v2.toArray()),
            e
        );
    }
    fromJSON(e) {
        return (
            super.fromJSON(e),
            this.v0.fromArray(e.v0),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this
        );
    }
}
class iw extends fo {
    constructor(e = new j(), t = new j(), n = new j()) {
        super(),
            (this.isQuadraticBezierCurve3 = !0),
            (this.type = 'QuadraticBezierCurve3'),
            (this.v0 = e),
            (this.v1 = t),
            (this.v2 = n);
    }
    getPoint(e, t = new j()) {
        const n = t,
            r = this.v0,
            s = this.v1,
            a = this.v2;
        return (
            n.set(
                sp(e, r.x, s.x, a.x),
                sp(e, r.y, s.y, a.y),
                sp(e, r.z, s.z, a.z)
            ),
            n
        );
    }
    copy(e) {
        return (
            super.copy(e),
            this.v0.copy(e.v0),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this
        );
    }
    toJSON() {
        const e = super.toJSON();
        return (
            (e.v0 = this.v0.toArray()),
            (e.v1 = this.v1.toArray()),
            (e.v2 = this.v2.toArray()),
            e
        );
    }
    fromJSON(e) {
        return (
            super.fromJSON(e),
            this.v0.fromArray(e.v0),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this
        );
    }
}
class rw extends fo {
    constructor(e = []) {
        super(),
            (this.isSplineCurve = !0),
            (this.type = 'SplineCurve'),
            (this.points = e);
    }
    getPoint(e, t = new Ce()) {
        const n = t,
            r = this.points,
            s = (r.length - 1) * e,
            a = Math.floor(s),
            l = s - a,
            c = r[a === 0 ? a : a - 1],
            d = r[a],
            p = r[a > r.length - 2 ? r.length - 1 : a + 1],
            g = r[a > r.length - 3 ? r.length - 1 : a + 2];
        return n.set(UE(l, c.x, d.x, p.x, g.x), UE(l, c.y, d.y, p.y, g.y)), n;
    }
    copy(e) {
        super.copy(e), (this.points = []);
        for (let t = 0, n = e.points.length; t < n; t++) {
            const r = e.points[t];
            this.points.push(r.clone());
        }
        return this;
    }
    toJSON() {
        const e = super.toJSON();
        e.points = [];
        for (let t = 0, n = this.points.length; t < n; t++) {
            const r = this.points[t];
            e.points.push(r.toArray());
        }
        return e;
    }
    fromJSON(e) {
        super.fromJSON(e), (this.points = []);
        for (let t = 0, n = e.points.length; t < n; t++) {
            const r = e.points[t];
            this.points.push(new Ce().fromArray(r));
        }
        return this;
    }
}
var qy = Object.freeze({
    __proto__: null,
    ArcCurve: pb,
    CatmullRomCurve3: mb,
    CubicBezierCurve: ew,
    CubicBezierCurve3: gb,
    EllipseCurve: Ev,
    LineCurve: tw,
    LineCurve3: yb,
    QuadraticBezierCurve: nw,
    QuadraticBezierCurve3: iw,
    SplineCurve: rw,
});
class vb extends fo {
    constructor() {
        super(),
            (this.type = 'CurvePath'),
            (this.curves = []),
            (this.autoClose = !1);
    }
    add(e) {
        this.curves.push(e);
    }
    closePath() {
        const e = this.curves[0].getPoint(0),
            t = this.curves[this.curves.length - 1].getPoint(1);
        if (!e.equals(t)) {
            const n = e.isVector2 === !0 ? 'LineCurve' : 'LineCurve3';
            this.curves.push(new qy[n](t, e));
        }
        return this;
    }
    getPoint(e, t) {
        const n = e * this.getLength(),
            r = this.getCurveLengths();
        let s = 0;
        for (; s < r.length; ) {
            if (r[s] >= n) {
                const a = r[s] - n,
                    l = this.curves[s],
                    c = l.getLength(),
                    d = c === 0 ? 0 : 1 - a / c;
                return l.getPointAt(d, t);
            }
            s++;
        }
        return null;
    }
    getLength() {
        const e = this.getCurveLengths();
        return e[e.length - 1];
    }
    updateArcLengths() {
        (this.needsUpdate = !0),
            (this.cacheLengths = null),
            this.getCurveLengths();
    }
    getCurveLengths() {
        if (
            this.cacheLengths &&
            this.cacheLengths.length === this.curves.length
        )
            return this.cacheLengths;
        const e = [];
        let t = 0;
        for (let n = 0, r = this.curves.length; n < r; n++)
            (t += this.curves[n].getLength()), e.push(t);
        return (this.cacheLengths = e), e;
    }
    getSpacedPoints(e = 40) {
        const t = [];
        for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
        return this.autoClose && t.push(t[0]), t;
    }
    getPoints(e = 12) {
        const t = [];
        let n;
        for (let r = 0, s = this.curves; r < s.length; r++) {
            const a = s[r],
                l = a.isEllipseCurve
                    ? e * 2
                    : a.isLineCurve || a.isLineCurve3
                      ? 1
                      : a.isSplineCurve
                        ? e * a.points.length
                        : e,
                c = a.getPoints(l);
            for (let d = 0; d < c.length; d++) {
                const p = c[d];
                (n && n.equals(p)) || (t.push(p), (n = p));
            }
        }
        return (
            this.autoClose &&
                t.length > 1 &&
                !t[t.length - 1].equals(t[0]) &&
                t.push(t[0]),
            t
        );
    }
    copy(e) {
        super.copy(e), (this.curves = []);
        for (let t = 0, n = e.curves.length; t < n; t++) {
            const r = e.curves[t];
            this.curves.push(r.clone());
        }
        return (this.autoClose = e.autoClose), this;
    }
    toJSON() {
        const e = super.toJSON();
        (e.autoClose = this.autoClose), (e.curves = []);
        for (let t = 0, n = this.curves.length; t < n; t++) {
            const r = this.curves[t];
            e.curves.push(r.toJSON());
        }
        return e;
    }
    fromJSON(e) {
        super.fromJSON(e), (this.autoClose = e.autoClose), (this.curves = []);
        for (let t = 0, n = e.curves.length; t < n; t++) {
            const r = e.curves[t];
            this.curves.push(new qy[r.type]().fromJSON(r));
        }
        return this;
    }
}
class Pp extends vb {
    constructor(e) {
        super(),
            (this.type = 'Path'),
            (this.currentPoint = new Ce()),
            e && this.setFromPoints(e);
    }
    setFromPoints(e) {
        this.moveTo(e[0].x, e[0].y);
        for (let t = 1, n = e.length; t < n; t++) this.lineTo(e[t].x, e[t].y);
        return this;
    }
    moveTo(e, t) {
        return this.currentPoint.set(e, t), this;
    }
    lineTo(e, t) {
        const n = new tw(this.currentPoint.clone(), new Ce(e, t));
        return this.curves.push(n), this.currentPoint.set(e, t), this;
    }
    quadraticCurveTo(e, t, n, r) {
        const s = new nw(this.currentPoint.clone(), new Ce(e, t), new Ce(n, r));
        return this.curves.push(s), this.currentPoint.set(n, r), this;
    }
    bezierCurveTo(e, t, n, r, s, a) {
        const l = new ew(
            this.currentPoint.clone(),
            new Ce(e, t),
            new Ce(n, r),
            new Ce(s, a)
        );
        return this.curves.push(l), this.currentPoint.set(s, a), this;
    }
    splineThru(e) {
        const t = [this.currentPoint.clone()].concat(e),
            n = new rw(t);
        return (
            this.curves.push(n), this.currentPoint.copy(e[e.length - 1]), this
        );
    }
    arc(e, t, n, r, s, a) {
        const l = this.currentPoint.x,
            c = this.currentPoint.y;
        return this.absarc(e + l, t + c, n, r, s, a), this;
    }
    absarc(e, t, n, r, s, a) {
        return this.absellipse(e, t, n, n, r, s, a), this;
    }
    ellipse(e, t, n, r, s, a, l, c) {
        const d = this.currentPoint.x,
            p = this.currentPoint.y;
        return this.absellipse(e + d, t + p, n, r, s, a, l, c), this;
    }
    absellipse(e, t, n, r, s, a, l, c) {
        const d = new Ev(e, t, n, r, s, a, l, c);
        if (this.curves.length > 0) {
            const g = d.getPoint(0);
            g.equals(this.currentPoint) || this.lineTo(g.x, g.y);
        }
        this.curves.push(d);
        const p = d.getPoint(1);
        return this.currentPoint.copy(p), this;
    }
    copy(e) {
        return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
    }
    toJSON() {
        const e = super.toJSON();
        return (e.currentPoint = this.currentPoint.toArray()), e;
    }
    fromJSON(e) {
        return (
            super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this
        );
    }
}
class em extends $t {
    constructor(
        e = [new Ce(0, -0.5), new Ce(0.5, 0), new Ce(0, 0.5)],
        t = 12,
        n = 0,
        r = Math.PI * 2
    ) {
        super(),
            (this.type = 'LatheGeometry'),
            (this.parameters = {
                points: e,
                segments: t,
                phiStart: n,
                phiLength: r,
            }),
            (t = Math.floor(t)),
            (r = Jn(r, 0, Math.PI * 2));
        const s = [],
            a = [],
            l = [],
            c = [],
            d = [],
            p = 1 / t,
            g = new j(),
            y = new Ce(),
            v = new j(),
            S = new j(),
            T = new j();
        let M = 0,
            w = 0;
        for (let b = 0; b <= e.length - 1; b++)
            switch (b) {
                case 0:
                    (M = e[b + 1].x - e[b].x),
                        (w = e[b + 1].y - e[b].y),
                        (v.x = w * 1),
                        (v.y = -M),
                        (v.z = w * 0),
                        T.copy(v),
                        v.normalize(),
                        c.push(v.x, v.y, v.z);
                    break;
                case e.length - 1:
                    c.push(T.x, T.y, T.z);
                    break;
                default:
                    (M = e[b + 1].x - e[b].x),
                        (w = e[b + 1].y - e[b].y),
                        (v.x = w * 1),
                        (v.y = -M),
                        (v.z = w * 0),
                        S.copy(v),
                        (v.x += T.x),
                        (v.y += T.y),
                        (v.z += T.z),
                        v.normalize(),
                        c.push(v.x, v.y, v.z),
                        T.copy(S);
            }
        for (let b = 0; b <= t; b++) {
            const C = n + b * p * r,
                L = Math.sin(C),
                F = Math.cos(C);
            for (let N = 0; N <= e.length - 1; N++) {
                (g.x = e[N].x * L),
                    (g.y = e[N].y),
                    (g.z = e[N].x * F),
                    a.push(g.x, g.y, g.z),
                    (y.x = b / t),
                    (y.y = N / (e.length - 1)),
                    l.push(y.x, y.y);
                const B = c[3 * N + 0] * L,
                    z = c[3 * N + 1],
                    U = c[3 * N + 0] * F;
                d.push(B, z, U);
            }
        }
        for (let b = 0; b < t; b++)
            for (let C = 0; C < e.length - 1; C++) {
                const L = C + b * e.length,
                    F = L,
                    N = L + e.length,
                    B = L + e.length + 1,
                    z = L + 1;
                s.push(F, N, z), s.push(B, z, N);
            }
        this.setIndex(s),
            this.setAttribute('position', new vt(a, 3)),
            this.setAttribute('uv', new vt(l, 2)),
            this.setAttribute('normal', new vt(d, 3));
    }
    copy(e) {
        return (
            super.copy(e),
            (this.parameters = Object.assign({}, e.parameters)),
            this
        );
    }
    static fromJSON(e) {
        return new em(e.points, e.segments, e.phiStart, e.phiLength);
    }
}
class Tv extends em {
    constructor(e = 1, t = 1, n = 4, r = 8) {
        const s = new Pp();
        s.absarc(0, -t / 2, e, Math.PI * 1.5, 0),
            s.absarc(0, t / 2, e, 0, Math.PI * 0.5),
            super(s.getPoints(n), r),
            (this.type = 'CapsuleGeometry'),
            (this.parameters = {
                radius: e,
                length: t,
                capSegments: n,
                radialSegments: r,
            });
    }
    static fromJSON(e) {
        return new Tv(e.radius, e.length, e.capSegments, e.radialSegments);
    }
}
class Av extends $t {
    constructor(e = 1, t = 32, n = 0, r = Math.PI * 2) {
        super(),
            (this.type = 'CircleGeometry'),
            (this.parameters = {
                radius: e,
                segments: t,
                thetaStart: n,
                thetaLength: r,
            }),
            (t = Math.max(3, t));
        const s = [],
            a = [],
            l = [],
            c = [],
            d = new j(),
            p = new Ce();
        a.push(0, 0, 0), l.push(0, 0, 1), c.push(0.5, 0.5);
        for (let g = 0, y = 3; g <= t; g++, y += 3) {
            const v = n + (g / t) * r;
            (d.x = e * Math.cos(v)),
                (d.y = e * Math.sin(v)),
                a.push(d.x, d.y, d.z),
                l.push(0, 0, 1),
                (p.x = (a[y] / e + 1) / 2),
                (p.y = (a[y + 1] / e + 1) / 2),
                c.push(p.x, p.y);
        }
        for (let g = 1; g <= t; g++) s.push(g, g + 1, 0);
        this.setIndex(s),
            this.setAttribute('position', new vt(a, 3)),
            this.setAttribute('normal', new vt(l, 3)),
            this.setAttribute('uv', new vt(c, 2));
    }
    copy(e) {
        return (
            super.copy(e),
            (this.parameters = Object.assign({}, e.parameters)),
            this
        );
    }
    static fromJSON(e) {
        return new Av(e.radius, e.segments, e.thetaStart, e.thetaLength);
    }
}
class Ch extends $t {
    constructor(
        e = 1,
        t = 1,
        n = 1,
        r = 32,
        s = 1,
        a = !1,
        l = 0,
        c = Math.PI * 2
    ) {
        super(),
            (this.type = 'CylinderGeometry'),
            (this.parameters = {
                radiusTop: e,
                radiusBottom: t,
                height: n,
                radialSegments: r,
                heightSegments: s,
                openEnded: a,
                thetaStart: l,
                thetaLength: c,
            });
        const d = this;
        (r = Math.floor(r)), (s = Math.floor(s));
        const p = [],
            g = [],
            y = [],
            v = [];
        let S = 0;
        const T = [],
            M = n / 2;
        let w = 0;
        b(),
            a === !1 && (e > 0 && C(!0), t > 0 && C(!1)),
            this.setIndex(p),
            this.setAttribute('position', new vt(g, 3)),
            this.setAttribute('normal', new vt(y, 3)),
            this.setAttribute('uv', new vt(v, 2));
        function b() {
            const L = new j(),
                F = new j();
            let N = 0;
            const B = (t - e) / n;
            for (let z = 0; z <= s; z++) {
                const U = [],
                    D = z / s,
                    H = D * (t - e) + e;
                for (let ie = 0; ie <= r; ie++) {
                    const ee = ie / r,
                        ue = ee * c + l,
                        Se = Math.sin(ue),
                        ce = Math.cos(ue);
                    (F.x = H * Se),
                        (F.y = -D * n + M),
                        (F.z = H * ce),
                        g.push(F.x, F.y, F.z),
                        L.set(Se, B, ce).normalize(),
                        y.push(L.x, L.y, L.z),
                        v.push(ee, 1 - D),
                        U.push(S++);
                }
                T.push(U);
            }
            for (let z = 0; z < r; z++)
                for (let U = 0; U < s; U++) {
                    const D = T[U][z],
                        H = T[U + 1][z],
                        ie = T[U + 1][z + 1],
                        ee = T[U][z + 1];
                    p.push(D, H, ee), p.push(H, ie, ee), (N += 6);
                }
            d.addGroup(w, N, 0), (w += N);
        }
        function C(L) {
            const F = S,
                N = new Ce(),
                B = new j();
            let z = 0;
            const U = L === !0 ? e : t,
                D = L === !0 ? 1 : -1;
            for (let ie = 1; ie <= r; ie++)
                g.push(0, M * D, 0), y.push(0, D, 0), v.push(0.5, 0.5), S++;
            const H = S;
            for (let ie = 0; ie <= r; ie++) {
                const ue = (ie / r) * c + l,
                    Se = Math.cos(ue),
                    ce = Math.sin(ue);
                (B.x = U * ce),
                    (B.y = M * D),
                    (B.z = U * Se),
                    g.push(B.x, B.y, B.z),
                    y.push(0, D, 0),
                    (N.x = Se * 0.5 + 0.5),
                    (N.y = ce * 0.5 * D + 0.5),
                    v.push(N.x, N.y),
                    S++;
            }
            for (let ie = 0; ie < r; ie++) {
                const ee = F + ie,
                    ue = H + ie;
                L === !0 ? p.push(ue, ue + 1, ee) : p.push(ue + 1, ue, ee),
                    (z += 3);
            }
            d.addGroup(w, z, L === !0 ? 1 : 2), (w += z);
        }
    }
    copy(e) {
        return (
            super.copy(e),
            (this.parameters = Object.assign({}, e.parameters)),
            this
        );
    }
    static fromJSON(e) {
        return new Ch(
            e.radiusTop,
            e.radiusBottom,
            e.height,
            e.radialSegments,
            e.heightSegments,
            e.openEnded,
            e.thetaStart,
            e.thetaLength
        );
    }
}
class Cv extends Ch {
    constructor(e = 1, t = 1, n = 32, r = 1, s = !1, a = 0, l = Math.PI * 2) {
        super(0, e, t, n, r, s, a, l),
            (this.type = 'ConeGeometry'),
            (this.parameters = {
                radius: e,
                height: t,
                radialSegments: n,
                heightSegments: r,
                openEnded: s,
                thetaStart: a,
                thetaLength: l,
            });
    }
    static fromJSON(e) {
        return new Cv(
            e.radius,
            e.height,
            e.radialSegments,
            e.heightSegments,
            e.openEnded,
            e.thetaStart,
            e.thetaLength
        );
    }
}
class Vl extends $t {
    constructor(e = [], t = [], n = 1, r = 0) {
        super(),
            (this.type = 'PolyhedronGeometry'),
            (this.parameters = {
                vertices: e,
                indices: t,
                radius: n,
                detail: r,
            });
        const s = [],
            a = [];
        l(r),
            d(n),
            p(),
            this.setAttribute('position', new vt(s, 3)),
            this.setAttribute('normal', new vt(s.slice(), 3)),
            this.setAttribute('uv', new vt(a, 2)),
            r === 0 ? this.computeVertexNormals() : this.normalizeNormals();
        function l(b) {
            const C = new j(),
                L = new j(),
                F = new j();
            for (let N = 0; N < t.length; N += 3)
                v(t[N + 0], C), v(t[N + 1], L), v(t[N + 2], F), c(C, L, F, b);
        }
        function c(b, C, L, F) {
            const N = F + 1,
                B = [];
            for (let z = 0; z <= N; z++) {
                B[z] = [];
                const U = b.clone().lerp(L, z / N),
                    D = C.clone().lerp(L, z / N),
                    H = N - z;
                for (let ie = 0; ie <= H; ie++)
                    ie === 0 && z === N
                        ? (B[z][ie] = U)
                        : (B[z][ie] = U.clone().lerp(D, ie / H));
            }
            for (let z = 0; z < N; z++)
                for (let U = 0; U < 2 * (N - z) - 1; U++) {
                    const D = Math.floor(U / 2);
                    U % 2 === 0
                        ? (y(B[z][D + 1]), y(B[z + 1][D]), y(B[z][D]))
                        : (y(B[z][D + 1]), y(B[z + 1][D + 1]), y(B[z + 1][D]));
                }
        }
        function d(b) {
            const C = new j();
            for (let L = 0; L < s.length; L += 3)
                (C.x = s[L + 0]),
                    (C.y = s[L + 1]),
                    (C.z = s[L + 2]),
                    C.normalize().multiplyScalar(b),
                    (s[L + 0] = C.x),
                    (s[L + 1] = C.y),
                    (s[L + 2] = C.z);
        }
        function p() {
            const b = new j();
            for (let C = 0; C < s.length; C += 3) {
                (b.x = s[C + 0]), (b.y = s[C + 1]), (b.z = s[C + 2]);
                const L = M(b) / 2 / Math.PI + 0.5,
                    F = w(b) / Math.PI + 0.5;
                a.push(L, 1 - F);
            }
            S(), g();
        }
        function g() {
            for (let b = 0; b < a.length; b += 6) {
                const C = a[b + 0],
                    L = a[b + 2],
                    F = a[b + 4],
                    N = Math.max(C, L, F),
                    B = Math.min(C, L, F);
                N > 0.9 &&
                    B < 0.1 &&
                    (C < 0.2 && (a[b + 0] += 1),
                    L < 0.2 && (a[b + 2] += 1),
                    F < 0.2 && (a[b + 4] += 1));
            }
        }
        function y(b) {
            s.push(b.x, b.y, b.z);
        }
        function v(b, C) {
            const L = b * 3;
            (C.x = e[L + 0]), (C.y = e[L + 1]), (C.z = e[L + 2]);
        }
        function S() {
            const b = new j(),
                C = new j(),
                L = new j(),
                F = new j(),
                N = new Ce(),
                B = new Ce(),
                z = new Ce();
            for (let U = 0, D = 0; U < s.length; U += 9, D += 6) {
                b.set(s[U + 0], s[U + 1], s[U + 2]),
                    C.set(s[U + 3], s[U + 4], s[U + 5]),
                    L.set(s[U + 6], s[U + 7], s[U + 8]),
                    N.set(a[D + 0], a[D + 1]),
                    B.set(a[D + 2], a[D + 3]),
                    z.set(a[D + 4], a[D + 5]),
                    F.copy(b).add(C).add(L).divideScalar(3);
                const H = M(F);
                T(N, D + 0, b, H), T(B, D + 2, C, H), T(z, D + 4, L, H);
            }
        }
        function T(b, C, L, F) {
            F < 0 && b.x === 1 && (a[C] = b.x - 1),
                L.x === 0 && L.z === 0 && (a[C] = F / 2 / Math.PI + 0.5);
        }
        function M(b) {
            return Math.atan2(b.z, -b.x);
        }
        function w(b) {
            return Math.atan2(-b.y, Math.sqrt(b.x * b.x + b.z * b.z));
        }
    }
    copy(e) {
        return (
            super.copy(e),
            (this.parameters = Object.assign({}, e.parameters)),
            this
        );
    }
    static fromJSON(e) {
        return new Vl(e.vertices, e.indices, e.radius, e.details);
    }
}
class Rv extends Vl {
    constructor(e = 1, t = 0) {
        const n = (1 + Math.sqrt(5)) / 2,
            r = 1 / n,
            s = [
                -1,
                -1,
                -1,
                -1,
                -1,
                1,
                -1,
                1,
                -1,
                -1,
                1,
                1,
                1,
                -1,
                -1,
                1,
                -1,
                1,
                1,
                1,
                -1,
                1,
                1,
                1,
                0,
                -r,
                -n,
                0,
                -r,
                n,
                0,
                r,
                -n,
                0,
                r,
                n,
                -r,
                -n,
                0,
                -r,
                n,
                0,
                r,
                -n,
                0,
                r,
                n,
                0,
                -n,
                0,
                -r,
                n,
                0,
                -r,
                -n,
                0,
                r,
                n,
                0,
                r,
            ],
            a = [
                3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15,
                17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0,
                12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2,
                16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4,
                14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19,
                5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9,
            ];
        super(s, a, e, t),
            (this.type = 'DodecahedronGeometry'),
            (this.parameters = { radius: e, detail: t });
    }
    static fromJSON(e) {
        return new Rv(e.radius, e.detail);
    }
}
const Fg = new j(),
    Bg = new j(),
    Sx = new j(),
    zg = new ss();
class xb extends $t {
    constructor(e = null, t = 1) {
        if (
            (super(),
            (this.type = 'EdgesGeometry'),
            (this.parameters = { geometry: e, thresholdAngle: t }),
            e !== null)
        ) {
            const r = Math.pow(10, 4),
                s = Math.cos(rc * t),
                a = e.getIndex(),
                l = e.getAttribute('position'),
                c = a ? a.count : l.count,
                d = [0, 0, 0],
                p = ['a', 'b', 'c'],
                g = new Array(3),
                y = {},
                v = [];
            for (let S = 0; S < c; S += 3) {
                a
                    ? ((d[0] = a.getX(S)),
                      (d[1] = a.getX(S + 1)),
                      (d[2] = a.getX(S + 2)))
                    : ((d[0] = S), (d[1] = S + 1), (d[2] = S + 2));
                const { a: T, b: M, c: w } = zg;
                if (
                    (T.fromBufferAttribute(l, d[0]),
                    M.fromBufferAttribute(l, d[1]),
                    w.fromBufferAttribute(l, d[2]),
                    zg.getNormal(Sx),
                    (g[0] = `${Math.round(T.x * r)},${Math.round(T.y * r)},${Math.round(T.z * r)}`),
                    (g[1] = `${Math.round(M.x * r)},${Math.round(M.y * r)},${Math.round(M.z * r)}`),
                    (g[2] = `${Math.round(w.x * r)},${Math.round(w.y * r)},${Math.round(w.z * r)}`),
                    !(g[0] === g[1] || g[1] === g[2] || g[2] === g[0]))
                )
                    for (let b = 0; b < 3; b++) {
                        const C = (b + 1) % 3,
                            L = g[b],
                            F = g[C],
                            N = zg[p[b]],
                            B = zg[p[C]],
                            z = `${L}_${F}`,
                            U = `${F}_${L}`;
                        U in y && y[U]
                            ? (Sx.dot(y[U].normal) <= s &&
                                  (v.push(N.x, N.y, N.z),
                                  v.push(B.x, B.y, B.z)),
                              (y[U] = null))
                            : z in y ||
                              (y[z] = {
                                  index0: d[b],
                                  index1: d[C],
                                  normal: Sx.clone(),
                              });
                    }
            }
            for (const S in y)
                if (y[S]) {
                    const { index0: T, index1: M } = y[S];
                    Fg.fromBufferAttribute(l, T),
                        Bg.fromBufferAttribute(l, M),
                        v.push(Fg.x, Fg.y, Fg.z),
                        v.push(Bg.x, Bg.y, Bg.z);
                }
            this.setAttribute('position', new vt(v, 3));
        }
    }
    copy(e) {
        return (
            super.copy(e),
            (this.parameters = Object.assign({}, e.parameters)),
            this
        );
    }
}
class oc extends Pp {
    constructor(e) {
        super(e), (this.uuid = os()), (this.type = 'Shape'), (this.holes = []);
    }
    getPointsHoles(e) {
        const t = [];
        for (let n = 0, r = this.holes.length; n < r; n++)
            t[n] = this.holes[n].getPoints(e);
        return t;
    }
    extractPoints(e) {
        return { shape: this.getPoints(e), holes: this.getPointsHoles(e) };
    }
    copy(e) {
        super.copy(e), (this.holes = []);
        for (let t = 0, n = e.holes.length; t < n; t++) {
            const r = e.holes[t];
            this.holes.push(r.clone());
        }
        return this;
    }
    toJSON() {
        const e = super.toJSON();
        (e.uuid = this.uuid), (e.holes = []);
        for (let t = 0, n = this.holes.length; t < n; t++) {
            const r = this.holes[t];
            e.holes.push(r.toJSON());
        }
        return e;
    }
    fromJSON(e) {
        super.fromJSON(e), (this.uuid = e.uuid), (this.holes = []);
        for (let t = 0, n = e.holes.length; t < n; t++) {
            const r = e.holes[t];
            this.holes.push(new Pp().fromJSON(r));
        }
        return this;
    }
}
const kV = {
    triangulate: function (i, e, t = 2) {
        const n = e && e.length,
            r = n ? e[0] * t : i.length;
        let s = _b(i, 0, r, t, !0);
        const a = [];
        if (!s || s.next === s.prev) return a;
        let l, c, d, p, g, y, v;
        if ((n && (s = HV(i, e, s, t)), i.length > 80 * t)) {
            (l = d = i[0]), (c = p = i[1]);
            for (let S = t; S < r; S += t)
                (g = i[S]),
                    (y = i[S + 1]),
                    g < l && (l = g),
                    y < c && (c = y),
                    g > d && (d = g),
                    y > p && (p = y);
            (v = Math.max(d - l, p - c)), (v = v !== 0 ? 32767 / v : 0);
        }
        return Lp(s, a, t, l, c, v, 0), a;
    },
};
function _b(i, e, t, n, r) {
    let s, a;
    if (r === QV(i, e, t, n) > 0)
        for (s = e; s < t; s += n) a = OE(s, i[s], i[s + 1], a);
    else for (s = t - n; s >= e; s -= n) a = OE(s, i[s], i[s + 1], a);
    return a && bv(a, a.next) && (Dp(a), (a = a.next)), a;
}
function cc(i, e) {
    if (!i) return i;
    e || (e = i);
    let t = i,
        n;
    do
        if (
            ((n = !1),
            !t.steiner && (bv(t, t.next) || Wn(t.prev, t, t.next) === 0))
        ) {
            if ((Dp(t), (t = e = t.prev), t === t.next)) break;
            n = !0;
        } else t = t.next;
    while (n || t !== e);
    return e;
}
function Lp(i, e, t, n, r, s, a) {
    if (!i) return;
    !a && s && qV(i, n, r, s);
    let l = i,
        c,
        d;
    for (; i.prev !== i.next; ) {
        if (((c = i.prev), (d = i.next), s ? BV(i, n, r, s) : FV(i))) {
            e.push((c.i / t) | 0),
                e.push((i.i / t) | 0),
                e.push((d.i / t) | 0),
                Dp(i),
                (i = d.next),
                (l = d.next);
            continue;
        }
        if (((i = d), i === l)) {
            a
                ? a === 1
                    ? ((i = zV(cc(i), e, t)), Lp(i, e, t, n, r, s, 2))
                    : a === 2 && VV(i, e, t, n, r, s)
                : Lp(cc(i), e, t, n, r, s, 1);
            break;
        }
    }
}
function FV(i) {
    const e = i.prev,
        t = i,
        n = i.next;
    if (Wn(e, t, n) >= 0) return !1;
    const r = e.x,
        s = t.x,
        a = n.x,
        l = e.y,
        c = t.y,
        d = n.y,
        p = r < s ? (r < a ? r : a) : s < a ? s : a,
        g = l < c ? (l < d ? l : d) : c < d ? c : d,
        y = r > s ? (r > a ? r : a) : s > a ? s : a,
        v = l > c ? (l > d ? l : d) : c > d ? c : d;
    let S = n.next;
    for (; S !== e; ) {
        if (
            S.x >= p &&
            S.x <= y &&
            S.y >= g &&
            S.y <= v &&
            nh(r, l, s, c, a, d, S.x, S.y) &&
            Wn(S.prev, S, S.next) >= 0
        )
            return !1;
        S = S.next;
    }
    return !0;
}
function BV(i, e, t, n) {
    const r = i.prev,
        s = i,
        a = i.next;
    if (Wn(r, s, a) >= 0) return !1;
    const l = r.x,
        c = s.x,
        d = a.x,
        p = r.y,
        g = s.y,
        y = a.y,
        v = l < c ? (l < d ? l : d) : c < d ? c : d,
        S = p < g ? (p < y ? p : y) : g < y ? g : y,
        T = l > c ? (l > d ? l : d) : c > d ? c : d,
        M = p > g ? (p > y ? p : y) : g > y ? g : y,
        w = w_(v, S, e, t, n),
        b = w_(T, M, e, t, n);
    let C = i.prevZ,
        L = i.nextZ;
    for (; C && C.z >= w && L && L.z <= b; ) {
        if (
            (C.x >= v &&
                C.x <= T &&
                C.y >= S &&
                C.y <= M &&
                C !== r &&
                C !== a &&
                nh(l, p, c, g, d, y, C.x, C.y) &&
                Wn(C.prev, C, C.next) >= 0) ||
            ((C = C.prevZ),
            L.x >= v &&
                L.x <= T &&
                L.y >= S &&
                L.y <= M &&
                L !== r &&
                L !== a &&
                nh(l, p, c, g, d, y, L.x, L.y) &&
                Wn(L.prev, L, L.next) >= 0)
        )
            return !1;
        L = L.nextZ;
    }
    for (; C && C.z >= w; ) {
        if (
            C.x >= v &&
            C.x <= T &&
            C.y >= S &&
            C.y <= M &&
            C !== r &&
            C !== a &&
            nh(l, p, c, g, d, y, C.x, C.y) &&
            Wn(C.prev, C, C.next) >= 0
        )
            return !1;
        C = C.prevZ;
    }
    for (; L && L.z <= b; ) {
        if (
            L.x >= v &&
            L.x <= T &&
            L.y >= S &&
            L.y <= M &&
            L !== r &&
            L !== a &&
            nh(l, p, c, g, d, y, L.x, L.y) &&
            Wn(L.prev, L, L.next) >= 0
        )
            return !1;
        L = L.nextZ;
    }
    return !0;
}
function zV(i, e, t) {
    let n = i;
    do {
        const r = n.prev,
            s = n.next.next;
        !bv(r, s) &&
            Sb(r, n, n.next, s) &&
            Ip(r, s) &&
            Ip(s, r) &&
            (e.push((r.i / t) | 0),
            e.push((n.i / t) | 0),
            e.push((s.i / t) | 0),
            Dp(n),
            Dp(n.next),
            (n = i = s)),
            (n = n.next);
    } while (n !== i);
    return cc(n);
}
function VV(i, e, t, n, r, s) {
    let a = i;
    do {
        let l = a.next.next;
        for (; l !== a.prev; ) {
            if (a.i !== l.i && KV(a, l)) {
                let c = wb(a, l);
                (a = cc(a, a.next)),
                    (c = cc(c, c.next)),
                    Lp(a, e, t, n, r, s, 0),
                    Lp(c, e, t, n, r, s, 0);
                return;
            }
            l = l.next;
        }
        a = a.next;
    } while (a !== i);
}
function HV(i, e, t, n) {
    const r = [];
    let s, a, l, c, d;
    for (s = 0, a = e.length; s < a; s++)
        (l = e[s] * n),
            (c = s < a - 1 ? e[s + 1] * n : i.length),
            (d = _b(i, l, c, n, !1)),
            d === d.next && (d.steiner = !0),
            r.push(YV(d));
    for (r.sort(GV), s = 0; s < r.length; s++) t = WV(r[s], t);
    return t;
}
function GV(i, e) {
    return i.x - e.x;
}
function WV(i, e) {
    const t = XV(i, e);
    if (!t) return e;
    const n = wb(t, i);
    return cc(n, n.next), cc(t, t.next);
}
function XV(i, e) {
    let t = e,
        n = -1 / 0,
        r;
    const s = i.x,
        a = i.y;
    do {
        if (a <= t.y && a >= t.next.y && t.next.y !== t.y) {
            const y = t.x + ((a - t.y) * (t.next.x - t.x)) / (t.next.y - t.y);
            if (
                y <= s &&
                y > n &&
                ((n = y), (r = t.x < t.next.x ? t : t.next), y === s)
            )
                return r;
        }
        t = t.next;
    } while (t !== e);
    if (!r) return null;
    const l = r,
        c = r.x,
        d = r.y;
    let p = 1 / 0,
        g;
    t = r;
    do
        s >= t.x &&
            t.x >= c &&
            s !== t.x &&
            nh(a < d ? s : n, a, c, d, a < d ? n : s, a, t.x, t.y) &&
            ((g = Math.abs(a - t.y) / (s - t.x)),
            Ip(t, i) &&
                (g < p ||
                    (g === p && (t.x > r.x || (t.x === r.x && jV(r, t))))) &&
                ((r = t), (p = g))),
            (t = t.next);
    while (t !== l);
    return r;
}
function jV(i, e) {
    return Wn(i.prev, i, e.prev) < 0 && Wn(e.next, i, i.next) < 0;
}
function qV(i, e, t, n) {
    let r = i;
    do
        r.z === 0 && (r.z = w_(r.x, r.y, e, t, n)),
            (r.prevZ = r.prev),
            (r.nextZ = r.next),
            (r = r.next);
    while (r !== i);
    (r.prevZ.nextZ = null), (r.prevZ = null), $V(r);
}
function $V(i) {
    let e,
        t,
        n,
        r,
        s,
        a,
        l,
        c,
        d = 1;
    do {
        for (t = i, i = null, s = null, a = 0; t; ) {
            for (
                a++, n = t, l = 0, e = 0;
                e < d && (l++, (n = n.nextZ), !!n);
                e++
            );
            for (c = d; l > 0 || (c > 0 && n); )
                l !== 0 && (c === 0 || !n || t.z <= n.z)
                    ? ((r = t), (t = t.nextZ), l--)
                    : ((r = n), (n = n.nextZ), c--),
                    s ? (s.nextZ = r) : (i = r),
                    (r.prevZ = s),
                    (s = r);
            t = n;
        }
        (s.nextZ = null), (d *= 2);
    } while (a > 1);
    return i;
}
function w_(i, e, t, n, r) {
    return (
        (i = ((i - t) * r) | 0),
        (e = ((e - n) * r) | 0),
        (i = (i | (i << 8)) & 16711935),
        (i = (i | (i << 4)) & 252645135),
        (i = (i | (i << 2)) & 858993459),
        (i = (i | (i << 1)) & 1431655765),
        (e = (e | (e << 8)) & 16711935),
        (e = (e | (e << 4)) & 252645135),
        (e = (e | (e << 2)) & 858993459),
        (e = (e | (e << 1)) & 1431655765),
        i | (e << 1)
    );
}
function YV(i) {
    let e = i,
        t = i;
    do (e.x < t.x || (e.x === t.x && e.y < t.y)) && (t = e), (e = e.next);
    while (e !== i);
    return t;
}
function nh(i, e, t, n, r, s, a, l) {
    return (
        (r - a) * (e - l) >= (i - a) * (s - l) &&
        (i - a) * (n - l) >= (t - a) * (e - l) &&
        (t - a) * (s - l) >= (r - a) * (n - l)
    );
}
function KV(i, e) {
    return (
        i.next.i !== e.i &&
        i.prev.i !== e.i &&
        !ZV(i, e) &&
        ((Ip(i, e) &&
            Ip(e, i) &&
            JV(i, e) &&
            (Wn(i.prev, i, e.prev) || Wn(i, e.prev, e))) ||
            (bv(i, e) &&
                Wn(i.prev, i, i.next) > 0 &&
                Wn(e.prev, e, e.next) > 0))
    );
}
function Wn(i, e, t) {
    return (e.y - i.y) * (t.x - e.x) - (e.x - i.x) * (t.y - e.y);
}
function bv(i, e) {
    return i.x === e.x && i.y === e.y;
}
function Sb(i, e, t, n) {
    const r = Hg(Wn(i, e, t)),
        s = Hg(Wn(i, e, n)),
        a = Hg(Wn(t, n, i)),
        l = Hg(Wn(t, n, e));
    return !!(
        (r !== s && a !== l) ||
        (r === 0 && Vg(i, t, e)) ||
        (s === 0 && Vg(i, n, e)) ||
        (a === 0 && Vg(t, i, n)) ||
        (l === 0 && Vg(t, e, n))
    );
}
function Vg(i, e, t) {
    return (
        e.x <= Math.max(i.x, t.x) &&
        e.x >= Math.min(i.x, t.x) &&
        e.y <= Math.max(i.y, t.y) &&
        e.y >= Math.min(i.y, t.y)
    );
}
function Hg(i) {
    return i > 0 ? 1 : i < 0 ? -1 : 0;
}
function ZV(i, e) {
    let t = i;
    do {
        if (
            t.i !== i.i &&
            t.next.i !== i.i &&
            t.i !== e.i &&
            t.next.i !== e.i &&
            Sb(t, t.next, i, e)
        )
            return !0;
        t = t.next;
    } while (t !== i);
    return !1;
}
function Ip(i, e) {
    return Wn(i.prev, i, i.next) < 0
        ? Wn(i, e, i.next) >= 0 && Wn(i, i.prev, e) >= 0
        : Wn(i, e, i.prev) < 0 || Wn(i, i.next, e) < 0;
}
function JV(i, e) {
    let t = i,
        n = !1;
    const r = (i.x + e.x) / 2,
        s = (i.y + e.y) / 2;
    do
        t.y > s != t.next.y > s &&
            t.next.y !== t.y &&
            r < ((t.next.x - t.x) * (s - t.y)) / (t.next.y - t.y) + t.x &&
            (n = !n),
            (t = t.next);
    while (t !== i);
    return n;
}
function wb(i, e) {
    const t = new M_(i.i, i.x, i.y),
        n = new M_(e.i, e.x, e.y),
        r = i.next,
        s = e.prev;
    return (
        (i.next = e),
        (e.prev = i),
        (t.next = r),
        (r.prev = t),
        (n.next = t),
        (t.prev = n),
        (s.next = n),
        (n.prev = s),
        n
    );
}
function OE(i, e, t, n) {
    const r = new M_(i, e, t);
    return (
        n
            ? ((r.next = n.next), (r.prev = n), (n.next.prev = r), (n.next = r))
            : ((r.prev = r), (r.next = r)),
        r
    );
}
function Dp(i) {
    (i.next.prev = i.prev),
        (i.prev.next = i.next),
        i.prevZ && (i.prevZ.nextZ = i.nextZ),
        i.nextZ && (i.nextZ.prevZ = i.prevZ);
}
function M_(i, e, t) {
    (this.i = i),
        (this.x = e),
        (this.y = t),
        (this.prev = null),
        (this.next = null),
        (this.z = 0),
        (this.prevZ = null),
        (this.nextZ = null),
        (this.steiner = !1);
}
function QV(i, e, t, n) {
    let r = 0;
    for (let s = e, a = t - n; s < t; s += n)
        (r += (i[a] - i[s]) * (i[s + 1] + i[a + 1])), (a = s);
    return r;
}
class zo {
    static area(e) {
        const t = e.length;
        let n = 0;
        for (let r = t - 1, s = 0; s < t; r = s++)
            n += e[r].x * e[s].y - e[s].x * e[r].y;
        return n * 0.5;
    }
    static isClockWise(e) {
        return zo.area(e) < 0;
    }
    static triangulateShape(e, t) {
        const n = [],
            r = [],
            s = [];
        kE(e), FE(n, e);
        let a = e.length;
        t.forEach(kE);
        for (let c = 0; c < t.length; c++)
            r.push(a), (a += t[c].length), FE(n, t[c]);
        const l = kV.triangulate(n, r);
        for (let c = 0; c < l.length; c += 3) s.push(l.slice(c, c + 3));
        return s;
    }
}
function kE(i) {
    const e = i.length;
    e > 2 && i[e - 1].equals(i[0]) && i.pop();
}
function FE(i, e) {
    for (let t = 0; t < e.length; t++) i.push(e[t].x), i.push(e[t].y);
}
class Pv extends $t {
    constructor(
        e = new oc([
            new Ce(0.5, 0.5),
            new Ce(-0.5, 0.5),
            new Ce(-0.5, -0.5),
            new Ce(0.5, -0.5),
        ]),
        t = {}
    ) {
        super(),
            (this.type = 'ExtrudeGeometry'),
            (this.parameters = { shapes: e, options: t }),
            (e = Array.isArray(e) ? e : [e]);
        const n = this,
            r = [],
            s = [];
        for (let l = 0, c = e.length; l < c; l++) {
            const d = e[l];
            a(d);
        }
        this.setAttribute('position', new vt(r, 3)),
            this.setAttribute('uv', new vt(s, 2)),
            this.computeVertexNormals();
        function a(l) {
            const c = [],
                d = t.curveSegments !== void 0 ? t.curveSegments : 12,
                p = t.steps !== void 0 ? t.steps : 1,
                g = t.depth !== void 0 ? t.depth : 1;
            let y = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0,
                v = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2,
                S = t.bevelSize !== void 0 ? t.bevelSize : v - 0.1,
                T = t.bevelOffset !== void 0 ? t.bevelOffset : 0,
                M = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
            const w = t.extrudePath,
                b = t.UVGenerator !== void 0 ? t.UVGenerator : eH;
            let C,
                L = !1,
                F,
                N,
                B,
                z;
            w &&
                ((C = w.getSpacedPoints(p)),
                (L = !0),
                (y = !1),
                (F = w.computeFrenetFrames(p, !1)),
                (N = new j()),
                (B = new j()),
                (z = new j())),
                y || ((M = 0), (v = 0), (S = 0), (T = 0));
            const U = l.extractPoints(d);
            let D = U.shape;
            const H = U.holes;
            if (!zo.isClockWise(D)) {
                D = D.reverse();
                for (let W = 0, Ie = H.length; W < Ie; W++) {
                    const ke = H[W];
                    zo.isClockWise(ke) && (H[W] = ke.reverse());
                }
            }
            const ee = zo.triangulateShape(D, H),
                ue = D;
            for (let W = 0, Ie = H.length; W < Ie; W++) {
                const ke = H[W];
                D = D.concat(ke);
            }
            function Se(W, Ie, ke) {
                return (
                    Ie ||
                        console.error(
                            'THREE.ExtrudeGeometry: vec does not exist'
                        ),
                    W.clone().addScaledVector(Ie, ke)
                );
            }
            const ce = D.length,
                me = ee.length;
            function X(W, Ie, ke) {
                let Ke, Ee, St;
                const Ze = W.x - Ie.x,
                    ot = W.y - Ie.y,
                    $ = ke.x - W.x,
                    k = ke.y - W.y,
                    ge = Ze * Ze + ot * ot,
                    De = Ze * k - ot * $;
                if (Math.abs(De) > Number.EPSILON) {
                    const be = Math.sqrt(ge),
                        Le = Math.sqrt($ * $ + k * k),
                        _t = Ie.x - ot / be,
                        $e = Ie.y + Ze / be,
                        tt = ke.x - k / Le,
                        Nt = ke.y + $ / Le,
                        Be =
                            ((tt - _t) * k - (Nt - $e) * $) / (Ze * k - ot * $);
                    (Ke = _t + Ze * Be - W.x), (Ee = $e + ot * Be - W.y);
                    const Je = Ke * Ke + Ee * Ee;
                    if (Je <= 2) return new Ce(Ke, Ee);
                    St = Math.sqrt(Je / 2);
                } else {
                    let be = !1;
                    Ze > Number.EPSILON
                        ? $ > Number.EPSILON && (be = !0)
                        : Ze < -Number.EPSILON
                          ? $ < -Number.EPSILON && (be = !0)
                          : Math.sign(ot) === Math.sign(k) && (be = !0),
                        be
                            ? ((Ke = -ot), (Ee = Ze), (St = Math.sqrt(ge)))
                            : ((Ke = Ze), (Ee = ot), (St = Math.sqrt(ge / 2)));
                }
                return new Ce(Ke / St, Ee / St);
            }
            const oe = [];
            for (
                let W = 0, Ie = ue.length, ke = Ie - 1, Ke = W + 1;
                W < Ie;
                W++, ke++, Ke++
            )
                ke === Ie && (ke = 0),
                    Ke === Ie && (Ke = 0),
                    (oe[W] = X(ue[W], ue[ke], ue[Ke]));
            const Q = [];
            let G,
                ae = oe.concat();
            for (let W = 0, Ie = H.length; W < Ie; W++) {
                const ke = H[W];
                G = [];
                for (
                    let Ke = 0, Ee = ke.length, St = Ee - 1, Ze = Ke + 1;
                    Ke < Ee;
                    Ke++, St++, Ze++
                )
                    St === Ee && (St = 0),
                        Ze === Ee && (Ze = 0),
                        (G[Ke] = X(ke[Ke], ke[St], ke[Ze]));
                Q.push(G), (ae = ae.concat(G));
            }
            for (let W = 0; W < M; W++) {
                const Ie = W / M,
                    ke = v * Math.cos((Ie * Math.PI) / 2),
                    Ke = S * Math.sin((Ie * Math.PI) / 2) + T;
                for (let Ee = 0, St = ue.length; Ee < St; Ee++) {
                    const Ze = Se(ue[Ee], oe[Ee], Ke);
                    Re(Ze.x, Ze.y, -ke);
                }
                for (let Ee = 0, St = H.length; Ee < St; Ee++) {
                    const Ze = H[Ee];
                    G = Q[Ee];
                    for (let ot = 0, $ = Ze.length; ot < $; ot++) {
                        const k = Se(Ze[ot], G[ot], Ke);
                        Re(k.x, k.y, -ke);
                    }
                }
            }
            const Oe = S + T;
            for (let W = 0; W < ce; W++) {
                const Ie = y ? Se(D[W], ae[W], Oe) : D[W];
                L
                    ? (B.copy(F.normals[0]).multiplyScalar(Ie.x),
                      N.copy(F.binormals[0]).multiplyScalar(Ie.y),
                      z.copy(C[0]).add(B).add(N),
                      Re(z.x, z.y, z.z))
                    : Re(Ie.x, Ie.y, 0);
            }
            for (let W = 1; W <= p; W++)
                for (let Ie = 0; Ie < ce; Ie++) {
                    const ke = y ? Se(D[Ie], ae[Ie], Oe) : D[Ie];
                    L
                        ? (B.copy(F.normals[W]).multiplyScalar(ke.x),
                          N.copy(F.binormals[W]).multiplyScalar(ke.y),
                          z.copy(C[W]).add(B).add(N),
                          Re(z.x, z.y, z.z))
                        : Re(ke.x, ke.y, (g / p) * W);
                }
            for (let W = M - 1; W >= 0; W--) {
                const Ie = W / M,
                    ke = v * Math.cos((Ie * Math.PI) / 2),
                    Ke = S * Math.sin((Ie * Math.PI) / 2) + T;
                for (let Ee = 0, St = ue.length; Ee < St; Ee++) {
                    const Ze = Se(ue[Ee], oe[Ee], Ke);
                    Re(Ze.x, Ze.y, g + ke);
                }
                for (let Ee = 0, St = H.length; Ee < St; Ee++) {
                    const Ze = H[Ee];
                    G = Q[Ee];
                    for (let ot = 0, $ = Ze.length; ot < $; ot++) {
                        const k = Se(Ze[ot], G[ot], Ke);
                        L
                            ? Re(k.x, k.y + C[p - 1].y, C[p - 1].x + ke)
                            : Re(k.x, k.y, g + ke);
                    }
                }
            }
            fe(), we();
            function fe() {
                const W = r.length / 3;
                if (y) {
                    let Ie = 0,
                        ke = ce * Ie;
                    for (let Ke = 0; Ke < me; Ke++) {
                        const Ee = ee[Ke];
                        Ye(Ee[2] + ke, Ee[1] + ke, Ee[0] + ke);
                    }
                    (Ie = p + M * 2), (ke = ce * Ie);
                    for (let Ke = 0; Ke < me; Ke++) {
                        const Ee = ee[Ke];
                        Ye(Ee[0] + ke, Ee[1] + ke, Ee[2] + ke);
                    }
                } else {
                    for (let Ie = 0; Ie < me; Ie++) {
                        const ke = ee[Ie];
                        Ye(ke[2], ke[1], ke[0]);
                    }
                    for (let Ie = 0; Ie < me; Ie++) {
                        const ke = ee[Ie];
                        Ye(ke[0] + ce * p, ke[1] + ce * p, ke[2] + ce * p);
                    }
                }
                n.addGroup(W, r.length / 3 - W, 0);
            }
            function we() {
                const W = r.length / 3;
                let Ie = 0;
                Pe(ue, Ie), (Ie += ue.length);
                for (let ke = 0, Ke = H.length; ke < Ke; ke++) {
                    const Ee = H[ke];
                    Pe(Ee, Ie), (Ie += Ee.length);
                }
                n.addGroup(W, r.length / 3 - W, 1);
            }
            function Pe(W, Ie) {
                let ke = W.length;
                for (; --ke >= 0; ) {
                    const Ke = ke;
                    let Ee = ke - 1;
                    Ee < 0 && (Ee = W.length - 1);
                    for (let St = 0, Ze = p + M * 2; St < Ze; St++) {
                        const ot = ce * St,
                            $ = ce * (St + 1),
                            k = Ie + Ke + ot,
                            ge = Ie + Ee + ot,
                            De = Ie + Ee + $,
                            be = Ie + Ke + $;
                        lt(k, ge, De, be);
                    }
                }
            }
            function Re(W, Ie, ke) {
                c.push(W), c.push(Ie), c.push(ke);
            }
            function Ye(W, Ie, ke) {
                dt(W), dt(Ie), dt(ke);
                const Ke = r.length / 3,
                    Ee = b.generateTopUV(n, r, Ke - 3, Ke - 2, Ke - 1);
                Lt(Ee[0]), Lt(Ee[1]), Lt(Ee[2]);
            }
            function lt(W, Ie, ke, Ke) {
                dt(W), dt(Ie), dt(Ke), dt(Ie), dt(ke), dt(Ke);
                const Ee = r.length / 3,
                    St = b.generateSideWallUV(
                        n,
                        r,
                        Ee - 6,
                        Ee - 3,
                        Ee - 2,
                        Ee - 1
                    );
                Lt(St[0]),
                    Lt(St[1]),
                    Lt(St[3]),
                    Lt(St[1]),
                    Lt(St[2]),
                    Lt(St[3]);
            }
            function dt(W) {
                r.push(c[W * 3 + 0]),
                    r.push(c[W * 3 + 1]),
                    r.push(c[W * 3 + 2]);
            }
            function Lt(W) {
                s.push(W.x), s.push(W.y);
            }
        }
    }
    copy(e) {
        return (
            super.copy(e),
            (this.parameters = Object.assign({}, e.parameters)),
            this
        );
    }
    toJSON() {
        const e = super.toJSON(),
            t = this.parameters.shapes,
            n = this.parameters.options;
        return tH(t, n, e);
    }
    static fromJSON(e, t) {
        const n = [];
        for (let s = 0, a = e.shapes.length; s < a; s++) {
            const l = t[e.shapes[s]];
            n.push(l);
        }
        const r = e.options.extrudePath;
        return (
            r !== void 0 &&
                (e.options.extrudePath = new qy[r.type]().fromJSON(r)),
            new Pv(n, e.options)
        );
    }
}
const eH = {
    generateTopUV: function (i, e, t, n, r) {
        const s = e[t * 3],
            a = e[t * 3 + 1],
            l = e[n * 3],
            c = e[n * 3 + 1],
            d = e[r * 3],
            p = e[r * 3 + 1];
        return [new Ce(s, a), new Ce(l, c), new Ce(d, p)];
    },
    generateSideWallUV: function (i, e, t, n, r, s) {
        const a = e[t * 3],
            l = e[t * 3 + 1],
            c = e[t * 3 + 2],
            d = e[n * 3],
            p = e[n * 3 + 1],
            g = e[n * 3 + 2],
            y = e[r * 3],
            v = e[r * 3 + 1],
            S = e[r * 3 + 2],
            T = e[s * 3],
            M = e[s * 3 + 1],
            w = e[s * 3 + 2];
        return Math.abs(l - p) < Math.abs(a - d)
            ? [
                  new Ce(a, 1 - c),
                  new Ce(d, 1 - g),
                  new Ce(y, 1 - S),
                  new Ce(T, 1 - w),
              ]
            : [
                  new Ce(l, 1 - c),
                  new Ce(p, 1 - g),
                  new Ce(v, 1 - S),
                  new Ce(M, 1 - w),
              ];
    },
};
function tH(i, e, t) {
    if (((t.shapes = []), Array.isArray(i)))
        for (let n = 0, r = i.length; n < r; n++) {
            const s = i[n];
            t.shapes.push(s.uuid);
        }
    else t.shapes.push(i.uuid);
    return (
        (t.options = Object.assign({}, e)),
        e.extrudePath !== void 0 &&
            (t.options.extrudePath = e.extrudePath.toJSON()),
        t
    );
}
class Lv extends Vl {
    constructor(e = 1, t = 0) {
        const n = (1 + Math.sqrt(5)) / 2,
            r = [
                -1,
                n,
                0,
                1,
                n,
                0,
                -1,
                -n,
                0,
                1,
                -n,
                0,
                0,
                -1,
                n,
                0,
                1,
                n,
                0,
                -1,
                -n,
                0,
                1,
                -n,
                n,
                0,
                -1,
                n,
                0,
                1,
                -n,
                0,
                -1,
                -n,
                0,
                1,
            ],
            s = [
                0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11,
                4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3,
                6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
            ];
        super(r, s, e, t),
            (this.type = 'IcosahedronGeometry'),
            (this.parameters = { radius: e, detail: t });
    }
    static fromJSON(e) {
        return new Lv(e.radius, e.detail);
    }
}
class tm extends Vl {
    constructor(e = 1, t = 0) {
        const n = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
            r = [
                0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4,
                1, 4, 2,
            ];
        super(n, r, e, t),
            (this.type = 'OctahedronGeometry'),
            (this.parameters = { radius: e, detail: t });
    }
    static fromJSON(e) {
        return new tm(e.radius, e.detail);
    }
}
class Iv extends $t {
    constructor(e = 0.5, t = 1, n = 32, r = 1, s = 0, a = Math.PI * 2) {
        super(),
            (this.type = 'RingGeometry'),
            (this.parameters = {
                innerRadius: e,
                outerRadius: t,
                thetaSegments: n,
                phiSegments: r,
                thetaStart: s,
                thetaLength: a,
            }),
            (n = Math.max(3, n)),
            (r = Math.max(1, r));
        const l = [],
            c = [],
            d = [],
            p = [];
        let g = e;
        const y = (t - e) / r,
            v = new j(),
            S = new Ce();
        for (let T = 0; T <= r; T++) {
            for (let M = 0; M <= n; M++) {
                const w = s + (M / n) * a;
                (v.x = g * Math.cos(w)),
                    (v.y = g * Math.sin(w)),
                    c.push(v.x, v.y, v.z),
                    d.push(0, 0, 1),
                    (S.x = (v.x / t + 1) / 2),
                    (S.y = (v.y / t + 1) / 2),
                    p.push(S.x, S.y);
            }
            g += y;
        }
        for (let T = 0; T < r; T++) {
            const M = T * (n + 1);
            for (let w = 0; w < n; w++) {
                const b = w + M,
                    C = b,
                    L = b + n + 1,
                    F = b + n + 2,
                    N = b + 1;
                l.push(C, L, N), l.push(L, F, N);
            }
        }
        this.setIndex(l),
            this.setAttribute('position', new vt(c, 3)),
            this.setAttribute('normal', new vt(d, 3)),
            this.setAttribute('uv', new vt(p, 2));
    }
    copy(e) {
        return (
            super.copy(e),
            (this.parameters = Object.assign({}, e.parameters)),
            this
        );
    }
    static fromJSON(e) {
        return new Iv(
            e.innerRadius,
            e.outerRadius,
            e.thetaSegments,
            e.phiSegments,
            e.thetaStart,
            e.thetaLength
        );
    }
}
class Dv extends $t {
    constructor(
        e = new oc([new Ce(0, 0.5), new Ce(-0.5, -0.5), new Ce(0.5, -0.5)]),
        t = 12
    ) {
        super(),
            (this.type = 'ShapeGeometry'),
            (this.parameters = { shapes: e, curveSegments: t });
        const n = [],
            r = [],
            s = [],
            a = [];
        let l = 0,
            c = 0;
        if (Array.isArray(e) === !1) d(e);
        else
            for (let p = 0; p < e.length; p++)
                d(e[p]), this.addGroup(l, c, p), (l += c), (c = 0);
        this.setIndex(n),
            this.setAttribute('position', new vt(r, 3)),
            this.setAttribute('normal', new vt(s, 3)),
            this.setAttribute('uv', new vt(a, 2));
        function d(p) {
            const g = r.length / 3,
                y = p.extractPoints(t);
            let v = y.shape;
            const S = y.holes;
            zo.isClockWise(v) === !1 && (v = v.reverse());
            for (let M = 0, w = S.length; M < w; M++) {
                const b = S[M];
                zo.isClockWise(b) === !0 && (S[M] = b.reverse());
            }
            const T = zo.triangulateShape(v, S);
            for (let M = 0, w = S.length; M < w; M++) {
                const b = S[M];
                v = v.concat(b);
            }
            for (let M = 0, w = v.length; M < w; M++) {
                const b = v[M];
                r.push(b.x, b.y, 0), s.push(0, 0, 1), a.push(b.x, b.y);
            }
            for (let M = 0, w = T.length; M < w; M++) {
                const b = T[M],
                    C = b[0] + g,
                    L = b[1] + g,
                    F = b[2] + g;
                n.push(C, L, F), (c += 3);
            }
        }
    }
    copy(e) {
        return (
            super.copy(e),
            (this.parameters = Object.assign({}, e.parameters)),
            this
        );
    }
    toJSON() {
        const e = super.toJSON(),
            t = this.parameters.shapes;
        return nH(t, e);
    }
    static fromJSON(e, t) {
        const n = [];
        for (let r = 0, s = e.shapes.length; r < s; r++) {
            const a = t[e.shapes[r]];
            n.push(a);
        }
        return new Dv(n, e.curveSegments);
    }
}
function nH(i, e) {
    if (((e.shapes = []), Array.isArray(i)))
        for (let t = 0, n = i.length; t < n; t++) {
            const r = i[t];
            e.shapes.push(r.uuid);
        }
    else e.shapes.push(i.uuid);
    return e;
}
class nm extends $t {
    constructor(
        e = 1,
        t = 32,
        n = 16,
        r = 0,
        s = Math.PI * 2,
        a = 0,
        l = Math.PI
    ) {
        super(),
            (this.type = 'SphereGeometry'),
            (this.parameters = {
                radius: e,
                widthSegments: t,
                heightSegments: n,
                phiStart: r,
                phiLength: s,
                thetaStart: a,
                thetaLength: l,
            }),
            (t = Math.max(3, Math.floor(t))),
            (n = Math.max(2, Math.floor(n)));
        const c = Math.min(a + l, Math.PI);
        let d = 0;
        const p = [],
            g = new j(),
            y = new j(),
            v = [],
            S = [],
            T = [],
            M = [];
        for (let w = 0; w <= n; w++) {
            const b = [],
                C = w / n;
            let L = 0;
            w === 0 && a === 0
                ? (L = 0.5 / t)
                : w === n && c === Math.PI && (L = -0.5 / t);
            for (let F = 0; F <= t; F++) {
                const N = F / t;
                (g.x = -e * Math.cos(r + N * s) * Math.sin(a + C * l)),
                    (g.y = e * Math.cos(a + C * l)),
                    (g.z = e * Math.sin(r + N * s) * Math.sin(a + C * l)),
                    S.push(g.x, g.y, g.z),
                    y.copy(g).normalize(),
                    T.push(y.x, y.y, y.z),
                    M.push(N + L, 1 - C),
                    b.push(d++);
            }
            p.push(b);
        }
        for (let w = 0; w < n; w++)
            for (let b = 0; b < t; b++) {
                const C = p[w][b + 1],
                    L = p[w][b],
                    F = p[w + 1][b],
                    N = p[w + 1][b + 1];
                (w !== 0 || a > 0) && v.push(C, L, N),
                    (w !== n - 1 || c < Math.PI) && v.push(L, F, N);
            }
        this.setIndex(v),
            this.setAttribute('position', new vt(S, 3)),
            this.setAttribute('normal', new vt(T, 3)),
            this.setAttribute('uv', new vt(M, 2));
    }
    copy(e) {
        return (
            super.copy(e),
            (this.parameters = Object.assign({}, e.parameters)),
            this
        );
    }
    static fromJSON(e) {
        return new nm(
            e.radius,
            e.widthSegments,
            e.heightSegments,
            e.phiStart,
            e.phiLength,
            e.thetaStart,
            e.thetaLength
        );
    }
}
class Nv extends Vl {
    constructor(e = 1, t = 0) {
        const n = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
            r = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
        super(n, r, e, t),
            (this.type = 'TetrahedronGeometry'),
            (this.parameters = { radius: e, detail: t });
    }
    static fromJSON(e) {
        return new Nv(e.radius, e.detail);
    }
}
class Uv extends $t {
    constructor(e = 1, t = 0.4, n = 12, r = 48, s = Math.PI * 2) {
        super(),
            (this.type = 'TorusGeometry'),
            (this.parameters = {
                radius: e,
                tube: t,
                radialSegments: n,
                tubularSegments: r,
                arc: s,
            }),
            (n = Math.floor(n)),
            (r = Math.floor(r));
        const a = [],
            l = [],
            c = [],
            d = [],
            p = new j(),
            g = new j(),
            y = new j();
        for (let v = 0; v <= n; v++)
            for (let S = 0; S <= r; S++) {
                const T = (S / r) * s,
                    M = (v / n) * Math.PI * 2;
                (g.x = (e + t * Math.cos(M)) * Math.cos(T)),
                    (g.y = (e + t * Math.cos(M)) * Math.sin(T)),
                    (g.z = t * Math.sin(M)),
                    l.push(g.x, g.y, g.z),
                    (p.x = e * Math.cos(T)),
                    (p.y = e * Math.sin(T)),
                    y.subVectors(g, p).normalize(),
                    c.push(y.x, y.y, y.z),
                    d.push(S / r),
                    d.push(v / n);
            }
        for (let v = 1; v <= n; v++)
            for (let S = 1; S <= r; S++) {
                const T = (r + 1) * v + S - 1,
                    M = (r + 1) * (v - 1) + S - 1,
                    w = (r + 1) * (v - 1) + S,
                    b = (r + 1) * v + S;
                a.push(T, M, b), a.push(M, w, b);
            }
        this.setIndex(a),
            this.setAttribute('position', new vt(l, 3)),
            this.setAttribute('normal', new vt(c, 3)),
            this.setAttribute('uv', new vt(d, 2));
    }
    copy(e) {
        return (
            super.copy(e),
            (this.parameters = Object.assign({}, e.parameters)),
            this
        );
    }
    static fromJSON(e) {
        return new Uv(
            e.radius,
            e.tube,
            e.radialSegments,
            e.tubularSegments,
            e.arc
        );
    }
}
class Ov extends $t {
    constructor(e = 1, t = 0.4, n = 64, r = 8, s = 2, a = 3) {
        super(),
            (this.type = 'TorusKnotGeometry'),
            (this.parameters = {
                radius: e,
                tube: t,
                tubularSegments: n,
                radialSegments: r,
                p: s,
                q: a,
            }),
            (n = Math.floor(n)),
            (r = Math.floor(r));
        const l = [],
            c = [],
            d = [],
            p = [],
            g = new j(),
            y = new j(),
            v = new j(),
            S = new j(),
            T = new j(),
            M = new j(),
            w = new j();
        for (let C = 0; C <= n; ++C) {
            const L = (C / n) * s * Math.PI * 2;
            b(L, s, a, e, v),
                b(L + 0.01, s, a, e, S),
                M.subVectors(S, v),
                w.addVectors(S, v),
                T.crossVectors(M, w),
                w.crossVectors(T, M),
                T.normalize(),
                w.normalize();
            for (let F = 0; F <= r; ++F) {
                const N = (F / r) * Math.PI * 2,
                    B = -t * Math.cos(N),
                    z = t * Math.sin(N);
                (g.x = v.x + (B * w.x + z * T.x)),
                    (g.y = v.y + (B * w.y + z * T.y)),
                    (g.z = v.z + (B * w.z + z * T.z)),
                    c.push(g.x, g.y, g.z),
                    y.subVectors(g, v).normalize(),
                    d.push(y.x, y.y, y.z),
                    p.push(C / n),
                    p.push(F / r);
            }
        }
        for (let C = 1; C <= n; C++)
            for (let L = 1; L <= r; L++) {
                const F = (r + 1) * (C - 1) + (L - 1),
                    N = (r + 1) * C + (L - 1),
                    B = (r + 1) * C + L,
                    z = (r + 1) * (C - 1) + L;
                l.push(F, N, z), l.push(N, B, z);
            }
        this.setIndex(l),
            this.setAttribute('position', new vt(c, 3)),
            this.setAttribute('normal', new vt(d, 3)),
            this.setAttribute('uv', new vt(p, 2));
        function b(C, L, F, N, B) {
            const z = Math.cos(C),
                U = Math.sin(C),
                D = (F / L) * C,
                H = Math.cos(D);
            (B.x = N * (2 + H) * 0.5 * z),
                (B.y = N * (2 + H) * U * 0.5),
                (B.z = N * Math.sin(D) * 0.5);
        }
    }
    copy(e) {
        return (
            super.copy(e),
            (this.parameters = Object.assign({}, e.parameters)),
            this
        );
    }
    static fromJSON(e) {
        return new Ov(
            e.radius,
            e.tube,
            e.tubularSegments,
            e.radialSegments,
            e.p,
            e.q
        );
    }
}
class kv extends $t {
    constructor(
        e = new iw(new j(-1, -1, 0), new j(-1, 1, 0), new j(1, 1, 0)),
        t = 64,
        n = 1,
        r = 8,
        s = !1
    ) {
        super(),
            (this.type = 'TubeGeometry'),
            (this.parameters = {
                path: e,
                tubularSegments: t,
                radius: n,
                radialSegments: r,
                closed: s,
            });
        const a = e.computeFrenetFrames(t, s);
        (this.tangents = a.tangents),
            (this.normals = a.normals),
            (this.binormals = a.binormals);
        const l = new j(),
            c = new j(),
            d = new Ce();
        let p = new j();
        const g = [],
            y = [],
            v = [],
            S = [];
        T(),
            this.setIndex(S),
            this.setAttribute('position', new vt(g, 3)),
            this.setAttribute('normal', new vt(y, 3)),
            this.setAttribute('uv', new vt(v, 2));
        function T() {
            for (let C = 0; C < t; C++) M(C);
            M(s === !1 ? t : 0), b(), w();
        }
        function M(C) {
            p = e.getPointAt(C / t, p);
            const L = a.normals[C],
                F = a.binormals[C];
            for (let N = 0; N <= r; N++) {
                const B = (N / r) * Math.PI * 2,
                    z = Math.sin(B),
                    U = -Math.cos(B);
                (c.x = U * L.x + z * F.x),
                    (c.y = U * L.y + z * F.y),
                    (c.z = U * L.z + z * F.z),
                    c.normalize(),
                    y.push(c.x, c.y, c.z),
                    (l.x = p.x + n * c.x),
                    (l.y = p.y + n * c.y),
                    (l.z = p.z + n * c.z),
                    g.push(l.x, l.y, l.z);
            }
        }
        function w() {
            for (let C = 1; C <= t; C++)
                for (let L = 1; L <= r; L++) {
                    const F = (r + 1) * (C - 1) + (L - 1),
                        N = (r + 1) * C + (L - 1),
                        B = (r + 1) * C + L,
                        z = (r + 1) * (C - 1) + L;
                    S.push(F, N, z), S.push(N, B, z);
                }
        }
        function b() {
            for (let C = 0; C <= t; C++)
                for (let L = 0; L <= r; L++)
                    (d.x = C / t), (d.y = L / r), v.push(d.x, d.y);
        }
    }
    copy(e) {
        return (
            super.copy(e),
            (this.parameters = Object.assign({}, e.parameters)),
            this
        );
    }
    toJSON() {
        const e = super.toJSON();
        return (e.path = this.parameters.path.toJSON()), e;
    }
    static fromJSON(e) {
        return new kv(
            new qy[e.path.type]().fromJSON(e.path),
            e.tubularSegments,
            e.radius,
            e.radialSegments,
            e.closed
        );
    }
}
class Mb extends $t {
    constructor(e = null) {
        if (
            (super(),
            (this.type = 'WireframeGeometry'),
            (this.parameters = { geometry: e }),
            e !== null)
        ) {
            const t = [],
                n = new Set(),
                r = new j(),
                s = new j();
            if (e.index !== null) {
                const a = e.attributes.position,
                    l = e.index;
                let c = e.groups;
                c.length === 0 &&
                    (c = [{ start: 0, count: l.count, materialIndex: 0 }]);
                for (let d = 0, p = c.length; d < p; ++d) {
                    const g = c[d],
                        y = g.start,
                        v = g.count;
                    for (let S = y, T = y + v; S < T; S += 3)
                        for (let M = 0; M < 3; M++) {
                            const w = l.getX(S + M),
                                b = l.getX(S + ((M + 1) % 3));
                            r.fromBufferAttribute(a, w),
                                s.fromBufferAttribute(a, b),
                                BE(r, s, n) === !0 &&
                                    (t.push(r.x, r.y, r.z),
                                    t.push(s.x, s.y, s.z));
                        }
                }
            } else {
                const a = e.attributes.position;
                for (let l = 0, c = a.count / 3; l < c; l++)
                    for (let d = 0; d < 3; d++) {
                        const p = 3 * l + d,
                            g = 3 * l + ((d + 1) % 3);
                        r.fromBufferAttribute(a, p),
                            s.fromBufferAttribute(a, g),
                            BE(r, s, n) === !0 &&
                                (t.push(r.x, r.y, r.z), t.push(s.x, s.y, s.z));
                    }
            }
            this.setAttribute('position', new vt(t, 3));
        }
    }
    copy(e) {
        return (
            super.copy(e),
            (this.parameters = Object.assign({}, e.parameters)),
            this
        );
    }
}
function BE(i, e, t) {
    const n = `${i.x},${i.y},${i.z}-${e.x},${e.y},${e.z}`,
        r = `${e.x},${e.y},${e.z}-${i.x},${i.y},${i.z}`;
    return t.has(n) === !0 || t.has(r) === !0 ? !1 : (t.add(n), t.add(r), !0);
}
var zE = Object.freeze({
    __proto__: null,
    BoxGeometry: dc,
    CapsuleGeometry: Tv,
    CircleGeometry: Av,
    ConeGeometry: Cv,
    CylinderGeometry: Ch,
    DodecahedronGeometry: Rv,
    EdgesGeometry: xb,
    ExtrudeGeometry: Pv,
    IcosahedronGeometry: Lv,
    LatheGeometry: em,
    OctahedronGeometry: tm,
    PlaneGeometry: Th,
    PolyhedronGeometry: Vl,
    RingGeometry: Iv,
    ShapeGeometry: Dv,
    SphereGeometry: nm,
    TetrahedronGeometry: Nv,
    TorusGeometry: Uv,
    TorusKnotGeometry: Ov,
    TubeGeometry: kv,
    WireframeGeometry: Mb,
});
class Eb extends lr {
    constructor(e) {
        super(),
            (this.isShadowMaterial = !0),
            (this.type = 'ShadowMaterial'),
            (this.color = new st(0)),
            (this.transparent = !0),
            (this.fog = !0),
            this.setValues(e);
    }
    copy(e) {
        return (
            super.copy(e), this.color.copy(e.color), (this.fog = e.fog), this
        );
    }
}
class Tb extends Ts {
    constructor(e) {
        super(e),
            (this.isRawShaderMaterial = !0),
            (this.type = 'RawShaderMaterial');
    }
}
class sw extends lr {
    constructor(e) {
        super(),
            (this.isMeshStandardMaterial = !0),
            (this.defines = { STANDARD: '' }),
            (this.type = 'MeshStandardMaterial'),
            (this.color = new st(16777215)),
            (this.roughness = 1),
            (this.metalness = 0),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new st(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = Bl),
            (this.normalScale = new Ce(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.roughnessMap = null),
            (this.metalnessMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.envMapRotation = new as()),
            (this.envMapIntensity = 1),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = 'round'),
            (this.wireframeLinejoin = 'round'),
            (this.flatShading = !1),
            (this.fog = !0),
            this.setValues(e);
    }
    copy(e) {
        return (
            super.copy(e),
            (this.defines = { STANDARD: '' }),
            this.color.copy(e.color),
            (this.roughness = e.roughness),
            (this.metalness = e.metalness),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            this.emissive.copy(e.emissive),
            (this.emissiveMap = e.emissiveMap),
            (this.emissiveIntensity = e.emissiveIntensity),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.roughnessMap = e.roughnessMap),
            (this.metalnessMap = e.metalnessMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            this.envMapRotation.copy(e.envMapRotation),
            (this.envMapIntensity = e.envMapIntensity),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.flatShading = e.flatShading),
            (this.fog = e.fog),
            this
        );
    }
}
class Ab extends sw {
    constructor(e) {
        super(),
            (this.isMeshPhysicalMaterial = !0),
            (this.defines = { STANDARD: '', PHYSICAL: '' }),
            (this.type = 'MeshPhysicalMaterial'),
            (this.anisotropyRotation = 0),
            (this.anisotropyMap = null),
            (this.clearcoatMap = null),
            (this.clearcoatRoughness = 0),
            (this.clearcoatRoughnessMap = null),
            (this.clearcoatNormalScale = new Ce(1, 1)),
            (this.clearcoatNormalMap = null),
            (this.ior = 1.5),
            Object.defineProperty(this, 'reflectivity', {
                get: function () {
                    return Jn((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
                },
                set: function (t) {
                    this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
                },
            }),
            (this.iridescenceMap = null),
            (this.iridescenceIOR = 1.3),
            (this.iridescenceThicknessRange = [100, 400]),
            (this.iridescenceThicknessMap = null),
            (this.sheenColor = new st(0)),
            (this.sheenColorMap = null),
            (this.sheenRoughness = 1),
            (this.sheenRoughnessMap = null),
            (this.transmissionMap = null),
            (this.thickness = 0),
            (this.thicknessMap = null),
            (this.attenuationDistance = 1 / 0),
            (this.attenuationColor = new st(1, 1, 1)),
            (this.specularIntensity = 1),
            (this.specularIntensityMap = null),
            (this.specularColor = new st(1, 1, 1)),
            (this.specularColorMap = null),
            (this._anisotropy = 0),
            (this._clearcoat = 0),
            (this._dispersion = 0),
            (this._iridescence = 0),
            (this._sheen = 0),
            (this._transmission = 0),
            this.setValues(e);
    }
    get anisotropy() {
        return this._anisotropy;
    }
    set anisotropy(e) {
        this._anisotropy > 0 != e > 0 && this.version++, (this._anisotropy = e);
    }
    get clearcoat() {
        return this._clearcoat;
    }
    set clearcoat(e) {
        this._clearcoat > 0 != e > 0 && this.version++, (this._clearcoat = e);
    }
    get iridescence() {
        return this._iridescence;
    }
    set iridescence(e) {
        this._iridescence > 0 != e > 0 && this.version++,
            (this._iridescence = e);
    }
    get dispersion() {
        return this._dispersion;
    }
    set dispersion(e) {
        this._dispersion > 0 != e > 0 && this.version++, (this._dispersion = e);
    }
    get sheen() {
        return this._sheen;
    }
    set sheen(e) {
        this._sheen > 0 != e > 0 && this.version++, (this._sheen = e);
    }
    get transmission() {
        return this._transmission;
    }
    set transmission(e) {
        this._transmission > 0 != e > 0 && this.version++,
            (this._transmission = e);
    }
    copy(e) {
        return (
            super.copy(e),
            (this.defines = { STANDARD: '', PHYSICAL: '' }),
            (this.anisotropy = e.anisotropy),
            (this.anisotropyRotation = e.anisotropyRotation),
            (this.anisotropyMap = e.anisotropyMap),
            (this.clearcoat = e.clearcoat),
            (this.clearcoatMap = e.clearcoatMap),
            (this.clearcoatRoughness = e.clearcoatRoughness),
            (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
            (this.clearcoatNormalMap = e.clearcoatNormalMap),
            this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
            (this.dispersion = e.dispersion),
            (this.ior = e.ior),
            (this.iridescence = e.iridescence),
            (this.iridescenceMap = e.iridescenceMap),
            (this.iridescenceIOR = e.iridescenceIOR),
            (this.iridescenceThicknessRange = [...e.iridescenceThicknessRange]),
            (this.iridescenceThicknessMap = e.iridescenceThicknessMap),
            (this.sheen = e.sheen),
            this.sheenColor.copy(e.sheenColor),
            (this.sheenColorMap = e.sheenColorMap),
            (this.sheenRoughness = e.sheenRoughness),
            (this.sheenRoughnessMap = e.sheenRoughnessMap),
            (this.transmission = e.transmission),
            (this.transmissionMap = e.transmissionMap),
            (this.thickness = e.thickness),
            (this.thicknessMap = e.thicknessMap),
            (this.attenuationDistance = e.attenuationDistance),
            this.attenuationColor.copy(e.attenuationColor),
            (this.specularIntensity = e.specularIntensity),
            (this.specularIntensityMap = e.specularIntensityMap),
            this.specularColor.copy(e.specularColor),
            (this.specularColorMap = e.specularColorMap),
            this
        );
    }
}
class Cb extends lr {
    constructor(e) {
        super(),
            (this.isMeshPhongMaterial = !0),
            (this.type = 'MeshPhongMaterial'),
            (this.color = new st(16777215)),
            (this.specular = new st(1118481)),
            (this.shininess = 30),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new st(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = Bl),
            (this.normalScale = new Ce(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.specularMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.envMapRotation = new as()),
            (this.combine = qp),
            (this.reflectivity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = 'round'),
            (this.wireframeLinejoin = 'round'),
            (this.flatShading = !1),
            (this.fog = !0),
            this.setValues(e);
    }
    copy(e) {
        return (
            super.copy(e),
            this.color.copy(e.color),
            this.specular.copy(e.specular),
            (this.shininess = e.shininess),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            this.emissive.copy(e.emissive),
            (this.emissiveMap = e.emissiveMap),
            (this.emissiveIntensity = e.emissiveIntensity),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.specularMap = e.specularMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            this.envMapRotation.copy(e.envMapRotation),
            (this.combine = e.combine),
            (this.reflectivity = e.reflectivity),
            (this.refractionRatio = e.refractionRatio),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.flatShading = e.flatShading),
            (this.fog = e.fog),
            this
        );
    }
}
class Rb extends lr {
    constructor(e) {
        super(),
            (this.isMeshToonMaterial = !0),
            (this.defines = { TOON: '' }),
            (this.type = 'MeshToonMaterial'),
            (this.color = new st(16777215)),
            (this.map = null),
            (this.gradientMap = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new st(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = Bl),
            (this.normalScale = new Ce(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.alphaMap = null),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = 'round'),
            (this.wireframeLinejoin = 'round'),
            (this.fog = !0),
            this.setValues(e);
    }
    copy(e) {
        return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.gradientMap = e.gradientMap),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            this.emissive.copy(e.emissive),
            (this.emissiveMap = e.emissiveMap),
            (this.emissiveIntensity = e.emissiveIntensity),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.alphaMap = e.alphaMap),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.fog = e.fog),
            this
        );
    }
}
class bb extends lr {
    constructor(e) {
        super(),
            (this.isMeshNormalMaterial = !0),
            (this.type = 'MeshNormalMaterial'),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = Bl),
            (this.normalScale = new Ce(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.flatShading = !1),
            this.setValues(e);
    }
    copy(e) {
        return (
            super.copy(e),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.flatShading = e.flatShading),
            this
        );
    }
}
class Pb extends lr {
    constructor(e) {
        super(),
            (this.isMeshLambertMaterial = !0),
            (this.type = 'MeshLambertMaterial'),
            (this.color = new st(16777215)),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new st(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = Bl),
            (this.normalScale = new Ce(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.specularMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.envMapRotation = new as()),
            (this.combine = qp),
            (this.reflectivity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = 'round'),
            (this.wireframeLinejoin = 'round'),
            (this.flatShading = !1),
            (this.fog = !0),
            this.setValues(e);
    }
    copy(e) {
        return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            this.emissive.copy(e.emissive),
            (this.emissiveMap = e.emissiveMap),
            (this.emissiveIntensity = e.emissiveIntensity),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.specularMap = e.specularMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            this.envMapRotation.copy(e.envMapRotation),
            (this.combine = e.combine),
            (this.reflectivity = e.reflectivity),
            (this.refractionRatio = e.refractionRatio),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.flatShading = e.flatShading),
            (this.fog = e.fog),
            this
        );
    }
}
class Lb extends lr {
    constructor(e) {
        super(),
            (this.isMeshMatcapMaterial = !0),
            (this.defines = { MATCAP: '' }),
            (this.type = 'MeshMatcapMaterial'),
            (this.color = new st(16777215)),
            (this.matcap = null),
            (this.map = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = Bl),
            (this.normalScale = new Ce(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.alphaMap = null),
            (this.flatShading = !1),
            (this.fog = !0),
            this.setValues(e);
    }
    copy(e) {
        return (
            super.copy(e),
            (this.defines = { MATCAP: '' }),
            this.color.copy(e.color),
            (this.matcap = e.matcap),
            (this.map = e.map),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.alphaMap = e.alphaMap),
            (this.flatShading = e.flatShading),
            (this.fog = e.fog),
            this
        );
    }
}
class Ib extends Ar {
    constructor(e) {
        super(),
            (this.isLineDashedMaterial = !0),
            (this.type = 'LineDashedMaterial'),
            (this.scale = 1),
            (this.dashSize = 3),
            (this.gapSize = 1),
            this.setValues(e);
    }
    copy(e) {
        return (
            super.copy(e),
            (this.scale = e.scale),
            (this.dashSize = e.dashSize),
            (this.gapSize = e.gapSize),
            this
        );
    }
}
function Ju(i, e, t) {
    return !i || (!t && i.constructor === e)
        ? i
        : typeof e.BYTES_PER_ELEMENT == 'number'
          ? new e(i)
          : Array.prototype.slice.call(i);
}
function Db(i) {
    return ArrayBuffer.isView(i) && !(i instanceof DataView);
}
function Nb(i) {
    function e(r, s) {
        return i[r] - i[s];
    }
    const t = i.length,
        n = new Array(t);
    for (let r = 0; r !== t; ++r) n[r] = r;
    return n.sort(e), n;
}
function E_(i, e, t) {
    const n = i.length,
        r = new i.constructor(n);
    for (let s = 0, a = 0; a !== n; ++s) {
        const l = t[s] * e;
        for (let c = 0; c !== e; ++c) r[a++] = i[l + c];
    }
    return r;
}
function ow(i, e, t, n) {
    let r = 1,
        s = i[0];
    for (; s !== void 0 && s[n] === void 0; ) s = i[r++];
    if (s === void 0) return;
    let a = s[n];
    if (a !== void 0)
        if (Array.isArray(a))
            do
                (a = s[n]),
                    a !== void 0 && (e.push(s.time), t.push.apply(t, a)),
                    (s = i[r++]);
            while (s !== void 0);
        else if (a.toArray !== void 0)
            do
                (a = s[n]),
                    a !== void 0 && (e.push(s.time), a.toArray(t, t.length)),
                    (s = i[r++]);
            while (s !== void 0);
        else
            do
                (a = s[n]),
                    a !== void 0 && (e.push(s.time), t.push(a)),
                    (s = i[r++]);
            while (s !== void 0);
}
function iH(i, e, t, n, r = 30) {
    const s = i.clone();
    s.name = e;
    const a = [];
    for (let c = 0; c < s.tracks.length; ++c) {
        const d = s.tracks[c],
            p = d.getValueSize(),
            g = [],
            y = [];
        for (let v = 0; v < d.times.length; ++v) {
            const S = d.times[v] * r;
            if (!(S < t || S >= n)) {
                g.push(d.times[v]);
                for (let T = 0; T < p; ++T) y.push(d.values[v * p + T]);
            }
        }
        g.length !== 0 &&
            ((d.times = Ju(g, d.times.constructor)),
            (d.values = Ju(y, d.values.constructor)),
            a.push(d));
    }
    s.tracks = a;
    let l = 1 / 0;
    for (let c = 0; c < s.tracks.length; ++c)
        l > s.tracks[c].times[0] && (l = s.tracks[c].times[0]);
    for (let c = 0; c < s.tracks.length; ++c) s.tracks[c].shift(-1 * l);
    return s.resetDuration(), s;
}
function rH(i, e = 0, t = i, n = 30) {
    n <= 0 && (n = 30);
    const r = t.tracks.length,
        s = e / n;
    for (let a = 0; a < r; ++a) {
        const l = t.tracks[a],
            c = l.ValueTypeName;
        if (c === 'bool' || c === 'string') continue;
        const d = i.tracks.find(function (w) {
            return w.name === l.name && w.ValueTypeName === c;
        });
        if (d === void 0) continue;
        let p = 0;
        const g = l.getValueSize();
        l.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
            (p = g / 3);
        let y = 0;
        const v = d.getValueSize();
        d.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
            (y = v / 3);
        const S = l.times.length - 1;
        let T;
        if (s <= l.times[0]) {
            const w = p,
                b = g - p;
            T = l.values.slice(w, b);
        } else if (s >= l.times[S]) {
            const w = S * g + p,
                b = w + g - p;
            T = l.values.slice(w, b);
        } else {
            const w = l.createInterpolant(),
                b = p,
                C = g - p;
            w.evaluate(s), (T = w.resultBuffer.slice(b, C));
        }
        c === 'quaternion' &&
            new Hr().fromArray(T).normalize().conjugate().toArray(T);
        const M = d.times.length;
        for (let w = 0; w < M; ++w) {
            const b = w * v + y;
            if (c === 'quaternion')
                Hr.multiplyQuaternionsFlat(d.values, b, T, 0, d.values, b);
            else {
                const C = v - y * 2;
                for (let L = 0; L < C; ++L) d.values[b + L] -= T[L];
            }
        }
    }
    return (i.blendMode = kS), i;
}
const sH = {
    convertArray: Ju,
    isTypedArray: Db,
    getKeyframeOrder: Nb,
    sortedArray: E_,
    flattenJSON: ow,
    subclip: iH,
    makeClipAdditive: rH,
};
class im {
    constructor(e, t, n, r) {
        (this.parameterPositions = e),
            (this._cachedIndex = 0),
            (this.resultBuffer = r !== void 0 ? r : new t.constructor(n)),
            (this.sampleValues = t),
            (this.valueSize = n),
            (this.settings = null),
            (this.DefaultSettings_ = {});
    }
    evaluate(e) {
        const t = this.parameterPositions;
        let n = this._cachedIndex,
            r = t[n],
            s = t[n - 1];
        e: {
            t: {
                let a;
                n: {
                    i: if (!(e < r)) {
                        for (let l = n + 2; ; ) {
                            if (r === void 0) {
                                if (e < s) break i;
                                return (
                                    (n = t.length),
                                    (this._cachedIndex = n),
                                    this.copySampleValue_(n - 1)
                                );
                            }
                            if (n === l) break;
                            if (((s = r), (r = t[++n]), e < r)) break t;
                        }
                        a = t.length;
                        break n;
                    }
                    if (!(e >= s)) {
                        const l = t[1];
                        e < l && ((n = 2), (s = l));
                        for (let c = n - 2; ; ) {
                            if (s === void 0)
                                return (
                                    (this._cachedIndex = 0),
                                    this.copySampleValue_(0)
                                );
                            if (n === c) break;
                            if (((r = s), (s = t[--n - 1]), e >= s)) break t;
                        }
                        (a = n), (n = 0);
                        break n;
                    }
                    break e;
                }
                for (; n < a; ) {
                    const l = (n + a) >>> 1;
                    e < t[l] ? (a = l) : (n = l + 1);
                }
                if (((r = t[n]), (s = t[n - 1]), s === void 0))
                    return (this._cachedIndex = 0), this.copySampleValue_(0);
                if (r === void 0)
                    return (
                        (n = t.length),
                        (this._cachedIndex = n),
                        this.copySampleValue_(n - 1)
                    );
            }
            (this._cachedIndex = n), this.intervalChanged_(n, s, r);
        }
        return this.interpolate_(n, s, e, r);
    }
    getSettings_() {
        return this.settings || this.DefaultSettings_;
    }
    copySampleValue_(e) {
        const t = this.resultBuffer,
            n = this.sampleValues,
            r = this.valueSize,
            s = e * r;
        for (let a = 0; a !== r; ++a) t[a] = n[s + a];
        return t;
    }
    interpolate_() {
        throw new Error('call to abstract method');
    }
    intervalChanged_() {}
}
class Ub extends im {
    constructor(e, t, n, r) {
        super(e, t, n, r),
            (this._weightPrev = -0),
            (this._offsetPrev = -0),
            (this._weightNext = -0),
            (this._offsetNext = -0),
            (this.DefaultSettings_ = { endingStart: Yu, endingEnd: Yu });
    }
    intervalChanged_(e, t, n) {
        const r = this.parameterPositions;
        let s = e - 2,
            a = e + 1,
            l = r[s],
            c = r[a];
        if (l === void 0)
            switch (this.getSettings_().endingStart) {
                case Ku:
                    (s = e), (l = 2 * t - n);
                    break;
                case Mp:
                    (s = r.length - 2), (l = t + r[s] - r[s + 1]);
                    break;
                default:
                    (s = e), (l = n);
            }
        if (c === void 0)
            switch (this.getSettings_().endingEnd) {
                case Ku:
                    (a = e), (c = 2 * n - t);
                    break;
                case Mp:
                    (a = 1), (c = n + r[1] - r[0]);
                    break;
                default:
                    (a = e - 1), (c = t);
            }
        const d = (n - t) * 0.5,
            p = this.valueSize;
        (this._weightPrev = d / (t - l)),
            (this._weightNext = d / (c - n)),
            (this._offsetPrev = s * p),
            (this._offsetNext = a * p);
    }
    interpolate_(e, t, n, r) {
        const s = this.resultBuffer,
            a = this.sampleValues,
            l = this.valueSize,
            c = e * l,
            d = c - l,
            p = this._offsetPrev,
            g = this._offsetNext,
            y = this._weightPrev,
            v = this._weightNext,
            S = (n - t) / (r - t),
            T = S * S,
            M = T * S,
            w = -y * M + 2 * y * T - y * S,
            b = (1 + y) * M + (-1.5 - 2 * y) * T + (-0.5 + y) * S + 1,
            C = (-1 - v) * M + (1.5 + v) * T + 0.5 * S,
            L = v * M - v * T;
        for (let F = 0; F !== l; ++F)
            s[F] = w * a[p + F] + b * a[d + F] + C * a[c + F] + L * a[g + F];
        return s;
    }
}
class aw extends im {
    constructor(e, t, n, r) {
        super(e, t, n, r);
    }
    interpolate_(e, t, n, r) {
        const s = this.resultBuffer,
            a = this.sampleValues,
            l = this.valueSize,
            c = e * l,
            d = c - l,
            p = (n - t) / (r - t),
            g = 1 - p;
        for (let y = 0; y !== l; ++y) s[y] = a[d + y] * g + a[c + y] * p;
        return s;
    }
}
class Ob extends im {
    constructor(e, t, n, r) {
        super(e, t, n, r);
    }
    interpolate_(e) {
        return this.copySampleValue_(e - 1);
    }
}
class ho {
    constructor(e, t, n, r) {
        if (e === void 0)
            throw new Error('THREE.KeyframeTrack: track name is undefined');
        if (t === void 0 || t.length === 0)
            throw new Error(
                'THREE.KeyframeTrack: no keyframes in track named ' + e
            );
        (this.name = e),
            (this.times = Ju(t, this.TimeBufferType)),
            (this.values = Ju(n, this.ValueBufferType)),
            this.setInterpolation(r || this.DefaultInterpolation);
    }
    static toJSON(e) {
        const t = e.constructor;
        let n;
        if (t.toJSON !== this.toJSON) n = t.toJSON(e);
        else {
            n = {
                name: e.name,
                times: Ju(e.times, Array),
                values: Ju(e.values, Array),
            };
            const r = e.getInterpolation();
            r !== e.DefaultInterpolation && (n.interpolation = r);
        }
        return (n.type = e.ValueTypeName), n;
    }
    InterpolantFactoryMethodDiscrete(e) {
        return new Ob(this.times, this.values, this.getValueSize(), e);
    }
    InterpolantFactoryMethodLinear(e) {
        return new aw(this.times, this.values, this.getValueSize(), e);
    }
    InterpolantFactoryMethodSmooth(e) {
        return new Ub(this.times, this.values, this.getValueSize(), e);
    }
    setInterpolation(e) {
        let t;
        switch (e) {
            case wp:
                t = this.InterpolantFactoryMethodDiscrete;
                break;
            case Wy:
                t = this.InterpolantFactoryMethodLinear;
                break;
            case oy:
                t = this.InterpolantFactoryMethodSmooth;
                break;
        }
        if (t === void 0) {
            const n =
                'unsupported interpolation for ' +
                this.ValueTypeName +
                ' keyframe track named ' +
                this.name;
            if (this.createInterpolant === void 0)
                if (e !== this.DefaultInterpolation)
                    this.setInterpolation(this.DefaultInterpolation);
                else throw new Error(n);
            return console.warn('THREE.KeyframeTrack:', n), this;
        }
        return (this.createInterpolant = t), this;
    }
    getInterpolation() {
        switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
                return wp;
            case this.InterpolantFactoryMethodLinear:
                return Wy;
            case this.InterpolantFactoryMethodSmooth:
                return oy;
        }
    }
    getValueSize() {
        return this.values.length / this.times.length;
    }
    shift(e) {
        if (e !== 0) {
            const t = this.times;
            for (let n = 0, r = t.length; n !== r; ++n) t[n] += e;
        }
        return this;
    }
    scale(e) {
        if (e !== 1) {
            const t = this.times;
            for (let n = 0, r = t.length; n !== r; ++n) t[n] *= e;
        }
        return this;
    }
    trim(e, t) {
        const n = this.times,
            r = n.length;
        let s = 0,
            a = r - 1;
        for (; s !== r && n[s] < e; ) ++s;
        for (; a !== -1 && n[a] > t; ) --a;
        if ((++a, s !== 0 || a !== r)) {
            s >= a && ((a = Math.max(a, 1)), (s = a - 1));
            const l = this.getValueSize();
            (this.times = n.slice(s, a)),
                (this.values = this.values.slice(s * l, a * l));
        }
        return this;
    }
    validate() {
        let e = !0;
        const t = this.getValueSize();
        t - Math.floor(t) !== 0 &&
            (console.error(
                'THREE.KeyframeTrack: Invalid value size in track.',
                this
            ),
            (e = !1));
        const n = this.times,
            r = this.values,
            s = n.length;
        s === 0 &&
            (console.error('THREE.KeyframeTrack: Track is empty.', this),
            (e = !1));
        let a = null;
        for (let l = 0; l !== s; l++) {
            const c = n[l];
            if (typeof c == 'number' && isNaN(c)) {
                console.error(
                    'THREE.KeyframeTrack: Time is not a valid number.',
                    this,
                    l,
                    c
                ),
                    (e = !1);
                break;
            }
            if (a !== null && a > c) {
                console.error(
                    'THREE.KeyframeTrack: Out of order keys.',
                    this,
                    l,
                    c,
                    a
                ),
                    (e = !1);
                break;
            }
            a = c;
        }
        if (r !== void 0 && Db(r))
            for (let l = 0, c = r.length; l !== c; ++l) {
                const d = r[l];
                if (isNaN(d)) {
                    console.error(
                        'THREE.KeyframeTrack: Value is not a valid number.',
                        this,
                        l,
                        d
                    ),
                        (e = !1);
                    break;
                }
            }
        return e;
    }
    optimize() {
        const e = this.times.slice(),
            t = this.values.slice(),
            n = this.getValueSize(),
            r = this.getInterpolation() === oy,
            s = e.length - 1;
        let a = 1;
        for (let l = 1; l < s; ++l) {
            let c = !1;
            const d = e[l],
                p = e[l + 1];
            if (d !== p && (l !== 1 || d !== e[0]))
                if (r) c = !0;
                else {
                    const g = l * n,
                        y = g - n,
                        v = g + n;
                    for (let S = 0; S !== n; ++S) {
                        const T = t[g + S];
                        if (T !== t[y + S] || T !== t[v + S]) {
                            c = !0;
                            break;
                        }
                    }
                }
            if (c) {
                if (l !== a) {
                    e[a] = e[l];
                    const g = l * n,
                        y = a * n;
                    for (let v = 0; v !== n; ++v) t[y + v] = t[g + v];
                }
                ++a;
            }
        }
        if (s > 0) {
            e[a] = e[s];
            for (let l = s * n, c = a * n, d = 0; d !== n; ++d)
                t[c + d] = t[l + d];
            ++a;
        }
        return (
            a !== e.length
                ? ((this.times = e.slice(0, a)),
                  (this.values = t.slice(0, a * n)))
                : ((this.times = e), (this.values = t)),
            this
        );
    }
    clone() {
        const e = this.times.slice(),
            t = this.values.slice(),
            n = this.constructor,
            r = new n(this.name, e, t);
        return (r.createInterpolant = this.createInterpolant), r;
    }
}
ho.prototype.TimeBufferType = Float32Array;
ho.prototype.ValueBufferType = Float32Array;
ho.prototype.DefaultInterpolation = Wy;
class pc extends ho {
    constructor(e, t, n) {
        super(e, t, n);
    }
}
pc.prototype.ValueTypeName = 'bool';
pc.prototype.ValueBufferType = Array;
pc.prototype.DefaultInterpolation = wp;
pc.prototype.InterpolantFactoryMethodLinear = void 0;
pc.prototype.InterpolantFactoryMethodSmooth = void 0;
class lw extends ho {}
lw.prototype.ValueTypeName = 'color';
class Np extends ho {}
Np.prototype.ValueTypeName = 'number';
class kb extends im {
    constructor(e, t, n, r) {
        super(e, t, n, r);
    }
    interpolate_(e, t, n, r) {
        const s = this.resultBuffer,
            a = this.sampleValues,
            l = this.valueSize,
            c = (n - t) / (r - t);
        let d = e * l;
        for (let p = d + l; d !== p; d += 4)
            Hr.slerpFlat(s, 0, a, d - l, a, d, c);
        return s;
    }
}
class rm extends ho {
    InterpolantFactoryMethodLinear(e) {
        return new kb(this.times, this.values, this.getValueSize(), e);
    }
}
rm.prototype.ValueTypeName = 'quaternion';
rm.prototype.InterpolantFactoryMethodSmooth = void 0;
class mc extends ho {
    constructor(e, t, n) {
        super(e, t, n);
    }
}
mc.prototype.ValueTypeName = 'string';
mc.prototype.ValueBufferType = Array;
mc.prototype.DefaultInterpolation = wp;
mc.prototype.InterpolantFactoryMethodLinear = void 0;
mc.prototype.InterpolantFactoryMethodSmooth = void 0;
class Up extends ho {}
Up.prototype.ValueTypeName = 'vector';
class Op {
    constructor(e = '', t = -1, n = [], r = mv) {
        (this.name = e),
            (this.tracks = n),
            (this.duration = t),
            (this.blendMode = r),
            (this.uuid = os()),
            this.duration < 0 && this.resetDuration();
    }
    static parse(e) {
        const t = [],
            n = e.tracks,
            r = 1 / (e.fps || 1);
        for (let a = 0, l = n.length; a !== l; ++a) t.push(aH(n[a]).scale(r));
        const s = new this(e.name, e.duration, t, e.blendMode);
        return (s.uuid = e.uuid), s;
    }
    static toJSON(e) {
        const t = [],
            n = e.tracks,
            r = {
                name: e.name,
                duration: e.duration,
                tracks: t,
                uuid: e.uuid,
                blendMode: e.blendMode,
            };
        for (let s = 0, a = n.length; s !== a; ++s) t.push(ho.toJSON(n[s]));
        return r;
    }
    static CreateFromMorphTargetSequence(e, t, n, r) {
        const s = t.length,
            a = [];
        for (let l = 0; l < s; l++) {
            let c = [],
                d = [];
            c.push((l + s - 1) % s, l, (l + 1) % s), d.push(0, 1, 0);
            const p = Nb(c);
            (c = E_(c, 1, p)),
                (d = E_(d, 1, p)),
                !r && c[0] === 0 && (c.push(s), d.push(d[0])),
                a.push(
                    new Np(
                        '.morphTargetInfluences[' + t[l].name + ']',
                        c,
                        d
                    ).scale(1 / n)
                );
        }
        return new this(e, -1, a);
    }
    static findByName(e, t) {
        let n = e;
        if (!Array.isArray(e)) {
            const r = e;
            n = (r.geometry && r.geometry.animations) || r.animations;
        }
        for (let r = 0; r < n.length; r++) if (n[r].name === t) return n[r];
        return null;
    }
    static CreateClipsFromMorphTargetSequences(e, t, n) {
        const r = {},
            s = /^([\w-]*?)([\d]+)$/;
        for (let l = 0, c = e.length; l < c; l++) {
            const d = e[l],
                p = d.name.match(s);
            if (p && p.length > 1) {
                const g = p[1];
                let y = r[g];
                y || (r[g] = y = []), y.push(d);
            }
        }
        const a = [];
        for (const l in r)
            a.push(this.CreateFromMorphTargetSequence(l, r[l], t, n));
        return a;
    }
    static parseAnimation(e, t) {
        if (!e)
            return (
                console.error(
                    'THREE.AnimationClip: No animation in JSONLoader data.'
                ),
                null
            );
        const n = function (g, y, v, S, T) {
                if (v.length !== 0) {
                    const M = [],
                        w = [];
                    ow(v, M, w, S), M.length !== 0 && T.push(new g(y, M, w));
                }
            },
            r = [],
            s = e.name || 'default',
            a = e.fps || 30,
            l = e.blendMode;
        let c = e.length || -1;
        const d = e.hierarchy || [];
        for (let g = 0; g < d.length; g++) {
            const y = d[g].keys;
            if (!(!y || y.length === 0))
                if (y[0].morphTargets) {
                    const v = {};
                    let S;
                    for (S = 0; S < y.length; S++)
                        if (y[S].morphTargets)
                            for (let T = 0; T < y[S].morphTargets.length; T++)
                                v[y[S].morphTargets[T]] = -1;
                    for (const T in v) {
                        const M = [],
                            w = [];
                        for (let b = 0; b !== y[S].morphTargets.length; ++b) {
                            const C = y[S];
                            M.push(C.time), w.push(C.morphTarget === T ? 1 : 0);
                        }
                        r.push(
                            new Np('.morphTargetInfluence[' + T + ']', M, w)
                        );
                    }
                    c = v.length * a;
                } else {
                    const v = '.bones[' + t[g].name + ']';
                    n(Up, v + '.position', y, 'pos', r),
                        n(rm, v + '.quaternion', y, 'rot', r),
                        n(Up, v + '.scale', y, 'scl', r);
                }
        }
        return r.length === 0 ? null : new this(s, c, r, l);
    }
    resetDuration() {
        const e = this.tracks;
        let t = 0;
        for (let n = 0, r = e.length; n !== r; ++n) {
            const s = this.tracks[n];
            t = Math.max(t, s.times[s.times.length - 1]);
        }
        return (this.duration = t), this;
    }
    trim() {
        for (let e = 0; e < this.tracks.length; e++)
            this.tracks[e].trim(0, this.duration);
        return this;
    }
    validate() {
        let e = !0;
        for (let t = 0; t < this.tracks.length; t++)
            e = e && this.tracks[t].validate();
        return e;
    }
    optimize() {
        for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
        return this;
    }
    clone() {
        const e = [];
        for (let t = 0; t < this.tracks.length; t++)
            e.push(this.tracks[t].clone());
        return new this.constructor(
            this.name,
            this.duration,
            e,
            this.blendMode
        );
    }
    toJSON() {
        return this.constructor.toJSON(this);
    }
}
function oH(i) {
    switch (i.toLowerCase()) {
        case 'scalar':
        case 'double':
        case 'float':
        case 'number':
        case 'integer':
            return Np;
        case 'vector':
        case 'vector2':
        case 'vector3':
        case 'vector4':
            return Up;
        case 'color':
            return lw;
        case 'quaternion':
            return rm;
        case 'bool':
        case 'boolean':
            return pc;
        case 'string':
            return mc;
    }
    throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + i);
}
function aH(i) {
    if (i.type === void 0)
        throw new Error(
            'THREE.KeyframeTrack: track type undefined, can not parse'
        );
    const e = oH(i.type);
    if (i.times === void 0) {
        const t = [],
            n = [];
        ow(i.keys, t, n, 'value'), (i.times = t), (i.values = n);
    }
    return e.parse !== void 0
        ? e.parse(i)
        : new e(i.name, i.times, i.values, i.interpolation);
}
const Ra = {
    enabled: !1,
    files: {},
    add: function (i, e) {
        this.enabled !== !1 && (this.files[i] = e);
    },
    get: function (i) {
        if (this.enabled !== !1) return this.files[i];
    },
    remove: function (i) {
        delete this.files[i];
    },
    clear: function () {
        this.files = {};
    },
};
class uw {
    constructor(e, t, n) {
        const r = this;
        let s = !1,
            a = 0,
            l = 0,
            c;
        const d = [];
        (this.onStart = void 0),
            (this.onLoad = e),
            (this.onProgress = t),
            (this.onError = n),
            (this.itemStart = function (p) {
                l++,
                    s === !1 && r.onStart !== void 0 && r.onStart(p, a, l),
                    (s = !0);
            }),
            (this.itemEnd = function (p) {
                a++,
                    r.onProgress !== void 0 && r.onProgress(p, a, l),
                    a === l && ((s = !1), r.onLoad !== void 0 && r.onLoad());
            }),
            (this.itemError = function (p) {
                r.onError !== void 0 && r.onError(p);
            }),
            (this.resolveURL = function (p) {
                return c ? c(p) : p;
            }),
            (this.setURLModifier = function (p) {
                return (c = p), this;
            }),
            (this.addHandler = function (p, g) {
                return d.push(p, g), this;
            }),
            (this.removeHandler = function (p) {
                const g = d.indexOf(p);
                return g !== -1 && d.splice(g, 2), this;
            }),
            (this.getHandler = function (p) {
                for (let g = 0, y = d.length; g < y; g += 2) {
                    const v = d[g],
                        S = d[g + 1];
                    if ((v.global && (v.lastIndex = 0), v.test(p))) return S;
                }
                return null;
            });
    }
}
const Fb = new uw();
class Gr {
    constructor(e) {
        (this.manager = e !== void 0 ? e : Fb),
            (this.crossOrigin = 'anonymous'),
            (this.withCredentials = !1),
            (this.path = ''),
            (this.resourcePath = ''),
            (this.requestHeader = {});
    }
    load() {}
    loadAsync(e, t) {
        const n = this;
        return new Promise(function (r, s) {
            n.load(e, r, t, s);
        });
    }
    parse() {}
    setCrossOrigin(e) {
        return (this.crossOrigin = e), this;
    }
    setWithCredentials(e) {
        return (this.withCredentials = e), this;
    }
    setPath(e) {
        return (this.path = e), this;
    }
    setResourcePath(e) {
        return (this.resourcePath = e), this;
    }
    setRequestHeader(e) {
        return (this.requestHeader = e), this;
    }
}
Gr.DEFAULT_MATERIAL_NAME = '__DEFAULT';
const Ta = {};
class lH extends Error {
    constructor(e, t) {
        super(e), (this.response = t);
    }
}
class ka extends Gr {
    constructor(e) {
        super(e);
    }
    load(e, t, n, r) {
        e === void 0 && (e = ''),
            this.path !== void 0 && (e = this.path + e),
            (e = this.manager.resolveURL(e));
        const s = Ra.get(e);
        if (s !== void 0)
            return (
                this.manager.itemStart(e),
                setTimeout(() => {
                    t && t(s), this.manager.itemEnd(e);
                }, 0),
                s
            );
        if (Ta[e] !== void 0) {
            Ta[e].push({ onLoad: t, onProgress: n, onError: r });
            return;
        }
        (Ta[e] = []), Ta[e].push({ onLoad: t, onProgress: n, onError: r });
        const a = new Request(e, {
                headers: new Headers(this.requestHeader),
                credentials: this.withCredentials ? 'include' : 'same-origin',
            }),
            l = this.mimeType,
            c = this.responseType;
        fetch(a)
            .then((d) => {
                if (d.status === 200 || d.status === 0) {
                    if (
                        (d.status === 0 &&
                            console.warn(
                                'THREE.FileLoader: HTTP Status 0 received.'
                            ),
                        typeof ReadableStream > 'u' ||
                            d.body === void 0 ||
                            d.body.getReader === void 0)
                    )
                        return d;
                    const p = Ta[e],
                        g = d.body.getReader(),
                        y =
                            d.headers.get('X-File-Size') ||
                            d.headers.get('Content-Length'),
                        v = y ? parseInt(y) : 0,
                        S = v !== 0;
                    let T = 0;
                    const M = new ReadableStream({
                        start(w) {
                            b();
                            function b() {
                                g.read().then(
                                    ({ done: C, value: L }) => {
                                        if (C) w.close();
                                        else {
                                            T += L.byteLength;
                                            const F = new ProgressEvent(
                                                'progress',
                                                {
                                                    lengthComputable: S,
                                                    loaded: T,
                                                    total: v,
                                                }
                                            );
                                            for (
                                                let N = 0, B = p.length;
                                                N < B;
                                                N++
                                            ) {
                                                const z = p[N];
                                                z.onProgress && z.onProgress(F);
                                            }
                                            w.enqueue(L), b();
                                        }
                                    },
                                    (C) => {
                                        w.error(C);
                                    }
                                );
                            }
                        },
                    });
                    return new Response(M);
                } else
                    throw new lH(
                        `fetch for "${d.url}" responded with ${d.status}: ${d.statusText}`,
                        d
                    );
            })
            .then((d) => {
                switch (c) {
                    case 'arraybuffer':
                        return d.arrayBuffer();
                    case 'blob':
                        return d.blob();
                    case 'document':
                        return d
                            .text()
                            .then((p) => new DOMParser().parseFromString(p, l));
                    case 'json':
                        return d.json();
                    default:
                        if (l === void 0) return d.text();
                        {
                            const g = /charset="?([^;"\s]*)"?/i.exec(l),
                                y = g && g[1] ? g[1].toLowerCase() : void 0,
                                v = new TextDecoder(y);
                            return d.arrayBuffer().then((S) => v.decode(S));
                        }
                }
            })
            .then((d) => {
                Ra.add(e, d);
                const p = Ta[e];
                delete Ta[e];
                for (let g = 0, y = p.length; g < y; g++) {
                    const v = p[g];
                    v.onLoad && v.onLoad(d);
                }
            })
            .catch((d) => {
                const p = Ta[e];
                if (p === void 0) throw (this.manager.itemError(e), d);
                delete Ta[e];
                for (let g = 0, y = p.length; g < y; g++) {
                    const v = p[g];
                    v.onError && v.onError(d);
                }
                this.manager.itemError(e);
            })
            .finally(() => {
                this.manager.itemEnd(e);
            }),
            this.manager.itemStart(e);
    }
    setResponseType(e) {
        return (this.responseType = e), this;
    }
    setMimeType(e) {
        return (this.mimeType = e), this;
    }
}
class uH extends Gr {
    constructor(e) {
        super(e);
    }
    load(e, t, n, r) {
        const s = this,
            a = new ka(this.manager);
        a.setPath(this.path),
            a.setRequestHeader(this.requestHeader),
            a.setWithCredentials(this.withCredentials),
            a.load(
                e,
                function (l) {
                    try {
                        t(s.parse(JSON.parse(l)));
                    } catch (c) {
                        r ? r(c) : console.error(c), s.manager.itemError(e);
                    }
                },
                n,
                r
            );
    }
    parse(e) {
        const t = [];
        for (let n = 0; n < e.length; n++) {
            const r = Op.parse(e[n]);
            t.push(r);
        }
        return t;
    }
}
class cH extends Gr {
    constructor(e) {
        super(e);
    }
    load(e, t, n, r) {
        const s = this,
            a = [],
            l = new Mv(),
            c = new ka(this.manager);
        c.setPath(this.path),
            c.setResponseType('arraybuffer'),
            c.setRequestHeader(this.requestHeader),
            c.setWithCredentials(s.withCredentials);
        let d = 0;
        function p(g) {
            c.load(
                e[g],
                function (y) {
                    const v = s.parse(y, !0);
                    (a[g] = {
                        width: v.width,
                        height: v.height,
                        format: v.format,
                        mipmaps: v.mipmaps,
                    }),
                        (d += 1),
                        d === 6 &&
                            (v.mipmapCount === 1 && (l.minFilter = hi),
                            (l.image = a),
                            (l.format = v.format),
                            (l.needsUpdate = !0),
                            t && t(l));
                },
                n,
                r
            );
        }
        if (Array.isArray(e)) for (let g = 0, y = e.length; g < y; ++g) p(g);
        else
            c.load(
                e,
                function (g) {
                    const y = s.parse(g, !0);
                    if (y.isCubemap) {
                        const v = y.mipmaps.length / y.mipmapCount;
                        for (let S = 0; S < v; S++) {
                            a[S] = { mipmaps: [] };
                            for (let T = 0; T < y.mipmapCount; T++)
                                a[S].mipmaps.push(
                                    y.mipmaps[S * y.mipmapCount + T]
                                ),
                                    (a[S].format = y.format),
                                    (a[S].width = y.width),
                                    (a[S].height = y.height);
                        }
                        l.image = a;
                    } else
                        (l.image.width = y.width),
                            (l.image.height = y.height),
                            (l.mipmaps = y.mipmaps);
                    y.mipmapCount === 1 && (l.minFilter = hi),
                        (l.format = y.format),
                        (l.needsUpdate = !0),
                        t && t(l);
                },
                n,
                r
            );
        return l;
    }
}
class kp extends Gr {
    constructor(e) {
        super(e);
    }
    load(e, t, n, r) {
        this.path !== void 0 && (e = this.path + e),
            (e = this.manager.resolveURL(e));
        const s = this,
            a = Ra.get(e);
        if (a !== void 0)
            return (
                s.manager.itemStart(e),
                setTimeout(function () {
                    t && t(a), s.manager.itemEnd(e);
                }, 0),
                a
            );
        const l = bp('img');
        function c() {
            p(), Ra.add(e, this), t && t(this), s.manager.itemEnd(e);
        }
        function d(g) {
            p(), r && r(g), s.manager.itemError(e), s.manager.itemEnd(e);
        }
        function p() {
            l.removeEventListener('load', c, !1),
                l.removeEventListener('error', d, !1);
        }
        return (
            l.addEventListener('load', c, !1),
            l.addEventListener('error', d, !1),
            e.slice(0, 5) !== 'data:' &&
                this.crossOrigin !== void 0 &&
                (l.crossOrigin = this.crossOrigin),
            s.manager.itemStart(e),
            (l.src = e),
            l
        );
    }
}
class fH extends Gr {
    constructor(e) {
        super(e);
    }
    load(e, t, n, r) {
        const s = new Zp();
        s.colorSpace = ws;
        const a = new kp(this.manager);
        a.setCrossOrigin(this.crossOrigin), a.setPath(this.path);
        let l = 0;
        function c(d) {
            a.load(
                e[d],
                function (p) {
                    (s.images[d] = p),
                        l++,
                        l === 6 && ((s.needsUpdate = !0), t && t(s));
                },
                void 0,
                r
            );
        }
        for (let d = 0; d < e.length; ++d) c(d);
        return s;
    }
}
class hH extends Gr {
    constructor(e) {
        super(e);
    }
    load(e, t, n, r) {
        const s = this,
            a = new Bo(),
            l = new ka(this.manager);
        return (
            l.setResponseType('arraybuffer'),
            l.setRequestHeader(this.requestHeader),
            l.setPath(this.path),
            l.setWithCredentials(s.withCredentials),
            l.load(
                e,
                function (c) {
                    let d;
                    try {
                        d = s.parse(c);
                    } catch (p) {
                        if (r !== void 0) r(p);
                        else {
                            console.error(p);
                            return;
                        }
                    }
                    d.image !== void 0
                        ? (a.image = d.image)
                        : d.data !== void 0 &&
                          ((a.image.width = d.width),
                          (a.image.height = d.height),
                          (a.image.data = d.data)),
                        (a.wrapS = d.wrapS !== void 0 ? d.wrapS : Ms),
                        (a.wrapT = d.wrapT !== void 0 ? d.wrapT : Ms),
                        (a.magFilter =
                            d.magFilter !== void 0 ? d.magFilter : hi),
                        (a.minFilter =
                            d.minFilter !== void 0 ? d.minFilter : hi),
                        (a.anisotropy =
                            d.anisotropy !== void 0 ? d.anisotropy : 1),
                        d.colorSpace !== void 0 &&
                            (a.colorSpace = d.colorSpace),
                        d.flipY !== void 0 && (a.flipY = d.flipY),
                        d.format !== void 0 && (a.format = d.format),
                        d.type !== void 0 && (a.type = d.type),
                        d.mipmaps !== void 0 &&
                            ((a.mipmaps = d.mipmaps), (a.minFilter = Io)),
                        d.mipmapCount === 1 && (a.minFilter = hi),
                        d.generateMipmaps !== void 0 &&
                            (a.generateMipmaps = d.generateMipmaps),
                        (a.needsUpdate = !0),
                        t && t(a, d);
                },
                n,
                r
            ),
            a
        );
    }
}
class dH extends Gr {
    constructor(e) {
        super(e);
    }
    load(e, t, n, r) {
        const s = new Qn(),
            a = new kp(this.manager);
        return (
            a.setCrossOrigin(this.crossOrigin),
            a.setPath(this.path),
            a.load(
                e,
                function (l) {
                    (s.image = l), (s.needsUpdate = !0), t !== void 0 && t(s);
                },
                n,
                r
            ),
            s
        );
    }
}
class Hl extends ln {
    constructor(e, t = 1) {
        super(),
            (this.isLight = !0),
            (this.type = 'Light'),
            (this.color = new st(e)),
            (this.intensity = t);
    }
    dispose() {}
    copy(e, t) {
        return (
            super.copy(e, t),
            this.color.copy(e.color),
            (this.intensity = e.intensity),
            this
        );
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return (
            (t.object.color = this.color.getHex()),
            (t.object.intensity = this.intensity),
            this.groundColor !== void 0 &&
                (t.object.groundColor = this.groundColor.getHex()),
            this.distance !== void 0 && (t.object.distance = this.distance),
            this.angle !== void 0 && (t.object.angle = this.angle),
            this.decay !== void 0 && (t.object.decay = this.decay),
            this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
            this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
            this.target !== void 0 && (t.object.target = this.target.uuid),
            t
        );
    }
}
class Bb extends Hl {
    constructor(e, t, n) {
        super(e, n),
            (this.isHemisphereLight = !0),
            (this.type = 'HemisphereLight'),
            this.position.copy(ln.DEFAULT_UP),
            this.updateMatrix(),
            (this.groundColor = new st(t));
    }
    copy(e, t) {
        return super.copy(e, t), this.groundColor.copy(e.groundColor), this;
    }
}
const wx = new Pt(),
    VE = new j(),
    HE = new j();
class cw {
    constructor(e) {
        (this.camera = e),
            (this.intensity = 1),
            (this.bias = 0),
            (this.normalBias = 0),
            (this.radius = 1),
            (this.blurSamples = 8),
            (this.mapSize = new Ce(512, 512)),
            (this.map = null),
            (this.mapPass = null),
            (this.matrix = new Pt()),
            (this.autoUpdate = !0),
            (this.needsUpdate = !1),
            (this._frustum = new Jp()),
            (this._frameExtents = new Ce(1, 1)),
            (this._viewportCount = 1),
            (this._viewports = [new gn(0, 0, 1, 1)]);
    }
    getViewportCount() {
        return this._viewportCount;
    }
    getFrustum() {
        return this._frustum;
    }
    updateMatrices(e) {
        const t = this.camera,
            n = this.matrix;
        VE.setFromMatrixPosition(e.matrixWorld),
            t.position.copy(VE),
            HE.setFromMatrixPosition(e.target.matrixWorld),
            t.lookAt(HE),
            t.updateMatrixWorld(),
            wx.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
            this._frustum.setFromProjectionMatrix(wx),
            n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
            n.multiply(wx);
    }
    getViewport(e) {
        return this._viewports[e];
    }
    getFrameExtents() {
        return this._frameExtents;
    }
    dispose() {
        this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
    }
    copy(e) {
        return (
            (this.camera = e.camera.clone()),
            (this.intensity = e.intensity),
            (this.bias = e.bias),
            (this.radius = e.radius),
            this.mapSize.copy(e.mapSize),
            this
        );
    }
    clone() {
        return new this.constructor().copy(this);
    }
    toJSON() {
        const e = {};
        return (
            this.intensity !== 1 && (e.intensity = this.intensity),
            this.bias !== 0 && (e.bias = this.bias),
            this.normalBias !== 0 && (e.normalBias = this.normalBias),
            this.radius !== 1 && (e.radius = this.radius),
            (this.mapSize.x !== 512 || this.mapSize.y !== 512) &&
                (e.mapSize = this.mapSize.toArray()),
            (e.camera = this.camera.toJSON(!1).object),
            delete e.camera.matrix,
            e
        );
    }
}
class pH extends cw {
    constructor() {
        super(new Pi(50, 1, 0.5, 500)),
            (this.isSpotLightShadow = !0),
            (this.focus = 1);
    }
    updateMatrices(e) {
        const t = this.camera,
            n = fh * 2 * e.angle * this.focus,
            r = this.mapSize.width / this.mapSize.height,
            s = e.distance || t.far;
        (n !== t.fov || r !== t.aspect || s !== t.far) &&
            ((t.fov = n),
            (t.aspect = r),
            (t.far = s),
            t.updateProjectionMatrix()),
            super.updateMatrices(e);
    }
    copy(e) {
        return super.copy(e), (this.focus = e.focus), this;
    }
}
class zb extends Hl {
    constructor(e, t, n = 0, r = Math.PI / 3, s = 0, a = 2) {
        super(e, t),
            (this.isSpotLight = !0),
            (this.type = 'SpotLight'),
            this.position.copy(ln.DEFAULT_UP),
            this.updateMatrix(),
            (this.target = new ln()),
            (this.distance = n),
            (this.angle = r),
            (this.penumbra = s),
            (this.decay = a),
            (this.map = null),
            (this.shadow = new pH());
    }
    get power() {
        return this.intensity * Math.PI;
    }
    set power(e) {
        this.intensity = e / Math.PI;
    }
    dispose() {
        this.shadow.dispose();
    }
    copy(e, t) {
        return (
            super.copy(e, t),
            (this.distance = e.distance),
            (this.angle = e.angle),
            (this.penumbra = e.penumbra),
            (this.decay = e.decay),
            (this.target = e.target.clone()),
            (this.shadow = e.shadow.clone()),
            this
        );
    }
}
const GE = new Pt(),
    Fd = new j(),
    Mx = new j();
class mH extends cw {
    constructor() {
        super(new Pi(90, 1, 0.5, 500)),
            (this.isPointLightShadow = !0),
            (this._frameExtents = new Ce(4, 2)),
            (this._viewportCount = 6),
            (this._viewports = [
                new gn(2, 1, 1, 1),
                new gn(0, 1, 1, 1),
                new gn(3, 1, 1, 1),
                new gn(1, 1, 1, 1),
                new gn(3, 0, 1, 1),
                new gn(1, 0, 1, 1),
            ]),
            (this._cubeDirections = [
                new j(1, 0, 0),
                new j(-1, 0, 0),
                new j(0, 0, 1),
                new j(0, 0, -1),
                new j(0, 1, 0),
                new j(0, -1, 0),
            ]),
            (this._cubeUps = [
                new j(0, 1, 0),
                new j(0, 1, 0),
                new j(0, 1, 0),
                new j(0, 1, 0),
                new j(0, 0, 1),
                new j(0, 0, -1),
            ]);
    }
    updateMatrices(e, t = 0) {
        const n = this.camera,
            r = this.matrix,
            s = e.distance || n.far;
        s !== n.far && ((n.far = s), n.updateProjectionMatrix()),
            Fd.setFromMatrixPosition(e.matrixWorld),
            n.position.copy(Fd),
            Mx.copy(n.position),
            Mx.add(this._cubeDirections[t]),
            n.up.copy(this._cubeUps[t]),
            n.lookAt(Mx),
            n.updateMatrixWorld(),
            r.makeTranslation(-Fd.x, -Fd.y, -Fd.z),
            GE.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
            this._frustum.setFromProjectionMatrix(GE);
    }
}
class Vb extends Hl {
    constructor(e, t, n = 0, r = 2) {
        super(e, t),
            (this.isPointLight = !0),
            (this.type = 'PointLight'),
            (this.distance = n),
            (this.decay = r),
            (this.shadow = new mH());
    }
    get power() {
        return this.intensity * 4 * Math.PI;
    }
    set power(e) {
        this.intensity = e / (4 * Math.PI);
    }
    dispose() {
        this.shadow.dispose();
    }
    copy(e, t) {
        return (
            super.copy(e, t),
            (this.distance = e.distance),
            (this.decay = e.decay),
            (this.shadow = e.shadow.clone()),
            this
        );
    }
}
class gH extends cw {
    constructor() {
        super(new Qp(-5, 5, 5, -5, 0.5, 500)),
            (this.isDirectionalLightShadow = !0);
    }
}
class Hb extends Hl {
    constructor(e, t) {
        super(e, t),
            (this.isDirectionalLight = !0),
            (this.type = 'DirectionalLight'),
            this.position.copy(ln.DEFAULT_UP),
            this.updateMatrix(),
            (this.target = new ln()),
            (this.shadow = new gH());
    }
    dispose() {
        this.shadow.dispose();
    }
    copy(e) {
        return (
            super.copy(e),
            (this.target = e.target.clone()),
            (this.shadow = e.shadow.clone()),
            this
        );
    }
}
class Gb extends Hl {
    constructor(e, t) {
        super(e, t), (this.isAmbientLight = !0), (this.type = 'AmbientLight');
    }
}
class Wb extends Hl {
    constructor(e, t, n = 10, r = 10) {
        super(e, t),
            (this.isRectAreaLight = !0),
            (this.type = 'RectAreaLight'),
            (this.width = n),
            (this.height = r);
    }
    get power() {
        return this.intensity * this.width * this.height * Math.PI;
    }
    set power(e) {
        this.intensity = e / (this.width * this.height * Math.PI);
    }
    copy(e) {
        return (
            super.copy(e),
            (this.width = e.width),
            (this.height = e.height),
            this
        );
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return (
            (t.object.width = this.width), (t.object.height = this.height), t
        );
    }
}
class Xb {
    constructor() {
        (this.isSphericalHarmonics3 = !0), (this.coefficients = []);
        for (let e = 0; e < 9; e++) this.coefficients.push(new j());
    }
    set(e) {
        for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
        return this;
    }
    zero() {
        for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
        return this;
    }
    getAt(e, t) {
        const n = e.x,
            r = e.y,
            s = e.z,
            a = this.coefficients;
        return (
            t.copy(a[0]).multiplyScalar(0.282095),
            t.addScaledVector(a[1], 0.488603 * r),
            t.addScaledVector(a[2], 0.488603 * s),
            t.addScaledVector(a[3], 0.488603 * n),
            t.addScaledVector(a[4], 1.092548 * (n * r)),
            t.addScaledVector(a[5], 1.092548 * (r * s)),
            t.addScaledVector(a[6], 0.315392 * (3 * s * s - 1)),
            t.addScaledVector(a[7], 1.092548 * (n * s)),
            t.addScaledVector(a[8], 0.546274 * (n * n - r * r)),
            t
        );
    }
    getIrradianceAt(e, t) {
        const n = e.x,
            r = e.y,
            s = e.z,
            a = this.coefficients;
        return (
            t.copy(a[0]).multiplyScalar(0.886227),
            t.addScaledVector(a[1], 2 * 0.511664 * r),
            t.addScaledVector(a[2], 2 * 0.511664 * s),
            t.addScaledVector(a[3], 2 * 0.511664 * n),
            t.addScaledVector(a[4], 2 * 0.429043 * n * r),
            t.addScaledVector(a[5], 2 * 0.429043 * r * s),
            t.addScaledVector(a[6], 0.743125 * s * s - 0.247708),
            t.addScaledVector(a[7], 2 * 0.429043 * n * s),
            t.addScaledVector(a[8], 0.429043 * (n * n - r * r)),
            t
        );
    }
    add(e) {
        for (let t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
        return this;
    }
    addScaledSH(e, t) {
        for (let n = 0; n < 9; n++)
            this.coefficients[n].addScaledVector(e.coefficients[n], t);
        return this;
    }
    scale(e) {
        for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
        return this;
    }
    lerp(e, t) {
        for (let n = 0; n < 9; n++)
            this.coefficients[n].lerp(e.coefficients[n], t);
        return this;
    }
    equals(e) {
        for (let t = 0; t < 9; t++)
            if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
        return !0;
    }
    copy(e) {
        return this.set(e.coefficients);
    }
    clone() {
        return new this.constructor().copy(this);
    }
    fromArray(e, t = 0) {
        const n = this.coefficients;
        for (let r = 0; r < 9; r++) n[r].fromArray(e, t + r * 3);
        return this;
    }
    toArray(e = [], t = 0) {
        const n = this.coefficients;
        for (let r = 0; r < 9; r++) n[r].toArray(e, t + r * 3);
        return e;
    }
    static getBasisAt(e, t) {
        const n = e.x,
            r = e.y,
            s = e.z;
        (t[0] = 0.282095),
            (t[1] = 0.488603 * r),
            (t[2] = 0.488603 * s),
            (t[3] = 0.488603 * n),
            (t[4] = 1.092548 * n * r),
            (t[5] = 1.092548 * r * s),
            (t[6] = 0.315392 * (3 * s * s - 1)),
            (t[7] = 1.092548 * n * s),
            (t[8] = 0.546274 * (n * n - r * r));
    }
}
class jb extends Hl {
    constructor(e = new Xb(), t = 1) {
        super(void 0, t), (this.isLightProbe = !0), (this.sh = e);
    }
    copy(e) {
        return super.copy(e), this.sh.copy(e.sh), this;
    }
    fromJSON(e) {
        return (this.intensity = e.intensity), this.sh.fromArray(e.sh), this;
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return (t.object.sh = this.sh.toArray()), t;
    }
}
class Fv extends Gr {
    constructor(e) {
        super(e), (this.textures = {});
    }
    load(e, t, n, r) {
        const s = this,
            a = new ka(s.manager);
        a.setPath(s.path),
            a.setRequestHeader(s.requestHeader),
            a.setWithCredentials(s.withCredentials),
            a.load(
                e,
                function (l) {
                    try {
                        t(s.parse(JSON.parse(l)));
                    } catch (c) {
                        r ? r(c) : console.error(c), s.manager.itemError(e);
                    }
                },
                n,
                r
            );
    }
    parse(e) {
        const t = this.textures;
        function n(s) {
            return (
                t[s] === void 0 &&
                    console.warn('THREE.MaterialLoader: Undefined texture', s),
                t[s]
            );
        }
        const r = Fv.createMaterialFromType(e.type);
        if (
            (e.uuid !== void 0 && (r.uuid = e.uuid),
            e.name !== void 0 && (r.name = e.name),
            e.color !== void 0 && r.color !== void 0 && r.color.setHex(e.color),
            e.roughness !== void 0 && (r.roughness = e.roughness),
            e.metalness !== void 0 && (r.metalness = e.metalness),
            e.sheen !== void 0 && (r.sheen = e.sheen),
            e.sheenColor !== void 0 &&
                (r.sheenColor = new st().setHex(e.sheenColor)),
            e.sheenRoughness !== void 0 &&
                (r.sheenRoughness = e.sheenRoughness),
            e.emissive !== void 0 &&
                r.emissive !== void 0 &&
                r.emissive.setHex(e.emissive),
            e.specular !== void 0 &&
                r.specular !== void 0 &&
                r.specular.setHex(e.specular),
            e.specularIntensity !== void 0 &&
                (r.specularIntensity = e.specularIntensity),
            e.specularColor !== void 0 &&
                r.specularColor !== void 0 &&
                r.specularColor.setHex(e.specularColor),
            e.shininess !== void 0 && (r.shininess = e.shininess),
            e.clearcoat !== void 0 && (r.clearcoat = e.clearcoat),
            e.clearcoatRoughness !== void 0 &&
                (r.clearcoatRoughness = e.clearcoatRoughness),
            e.dispersion !== void 0 && (r.dispersion = e.dispersion),
            e.iridescence !== void 0 && (r.iridescence = e.iridescence),
            e.iridescenceIOR !== void 0 &&
                (r.iridescenceIOR = e.iridescenceIOR),
            e.iridescenceThicknessRange !== void 0 &&
                (r.iridescenceThicknessRange = e.iridescenceThicknessRange),
            e.transmission !== void 0 && (r.transmission = e.transmission),
            e.thickness !== void 0 && (r.thickness = e.thickness),
            e.attenuationDistance !== void 0 &&
                (r.attenuationDistance = e.attenuationDistance),
            e.attenuationColor !== void 0 &&
                r.attenuationColor !== void 0 &&
                r.attenuationColor.setHex(e.attenuationColor),
            e.anisotropy !== void 0 && (r.anisotropy = e.anisotropy),
            e.anisotropyRotation !== void 0 &&
                (r.anisotropyRotation = e.anisotropyRotation),
            e.fog !== void 0 && (r.fog = e.fog),
            e.flatShading !== void 0 && (r.flatShading = e.flatShading),
            e.blending !== void 0 && (r.blending = e.blending),
            e.combine !== void 0 && (r.combine = e.combine),
            e.side !== void 0 && (r.side = e.side),
            e.shadowSide !== void 0 && (r.shadowSide = e.shadowSide),
            e.opacity !== void 0 && (r.opacity = e.opacity),
            e.transparent !== void 0 && (r.transparent = e.transparent),
            e.alphaTest !== void 0 && (r.alphaTest = e.alphaTest),
            e.alphaHash !== void 0 && (r.alphaHash = e.alphaHash),
            e.depthFunc !== void 0 && (r.depthFunc = e.depthFunc),
            e.depthTest !== void 0 && (r.depthTest = e.depthTest),
            e.depthWrite !== void 0 && (r.depthWrite = e.depthWrite),
            e.colorWrite !== void 0 && (r.colorWrite = e.colorWrite),
            e.blendSrc !== void 0 && (r.blendSrc = e.blendSrc),
            e.blendDst !== void 0 && (r.blendDst = e.blendDst),
            e.blendEquation !== void 0 && (r.blendEquation = e.blendEquation),
            e.blendSrcAlpha !== void 0 && (r.blendSrcAlpha = e.blendSrcAlpha),
            e.blendDstAlpha !== void 0 && (r.blendDstAlpha = e.blendDstAlpha),
            e.blendEquationAlpha !== void 0 &&
                (r.blendEquationAlpha = e.blendEquationAlpha),
            e.blendColor !== void 0 &&
                r.blendColor !== void 0 &&
                r.blendColor.setHex(e.blendColor),
            e.blendAlpha !== void 0 && (r.blendAlpha = e.blendAlpha),
            e.stencilWriteMask !== void 0 &&
                (r.stencilWriteMask = e.stencilWriteMask),
            e.stencilFunc !== void 0 && (r.stencilFunc = e.stencilFunc),
            e.stencilRef !== void 0 && (r.stencilRef = e.stencilRef),
            e.stencilFuncMask !== void 0 &&
                (r.stencilFuncMask = e.stencilFuncMask),
            e.stencilFail !== void 0 && (r.stencilFail = e.stencilFail),
            e.stencilZFail !== void 0 && (r.stencilZFail = e.stencilZFail),
            e.stencilZPass !== void 0 && (r.stencilZPass = e.stencilZPass),
            e.stencilWrite !== void 0 && (r.stencilWrite = e.stencilWrite),
            e.wireframe !== void 0 && (r.wireframe = e.wireframe),
            e.wireframeLinewidth !== void 0 &&
                (r.wireframeLinewidth = e.wireframeLinewidth),
            e.wireframeLinecap !== void 0 &&
                (r.wireframeLinecap = e.wireframeLinecap),
            e.wireframeLinejoin !== void 0 &&
                (r.wireframeLinejoin = e.wireframeLinejoin),
            e.rotation !== void 0 && (r.rotation = e.rotation),
            e.linewidth !== void 0 && (r.linewidth = e.linewidth),
            e.dashSize !== void 0 && (r.dashSize = e.dashSize),
            e.gapSize !== void 0 && (r.gapSize = e.gapSize),
            e.scale !== void 0 && (r.scale = e.scale),
            e.polygonOffset !== void 0 && (r.polygonOffset = e.polygonOffset),
            e.polygonOffsetFactor !== void 0 &&
                (r.polygonOffsetFactor = e.polygonOffsetFactor),
            e.polygonOffsetUnits !== void 0 &&
                (r.polygonOffsetUnits = e.polygonOffsetUnits),
            e.dithering !== void 0 && (r.dithering = e.dithering),
            e.alphaToCoverage !== void 0 &&
                (r.alphaToCoverage = e.alphaToCoverage),
            e.premultipliedAlpha !== void 0 &&
                (r.premultipliedAlpha = e.premultipliedAlpha),
            e.forceSinglePass !== void 0 &&
                (r.forceSinglePass = e.forceSinglePass),
            e.visible !== void 0 && (r.visible = e.visible),
            e.toneMapped !== void 0 && (r.toneMapped = e.toneMapped),
            e.userData !== void 0 && (r.userData = e.userData),
            e.vertexColors !== void 0 &&
                (typeof e.vertexColors == 'number'
                    ? (r.vertexColors = e.vertexColors > 0)
                    : (r.vertexColors = e.vertexColors)),
            e.uniforms !== void 0)
        )
            for (const s in e.uniforms) {
                const a = e.uniforms[s];
                switch (((r.uniforms[s] = {}), a.type)) {
                    case 't':
                        r.uniforms[s].value = n(a.value);
                        break;
                    case 'c':
                        r.uniforms[s].value = new st().setHex(a.value);
                        break;
                    case 'v2':
                        r.uniforms[s].value = new Ce().fromArray(a.value);
                        break;
                    case 'v3':
                        r.uniforms[s].value = new j().fromArray(a.value);
                        break;
                    case 'v4':
                        r.uniforms[s].value = new gn().fromArray(a.value);
                        break;
                    case 'm3':
                        r.uniforms[s].value = new Wt().fromArray(a.value);
                        break;
                    case 'm4':
                        r.uniforms[s].value = new Pt().fromArray(a.value);
                        break;
                    default:
                        r.uniforms[s].value = a.value;
                }
            }
        if (
            (e.defines !== void 0 && (r.defines = e.defines),
            e.vertexShader !== void 0 && (r.vertexShader = e.vertexShader),
            e.fragmentShader !== void 0 &&
                (r.fragmentShader = e.fragmentShader),
            e.glslVersion !== void 0 && (r.glslVersion = e.glslVersion),
            e.extensions !== void 0)
        )
            for (const s in e.extensions) r.extensions[s] = e.extensions[s];
        if (
            (e.lights !== void 0 && (r.lights = e.lights),
            e.clipping !== void 0 && (r.clipping = e.clipping),
            e.size !== void 0 && (r.size = e.size),
            e.sizeAttenuation !== void 0 &&
                (r.sizeAttenuation = e.sizeAttenuation),
            e.map !== void 0 && (r.map = n(e.map)),
            e.matcap !== void 0 && (r.matcap = n(e.matcap)),
            e.alphaMap !== void 0 && (r.alphaMap = n(e.alphaMap)),
            e.bumpMap !== void 0 && (r.bumpMap = n(e.bumpMap)),
            e.bumpScale !== void 0 && (r.bumpScale = e.bumpScale),
            e.normalMap !== void 0 && (r.normalMap = n(e.normalMap)),
            e.normalMapType !== void 0 && (r.normalMapType = e.normalMapType),
            e.normalScale !== void 0)
        ) {
            let s = e.normalScale;
            Array.isArray(s) === !1 && (s = [s, s]),
                (r.normalScale = new Ce().fromArray(s));
        }
        return (
            e.displacementMap !== void 0 &&
                (r.displacementMap = n(e.displacementMap)),
            e.displacementScale !== void 0 &&
                (r.displacementScale = e.displacementScale),
            e.displacementBias !== void 0 &&
                (r.displacementBias = e.displacementBias),
            e.roughnessMap !== void 0 && (r.roughnessMap = n(e.roughnessMap)),
            e.metalnessMap !== void 0 && (r.metalnessMap = n(e.metalnessMap)),
            e.emissiveMap !== void 0 && (r.emissiveMap = n(e.emissiveMap)),
            e.emissiveIntensity !== void 0 &&
                (r.emissiveIntensity = e.emissiveIntensity),
            e.specularMap !== void 0 && (r.specularMap = n(e.specularMap)),
            e.specularIntensityMap !== void 0 &&
                (r.specularIntensityMap = n(e.specularIntensityMap)),
            e.specularColorMap !== void 0 &&
                (r.specularColorMap = n(e.specularColorMap)),
            e.envMap !== void 0 && (r.envMap = n(e.envMap)),
            e.envMapRotation !== void 0 &&
                r.envMapRotation.fromArray(e.envMapRotation),
            e.envMapIntensity !== void 0 &&
                (r.envMapIntensity = e.envMapIntensity),
            e.reflectivity !== void 0 && (r.reflectivity = e.reflectivity),
            e.refractionRatio !== void 0 &&
                (r.refractionRatio = e.refractionRatio),
            e.lightMap !== void 0 && (r.lightMap = n(e.lightMap)),
            e.lightMapIntensity !== void 0 &&
                (r.lightMapIntensity = e.lightMapIntensity),
            e.aoMap !== void 0 && (r.aoMap = n(e.aoMap)),
            e.aoMapIntensity !== void 0 &&
                (r.aoMapIntensity = e.aoMapIntensity),
            e.gradientMap !== void 0 && (r.gradientMap = n(e.gradientMap)),
            e.clearcoatMap !== void 0 && (r.clearcoatMap = n(e.clearcoatMap)),
            e.clearcoatRoughnessMap !== void 0 &&
                (r.clearcoatRoughnessMap = n(e.clearcoatRoughnessMap)),
            e.clearcoatNormalMap !== void 0 &&
                (r.clearcoatNormalMap = n(e.clearcoatNormalMap)),
            e.clearcoatNormalScale !== void 0 &&
                (r.clearcoatNormalScale = new Ce().fromArray(
                    e.clearcoatNormalScale
                )),
            e.iridescenceMap !== void 0 &&
                (r.iridescenceMap = n(e.iridescenceMap)),
            e.iridescenceThicknessMap !== void 0 &&
                (r.iridescenceThicknessMap = n(e.iridescenceThicknessMap)),
            e.transmissionMap !== void 0 &&
                (r.transmissionMap = n(e.transmissionMap)),
            e.thicknessMap !== void 0 && (r.thicknessMap = n(e.thicknessMap)),
            e.anisotropyMap !== void 0 &&
                (r.anisotropyMap = n(e.anisotropyMap)),
            e.sheenColorMap !== void 0 &&
                (r.sheenColorMap = n(e.sheenColorMap)),
            e.sheenRoughnessMap !== void 0 &&
                (r.sheenRoughnessMap = n(e.sheenRoughnessMap)),
            r
        );
    }
    setTextures(e) {
        return (this.textures = e), this;
    }
    static createMaterialFromType(e) {
        const t = {
            ShadowMaterial: Eb,
            SpriteMaterial: KS,
            RawShaderMaterial: Tb,
            ShaderMaterial: Ts,
            PointsMaterial: JS,
            MeshPhysicalMaterial: Ab,
            MeshStandardMaterial: sw,
            MeshPhongMaterial: Cb,
            MeshToonMaterial: Rb,
            MeshNormalMaterial: bb,
            MeshLambertMaterial: Pb,
            MeshDepthMaterial: qS,
            MeshDistanceMaterial: $S,
            MeshBasicMaterial: zl,
            MeshMatcapMaterial: Lb,
            LineDashedMaterial: Ib,
            LineBasicMaterial: Ar,
            Material: lr,
        };
        return new t[e]();
    }
}
class T_ {
    static decodeText(e) {
        if (
            (console.warn(
                'THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead.'
            ),
            typeof TextDecoder < 'u')
        )
            return new TextDecoder().decode(e);
        let t = '';
        for (let n = 0, r = e.length; n < r; n++)
            t += String.fromCharCode(e[n]);
        try {
            return decodeURIComponent(escape(t));
        } catch {
            return t;
        }
    }
    static extractUrlBase(e) {
        const t = e.lastIndexOf('/');
        return t === -1 ? './' : e.slice(0, t + 1);
    }
    static resolveURL(e, t) {
        return typeof e != 'string' || e === ''
            ? ''
            : (/^https?:\/\//i.test(t) &&
                  /^\//.test(e) &&
                  (t = t.replace(/(^https?:\/\/[^\/]+).*/i, '$1')),
              /^(https?:)?\/\//i.test(e) ||
              /^data:.*,.*$/i.test(e) ||
              /^blob:.*$/i.test(e)
                  ? e
                  : t + e);
    }
}
class qb extends $t {
    constructor() {
        super(),
            (this.isInstancedBufferGeometry = !0),
            (this.type = 'InstancedBufferGeometry'),
            (this.instanceCount = 1 / 0);
    }
    copy(e) {
        return super.copy(e), (this.instanceCount = e.instanceCount), this;
    }
    toJSON() {
        const e = super.toJSON();
        return (
            (e.instanceCount = this.instanceCount),
            (e.isInstancedBufferGeometry = !0),
            e
        );
    }
}
class $b extends Gr {
    constructor(e) {
        super(e);
    }
    load(e, t, n, r) {
        const s = this,
            a = new ka(s.manager);
        a.setPath(s.path),
            a.setRequestHeader(s.requestHeader),
            a.setWithCredentials(s.withCredentials),
            a.load(
                e,
                function (l) {
                    try {
                        t(s.parse(JSON.parse(l)));
                    } catch (c) {
                        r ? r(c) : console.error(c), s.manager.itemError(e);
                    }
                },
                n,
                r
            );
    }
    parse(e) {
        const t = {},
            n = {};
        function r(v, S) {
            if (t[S] !== void 0) return t[S];
            const M = v.interleavedBuffers[S],
                w = s(v, M.buffer),
                b = Qf(M.type, w),
                C = new Sv(b, M.stride);
            return (C.uuid = M.uuid), (t[S] = C), C;
        }
        function s(v, S) {
            if (n[S] !== void 0) return n[S];
            const M = v.arrayBuffers[S],
                w = new Uint32Array(M).buffer;
            return (n[S] = w), w;
        }
        const a = e.isInstancedBufferGeometry ? new qb() : new $t(),
            l = e.data.index;
        if (l !== void 0) {
            const v = Qf(l.type, l.array);
            a.setIndex(new Mn(v, 1));
        }
        const c = e.data.attributes;
        for (const v in c) {
            const S = c[v];
            let T;
            if (S.isInterleavedBufferAttribute) {
                const M = r(e.data, S.data);
                T = new uc(M, S.itemSize, S.offset, S.normalized);
            } else {
                const M = Qf(S.type, S.array),
                    w = S.isInstancedBufferAttribute ? dh : Mn;
                T = new w(M, S.itemSize, S.normalized);
            }
            S.name !== void 0 && (T.name = S.name),
                S.usage !== void 0 && T.setUsage(S.usage),
                a.setAttribute(v, T);
        }
        const d = e.data.morphAttributes;
        if (d)
            for (const v in d) {
                const S = d[v],
                    T = [];
                for (let M = 0, w = S.length; M < w; M++) {
                    const b = S[M];
                    let C;
                    if (b.isInterleavedBufferAttribute) {
                        const L = r(e.data, b.data);
                        C = new uc(L, b.itemSize, b.offset, b.normalized);
                    } else {
                        const L = Qf(b.type, b.array);
                        C = new Mn(L, b.itemSize, b.normalized);
                    }
                    b.name !== void 0 && (C.name = b.name), T.push(C);
                }
                a.morphAttributes[v] = T;
            }
        e.data.morphTargetsRelative && (a.morphTargetsRelative = !0);
        const g = e.data.groups || e.data.drawcalls || e.data.offsets;
        if (g !== void 0)
            for (let v = 0, S = g.length; v !== S; ++v) {
                const T = g[v];
                a.addGroup(T.start, T.count, T.materialIndex);
            }
        const y = e.data.boundingSphere;
        if (y !== void 0) {
            const v = new j();
            y.center !== void 0 && v.fromArray(y.center),
                (a.boundingSphere = new or(v, y.radius));
        }
        return (
            e.name && (a.name = e.name),
            e.userData && (a.userData = e.userData),
            a
        );
    }
}
class yH extends Gr {
    constructor(e) {
        super(e);
    }
    load(e, t, n, r) {
        const s = this,
            a = this.path === '' ? T_.extractUrlBase(e) : this.path;
        this.resourcePath = this.resourcePath || a;
        const l = new ka(this.manager);
        l.setPath(this.path),
            l.setRequestHeader(this.requestHeader),
            l.setWithCredentials(this.withCredentials),
            l.load(
                e,
                function (c) {
                    let d = null;
                    try {
                        d = JSON.parse(c);
                    } catch (g) {
                        r !== void 0 && r(g),
                            console.error(
                                "THREE:ObjectLoader: Can't parse " + e + '.',
                                g.message
                            );
                        return;
                    }
                    const p = d.metadata;
                    if (
                        p === void 0 ||
                        p.type === void 0 ||
                        p.type.toLowerCase() === 'geometry'
                    ) {
                        r !== void 0 &&
                            r(new Error("THREE.ObjectLoader: Can't load " + e)),
                            console.error(
                                "THREE.ObjectLoader: Can't load " + e
                            );
                        return;
                    }
                    s.parse(d, t);
                },
                n,
                r
            );
    }
    async loadAsync(e, t) {
        const n = this,
            r = this.path === '' ? T_.extractUrlBase(e) : this.path;
        this.resourcePath = this.resourcePath || r;
        const s = new ka(this.manager);
        s.setPath(this.path),
            s.setRequestHeader(this.requestHeader),
            s.setWithCredentials(this.withCredentials);
        const a = await s.loadAsync(e, t),
            l = JSON.parse(a),
            c = l.metadata;
        if (
            c === void 0 ||
            c.type === void 0 ||
            c.type.toLowerCase() === 'geometry'
        )
            throw new Error("THREE.ObjectLoader: Can't load " + e);
        return await n.parseAsync(l);
    }
    parse(e, t) {
        const n = this.parseAnimations(e.animations),
            r = this.parseShapes(e.shapes),
            s = this.parseGeometries(e.geometries, r),
            a = this.parseImages(e.images, function () {
                t !== void 0 && t(d);
            }),
            l = this.parseTextures(e.textures, a),
            c = this.parseMaterials(e.materials, l),
            d = this.parseObject(e.object, s, c, l, n),
            p = this.parseSkeletons(e.skeletons, d);
        if (
            (this.bindSkeletons(d, p), this.bindLightTargets(d), t !== void 0)
        ) {
            let g = !1;
            for (const y in a)
                if (a[y].data instanceof HTMLImageElement) {
                    g = !0;
                    break;
                }
            g === !1 && t(d);
        }
        return d;
    }
    async parseAsync(e) {
        const t = this.parseAnimations(e.animations),
            n = this.parseShapes(e.shapes),
            r = this.parseGeometries(e.geometries, n),
            s = await this.parseImagesAsync(e.images),
            a = this.parseTextures(e.textures, s),
            l = this.parseMaterials(e.materials, a),
            c = this.parseObject(e.object, r, l, a, t),
            d = this.parseSkeletons(e.skeletons, c);
        return this.bindSkeletons(c, d), this.bindLightTargets(c), c;
    }
    parseShapes(e) {
        const t = {};
        if (e !== void 0)
            for (let n = 0, r = e.length; n < r; n++) {
                const s = new oc().fromJSON(e[n]);
                t[s.uuid] = s;
            }
        return t;
    }
    parseSkeletons(e, t) {
        const n = {},
            r = {};
        if (
            (t.traverse(function (s) {
                s.isBone && (r[s.uuid] = s);
            }),
            e !== void 0)
        )
            for (let s = 0, a = e.length; s < a; s++) {
                const l = new wv().fromJSON(e[s], r);
                n[l.uuid] = l;
            }
        return n;
    }
    parseGeometries(e, t) {
        const n = {};
        if (e !== void 0) {
            const r = new $b();
            for (let s = 0, a = e.length; s < a; s++) {
                let l;
                const c = e[s];
                switch (c.type) {
                    case 'BufferGeometry':
                    case 'InstancedBufferGeometry':
                        l = r.parse(c);
                        break;
                    default:
                        c.type in zE
                            ? (l = zE[c.type].fromJSON(c, t))
                            : console.warn(
                                  `THREE.ObjectLoader: Unsupported geometry type "${c.type}"`
                              );
                }
                (l.uuid = c.uuid),
                    c.name !== void 0 && (l.name = c.name),
                    c.userData !== void 0 && (l.userData = c.userData),
                    (n[c.uuid] = l);
            }
        }
        return n;
    }
    parseMaterials(e, t) {
        const n = {},
            r = {};
        if (e !== void 0) {
            const s = new Fv();
            s.setTextures(t);
            for (let a = 0, l = e.length; a < l; a++) {
                const c = e[a];
                n[c.uuid] === void 0 && (n[c.uuid] = s.parse(c)),
                    (r[c.uuid] = n[c.uuid]);
            }
        }
        return r;
    }
    parseAnimations(e) {
        const t = {};
        if (e !== void 0)
            for (let n = 0; n < e.length; n++) {
                const r = e[n],
                    s = Op.parse(r);
                t[s.uuid] = s;
            }
        return t;
    }
    parseImages(e, t) {
        const n = this,
            r = {};
        let s;
        function a(c) {
            return (
                n.manager.itemStart(c),
                s.load(
                    c,
                    function () {
                        n.manager.itemEnd(c);
                    },
                    void 0,
                    function () {
                        n.manager.itemError(c), n.manager.itemEnd(c);
                    }
                )
            );
        }
        function l(c) {
            if (typeof c == 'string') {
                const d = c,
                    p = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(d)
                        ? d
                        : n.resourcePath + d;
                return a(p);
            } else
                return c.data
                    ? {
                          data: Qf(c.type, c.data),
                          width: c.width,
                          height: c.height,
                      }
                    : null;
        }
        if (e !== void 0 && e.length > 0) {
            const c = new uw(t);
            (s = new kp(c)), s.setCrossOrigin(this.crossOrigin);
            for (let d = 0, p = e.length; d < p; d++) {
                const g = e[d],
                    y = g.url;
                if (Array.isArray(y)) {
                    const v = [];
                    for (let S = 0, T = y.length; S < T; S++) {
                        const M = y[S],
                            w = l(M);
                        w !== null &&
                            (w instanceof HTMLImageElement
                                ? v.push(w)
                                : v.push(new Bo(w.data, w.width, w.height)));
                    }
                    r[g.uuid] = new Zu(v);
                } else {
                    const v = l(g.url);
                    r[g.uuid] = new Zu(v);
                }
            }
        }
        return r;
    }
    async parseImagesAsync(e) {
        const t = this,
            n = {};
        let r;
        async function s(a) {
            if (typeof a == 'string') {
                const l = a,
                    c = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(l)
                        ? l
                        : t.resourcePath + l;
                return await r.loadAsync(c);
            } else
                return a.data
                    ? {
                          data: Qf(a.type, a.data),
                          width: a.width,
                          height: a.height,
                      }
                    : null;
        }
        if (e !== void 0 && e.length > 0) {
            (r = new kp(this.manager)), r.setCrossOrigin(this.crossOrigin);
            for (let a = 0, l = e.length; a < l; a++) {
                const c = e[a],
                    d = c.url;
                if (Array.isArray(d)) {
                    const p = [];
                    for (let g = 0, y = d.length; g < y; g++) {
                        const v = d[g],
                            S = await s(v);
                        S !== null &&
                            (S instanceof HTMLImageElement
                                ? p.push(S)
                                : p.push(new Bo(S.data, S.width, S.height)));
                    }
                    n[c.uuid] = new Zu(p);
                } else {
                    const p = await s(c.url);
                    n[c.uuid] = new Zu(p);
                }
            }
        }
        return n;
    }
    parseTextures(e, t) {
        function n(s, a) {
            return typeof s == 'number'
                ? s
                : (console.warn(
                      'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.',
                      s
                  ),
                  a[s]);
        }
        const r = {};
        if (e !== void 0)
            for (let s = 0, a = e.length; s < a; s++) {
                const l = e[s];
                l.image === void 0 &&
                    console.warn(
                        'THREE.ObjectLoader: No "image" specified for',
                        l.uuid
                    ),
                    t[l.image] === void 0 &&
                        console.warn(
                            'THREE.ObjectLoader: Undefined image',
                            l.image
                        );
                const c = t[l.image],
                    d = c.data;
                let p;
                Array.isArray(d)
                    ? ((p = new Zp()), d.length === 6 && (p.needsUpdate = !0))
                    : (d && d.data ? (p = new Bo()) : (p = new Qn()),
                      d && (p.needsUpdate = !0)),
                    (p.source = c),
                    (p.uuid = l.uuid),
                    l.name !== void 0 && (p.name = l.name),
                    l.mapping !== void 0 && (p.mapping = n(l.mapping, vH)),
                    l.channel !== void 0 && (p.channel = l.channel),
                    l.offset !== void 0 && p.offset.fromArray(l.offset),
                    l.repeat !== void 0 && p.repeat.fromArray(l.repeat),
                    l.center !== void 0 && p.center.fromArray(l.center),
                    l.rotation !== void 0 && (p.rotation = l.rotation),
                    l.wrap !== void 0 &&
                        ((p.wrapS = n(l.wrap[0], WE)),
                        (p.wrapT = n(l.wrap[1], WE))),
                    l.format !== void 0 && (p.format = l.format),
                    l.internalFormat !== void 0 &&
                        (p.internalFormat = l.internalFormat),
                    l.type !== void 0 && (p.type = l.type),
                    l.colorSpace !== void 0 && (p.colorSpace = l.colorSpace),
                    l.minFilter !== void 0 &&
                        (p.minFilter = n(l.minFilter, XE)),
                    l.magFilter !== void 0 &&
                        (p.magFilter = n(l.magFilter, XE)),
                    l.anisotropy !== void 0 && (p.anisotropy = l.anisotropy),
                    l.flipY !== void 0 && (p.flipY = l.flipY),
                    l.generateMipmaps !== void 0 &&
                        (p.generateMipmaps = l.generateMipmaps),
                    l.premultiplyAlpha !== void 0 &&
                        (p.premultiplyAlpha = l.premultiplyAlpha),
                    l.unpackAlignment !== void 0 &&
                        (p.unpackAlignment = l.unpackAlignment),
                    l.compareFunction !== void 0 &&
                        (p.compareFunction = l.compareFunction),
                    l.userData !== void 0 && (p.userData = l.userData),
                    (r[l.uuid] = p);
            }
        return r;
    }
    parseObject(e, t, n, r, s) {
        let a;
        function l(y) {
            return (
                t[y] === void 0 &&
                    console.warn('THREE.ObjectLoader: Undefined geometry', y),
                t[y]
            );
        }
        function c(y) {
            if (y !== void 0) {
                if (Array.isArray(y)) {
                    const v = [];
                    for (let S = 0, T = y.length; S < T; S++) {
                        const M = y[S];
                        n[M] === void 0 &&
                            console.warn(
                                'THREE.ObjectLoader: Undefined material',
                                M
                            ),
                            v.push(n[M]);
                    }
                    return v;
                }
                return (
                    n[y] === void 0 &&
                        console.warn(
                            'THREE.ObjectLoader: Undefined material',
                            y
                        ),
                    n[y]
                );
            }
        }
        function d(y) {
            return (
                r[y] === void 0 &&
                    console.warn('THREE.ObjectLoader: Undefined texture', y),
                r[y]
            );
        }
        let p, g;
        switch (e.type) {
            case 'Scene':
                (a = new YS()),
                    e.background !== void 0 &&
                        (Number.isInteger(e.background)
                            ? (a.background = new st(e.background))
                            : (a.background = d(e.background))),
                    e.environment !== void 0 &&
                        (a.environment = d(e.environment)),
                    e.fog !== void 0 &&
                        (e.fog.type === 'Fog'
                            ? (a.fog = new _v(
                                  e.fog.color,
                                  e.fog.near,
                                  e.fog.far
                              ))
                            : e.fog.type === 'FogExp2' &&
                              (a.fog = new xv(e.fog.color, e.fog.density)),
                        e.fog.name !== '' && (a.fog.name = e.fog.name)),
                    e.backgroundBlurriness !== void 0 &&
                        (a.backgroundBlurriness = e.backgroundBlurriness),
                    e.backgroundIntensity !== void 0 &&
                        (a.backgroundIntensity = e.backgroundIntensity),
                    e.backgroundRotation !== void 0 &&
                        a.backgroundRotation.fromArray(e.backgroundRotation),
                    e.environmentIntensity !== void 0 &&
                        (a.environmentIntensity = e.environmentIntensity),
                    e.environmentRotation !== void 0 &&
                        a.environmentRotation.fromArray(e.environmentRotation);
                break;
            case 'PerspectiveCamera':
                (a = new Pi(e.fov, e.aspect, e.near, e.far)),
                    e.focus !== void 0 && (a.focus = e.focus),
                    e.zoom !== void 0 && (a.zoom = e.zoom),
                    e.filmGauge !== void 0 && (a.filmGauge = e.filmGauge),
                    e.filmOffset !== void 0 && (a.filmOffset = e.filmOffset),
                    e.view !== void 0 && (a.view = Object.assign({}, e.view));
                break;
            case 'OrthographicCamera':
                (a = new Qp(e.left, e.right, e.top, e.bottom, e.near, e.far)),
                    e.zoom !== void 0 && (a.zoom = e.zoom),
                    e.view !== void 0 && (a.view = Object.assign({}, e.view));
                break;
            case 'AmbientLight':
                a = new Gb(e.color, e.intensity);
                break;
            case 'DirectionalLight':
                (a = new Hb(e.color, e.intensity)), (a.target = e.target || '');
                break;
            case 'PointLight':
                a = new Vb(e.color, e.intensity, e.distance, e.decay);
                break;
            case 'RectAreaLight':
                a = new Wb(e.color, e.intensity, e.width, e.height);
                break;
            case 'SpotLight':
                (a = new zb(
                    e.color,
                    e.intensity,
                    e.distance,
                    e.angle,
                    e.penumbra,
                    e.decay
                )),
                    (a.target = e.target || '');
                break;
            case 'HemisphereLight':
                a = new Bb(e.color, e.groundColor, e.intensity);
                break;
            case 'LightProbe':
                a = new jb().fromJSON(e);
                break;
            case 'SkinnedMesh':
                (p = l(e.geometry)),
                    (g = c(e.material)),
                    (a = new ub(p, g)),
                    e.bindMode !== void 0 && (a.bindMode = e.bindMode),
                    e.bindMatrix !== void 0 &&
                        a.bindMatrix.fromArray(e.bindMatrix),
                    e.skeleton !== void 0 && (a.skeleton = e.skeleton);
                break;
            case 'Mesh':
                (p = l(e.geometry)), (g = c(e.material)), (a = new di(p, g));
                break;
            case 'InstancedMesh':
                (p = l(e.geometry)), (g = c(e.material));
                const y = e.count,
                    v = e.instanceMatrix,
                    S = e.instanceColor;
                (a = new cb(p, g, y)),
                    (a.instanceMatrix = new dh(new Float32Array(v.array), 16)),
                    S !== void 0 &&
                        (a.instanceColor = new dh(
                            new Float32Array(S.array),
                            S.itemSize
                        ));
                break;
            case 'BatchedMesh':
                (p = l(e.geometry)),
                    (g = c(e.material)),
                    (a = new fb(
                        e.maxInstanceCount,
                        e.maxVertexCount,
                        e.maxIndexCount,
                        g
                    )),
                    (a.geometry = p),
                    (a.perObjectFrustumCulled = e.perObjectFrustumCulled),
                    (a.sortObjects = e.sortObjects),
                    (a._drawRanges = e.drawRanges),
                    (a._reservedRanges = e.reservedRanges),
                    (a._visibility = e.visibility),
                    (a._active = e.active),
                    (a._bounds = e.bounds.map((T) => {
                        const M = new Tr();
                        M.min.fromArray(T.boxMin), M.max.fromArray(T.boxMax);
                        const w = new or();
                        return (
                            (w.radius = T.sphereRadius),
                            w.center.fromArray(T.sphereCenter),
                            {
                                boxInitialized: T.boxInitialized,
                                box: M,
                                sphereInitialized: T.sphereInitialized,
                                sphere: w,
                            }
                        );
                    })),
                    (a._maxInstanceCount = e.maxInstanceCount),
                    (a._maxVertexCount = e.maxVertexCount),
                    (a._maxIndexCount = e.maxIndexCount),
                    (a._geometryInitialized = e.geometryInitialized),
                    (a._geometryCount = e.geometryCount),
                    (a._matricesTexture = d(e.matricesTexture.uuid)),
                    e.colorsTexture !== void 0 &&
                        (a._colorsTexture = d(e.colorsTexture.uuid));
                break;
            case 'LOD':
                a = new lb();
                break;
            case 'Line':
                a = new Ul(l(e.geometry), c(e.material));
                break;
            case 'LineLoop':
                a = new hb(l(e.geometry), c(e.material));
                break;
            case 'LineSegments':
                a = new Vo(l(e.geometry), c(e.material));
                break;
            case 'PointCloud':
            case 'Points':
                a = new db(l(e.geometry), c(e.material));
                break;
            case 'Sprite':
                a = new ab(c(e.material));
                break;
            case 'Group':
                a = new th();
                break;
            case 'Bone':
                a = new ZS();
                break;
            default:
                a = new ln();
        }
        if (
            ((a.uuid = e.uuid),
            e.name !== void 0 && (a.name = e.name),
            e.matrix !== void 0
                ? (a.matrix.fromArray(e.matrix),
                  e.matrixAutoUpdate !== void 0 &&
                      (a.matrixAutoUpdate = e.matrixAutoUpdate),
                  a.matrixAutoUpdate &&
                      a.matrix.decompose(a.position, a.quaternion, a.scale))
                : (e.position !== void 0 && a.position.fromArray(e.position),
                  e.rotation !== void 0 && a.rotation.fromArray(e.rotation),
                  e.quaternion !== void 0 &&
                      a.quaternion.fromArray(e.quaternion),
                  e.scale !== void 0 && a.scale.fromArray(e.scale)),
            e.up !== void 0 && a.up.fromArray(e.up),
            e.castShadow !== void 0 && (a.castShadow = e.castShadow),
            e.receiveShadow !== void 0 && (a.receiveShadow = e.receiveShadow),
            e.shadow &&
                (e.shadow.intensity !== void 0 &&
                    (a.shadow.intensity = e.shadow.intensity),
                e.shadow.bias !== void 0 && (a.shadow.bias = e.shadow.bias),
                e.shadow.normalBias !== void 0 &&
                    (a.shadow.normalBias = e.shadow.normalBias),
                e.shadow.radius !== void 0 &&
                    (a.shadow.radius = e.shadow.radius),
                e.shadow.mapSize !== void 0 &&
                    a.shadow.mapSize.fromArray(e.shadow.mapSize),
                e.shadow.camera !== void 0 &&
                    (a.shadow.camera = this.parseObject(e.shadow.camera))),
            e.visible !== void 0 && (a.visible = e.visible),
            e.frustumCulled !== void 0 && (a.frustumCulled = e.frustumCulled),
            e.renderOrder !== void 0 && (a.renderOrder = e.renderOrder),
            e.userData !== void 0 && (a.userData = e.userData),
            e.layers !== void 0 && (a.layers.mask = e.layers),
            e.children !== void 0)
        ) {
            const y = e.children;
            for (let v = 0; v < y.length; v++)
                a.add(this.parseObject(y[v], t, n, r, s));
        }
        if (e.animations !== void 0) {
            const y = e.animations;
            for (let v = 0; v < y.length; v++) {
                const S = y[v];
                a.animations.push(s[S]);
            }
        }
        if (e.type === 'LOD') {
            e.autoUpdate !== void 0 && (a.autoUpdate = e.autoUpdate);
            const y = e.levels;
            for (let v = 0; v < y.length; v++) {
                const S = y[v],
                    T = a.getObjectByProperty('uuid', S.object);
                T !== void 0 && a.addLevel(T, S.distance, S.hysteresis);
            }
        }
        return a;
    }
    bindSkeletons(e, t) {
        Object.keys(t).length !== 0 &&
            e.traverse(function (n) {
                if (n.isSkinnedMesh === !0 && n.skeleton !== void 0) {
                    const r = t[n.skeleton];
                    r === void 0
                        ? console.warn(
                              'THREE.ObjectLoader: No skeleton found with UUID:',
                              n.skeleton
                          )
                        : n.bind(r, n.bindMatrix);
                }
            });
    }
    bindLightTargets(e) {
        e.traverse(function (t) {
            if (t.isDirectionalLight || t.isSpotLight) {
                const n = t.target,
                    r = e.getObjectByProperty('uuid', n);
                r !== void 0 ? (t.target = r) : (t.target = new ln());
            }
        });
    }
}
const vH = {
        UVMapping: lv,
        CubeReflectionMapping: Ua,
        CubeRefractionMapping: Nl,
        EquirectangularReflectionMapping: vp,
        EquirectangularRefractionMapping: xp,
        CubeUVReflectionMapping: wh,
    },
    WE = {
        RepeatWrapping: _p,
        ClampToEdgeWrapping: Ms,
        MirroredRepeatWrapping: Sp,
    },
    XE = {
        NearestFilter: Li,
        NearestMipmapNearestFilter: CS,
        NearestMipmapLinearFilter: Jf,
        LinearFilter: hi,
        LinearMipmapNearestFilter: Jd,
        LinearMipmapLinearFilter: Io,
    };
class xH extends Gr {
    constructor(e) {
        super(e),
            (this.isImageBitmapLoader = !0),
            typeof createImageBitmap > 'u' &&
                console.warn(
                    'THREE.ImageBitmapLoader: createImageBitmap() not supported.'
                ),
            typeof fetch > 'u' &&
                console.warn('THREE.ImageBitmapLoader: fetch() not supported.'),
            (this.options = { premultiplyAlpha: 'none' });
    }
    setOptions(e) {
        return (this.options = e), this;
    }
    load(e, t, n, r) {
        e === void 0 && (e = ''),
            this.path !== void 0 && (e = this.path + e),
            (e = this.manager.resolveURL(e));
        const s = this,
            a = Ra.get(e);
        if (a !== void 0) {
            if ((s.manager.itemStart(e), a.then)) {
                a.then((d) => {
                    t && t(d), s.manager.itemEnd(e);
                }).catch((d) => {
                    r && r(d);
                });
                return;
            }
            return (
                setTimeout(function () {
                    t && t(a), s.manager.itemEnd(e);
                }, 0),
                a
            );
        }
        const l = {};
        (l.credentials =
            this.crossOrigin === 'anonymous' ? 'same-origin' : 'include'),
            (l.headers = this.requestHeader);
        const c = fetch(e, l)
            .then(function (d) {
                return d.blob();
            })
            .then(function (d) {
                return createImageBitmap(
                    d,
                    Object.assign(s.options, { colorSpaceConversion: 'none' })
                );
            })
            .then(function (d) {
                return Ra.add(e, d), t && t(d), s.manager.itemEnd(e), d;
            })
            .catch(function (d) {
                r && r(d),
                    Ra.remove(e),
                    s.manager.itemError(e),
                    s.manager.itemEnd(e);
            });
        Ra.add(e, c), s.manager.itemStart(e);
    }
}
let Gg;
class fw {
    static getContext() {
        return (
            Gg === void 0 &&
                (Gg = new (window.AudioContext || window.webkitAudioContext)()),
            Gg
        );
    }
    static setContext(e) {
        Gg = e;
    }
}
class _H extends Gr {
    constructor(e) {
        super(e);
    }
    load(e, t, n, r) {
        const s = this,
            a = new ka(this.manager);
        a.setResponseType('arraybuffer'),
            a.setPath(this.path),
            a.setRequestHeader(this.requestHeader),
            a.setWithCredentials(this.withCredentials),
            a.load(
                e,
                function (c) {
                    try {
                        const d = c.slice(0);
                        fw.getContext()
                            .decodeAudioData(d, function (g) {
                                t(g);
                            })
                            .catch(l);
                    } catch (d) {
                        l(d);
                    }
                },
                n,
                r
            );
        function l(c) {
            r ? r(c) : console.error(c), s.manager.itemError(e);
        }
    }
}
const jE = new Pt(),
    qE = new Pt(),
    Fu = new Pt();
class SH {
    constructor() {
        (this.type = 'StereoCamera'),
            (this.aspect = 1),
            (this.eyeSep = 0.064),
            (this.cameraL = new Pi()),
            this.cameraL.layers.enable(1),
            (this.cameraL.matrixAutoUpdate = !1),
            (this.cameraR = new Pi()),
            this.cameraR.layers.enable(2),
            (this.cameraR.matrixAutoUpdate = !1),
            (this._cache = {
                focus: null,
                fov: null,
                aspect: null,
                near: null,
                far: null,
                zoom: null,
                eyeSep: null,
            });
    }
    update(e) {
        const t = this._cache;
        if (
            t.focus !== e.focus ||
            t.fov !== e.fov ||
            t.aspect !== e.aspect * this.aspect ||
            t.near !== e.near ||
            t.far !== e.far ||
            t.zoom !== e.zoom ||
            t.eyeSep !== this.eyeSep
        ) {
            (t.focus = e.focus),
                (t.fov = e.fov),
                (t.aspect = e.aspect * this.aspect),
                (t.near = e.near),
                (t.far = e.far),
                (t.zoom = e.zoom),
                (t.eyeSep = this.eyeSep),
                Fu.copy(e.projectionMatrix);
            const r = t.eyeSep / 2,
                s = (r * t.near) / t.focus,
                a = (t.near * Math.tan(rc * t.fov * 0.5)) / t.zoom;
            let l, c;
            (qE.elements[12] = -r),
                (jE.elements[12] = r),
                (l = -a * t.aspect + s),
                (c = a * t.aspect + s),
                (Fu.elements[0] = (2 * t.near) / (c - l)),
                (Fu.elements[8] = (c + l) / (c - l)),
                this.cameraL.projectionMatrix.copy(Fu),
                (l = -a * t.aspect - s),
                (c = a * t.aspect - s),
                (Fu.elements[0] = (2 * t.near) / (c - l)),
                (Fu.elements[8] = (c + l) / (c - l)),
                this.cameraR.projectionMatrix.copy(Fu);
        }
        this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(qE),
            this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(jE);
    }
}
class hw {
    constructor(e = !0) {
        (this.autoStart = e),
            (this.startTime = 0),
            (this.oldTime = 0),
            (this.elapsedTime = 0),
            (this.running = !1);
    }
    start() {
        (this.startTime = $E()),
            (this.oldTime = this.startTime),
            (this.elapsedTime = 0),
            (this.running = !0);
    }
    stop() {
        this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
    }
    getElapsedTime() {
        return this.getDelta(), this.elapsedTime;
    }
    getDelta() {
        let e = 0;
        if (this.autoStart && !this.running) return this.start(), 0;
        if (this.running) {
            const t = $E();
            (e = (t - this.oldTime) / 1e3),
                (this.oldTime = t),
                (this.elapsedTime += e);
        }
        return e;
    }
}
function $E() {
    return (typeof performance > 'u' ? Date : performance).now();
}
const Bu = new j(),
    YE = new Hr(),
    wH = new j(),
    zu = new j();
class MH extends ln {
    constructor() {
        super(),
            (this.type = 'AudioListener'),
            (this.context = fw.getContext()),
            (this.gain = this.context.createGain()),
            this.gain.connect(this.context.destination),
            (this.filter = null),
            (this.timeDelta = 0),
            (this._clock = new hw());
    }
    getInput() {
        return this.gain;
    }
    removeFilter() {
        return (
            this.filter !== null &&
                (this.gain.disconnect(this.filter),
                this.filter.disconnect(this.context.destination),
                this.gain.connect(this.context.destination),
                (this.filter = null)),
            this
        );
    }
    getFilter() {
        return this.filter;
    }
    setFilter(e) {
        return (
            this.filter !== null
                ? (this.gain.disconnect(this.filter),
                  this.filter.disconnect(this.context.destination))
                : this.gain.disconnect(this.context.destination),
            (this.filter = e),
            this.gain.connect(this.filter),
            this.filter.connect(this.context.destination),
            this
        );
    }
    getMasterVolume() {
        return this.gain.gain.value;
    }
    setMasterVolume(e) {
        return (
            this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01),
            this
        );
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e);
        const t = this.context.listener,
            n = this.up;
        if (
            ((this.timeDelta = this._clock.getDelta()),
            this.matrixWorld.decompose(Bu, YE, wH),
            zu.set(0, 0, -1).applyQuaternion(YE),
            t.positionX)
        ) {
            const r = this.context.currentTime + this.timeDelta;
            t.positionX.linearRampToValueAtTime(Bu.x, r),
                t.positionY.linearRampToValueAtTime(Bu.y, r),
                t.positionZ.linearRampToValueAtTime(Bu.z, r),
                t.forwardX.linearRampToValueAtTime(zu.x, r),
                t.forwardY.linearRampToValueAtTime(zu.y, r),
                t.forwardZ.linearRampToValueAtTime(zu.z, r),
                t.upX.linearRampToValueAtTime(n.x, r),
                t.upY.linearRampToValueAtTime(n.y, r),
                t.upZ.linearRampToValueAtTime(n.z, r);
        } else
            t.setPosition(Bu.x, Bu.y, Bu.z),
                t.setOrientation(zu.x, zu.y, zu.z, n.x, n.y, n.z);
    }
}
let Yb = class extends ln {
    constructor(e) {
        super(),
            (this.type = 'Audio'),
            (this.listener = e),
            (this.context = e.context),
            (this.gain = this.context.createGain()),
            this.gain.connect(e.getInput()),
            (this.autoplay = !1),
            (this.buffer = null),
            (this.detune = 0),
            (this.loop = !1),
            (this.loopStart = 0),
            (this.loopEnd = 0),
            (this.offset = 0),
            (this.duration = void 0),
            (this.playbackRate = 1),
            (this.isPlaying = !1),
            (this.hasPlaybackControl = !0),
            (this.source = null),
            (this.sourceType = 'empty'),
            (this._startedAt = 0),
            (this._progress = 0),
            (this._connected = !1),
            (this.filters = []);
    }
    getOutput() {
        return this.gain;
    }
    setNodeSource(e) {
        return (
            (this.hasPlaybackControl = !1),
            (this.sourceType = 'audioNode'),
            (this.source = e),
            this.connect(),
            this
        );
    }
    setMediaElementSource(e) {
        return (
            (this.hasPlaybackControl = !1),
            (this.sourceType = 'mediaNode'),
            (this.source = this.context.createMediaElementSource(e)),
            this.connect(),
            this
        );
    }
    setMediaStreamSource(e) {
        return (
            (this.hasPlaybackControl = !1),
            (this.sourceType = 'mediaStreamNode'),
            (this.source = this.context.createMediaStreamSource(e)),
            this.connect(),
            this
        );
    }
    setBuffer(e) {
        return (
            (this.buffer = e),
            (this.sourceType = 'buffer'),
            this.autoplay && this.play(),
            this
        );
    }
    play(e = 0) {
        if (this.isPlaying === !0) {
            console.warn('THREE.Audio: Audio is already playing.');
            return;
        }
        if (this.hasPlaybackControl === !1) {
            console.warn('THREE.Audio: this Audio has no playback control.');
            return;
        }
        this._startedAt = this.context.currentTime + e;
        const t = this.context.createBufferSource();
        return (
            (t.buffer = this.buffer),
            (t.loop = this.loop),
            (t.loopStart = this.loopStart),
            (t.loopEnd = this.loopEnd),
            (t.onended = this.onEnded.bind(this)),
            t.start(
                this._startedAt,
                this._progress + this.offset,
                this.duration
            ),
            (this.isPlaying = !0),
            (this.source = t),
            this.setDetune(this.detune),
            this.setPlaybackRate(this.playbackRate),
            this.connect()
        );
    }
    pause() {
        if (this.hasPlaybackControl === !1) {
            console.warn('THREE.Audio: this Audio has no playback control.');
            return;
        }
        return (
            this.isPlaying === !0 &&
                ((this._progress +=
                    Math.max(this.context.currentTime - this._startedAt, 0) *
                    this.playbackRate),
                this.loop === !0 &&
                    (this._progress =
                        this._progress %
                        (this.duration || this.buffer.duration)),
                this.source.stop(),
                (this.source.onended = null),
                (this.isPlaying = !1)),
            this
        );
    }
    stop() {
        if (this.hasPlaybackControl === !1) {
            console.warn('THREE.Audio: this Audio has no playback control.');
            return;
        }
        return (
            (this._progress = 0),
            this.source !== null &&
                (this.source.stop(), (this.source.onended = null)),
            (this.isPlaying = !1),
            this
        );
    }
    connect() {
        if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for (let e = 1, t = this.filters.length; e < t; e++)
                this.filters[e - 1].connect(this.filters[e]);
            this.filters[this.filters.length - 1].connect(this.getOutput());
        } else this.source.connect(this.getOutput());
        return (this._connected = !0), this;
    }
    disconnect() {
        if (this._connected !== !1) {
            if (this.filters.length > 0) {
                this.source.disconnect(this.filters[0]);
                for (let e = 1, t = this.filters.length; e < t; e++)
                    this.filters[e - 1].disconnect(this.filters[e]);
                this.filters[this.filters.length - 1].disconnect(
                    this.getOutput()
                );
            } else this.source.disconnect(this.getOutput());
            return (this._connected = !1), this;
        }
    }
    getFilters() {
        return this.filters;
    }
    setFilters(e) {
        return (
            e || (e = []),
            this._connected === !0
                ? (this.disconnect(),
                  (this.filters = e.slice()),
                  this.connect())
                : (this.filters = e.slice()),
            this
        );
    }
    setDetune(e) {
        return (
            (this.detune = e),
            this.isPlaying === !0 &&
                this.source.detune !== void 0 &&
                this.source.detune.setTargetAtTime(
                    this.detune,
                    this.context.currentTime,
                    0.01
                ),
            this
        );
    }
    getDetune() {
        return this.detune;
    }
    getFilter() {
        return this.getFilters()[0];
    }
    setFilter(e) {
        return this.setFilters(e ? [e] : []);
    }
    setPlaybackRate(e) {
        if (this.hasPlaybackControl === !1) {
            console.warn('THREE.Audio: this Audio has no playback control.');
            return;
        }
        return (
            (this.playbackRate = e),
            this.isPlaying === !0 &&
                this.source.playbackRate.setTargetAtTime(
                    this.playbackRate,
                    this.context.currentTime,
                    0.01
                ),
            this
        );
    }
    getPlaybackRate() {
        return this.playbackRate;
    }
    onEnded() {
        this.isPlaying = !1;
    }
    getLoop() {
        return this.hasPlaybackControl === !1
            ? (console.warn('THREE.Audio: this Audio has no playback control.'),
              !1)
            : this.loop;
    }
    setLoop(e) {
        if (this.hasPlaybackControl === !1) {
            console.warn('THREE.Audio: this Audio has no playback control.');
            return;
        }
        return (
            (this.loop = e),
            this.isPlaying === !0 && (this.source.loop = this.loop),
            this
        );
    }
    setLoopStart(e) {
        return (this.loopStart = e), this;
    }
    setLoopEnd(e) {
        return (this.loopEnd = e), this;
    }
    getVolume() {
        return this.gain.gain.value;
    }
    setVolume(e) {
        return (
            this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01),
            this
        );
    }
};
const Vu = new j(),
    KE = new Hr(),
    EH = new j(),
    Hu = new j();
class TH extends Yb {
    constructor(e) {
        super(e),
            (this.panner = this.context.createPanner()),
            (this.panner.panningModel = 'HRTF'),
            this.panner.connect(this.gain);
    }
    connect() {
        super.connect(), this.panner.connect(this.gain);
    }
    disconnect() {
        super.disconnect(), this.panner.disconnect(this.gain);
    }
    getOutput() {
        return this.panner;
    }
    getRefDistance() {
        return this.panner.refDistance;
    }
    setRefDistance(e) {
        return (this.panner.refDistance = e), this;
    }
    getRolloffFactor() {
        return this.panner.rolloffFactor;
    }
    setRolloffFactor(e) {
        return (this.panner.rolloffFactor = e), this;
    }
    getDistanceModel() {
        return this.panner.distanceModel;
    }
    setDistanceModel(e) {
        return (this.panner.distanceModel = e), this;
    }
    getMaxDistance() {
        return this.panner.maxDistance;
    }
    setMaxDistance(e) {
        return (this.panner.maxDistance = e), this;
    }
    setDirectionalCone(e, t, n) {
        return (
            (this.panner.coneInnerAngle = e),
            (this.panner.coneOuterAngle = t),
            (this.panner.coneOuterGain = n),
            this
        );
    }
    updateMatrixWorld(e) {
        if (
            (super.updateMatrixWorld(e),
            this.hasPlaybackControl === !0 && this.isPlaying === !1)
        )
            return;
        this.matrixWorld.decompose(Vu, KE, EH),
            Hu.set(0, 0, 1).applyQuaternion(KE);
        const t = this.panner;
        if (t.positionX) {
            const n = this.context.currentTime + this.listener.timeDelta;
            t.positionX.linearRampToValueAtTime(Vu.x, n),
                t.positionY.linearRampToValueAtTime(Vu.y, n),
                t.positionZ.linearRampToValueAtTime(Vu.z, n),
                t.orientationX.linearRampToValueAtTime(Hu.x, n),
                t.orientationY.linearRampToValueAtTime(Hu.y, n),
                t.orientationZ.linearRampToValueAtTime(Hu.z, n);
        } else
            t.setPosition(Vu.x, Vu.y, Vu.z), t.setOrientation(Hu.x, Hu.y, Hu.z);
    }
}
class AH {
    constructor(e, t = 2048) {
        (this.analyser = e.context.createAnalyser()),
            (this.analyser.fftSize = t),
            (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
            e.getOutput().connect(this.analyser);
    }
    getFrequencyData() {
        return this.analyser.getByteFrequencyData(this.data), this.data;
    }
    getAverageFrequency() {
        let e = 0;
        const t = this.getFrequencyData();
        for (let n = 0; n < t.length; n++) e += t[n];
        return e / t.length;
    }
}
class Kb {
    constructor(e, t, n) {
        (this.binding = e), (this.valueSize = n);
        let r, s, a;
        switch (t) {
            case 'quaternion':
                (r = this._slerp),
                    (s = this._slerpAdditive),
                    (a = this._setAdditiveIdentityQuaternion),
                    (this.buffer = new Float64Array(n * 6)),
                    (this._workIndex = 5);
                break;
            case 'string':
            case 'bool':
                (r = this._select),
                    (s = this._select),
                    (a = this._setAdditiveIdentityOther),
                    (this.buffer = new Array(n * 5));
                break;
            default:
                (r = this._lerp),
                    (s = this._lerpAdditive),
                    (a = this._setAdditiveIdentityNumeric),
                    (this.buffer = new Float64Array(n * 5));
        }
        (this._mixBufferRegion = r),
            (this._mixBufferRegionAdditive = s),
            (this._setIdentity = a),
            (this._origIndex = 3),
            (this._addIndex = 4),
            (this.cumulativeWeight = 0),
            (this.cumulativeWeightAdditive = 0),
            (this.useCount = 0),
            (this.referenceCount = 0);
    }
    accumulate(e, t) {
        const n = this.buffer,
            r = this.valueSize,
            s = e * r + r;
        let a = this.cumulativeWeight;
        if (a === 0) {
            for (let l = 0; l !== r; ++l) n[s + l] = n[l];
            a = t;
        } else {
            a += t;
            const l = t / a;
            this._mixBufferRegion(n, s, 0, l, r);
        }
        this.cumulativeWeight = a;
    }
    accumulateAdditive(e) {
        const t = this.buffer,
            n = this.valueSize,
            r = n * this._addIndex;
        this.cumulativeWeightAdditive === 0 && this._setIdentity(),
            this._mixBufferRegionAdditive(t, r, 0, e, n),
            (this.cumulativeWeightAdditive += e);
    }
    apply(e) {
        const t = this.valueSize,
            n = this.buffer,
            r = e * t + t,
            s = this.cumulativeWeight,
            a = this.cumulativeWeightAdditive,
            l = this.binding;
        if (
            ((this.cumulativeWeight = 0),
            (this.cumulativeWeightAdditive = 0),
            s < 1)
        ) {
            const c = t * this._origIndex;
            this._mixBufferRegion(n, r, c, 1 - s, t);
        }
        a > 0 && this._mixBufferRegionAdditive(n, r, this._addIndex * t, 1, t);
        for (let c = t, d = t + t; c !== d; ++c)
            if (n[c] !== n[c + t]) {
                l.setValue(n, r);
                break;
            }
    }
    saveOriginalState() {
        const e = this.binding,
            t = this.buffer,
            n = this.valueSize,
            r = n * this._origIndex;
        e.getValue(t, r);
        for (let s = n, a = r; s !== a; ++s) t[s] = t[r + (s % n)];
        this._setIdentity(),
            (this.cumulativeWeight = 0),
            (this.cumulativeWeightAdditive = 0);
    }
    restoreOriginalState() {
        const e = this.valueSize * 3;
        this.binding.setValue(this.buffer, e);
    }
    _setAdditiveIdentityNumeric() {
        const e = this._addIndex * this.valueSize,
            t = e + this.valueSize;
        for (let n = e; n < t; n++) this.buffer[n] = 0;
    }
    _setAdditiveIdentityQuaternion() {
        this._setAdditiveIdentityNumeric(),
            (this.buffer[this._addIndex * this.valueSize + 3] = 1);
    }
    _setAdditiveIdentityOther() {
        const e = this._origIndex * this.valueSize,
            t = this._addIndex * this.valueSize;
        for (let n = 0; n < this.valueSize; n++)
            this.buffer[t + n] = this.buffer[e + n];
    }
    _select(e, t, n, r, s) {
        if (r >= 0.5) for (let a = 0; a !== s; ++a) e[t + a] = e[n + a];
    }
    _slerp(e, t, n, r) {
        Hr.slerpFlat(e, t, e, t, e, n, r);
    }
    _slerpAdditive(e, t, n, r, s) {
        const a = this._workIndex * s;
        Hr.multiplyQuaternionsFlat(e, a, e, t, e, n),
            Hr.slerpFlat(e, t, e, t, e, a, r);
    }
    _lerp(e, t, n, r, s) {
        const a = 1 - r;
        for (let l = 0; l !== s; ++l) {
            const c = t + l;
            e[c] = e[c] * a + e[n + l] * r;
        }
    }
    _lerpAdditive(e, t, n, r, s) {
        for (let a = 0; a !== s; ++a) {
            const l = t + a;
            e[l] = e[l] + e[n + a] * r;
        }
    }
}
const dw = '\\[\\]\\.:\\/',
    CH = new RegExp('[' + dw + ']', 'g'),
    pw = '[^' + dw + ']',
    RH = '[^' + dw.replace('\\.', '') + ']',
    bH = /((?:WC+[\/:])*)/.source.replace('WC', pw),
    PH = /(WCOD+)?/.source.replace('WCOD', RH),
    LH = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', pw),
    IH = /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', pw),
    DH = new RegExp('^' + bH + PH + LH + IH + '$'),
    NH = ['material', 'materials', 'bones', 'map'];
class UH {
    constructor(e, t, n) {
        const r = n || an.parseTrackName(t);
        (this._targetGroup = e), (this._bindings = e.subscribe_(t, r));
    }
    getValue(e, t) {
        this.bind();
        const n = this._targetGroup.nCachedObjects_,
            r = this._bindings[n];
        r !== void 0 && r.getValue(e, t);
    }
    setValue(e, t) {
        const n = this._bindings;
        for (
            let r = this._targetGroup.nCachedObjects_, s = n.length;
            r !== s;
            ++r
        )
            n[r].setValue(e, t);
    }
    bind() {
        const e = this._bindings;
        for (
            let t = this._targetGroup.nCachedObjects_, n = e.length;
            t !== n;
            ++t
        )
            e[t].bind();
    }
    unbind() {
        const e = this._bindings;
        for (
            let t = this._targetGroup.nCachedObjects_, n = e.length;
            t !== n;
            ++t
        )
            e[t].unbind();
    }
}
class an {
    constructor(e, t, n) {
        (this.path = t),
            (this.parsedPath = n || an.parseTrackName(t)),
            (this.node = an.findNode(e, this.parsedPath.nodeName)),
            (this.rootNode = e),
            (this.getValue = this._getValue_unbound),
            (this.setValue = this._setValue_unbound);
    }
    static create(e, t, n) {
        return e && e.isAnimationObjectGroup
            ? new an.Composite(e, t, n)
            : new an(e, t, n);
    }
    static sanitizeNodeName(e) {
        return e.replace(/\s/g, '_').replace(CH, '');
    }
    static parseTrackName(e) {
        const t = DH.exec(e);
        if (t === null)
            throw new Error('PropertyBinding: Cannot parse trackName: ' + e);
        const n = {
                nodeName: t[2],
                objectName: t[3],
                objectIndex: t[4],
                propertyName: t[5],
                propertyIndex: t[6],
            },
            r = n.nodeName && n.nodeName.lastIndexOf('.');
        if (r !== void 0 && r !== -1) {
            const s = n.nodeName.substring(r + 1);
            NH.indexOf(s) !== -1 &&
                ((n.nodeName = n.nodeName.substring(0, r)), (n.objectName = s));
        }
        if (n.propertyName === null || n.propertyName.length === 0)
            throw new Error(
                'PropertyBinding: can not parse propertyName from trackName: ' +
                    e
            );
        return n;
    }
    static findNode(e, t) {
        if (
            t === void 0 ||
            t === '' ||
            t === '.' ||
            t === -1 ||
            t === e.name ||
            t === e.uuid
        )
            return e;
        if (e.skeleton) {
            const n = e.skeleton.getBoneByName(t);
            if (n !== void 0) return n;
        }
        if (e.children) {
            const n = function (s) {
                    for (let a = 0; a < s.length; a++) {
                        const l = s[a];
                        if (l.name === t || l.uuid === t) return l;
                        const c = n(l.children);
                        if (c) return c;
                    }
                    return null;
                },
                r = n(e.children);
            if (r) return r;
        }
        return null;
    }
    _getValue_unavailable() {}
    _setValue_unavailable() {}
    _getValue_direct(e, t) {
        e[t] = this.targetObject[this.propertyName];
    }
    _getValue_array(e, t) {
        const n = this.resolvedProperty;
        for (let r = 0, s = n.length; r !== s; ++r) e[t++] = n[r];
    }
    _getValue_arrayElement(e, t) {
        e[t] = this.resolvedProperty[this.propertyIndex];
    }
    _getValue_toArray(e, t) {
        this.resolvedProperty.toArray(e, t);
    }
    _setValue_direct(e, t) {
        this.targetObject[this.propertyName] = e[t];
    }
    _setValue_direct_setNeedsUpdate(e, t) {
        (this.targetObject[this.propertyName] = e[t]),
            (this.targetObject.needsUpdate = !0);
    }
    _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
        (this.targetObject[this.propertyName] = e[t]),
            (this.targetObject.matrixWorldNeedsUpdate = !0);
    }
    _setValue_array(e, t) {
        const n = this.resolvedProperty;
        for (let r = 0, s = n.length; r !== s; ++r) n[r] = e[t++];
    }
    _setValue_array_setNeedsUpdate(e, t) {
        const n = this.resolvedProperty;
        for (let r = 0, s = n.length; r !== s; ++r) n[r] = e[t++];
        this.targetObject.needsUpdate = !0;
    }
    _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
        const n = this.resolvedProperty;
        for (let r = 0, s = n.length; r !== s; ++r) n[r] = e[t++];
        this.targetObject.matrixWorldNeedsUpdate = !0;
    }
    _setValue_arrayElement(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t];
    }
    _setValue_arrayElement_setNeedsUpdate(e, t) {
        (this.resolvedProperty[this.propertyIndex] = e[t]),
            (this.targetObject.needsUpdate = !0);
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
        (this.resolvedProperty[this.propertyIndex] = e[t]),
            (this.targetObject.matrixWorldNeedsUpdate = !0);
    }
    _setValue_fromArray(e, t) {
        this.resolvedProperty.fromArray(e, t);
    }
    _setValue_fromArray_setNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t),
            (this.targetObject.needsUpdate = !0);
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t),
            (this.targetObject.matrixWorldNeedsUpdate = !0);
    }
    _getValue_unbound(e, t) {
        this.bind(), this.getValue(e, t);
    }
    _setValue_unbound(e, t) {
        this.bind(), this.setValue(e, t);
    }
    bind() {
        let e = this.node;
        const t = this.parsedPath,
            n = t.objectName,
            r = t.propertyName;
        let s = t.propertyIndex;
        if (
            (e ||
                ((e = an.findNode(this.rootNode, t.nodeName)), (this.node = e)),
            (this.getValue = this._getValue_unavailable),
            (this.setValue = this._setValue_unavailable),
            !e)
        ) {
            console.warn(
                'THREE.PropertyBinding: No target node found for track: ' +
                    this.path +
                    '.'
            );
            return;
        }
        if (n) {
            let d = t.objectIndex;
            switch (n) {
                case 'materials':
                    if (!e.material) {
                        console.error(
                            'THREE.PropertyBinding: Can not bind to material as node does not have a material.',
                            this
                        );
                        return;
                    }
                    if (!e.material.materials) {
                        console.error(
                            'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.',
                            this
                        );
                        return;
                    }
                    e = e.material.materials;
                    break;
                case 'bones':
                    if (!e.skeleton) {
                        console.error(
                            'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.',
                            this
                        );
                        return;
                    }
                    e = e.skeleton.bones;
                    for (let p = 0; p < e.length; p++)
                        if (e[p].name === d) {
                            d = p;
                            break;
                        }
                    break;
                case 'map':
                    if ('map' in e) {
                        e = e.map;
                        break;
                    }
                    if (!e.material) {
                        console.error(
                            'THREE.PropertyBinding: Can not bind to material as node does not have a material.',
                            this
                        );
                        return;
                    }
                    if (!e.material.map) {
                        console.error(
                            'THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.',
                            this
                        );
                        return;
                    }
                    e = e.material.map;
                    break;
                default:
                    if (e[n] === void 0) {
                        console.error(
                            'THREE.PropertyBinding: Can not bind to objectName of node undefined.',
                            this
                        );
                        return;
                    }
                    e = e[n];
            }
            if (d !== void 0) {
                if (e[d] === void 0) {
                    console.error(
                        'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.',
                        this,
                        e
                    );
                    return;
                }
                e = e[d];
            }
        }
        const a = e[r];
        if (a === void 0) {
            const d = t.nodeName;
            console.error(
                'THREE.PropertyBinding: Trying to update property for track: ' +
                    d +
                    '.' +
                    r +
                    " but it wasn't found.",
                e
            );
            return;
        }
        let l = this.Versioning.None;
        (this.targetObject = e),
            e.needsUpdate !== void 0
                ? (l = this.Versioning.NeedsUpdate)
                : e.matrixWorldNeedsUpdate !== void 0 &&
                  (l = this.Versioning.MatrixWorldNeedsUpdate);
        let c = this.BindingType.Direct;
        if (s !== void 0) {
            if (r === 'morphTargetInfluences') {
                if (!e.geometry) {
                    console.error(
                        'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.',
                        this
                    );
                    return;
                }
                if (!e.geometry.morphAttributes) {
                    console.error(
                        'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.',
                        this
                    );
                    return;
                }
                e.morphTargetDictionary[s] !== void 0 &&
                    (s = e.morphTargetDictionary[s]);
            }
            (c = this.BindingType.ArrayElement),
                (this.resolvedProperty = a),
                (this.propertyIndex = s);
        } else
            a.fromArray !== void 0 && a.toArray !== void 0
                ? ((c = this.BindingType.HasFromToArray),
                  (this.resolvedProperty = a))
                : Array.isArray(a)
                  ? ((c = this.BindingType.EntireArray),
                    (this.resolvedProperty = a))
                  : (this.propertyName = r);
        (this.getValue = this.GetterByBindingType[c]),
            (this.setValue = this.SetterByBindingTypeAndVersioning[c][l]);
    }
    unbind() {
        (this.node = null),
            (this.getValue = this._getValue_unbound),
            (this.setValue = this._setValue_unbound);
    }
}
an.Composite = UH;
an.prototype.BindingType = {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3,
};
an.prototype.Versioning = {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2,
};
an.prototype.GetterByBindingType = [
    an.prototype._getValue_direct,
    an.prototype._getValue_array,
    an.prototype._getValue_arrayElement,
    an.prototype._getValue_toArray,
];
an.prototype.SetterByBindingTypeAndVersioning = [
    [
        an.prototype._setValue_direct,
        an.prototype._setValue_direct_setNeedsUpdate,
        an.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
    ],
    [
        an.prototype._setValue_array,
        an.prototype._setValue_array_setNeedsUpdate,
        an.prototype._setValue_array_setMatrixWorldNeedsUpdate,
    ],
    [
        an.prototype._setValue_arrayElement,
        an.prototype._setValue_arrayElement_setNeedsUpdate,
        an.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
    ],
    [
        an.prototype._setValue_fromArray,
        an.prototype._setValue_fromArray_setNeedsUpdate,
        an.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
    ],
];
class OH {
    constructor() {
        (this.isAnimationObjectGroup = !0),
            (this.uuid = os()),
            (this._objects = Array.prototype.slice.call(arguments)),
            (this.nCachedObjects_ = 0);
        const e = {};
        this._indicesByUUID = e;
        for (let n = 0, r = arguments.length; n !== r; ++n)
            e[arguments[n].uuid] = n;
        (this._paths = []),
            (this._parsedPaths = []),
            (this._bindings = []),
            (this._bindingsIndicesByPath = {});
        const t = this;
        this.stats = {
            objects: {
                get total() {
                    return t._objects.length;
                },
                get inUse() {
                    return this.total - t.nCachedObjects_;
                },
            },
            get bindingsPerObject() {
                return t._bindings.length;
            },
        };
    }
    add() {
        const e = this._objects,
            t = this._indicesByUUID,
            n = this._paths,
            r = this._parsedPaths,
            s = this._bindings,
            a = s.length;
        let l,
            c = e.length,
            d = this.nCachedObjects_;
        for (let p = 0, g = arguments.length; p !== g; ++p) {
            const y = arguments[p],
                v = y.uuid;
            let S = t[v];
            if (S === void 0) {
                (S = c++), (t[v] = S), e.push(y);
                for (let T = 0, M = a; T !== M; ++T)
                    s[T].push(new an(y, n[T], r[T]));
            } else if (S < d) {
                l = e[S];
                const T = --d,
                    M = e[T];
                (t[M.uuid] = S), (e[S] = M), (t[v] = T), (e[T] = y);
                for (let w = 0, b = a; w !== b; ++w) {
                    const C = s[w],
                        L = C[T];
                    let F = C[S];
                    (C[S] = L),
                        F === void 0 && (F = new an(y, n[w], r[w])),
                        (C[T] = F);
                }
            } else
                e[S] !== l &&
                    console.error(
                        'THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.'
                    );
        }
        this.nCachedObjects_ = d;
    }
    remove() {
        const e = this._objects,
            t = this._indicesByUUID,
            n = this._bindings,
            r = n.length;
        let s = this.nCachedObjects_;
        for (let a = 0, l = arguments.length; a !== l; ++a) {
            const c = arguments[a],
                d = c.uuid,
                p = t[d];
            if (p !== void 0 && p >= s) {
                const g = s++,
                    y = e[g];
                (t[y.uuid] = p), (e[p] = y), (t[d] = g), (e[g] = c);
                for (let v = 0, S = r; v !== S; ++v) {
                    const T = n[v],
                        M = T[g],
                        w = T[p];
                    (T[p] = M), (T[g] = w);
                }
            }
        }
        this.nCachedObjects_ = s;
    }
    uncache() {
        const e = this._objects,
            t = this._indicesByUUID,
            n = this._bindings,
            r = n.length;
        let s = this.nCachedObjects_,
            a = e.length;
        for (let l = 0, c = arguments.length; l !== c; ++l) {
            const d = arguments[l],
                p = d.uuid,
                g = t[p];
            if (g !== void 0)
                if ((delete t[p], g < s)) {
                    const y = --s,
                        v = e[y],
                        S = --a,
                        T = e[S];
                    (t[v.uuid] = g),
                        (e[g] = v),
                        (t[T.uuid] = y),
                        (e[y] = T),
                        e.pop();
                    for (let M = 0, w = r; M !== w; ++M) {
                        const b = n[M],
                            C = b[y],
                            L = b[S];
                        (b[g] = C), (b[y] = L), b.pop();
                    }
                } else {
                    const y = --a,
                        v = e[y];
                    y > 0 && (t[v.uuid] = g), (e[g] = v), e.pop();
                    for (let S = 0, T = r; S !== T; ++S) {
                        const M = n[S];
                        (M[g] = M[y]), M.pop();
                    }
                }
        }
        this.nCachedObjects_ = s;
    }
    subscribe_(e, t) {
        const n = this._bindingsIndicesByPath;
        let r = n[e];
        const s = this._bindings;
        if (r !== void 0) return s[r];
        const a = this._paths,
            l = this._parsedPaths,
            c = this._objects,
            d = c.length,
            p = this.nCachedObjects_,
            g = new Array(d);
        (r = s.length), (n[e] = r), a.push(e), l.push(t), s.push(g);
        for (let y = p, v = c.length; y !== v; ++y) {
            const S = c[y];
            g[y] = new an(S, e, t);
        }
        return g;
    }
    unsubscribe_(e) {
        const t = this._bindingsIndicesByPath,
            n = t[e];
        if (n !== void 0) {
            const r = this._paths,
                s = this._parsedPaths,
                a = this._bindings,
                l = a.length - 1,
                c = a[l],
                d = e[l];
            (t[d] = n),
                (a[n] = c),
                a.pop(),
                (s[n] = s[l]),
                s.pop(),
                (r[n] = r[l]),
                r.pop();
        }
    }
}
class Zb {
    constructor(e, t, n = null, r = t.blendMode) {
        (this._mixer = e),
            (this._clip = t),
            (this._localRoot = n),
            (this.blendMode = r);
        const s = t.tracks,
            a = s.length,
            l = new Array(a),
            c = { endingStart: Yu, endingEnd: Yu };
        for (let d = 0; d !== a; ++d) {
            const p = s[d].createInterpolant(null);
            (l[d] = p), (p.settings = c);
        }
        (this._interpolantSettings = c),
            (this._interpolants = l),
            (this._propertyBindings = new Array(a)),
            (this._cacheIndex = null),
            (this._byClipCacheIndex = null),
            (this._timeScaleInterpolant = null),
            (this._weightInterpolant = null),
            (this.loop = LR),
            (this._loopCount = -1),
            (this._startTime = null),
            (this.time = 0),
            (this.timeScale = 1),
            (this._effectiveTimeScale = 1),
            (this.weight = 1),
            (this._effectiveWeight = 1),
            (this.repetitions = 1 / 0),
            (this.paused = !1),
            (this.enabled = !0),
            (this.clampWhenFinished = !1),
            (this.zeroSlopeAtStart = !0),
            (this.zeroSlopeAtEnd = !0);
    }
    play() {
        return this._mixer._activateAction(this), this;
    }
    stop() {
        return this._mixer._deactivateAction(this), this.reset();
    }
    reset() {
        return (
            (this.paused = !1),
            (this.enabled = !0),
            (this.time = 0),
            (this._loopCount = -1),
            (this._startTime = null),
            this.stopFading().stopWarping()
        );
    }
    isRunning() {
        return (
            this.enabled &&
            !this.paused &&
            this.timeScale !== 0 &&
            this._startTime === null &&
            this._mixer._isActiveAction(this)
        );
    }
    isScheduled() {
        return this._mixer._isActiveAction(this);
    }
    startAt(e) {
        return (this._startTime = e), this;
    }
    setLoop(e, t) {
        return (this.loop = e), (this.repetitions = t), this;
    }
    setEffectiveWeight(e) {
        return (
            (this.weight = e),
            (this._effectiveWeight = this.enabled ? e : 0),
            this.stopFading()
        );
    }
    getEffectiveWeight() {
        return this._effectiveWeight;
    }
    fadeIn(e) {
        return this._scheduleFading(e, 0, 1);
    }
    fadeOut(e) {
        return this._scheduleFading(e, 1, 0);
    }
    crossFadeFrom(e, t, n) {
        if ((e.fadeOut(t), this.fadeIn(t), n)) {
            const r = this._clip.duration,
                s = e._clip.duration,
                a = s / r,
                l = r / s;
            e.warp(1, a, t), this.warp(l, 1, t);
        }
        return this;
    }
    crossFadeTo(e, t, n) {
        return e.crossFadeFrom(this, t, n);
    }
    stopFading() {
        const e = this._weightInterpolant;
        return (
            e !== null &&
                ((this._weightInterpolant = null),
                this._mixer._takeBackControlInterpolant(e)),
            this
        );
    }
    setEffectiveTimeScale(e) {
        return (
            (this.timeScale = e),
            (this._effectiveTimeScale = this.paused ? 0 : e),
            this.stopWarping()
        );
    }
    getEffectiveTimeScale() {
        return this._effectiveTimeScale;
    }
    setDuration(e) {
        return (this.timeScale = this._clip.duration / e), this.stopWarping();
    }
    syncWith(e) {
        return (
            (this.time = e.time),
            (this.timeScale = e.timeScale),
            this.stopWarping()
        );
    }
    halt(e) {
        return this.warp(this._effectiveTimeScale, 0, e);
    }
    warp(e, t, n) {
        const r = this._mixer,
            s = r.time,
            a = this.timeScale;
        let l = this._timeScaleInterpolant;
        l === null &&
            ((l = r._lendControlInterpolant()),
            (this._timeScaleInterpolant = l));
        const c = l.parameterPositions,
            d = l.sampleValues;
        return (c[0] = s), (c[1] = s + n), (d[0] = e / a), (d[1] = t / a), this;
    }
    stopWarping() {
        const e = this._timeScaleInterpolant;
        return (
            e !== null &&
                ((this._timeScaleInterpolant = null),
                this._mixer._takeBackControlInterpolant(e)),
            this
        );
    }
    getMixer() {
        return this._mixer;
    }
    getClip() {
        return this._clip;
    }
    getRoot() {
        return this._localRoot || this._mixer._root;
    }
    _update(e, t, n, r) {
        if (!this.enabled) {
            this._updateWeight(e);
            return;
        }
        const s = this._startTime;
        if (s !== null) {
            const c = (e - s) * n;
            c < 0 || n === 0
                ? (t = 0)
                : ((this._startTime = null), (t = n * c));
        }
        t *= this._updateTimeScale(e);
        const a = this._updateTime(t),
            l = this._updateWeight(e);
        if (l > 0) {
            const c = this._interpolants,
                d = this._propertyBindings;
            switch (this.blendMode) {
                case kS:
                    for (let p = 0, g = c.length; p !== g; ++p)
                        c[p].evaluate(a), d[p].accumulateAdditive(l);
                    break;
                case mv:
                default:
                    for (let p = 0, g = c.length; p !== g; ++p)
                        c[p].evaluate(a), d[p].accumulate(r, l);
            }
        }
    }
    _updateWeight(e) {
        let t = 0;
        if (this.enabled) {
            t = this.weight;
            const n = this._weightInterpolant;
            if (n !== null) {
                const r = n.evaluate(e)[0];
                (t *= r),
                    e > n.parameterPositions[1] &&
                        (this.stopFading(), r === 0 && (this.enabled = !1));
            }
        }
        return (this._effectiveWeight = t), t;
    }
    _updateTimeScale(e) {
        let t = 0;
        if (!this.paused) {
            t = this.timeScale;
            const n = this._timeScaleInterpolant;
            if (n !== null) {
                const r = n.evaluate(e)[0];
                (t *= r),
                    e > n.parameterPositions[1] &&
                        (this.stopWarping(),
                        t === 0 ? (this.paused = !0) : (this.timeScale = t));
            }
        }
        return (this._effectiveTimeScale = t), t;
    }
    _updateTime(e) {
        const t = this._clip.duration,
            n = this.loop;
        let r = this.time + e,
            s = this._loopCount;
        const a = n === IR;
        if (e === 0) return s === -1 ? r : a && (s & 1) === 1 ? t - r : r;
        if (n === PR) {
            s === -1 && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
            e: {
                if (r >= t) r = t;
                else if (r < 0) r = 0;
                else {
                    this.time = r;
                    break e;
                }
                this.clampWhenFinished
                    ? (this.paused = !0)
                    : (this.enabled = !1),
                    (this.time = r),
                    this._mixer.dispatchEvent({
                        type: 'finished',
                        action: this,
                        direction: e < 0 ? -1 : 1,
                    });
            }
        } else {
            if (
                (s === -1 &&
                    (e >= 0
                        ? ((s = 0),
                          this._setEndings(!0, this.repetitions === 0, a))
                        : this._setEndings(this.repetitions === 0, !0, a)),
                r >= t || r < 0)
            ) {
                const l = Math.floor(r / t);
                (r -= t * l), (s += Math.abs(l));
                const c = this.repetitions - s;
                if (c <= 0)
                    this.clampWhenFinished
                        ? (this.paused = !0)
                        : (this.enabled = !1),
                        (r = e > 0 ? t : 0),
                        (this.time = r),
                        this._mixer.dispatchEvent({
                            type: 'finished',
                            action: this,
                            direction: e > 0 ? 1 : -1,
                        });
                else {
                    if (c === 1) {
                        const d = e < 0;
                        this._setEndings(d, !d, a);
                    } else this._setEndings(!1, !1, a);
                    (this._loopCount = s),
                        (this.time = r),
                        this._mixer.dispatchEvent({
                            type: 'loop',
                            action: this,
                            loopDelta: l,
                        });
                }
            } else this.time = r;
            if (a && (s & 1) === 1) return t - r;
        }
        return r;
    }
    _setEndings(e, t, n) {
        const r = this._interpolantSettings;
        n
            ? ((r.endingStart = Ku), (r.endingEnd = Ku))
            : (e
                  ? (r.endingStart = this.zeroSlopeAtStart ? Ku : Yu)
                  : (r.endingStart = Mp),
              t
                  ? (r.endingEnd = this.zeroSlopeAtEnd ? Ku : Yu)
                  : (r.endingEnd = Mp));
    }
    _scheduleFading(e, t, n) {
        const r = this._mixer,
            s = r.time;
        let a = this._weightInterpolant;
        a === null &&
            ((a = r._lendControlInterpolant()), (this._weightInterpolant = a));
        const l = a.parameterPositions,
            c = a.sampleValues;
        return (l[0] = s), (c[0] = t), (l[1] = s + e), (c[1] = n), this;
    }
}
const kH = new Float32Array(1);
class FH extends Ba {
    constructor(e) {
        super(),
            (this._root = e),
            this._initMemoryManager(),
            (this._accuIndex = 0),
            (this.time = 0),
            (this.timeScale = 1);
    }
    _bindAction(e, t) {
        const n = e._localRoot || this._root,
            r = e._clip.tracks,
            s = r.length,
            a = e._propertyBindings,
            l = e._interpolants,
            c = n.uuid,
            d = this._bindingsByRootAndName;
        let p = d[c];
        p === void 0 && ((p = {}), (d[c] = p));
        for (let g = 0; g !== s; ++g) {
            const y = r[g],
                v = y.name;
            let S = p[v];
            if (S !== void 0) ++S.referenceCount, (a[g] = S);
            else {
                if (((S = a[g]), S !== void 0)) {
                    S._cacheIndex === null &&
                        (++S.referenceCount, this._addInactiveBinding(S, c, v));
                    continue;
                }
                const T = t && t._propertyBindings[g].binding.parsedPath;
                (S = new Kb(
                    an.create(n, v, T),
                    y.ValueTypeName,
                    y.getValueSize()
                )),
                    ++S.referenceCount,
                    this._addInactiveBinding(S, c, v),
                    (a[g] = S);
            }
            l[g].resultBuffer = S.buffer;
        }
    }
    _activateAction(e) {
        if (!this._isActiveAction(e)) {
            if (e._cacheIndex === null) {
                const n = (e._localRoot || this._root).uuid,
                    r = e._clip.uuid,
                    s = this._actionsByClip[r];
                this._bindAction(e, s && s.knownActions[0]),
                    this._addInactiveAction(e, r, n);
            }
            const t = e._propertyBindings;
            for (let n = 0, r = t.length; n !== r; ++n) {
                const s = t[n];
                s.useCount++ === 0 &&
                    (this._lendBinding(s), s.saveOriginalState());
            }
            this._lendAction(e);
        }
    }
    _deactivateAction(e) {
        if (this._isActiveAction(e)) {
            const t = e._propertyBindings;
            for (let n = 0, r = t.length; n !== r; ++n) {
                const s = t[n];
                --s.useCount === 0 &&
                    (s.restoreOriginalState(), this._takeBackBinding(s));
            }
            this._takeBackAction(e);
        }
    }
    _initMemoryManager() {
        (this._actions = []),
            (this._nActiveActions = 0),
            (this._actionsByClip = {}),
            (this._bindings = []),
            (this._nActiveBindings = 0),
            (this._bindingsByRootAndName = {}),
            (this._controlInterpolants = []),
            (this._nActiveControlInterpolants = 0);
        const e = this;
        this.stats = {
            actions: {
                get total() {
                    return e._actions.length;
                },
                get inUse() {
                    return e._nActiveActions;
                },
            },
            bindings: {
                get total() {
                    return e._bindings.length;
                },
                get inUse() {
                    return e._nActiveBindings;
                },
            },
            controlInterpolants: {
                get total() {
                    return e._controlInterpolants.length;
                },
                get inUse() {
                    return e._nActiveControlInterpolants;
                },
            },
        };
    }
    _isActiveAction(e) {
        const t = e._cacheIndex;
        return t !== null && t < this._nActiveActions;
    }
    _addInactiveAction(e, t, n) {
        const r = this._actions,
            s = this._actionsByClip;
        let a = s[t];
        if (a === void 0)
            (a = { knownActions: [e], actionByRoot: {} }),
                (e._byClipCacheIndex = 0),
                (s[t] = a);
        else {
            const l = a.knownActions;
            (e._byClipCacheIndex = l.length), l.push(e);
        }
        (e._cacheIndex = r.length), r.push(e), (a.actionByRoot[n] = e);
    }
    _removeInactiveAction(e) {
        const t = this._actions,
            n = t[t.length - 1],
            r = e._cacheIndex;
        (n._cacheIndex = r), (t[r] = n), t.pop(), (e._cacheIndex = null);
        const s = e._clip.uuid,
            a = this._actionsByClip,
            l = a[s],
            c = l.knownActions,
            d = c[c.length - 1],
            p = e._byClipCacheIndex;
        (d._byClipCacheIndex = p),
            (c[p] = d),
            c.pop(),
            (e._byClipCacheIndex = null);
        const g = l.actionByRoot,
            y = (e._localRoot || this._root).uuid;
        delete g[y],
            c.length === 0 && delete a[s],
            this._removeInactiveBindingsForAction(e);
    }
    _removeInactiveBindingsForAction(e) {
        const t = e._propertyBindings;
        for (let n = 0, r = t.length; n !== r; ++n) {
            const s = t[n];
            --s.referenceCount === 0 && this._removeInactiveBinding(s);
        }
    }
    _lendAction(e) {
        const t = this._actions,
            n = e._cacheIndex,
            r = this._nActiveActions++,
            s = t[r];
        (e._cacheIndex = r), (t[r] = e), (s._cacheIndex = n), (t[n] = s);
    }
    _takeBackAction(e) {
        const t = this._actions,
            n = e._cacheIndex,
            r = --this._nActiveActions,
            s = t[r];
        (e._cacheIndex = r), (t[r] = e), (s._cacheIndex = n), (t[n] = s);
    }
    _addInactiveBinding(e, t, n) {
        const r = this._bindingsByRootAndName,
            s = this._bindings;
        let a = r[t];
        a === void 0 && ((a = {}), (r[t] = a)),
            (a[n] = e),
            (e._cacheIndex = s.length),
            s.push(e);
    }
    _removeInactiveBinding(e) {
        const t = this._bindings,
            n = e.binding,
            r = n.rootNode.uuid,
            s = n.path,
            a = this._bindingsByRootAndName,
            l = a[r],
            c = t[t.length - 1],
            d = e._cacheIndex;
        (c._cacheIndex = d),
            (t[d] = c),
            t.pop(),
            delete l[s],
            Object.keys(l).length === 0 && delete a[r];
    }
    _lendBinding(e) {
        const t = this._bindings,
            n = e._cacheIndex,
            r = this._nActiveBindings++,
            s = t[r];
        (e._cacheIndex = r), (t[r] = e), (s._cacheIndex = n), (t[n] = s);
    }
    _takeBackBinding(e) {
        const t = this._bindings,
            n = e._cacheIndex,
            r = --this._nActiveBindings,
            s = t[r];
        (e._cacheIndex = r), (t[r] = e), (s._cacheIndex = n), (t[n] = s);
    }
    _lendControlInterpolant() {
        const e = this._controlInterpolants,
            t = this._nActiveControlInterpolants++;
        let n = e[t];
        return (
            n === void 0 &&
                ((n = new aw(new Float32Array(2), new Float32Array(2), 1, kH)),
                (n.__cacheIndex = t),
                (e[t] = n)),
            n
        );
    }
    _takeBackControlInterpolant(e) {
        const t = this._controlInterpolants,
            n = e.__cacheIndex,
            r = --this._nActiveControlInterpolants,
            s = t[r];
        (e.__cacheIndex = r), (t[r] = e), (s.__cacheIndex = n), (t[n] = s);
    }
    clipAction(e, t, n) {
        const r = t || this._root,
            s = r.uuid;
        let a = typeof e == 'string' ? Op.findByName(r, e) : e;
        const l = a !== null ? a.uuid : e,
            c = this._actionsByClip[l];
        let d = null;
        if (
            (n === void 0 && (a !== null ? (n = a.blendMode) : (n = mv)),
            c !== void 0)
        ) {
            const g = c.actionByRoot[s];
            if (g !== void 0 && g.blendMode === n) return g;
            (d = c.knownActions[0]), a === null && (a = d._clip);
        }
        if (a === null) return null;
        const p = new Zb(this, a, t, n);
        return this._bindAction(p, d), this._addInactiveAction(p, l, s), p;
    }
    existingAction(e, t) {
        const n = t || this._root,
            r = n.uuid,
            s = typeof e == 'string' ? Op.findByName(n, e) : e,
            a = s ? s.uuid : e,
            l = this._actionsByClip[a];
        return (l !== void 0 && l.actionByRoot[r]) || null;
    }
    stopAllAction() {
        const e = this._actions,
            t = this._nActiveActions;
        for (let n = t - 1; n >= 0; --n) e[n].stop();
        return this;
    }
    update(e) {
        e *= this.timeScale;
        const t = this._actions,
            n = this._nActiveActions,
            r = (this.time += e),
            s = Math.sign(e),
            a = (this._accuIndex ^= 1);
        for (let d = 0; d !== n; ++d) t[d]._update(r, e, s, a);
        const l = this._bindings,
            c = this._nActiveBindings;
        for (let d = 0; d !== c; ++d) l[d].apply(a);
        return this;
    }
    setTime(e) {
        this.time = 0;
        for (let t = 0; t < this._actions.length; t++)
            this._actions[t].time = 0;
        return this.update(e);
    }
    getRoot() {
        return this._root;
    }
    uncacheClip(e) {
        const t = this._actions,
            n = e.uuid,
            r = this._actionsByClip,
            s = r[n];
        if (s !== void 0) {
            const a = s.knownActions;
            for (let l = 0, c = a.length; l !== c; ++l) {
                const d = a[l];
                this._deactivateAction(d);
                const p = d._cacheIndex,
                    g = t[t.length - 1];
                (d._cacheIndex = null),
                    (d._byClipCacheIndex = null),
                    (g._cacheIndex = p),
                    (t[p] = g),
                    t.pop(),
                    this._removeInactiveBindingsForAction(d);
            }
            delete r[n];
        }
    }
    uncacheRoot(e) {
        const t = e.uuid,
            n = this._actionsByClip;
        for (const a in n) {
            const l = n[a].actionByRoot,
                c = l[t];
            c !== void 0 &&
                (this._deactivateAction(c), this._removeInactiveAction(c));
        }
        const r = this._bindingsByRootAndName,
            s = r[t];
        if (s !== void 0)
            for (const a in s) {
                const l = s[a];
                l.restoreOriginalState(), this._removeInactiveBinding(l);
            }
    }
    uncacheAction(e, t) {
        const n = this.existingAction(e, t);
        n !== null &&
            (this._deactivateAction(n), this._removeInactiveAction(n));
    }
}
class mw {
    constructor(e) {
        this.value = e;
    }
    clone() {
        return new mw(
            this.value.clone === void 0 ? this.value : this.value.clone()
        );
    }
}
let BH = 0;
class zH extends Ba {
    constructor() {
        super(),
            (this.isUniformsGroup = !0),
            Object.defineProperty(this, 'id', { value: BH++ }),
            (this.name = ''),
            (this.usage = Cp),
            (this.uniforms = []);
    }
    add(e) {
        return this.uniforms.push(e), this;
    }
    remove(e) {
        const t = this.uniforms.indexOf(e);
        return t !== -1 && this.uniforms.splice(t, 1), this;
    }
    setName(e) {
        return (this.name = e), this;
    }
    setUsage(e) {
        return (this.usage = e), this;
    }
    dispose() {
        return this.dispatchEvent({ type: 'dispose' }), this;
    }
    copy(e) {
        (this.name = e.name), (this.usage = e.usage);
        const t = e.uniforms;
        this.uniforms.length = 0;
        for (let n = 0, r = t.length; n < r; n++) {
            const s = Array.isArray(t[n]) ? t[n] : [t[n]];
            for (let a = 0; a < s.length; a++) this.uniforms.push(s[a].clone());
        }
        return this;
    }
    clone() {
        return new this.constructor().copy(this);
    }
}
class VH extends Sv {
    constructor(e, t, n = 1) {
        super(e, t),
            (this.isInstancedInterleavedBuffer = !0),
            (this.meshPerAttribute = n);
    }
    copy(e) {
        return (
            super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this
        );
    }
    clone(e) {
        const t = super.clone(e);
        return (t.meshPerAttribute = this.meshPerAttribute), t;
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return (
            (t.isInstancedInterleavedBuffer = !0),
            (t.meshPerAttribute = this.meshPerAttribute),
            t
        );
    }
}
class HH {
    constructor(e, t, n, r, s) {
        (this.isGLBufferAttribute = !0),
            (this.name = ''),
            (this.buffer = e),
            (this.type = t),
            (this.itemSize = n),
            (this.elementSize = r),
            (this.count = s),
            (this.version = 0);
    }
    set needsUpdate(e) {
        e === !0 && this.version++;
    }
    setBuffer(e) {
        return (this.buffer = e), this;
    }
    setType(e, t) {
        return (this.type = e), (this.elementSize = t), this;
    }
    setItemSize(e) {
        return (this.itemSize = e), this;
    }
    setCount(e) {
        return (this.count = e), this;
    }
}
const ZE = new Pt();
class gw {
    constructor(e, t, n = 0, r = 1 / 0) {
        (this.ray = new Eh(e, t)),
            (this.near = n),
            (this.far = r),
            (this.camera = null),
            (this.layers = new sc()),
            (this.params = {
                Mesh: {},
                Line: { threshold: 1 },
                LOD: {},
                Points: { threshold: 1 },
                Sprite: {},
            });
    }
    set(e, t) {
        this.ray.set(e, t);
    }
    setFromCamera(e, t) {
        t.isPerspectiveCamera
            ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
              this.ray.direction
                  .set(e.x, e.y, 0.5)
                  .unproject(t)
                  .sub(this.ray.origin)
                  .normalize(),
              (this.camera = t))
            : t.isOrthographicCamera
              ? (this.ray.origin
                    .set(e.x, e.y, (t.near + t.far) / (t.near - t.far))
                    .unproject(t),
                this.ray.direction
                    .set(0, 0, -1)
                    .transformDirection(t.matrixWorld),
                (this.camera = t))
              : console.error(
                    'THREE.Raycaster: Unsupported camera type: ' + t.type
                );
    }
    setFromXRController(e) {
        return (
            ZE.identity().extractRotation(e.matrixWorld),
            this.ray.origin.setFromMatrixPosition(e.matrixWorld),
            this.ray.direction.set(0, 0, -1).applyMatrix4(ZE),
            this
        );
    }
    intersectObject(e, t = !0, n = []) {
        return A_(e, this, n, t), n.sort(JE), n;
    }
    intersectObjects(e, t = !0, n = []) {
        for (let r = 0, s = e.length; r < s; r++) A_(e[r], this, n, t);
        return n.sort(JE), n;
    }
}
function JE(i, e) {
    return i.distance - e.distance;
}
function A_(i, e, t, n) {
    let r = !0;
    if (
        (i.layers.test(e.layers) && i.raycast(e, t) === !1 && (r = !1),
        r === !0 && n === !0)
    ) {
        const s = i.children;
        for (let a = 0, l = s.length; a < l; a++) A_(s[a], e, t, !0);
    }
}
class GH {
    constructor(e = 1, t = 0, n = 0) {
        return (this.radius = e), (this.phi = t), (this.theta = n), this;
    }
    set(e, t, n) {
        return (this.radius = e), (this.phi = t), (this.theta = n), this;
    }
    copy(e) {
        return (
            (this.radius = e.radius),
            (this.phi = e.phi),
            (this.theta = e.theta),
            this
        );
    }
    makeSafe() {
        return (
            (this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))),
            this
        );
    }
    setFromVector3(e) {
        return this.setFromCartesianCoords(e.x, e.y, e.z);
    }
    setFromCartesianCoords(e, t, n) {
        return (
            (this.radius = Math.sqrt(e * e + t * t + n * n)),
            this.radius === 0
                ? ((this.theta = 0), (this.phi = 0))
                : ((this.theta = Math.atan2(e, n)),
                  (this.phi = Math.acos(Jn(t / this.radius, -1, 1)))),
            this
        );
    }
    clone() {
        return new this.constructor().copy(this);
    }
}
class WH {
    constructor(e = 1, t = 0, n = 0) {
        return (this.radius = e), (this.theta = t), (this.y = n), this;
    }
    set(e, t, n) {
        return (this.radius = e), (this.theta = t), (this.y = n), this;
    }
    copy(e) {
        return (
            (this.radius = e.radius),
            (this.theta = e.theta),
            (this.y = e.y),
            this
        );
    }
    setFromVector3(e) {
        return this.setFromCartesianCoords(e.x, e.y, e.z);
    }
    setFromCartesianCoords(e, t, n) {
        return (
            (this.radius = Math.sqrt(e * e + n * n)),
            (this.theta = Math.atan2(e, n)),
            (this.y = t),
            this
        );
    }
    clone() {
        return new this.constructor().copy(this);
    }
}
const QE = new Ce();
class XH {
    constructor(e = new Ce(1 / 0, 1 / 0), t = new Ce(-1 / 0, -1 / 0)) {
        (this.isBox2 = !0), (this.min = e), (this.max = t);
    }
    set(e, t) {
        return this.min.copy(e), this.max.copy(t), this;
    }
    setFromPoints(e) {
        this.makeEmpty();
        for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
        return this;
    }
    setFromCenterAndSize(e, t) {
        const n = QE.copy(t).multiplyScalar(0.5);
        return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(e) {
        return this.min.copy(e.min), this.max.copy(e.max), this;
    }
    makeEmpty() {
        return (
            (this.min.x = this.min.y = 1 / 0),
            (this.max.x = this.max.y = -1 / 0),
            this
        );
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y;
    }
    getCenter(e) {
        return this.isEmpty()
            ? e.set(0, 0)
            : e.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
    getSize(e) {
        return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
    }
    expandByPoint(e) {
        return this.min.min(e), this.max.max(e), this;
    }
    expandByVector(e) {
        return this.min.sub(e), this.max.add(e), this;
    }
    expandByScalar(e) {
        return this.min.addScalar(-e), this.max.addScalar(e), this;
    }
    containsPoint(e) {
        return !(
            e.x < this.min.x ||
            e.x > this.max.x ||
            e.y < this.min.y ||
            e.y > this.max.y
        );
    }
    containsBox(e) {
        return (
            this.min.x <= e.min.x &&
            e.max.x <= this.max.x &&
            this.min.y <= e.min.y &&
            e.max.y <= this.max.y
        );
    }
    getParameter(e, t) {
        return t.set(
            (e.x - this.min.x) / (this.max.x - this.min.x),
            (e.y - this.min.y) / (this.max.y - this.min.y)
        );
    }
    intersectsBox(e) {
        return !(
            e.max.x < this.min.x ||
            e.min.x > this.max.x ||
            e.max.y < this.min.y ||
            e.min.y > this.max.y
        );
    }
    clampPoint(e, t) {
        return t.copy(e).clamp(this.min, this.max);
    }
    distanceToPoint(e) {
        return this.clampPoint(e, QE).distanceTo(e);
    }
    intersect(e) {
        return (
            this.min.max(e.min),
            this.max.min(e.max),
            this.isEmpty() && this.makeEmpty(),
            this
        );
    }
    union(e) {
        return this.min.min(e.min), this.max.max(e.max), this;
    }
    translate(e) {
        return this.min.add(e), this.max.add(e), this;
    }
    equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max);
    }
}
const eT = new j(),
    Wg = new j();
class jH {
    constructor(e = new j(), t = new j()) {
        (this.start = e), (this.end = t);
    }
    set(e, t) {
        return this.start.copy(e), this.end.copy(t), this;
    }
    copy(e) {
        return this.start.copy(e.start), this.end.copy(e.end), this;
    }
    getCenter(e) {
        return e.addVectors(this.start, this.end).multiplyScalar(0.5);
    }
    delta(e) {
        return e.subVectors(this.end, this.start);
    }
    distanceSq() {
        return this.start.distanceToSquared(this.end);
    }
    distance() {
        return this.start.distanceTo(this.end);
    }
    at(e, t) {
        return this.delta(t).multiplyScalar(e).add(this.start);
    }
    closestPointToPointParameter(e, t) {
        eT.subVectors(e, this.start), Wg.subVectors(this.end, this.start);
        const n = Wg.dot(Wg);
        let s = Wg.dot(eT) / n;
        return t && (s = Jn(s, 0, 1)), s;
    }
    closestPointToPoint(e, t, n) {
        const r = this.closestPointToPointParameter(e, t);
        return this.delta(n).multiplyScalar(r).add(this.start);
    }
    applyMatrix4(e) {
        return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
    }
    equals(e) {
        return e.start.equals(this.start) && e.end.equals(this.end);
    }
    clone() {
        return new this.constructor().copy(this);
    }
}
const tT = new j();
class qH extends ln {
    constructor(e, t) {
        super(),
            (this.light = e),
            (this.matrixAutoUpdate = !1),
            (this.color = t),
            (this.type = 'SpotLightHelper');
        const n = new $t(),
            r = [
                0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0,
                0, 1, 1, 0, 0, 0, 0, -1, 1,
            ];
        for (let a = 0, l = 1, c = 32; a < c; a++, l++) {
            const d = (a / c) * Math.PI * 2,
                p = (l / c) * Math.PI * 2;
            r.push(Math.cos(d), Math.sin(d), 1, Math.cos(p), Math.sin(p), 1);
        }
        n.setAttribute('position', new vt(r, 3));
        const s = new Ar({ fog: !1, toneMapped: !1 });
        (this.cone = new Vo(n, s)), this.add(this.cone), this.update();
    }
    dispose() {
        this.cone.geometry.dispose(), this.cone.material.dispose();
    }
    update() {
        this.light.updateWorldMatrix(!0, !1),
            this.light.target.updateWorldMatrix(!0, !1),
            this.parent
                ? (this.parent.updateWorldMatrix(!0),
                  this.matrix
                      .copy(this.parent.matrixWorld)
                      .invert()
                      .multiply(this.light.matrixWorld))
                : this.matrix.copy(this.light.matrixWorld),
            this.matrixWorld.copy(this.light.matrixWorld);
        const e = this.light.distance ? this.light.distance : 1e3,
            t = e * Math.tan(this.light.angle);
        this.cone.scale.set(t, t, e),
            tT.setFromMatrixPosition(this.light.target.matrixWorld),
            this.cone.lookAt(tT),
            this.color !== void 0
                ? this.cone.material.color.set(this.color)
                : this.cone.material.color.copy(this.light.color);
    }
}
const Cl = new j(),
    Xg = new Pt(),
    Ex = new Pt();
class $H extends Vo {
    constructor(e) {
        const t = Jb(e),
            n = new $t(),
            r = [],
            s = [],
            a = new st(0, 0, 1),
            l = new st(0, 1, 0);
        for (let d = 0; d < t.length; d++) {
            const p = t[d];
            p.parent &&
                p.parent.isBone &&
                (r.push(0, 0, 0),
                r.push(0, 0, 0),
                s.push(a.r, a.g, a.b),
                s.push(l.r, l.g, l.b));
        }
        n.setAttribute('position', new vt(r, 3)),
            n.setAttribute('color', new vt(s, 3));
        const c = new Ar({
            vertexColors: !0,
            depthTest: !1,
            depthWrite: !1,
            toneMapped: !1,
            transparent: !0,
        });
        super(n, c),
            (this.isSkeletonHelper = !0),
            (this.type = 'SkeletonHelper'),
            (this.root = e),
            (this.bones = t),
            (this.matrix = e.matrixWorld),
            (this.matrixAutoUpdate = !1);
    }
    updateMatrixWorld(e) {
        const t = this.bones,
            n = this.geometry,
            r = n.getAttribute('position');
        Ex.copy(this.root.matrixWorld).invert();
        for (let s = 0, a = 0; s < t.length; s++) {
            const l = t[s];
            l.parent &&
                l.parent.isBone &&
                (Xg.multiplyMatrices(Ex, l.matrixWorld),
                Cl.setFromMatrixPosition(Xg),
                r.setXYZ(a, Cl.x, Cl.y, Cl.z),
                Xg.multiplyMatrices(Ex, l.parent.matrixWorld),
                Cl.setFromMatrixPosition(Xg),
                r.setXYZ(a + 1, Cl.x, Cl.y, Cl.z),
                (a += 2));
        }
        (n.getAttribute('position').needsUpdate = !0),
            super.updateMatrixWorld(e);
    }
    dispose() {
        this.geometry.dispose(), this.material.dispose();
    }
}
function Jb(i) {
    const e = [];
    i.isBone === !0 && e.push(i);
    for (let t = 0; t < i.children.length; t++)
        e.push.apply(e, Jb(i.children[t]));
    return e;
}
class YH extends di {
    constructor(e, t, n) {
        const r = new nm(t, 4, 2),
            s = new zl({ wireframe: !0, fog: !1, toneMapped: !1 });
        super(r, s),
            (this.light = e),
            (this.color = n),
            (this.type = 'PointLightHelper'),
            (this.matrix = this.light.matrixWorld),
            (this.matrixAutoUpdate = !1),
            this.update();
    }
    dispose() {
        this.geometry.dispose(), this.material.dispose();
    }
    update() {
        this.light.updateWorldMatrix(!0, !1),
            this.color !== void 0
                ? this.material.color.set(this.color)
                : this.material.color.copy(this.light.color);
    }
}
const KH = new j(),
    nT = new st(),
    iT = new st();
class ZH extends ln {
    constructor(e, t, n) {
        super(),
            (this.light = e),
            (this.matrix = e.matrixWorld),
            (this.matrixAutoUpdate = !1),
            (this.color = n),
            (this.type = 'HemisphereLightHelper');
        const r = new tm(t);
        r.rotateY(Math.PI * 0.5),
            (this.material = new zl({
                wireframe: !0,
                fog: !1,
                toneMapped: !1,
            })),
            this.color === void 0 && (this.material.vertexColors = !0);
        const s = r.getAttribute('position'),
            a = new Float32Array(s.count * 3);
        r.setAttribute('color', new Mn(a, 3)),
            this.add(new di(r, this.material)),
            this.update();
    }
    dispose() {
        this.children[0].geometry.dispose(),
            this.children[0].material.dispose();
    }
    update() {
        const e = this.children[0];
        if (this.color !== void 0) this.material.color.set(this.color);
        else {
            const t = e.geometry.getAttribute('color');
            nT.copy(this.light.color), iT.copy(this.light.groundColor);
            for (let n = 0, r = t.count; n < r; n++) {
                const s = n < r / 2 ? nT : iT;
                t.setXYZ(n, s.r, s.g, s.b);
            }
            t.needsUpdate = !0;
        }
        this.light.updateWorldMatrix(!0, !1),
            e.lookAt(KH.setFromMatrixPosition(this.light.matrixWorld).negate());
    }
}
class JH extends Vo {
    constructor(e = 10, t = 10, n = 4473924, r = 8947848) {
        (n = new st(n)), (r = new st(r));
        const s = t / 2,
            a = e / t,
            l = e / 2,
            c = [],
            d = [];
        for (let y = 0, v = 0, S = -l; y <= t; y++, S += a) {
            c.push(-l, 0, S, l, 0, S), c.push(S, 0, -l, S, 0, l);
            const T = y === s ? n : r;
            T.toArray(d, v),
                (v += 3),
                T.toArray(d, v),
                (v += 3),
                T.toArray(d, v),
                (v += 3),
                T.toArray(d, v),
                (v += 3);
        }
        const p = new $t();
        p.setAttribute('position', new vt(c, 3)),
            p.setAttribute('color', new vt(d, 3));
        const g = new Ar({ vertexColors: !0, toneMapped: !1 });
        super(p, g), (this.type = 'GridHelper');
    }
    dispose() {
        this.geometry.dispose(), this.material.dispose();
    }
}
class QH extends Vo {
    constructor(e = 10, t = 16, n = 8, r = 64, s = 4473924, a = 8947848) {
        (s = new st(s)), (a = new st(a));
        const l = [],
            c = [];
        if (t > 1)
            for (let g = 0; g < t; g++) {
                const y = (g / t) * (Math.PI * 2),
                    v = Math.sin(y) * e,
                    S = Math.cos(y) * e;
                l.push(0, 0, 0), l.push(v, 0, S);
                const T = g & 1 ? s : a;
                c.push(T.r, T.g, T.b), c.push(T.r, T.g, T.b);
            }
        for (let g = 0; g < n; g++) {
            const y = g & 1 ? s : a,
                v = e - (e / n) * g;
            for (let S = 0; S < r; S++) {
                let T = (S / r) * (Math.PI * 2),
                    M = Math.sin(T) * v,
                    w = Math.cos(T) * v;
                l.push(M, 0, w),
                    c.push(y.r, y.g, y.b),
                    (T = ((S + 1) / r) * (Math.PI * 2)),
                    (M = Math.sin(T) * v),
                    (w = Math.cos(T) * v),
                    l.push(M, 0, w),
                    c.push(y.r, y.g, y.b);
            }
        }
        const d = new $t();
        d.setAttribute('position', new vt(l, 3)),
            d.setAttribute('color', new vt(c, 3));
        const p = new Ar({ vertexColors: !0, toneMapped: !1 });
        super(d, p), (this.type = 'PolarGridHelper');
    }
    dispose() {
        this.geometry.dispose(), this.material.dispose();
    }
}
const rT = new j(),
    jg = new j(),
    sT = new j();
class e5 extends ln {
    constructor(e, t, n) {
        super(),
            (this.light = e),
            (this.matrix = e.matrixWorld),
            (this.matrixAutoUpdate = !1),
            (this.color = n),
            (this.type = 'DirectionalLightHelper'),
            t === void 0 && (t = 1);
        let r = new $t();
        r.setAttribute(
            'position',
            new vt([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3)
        );
        const s = new Ar({ fog: !1, toneMapped: !1 });
        (this.lightPlane = new Ul(r, s)),
            this.add(this.lightPlane),
            (r = new $t()),
            r.setAttribute('position', new vt([0, 0, 0, 0, 0, 1], 3)),
            (this.targetLine = new Ul(r, s)),
            this.add(this.targetLine),
            this.update();
    }
    dispose() {
        this.lightPlane.geometry.dispose(),
            this.lightPlane.material.dispose(),
            this.targetLine.geometry.dispose(),
            this.targetLine.material.dispose();
    }
    update() {
        this.light.updateWorldMatrix(!0, !1),
            this.light.target.updateWorldMatrix(!0, !1),
            rT.setFromMatrixPosition(this.light.matrixWorld),
            jg.setFromMatrixPosition(this.light.target.matrixWorld),
            sT.subVectors(jg, rT),
            this.lightPlane.lookAt(jg),
            this.color !== void 0
                ? (this.lightPlane.material.color.set(this.color),
                  this.targetLine.material.color.set(this.color))
                : (this.lightPlane.material.color.copy(this.light.color),
                  this.targetLine.material.color.copy(this.light.color)),
            this.targetLine.lookAt(jg),
            (this.targetLine.scale.z = sT.length());
    }
}
const qg = new j(),
    Kn = new Kp();
class t5 extends Vo {
    constructor(e) {
        const t = new $t(),
            n = new Ar({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
            r = [],
            s = [],
            a = {};
        l('n1', 'n2'),
            l('n2', 'n4'),
            l('n4', 'n3'),
            l('n3', 'n1'),
            l('f1', 'f2'),
            l('f2', 'f4'),
            l('f4', 'f3'),
            l('f3', 'f1'),
            l('n1', 'f1'),
            l('n2', 'f2'),
            l('n3', 'f3'),
            l('n4', 'f4'),
            l('p', 'n1'),
            l('p', 'n2'),
            l('p', 'n3'),
            l('p', 'n4'),
            l('u1', 'u2'),
            l('u2', 'u3'),
            l('u3', 'u1'),
            l('c', 't'),
            l('p', 'c'),
            l('cn1', 'cn2'),
            l('cn3', 'cn4'),
            l('cf1', 'cf2'),
            l('cf3', 'cf4');
        function l(S, T) {
            c(S), c(T);
        }
        function c(S) {
            r.push(0, 0, 0),
                s.push(0, 0, 0),
                a[S] === void 0 && (a[S] = []),
                a[S].push(r.length / 3 - 1);
        }
        t.setAttribute('position', new vt(r, 3)),
            t.setAttribute('color', new vt(s, 3)),
            super(t, n),
            (this.type = 'CameraHelper'),
            (this.camera = e),
            this.camera.updateProjectionMatrix &&
                this.camera.updateProjectionMatrix(),
            (this.matrix = e.matrixWorld),
            (this.matrixAutoUpdate = !1),
            (this.pointMap = a),
            this.update();
        const d = new st(16755200),
            p = new st(16711680),
            g = new st(43775),
            y = new st(16777215),
            v = new st(3355443);
        this.setColors(d, p, g, y, v);
    }
    setColors(e, t, n, r, s) {
        const l = this.geometry.getAttribute('color');
        l.setXYZ(0, e.r, e.g, e.b),
            l.setXYZ(1, e.r, e.g, e.b),
            l.setXYZ(2, e.r, e.g, e.b),
            l.setXYZ(3, e.r, e.g, e.b),
            l.setXYZ(4, e.r, e.g, e.b),
            l.setXYZ(5, e.r, e.g, e.b),
            l.setXYZ(6, e.r, e.g, e.b),
            l.setXYZ(7, e.r, e.g, e.b),
            l.setXYZ(8, e.r, e.g, e.b),
            l.setXYZ(9, e.r, e.g, e.b),
            l.setXYZ(10, e.r, e.g, e.b),
            l.setXYZ(11, e.r, e.g, e.b),
            l.setXYZ(12, e.r, e.g, e.b),
            l.setXYZ(13, e.r, e.g, e.b),
            l.setXYZ(14, e.r, e.g, e.b),
            l.setXYZ(15, e.r, e.g, e.b),
            l.setXYZ(16, e.r, e.g, e.b),
            l.setXYZ(17, e.r, e.g, e.b),
            l.setXYZ(18, e.r, e.g, e.b),
            l.setXYZ(19, e.r, e.g, e.b),
            l.setXYZ(20, e.r, e.g, e.b),
            l.setXYZ(21, e.r, e.g, e.b),
            l.setXYZ(22, e.r, e.g, e.b),
            l.setXYZ(23, e.r, e.g, e.b),
            l.setXYZ(24, t.r, t.g, t.b),
            l.setXYZ(25, t.r, t.g, t.b),
            l.setXYZ(26, t.r, t.g, t.b),
            l.setXYZ(27, t.r, t.g, t.b),
            l.setXYZ(28, t.r, t.g, t.b),
            l.setXYZ(29, t.r, t.g, t.b),
            l.setXYZ(30, t.r, t.g, t.b),
            l.setXYZ(31, t.r, t.g, t.b),
            l.setXYZ(32, n.r, n.g, n.b),
            l.setXYZ(33, n.r, n.g, n.b),
            l.setXYZ(34, n.r, n.g, n.b),
            l.setXYZ(35, n.r, n.g, n.b),
            l.setXYZ(36, n.r, n.g, n.b),
            l.setXYZ(37, n.r, n.g, n.b),
            l.setXYZ(38, r.r, r.g, r.b),
            l.setXYZ(39, r.r, r.g, r.b),
            l.setXYZ(40, s.r, s.g, s.b),
            l.setXYZ(41, s.r, s.g, s.b),
            l.setXYZ(42, s.r, s.g, s.b),
            l.setXYZ(43, s.r, s.g, s.b),
            l.setXYZ(44, s.r, s.g, s.b),
            l.setXYZ(45, s.r, s.g, s.b),
            l.setXYZ(46, s.r, s.g, s.b),
            l.setXYZ(47, s.r, s.g, s.b),
            l.setXYZ(48, s.r, s.g, s.b),
            l.setXYZ(49, s.r, s.g, s.b),
            (l.needsUpdate = !0);
    }
    update() {
        const e = this.geometry,
            t = this.pointMap,
            n = 1,
            r = 1;
        Kn.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
            ii('c', t, e, Kn, 0, 0, -1),
            ii('t', t, e, Kn, 0, 0, 1),
            ii('n1', t, e, Kn, -1, -1, -1),
            ii('n2', t, e, Kn, n, -1, -1),
            ii('n3', t, e, Kn, -1, r, -1),
            ii('n4', t, e, Kn, n, r, -1),
            ii('f1', t, e, Kn, -1, -1, 1),
            ii('f2', t, e, Kn, n, -1, 1),
            ii('f3', t, e, Kn, -1, r, 1),
            ii('f4', t, e, Kn, n, r, 1),
            ii('u1', t, e, Kn, n * 0.7, r * 1.1, -1),
            ii('u2', t, e, Kn, -1 * 0.7, r * 1.1, -1),
            ii('u3', t, e, Kn, 0, r * 2, -1),
            ii('cf1', t, e, Kn, -1, 0, 1),
            ii('cf2', t, e, Kn, n, 0, 1),
            ii('cf3', t, e, Kn, 0, -1, 1),
            ii('cf4', t, e, Kn, 0, r, 1),
            ii('cn1', t, e, Kn, -1, 0, -1),
            ii('cn2', t, e, Kn, n, 0, -1),
            ii('cn3', t, e, Kn, 0, -1, -1),
            ii('cn4', t, e, Kn, 0, r, -1),
            (e.getAttribute('position').needsUpdate = !0);
    }
    dispose() {
        this.geometry.dispose(), this.material.dispose();
    }
}
function ii(i, e, t, n, r, s, a) {
    qg.set(r, s, a).unproject(n);
    const l = e[i];
    if (l !== void 0) {
        const c = t.getAttribute('position');
        for (let d = 0, p = l.length; d < p; d++)
            c.setXYZ(l[d], qg.x, qg.y, qg.z);
    }
}
const $g = new Tr();
class n5 extends Vo {
    constructor(e, t = 16776960) {
        const n = new Uint16Array([
                0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2,
                6, 3, 7,
            ]),
            r = new Float32Array(8 * 3),
            s = new $t();
        s.setIndex(new Mn(n, 1)),
            s.setAttribute('position', new Mn(r, 3)),
            super(s, new Ar({ color: t, toneMapped: !1 })),
            (this.object = e),
            (this.type = 'BoxHelper'),
            (this.matrixAutoUpdate = !1),
            this.update();
    }
    update(e) {
        if (
            (e !== void 0 &&
                console.warn(
                    'THREE.BoxHelper: .update() has no longer arguments.'
                ),
            this.object !== void 0 && $g.setFromObject(this.object),
            $g.isEmpty())
        )
            return;
        const t = $g.min,
            n = $g.max,
            r = this.geometry.attributes.position,
            s = r.array;
        (s[0] = n.x),
            (s[1] = n.y),
            (s[2] = n.z),
            (s[3] = t.x),
            (s[4] = n.y),
            (s[5] = n.z),
            (s[6] = t.x),
            (s[7] = t.y),
            (s[8] = n.z),
            (s[9] = n.x),
            (s[10] = t.y),
            (s[11] = n.z),
            (s[12] = n.x),
            (s[13] = n.y),
            (s[14] = t.z),
            (s[15] = t.x),
            (s[16] = n.y),
            (s[17] = t.z),
            (s[18] = t.x),
            (s[19] = t.y),
            (s[20] = t.z),
            (s[21] = n.x),
            (s[22] = t.y),
            (s[23] = t.z),
            (r.needsUpdate = !0),
            this.geometry.computeBoundingSphere();
    }
    setFromObject(e) {
        return (this.object = e), this.update(), this;
    }
    copy(e, t) {
        return super.copy(e, t), (this.object = e.object), this;
    }
    dispose() {
        this.geometry.dispose(), this.material.dispose();
    }
}
class i5 extends Vo {
    constructor(e, t = 16776960) {
        const n = new Uint16Array([
                0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2,
                6, 3, 7,
            ]),
            r = [
                1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1,
                -1, -1, 1, -1, -1,
            ],
            s = new $t();
        s.setIndex(new Mn(n, 1)),
            s.setAttribute('position', new vt(r, 3)),
            super(s, new Ar({ color: t, toneMapped: !1 })),
            (this.box = e),
            (this.type = 'Box3Helper'),
            this.geometry.computeBoundingSphere();
    }
    updateMatrixWorld(e) {
        const t = this.box;
        t.isEmpty() ||
            (t.getCenter(this.position),
            t.getSize(this.scale),
            this.scale.multiplyScalar(0.5),
            super.updateMatrixWorld(e));
    }
    dispose() {
        this.geometry.dispose(), this.material.dispose();
    }
}
class r5 extends Ul {
    constructor(e, t = 1, n = 16776960) {
        const r = n,
            s = [
                1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1,
                -1, 0, 1, 1, 0,
            ],
            a = new $t();
        a.setAttribute('position', new vt(s, 3)),
            a.computeBoundingSphere(),
            super(a, new Ar({ color: r, toneMapped: !1 })),
            (this.type = 'PlaneHelper'),
            (this.plane = e),
            (this.size = t);
        const l = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],
            c = new $t();
        c.setAttribute('position', new vt(l, 3)),
            c.computeBoundingSphere(),
            this.add(
                new di(
                    c,
                    new zl({
                        color: r,
                        opacity: 0.2,
                        transparent: !0,
                        depthWrite: !1,
                        toneMapped: !1,
                    })
                )
            );
    }
    updateMatrixWorld(e) {
        this.position.set(0, 0, 0),
            this.scale.set(0.5 * this.size, 0.5 * this.size, 1),
            this.lookAt(this.plane.normal),
            this.translateZ(-this.plane.constant),
            super.updateMatrixWorld(e);
    }
    dispose() {
        this.geometry.dispose(),
            this.material.dispose(),
            this.children[0].geometry.dispose(),
            this.children[0].material.dispose();
    }
}
const oT = new j();
let Yg, Tx;
class s5 extends ln {
    constructor(
        e = new j(0, 0, 1),
        t = new j(0, 0, 0),
        n = 1,
        r = 16776960,
        s = n * 0.2,
        a = s * 0.2
    ) {
        super(),
            (this.type = 'ArrowHelper'),
            Yg === void 0 &&
                ((Yg = new $t()),
                Yg.setAttribute('position', new vt([0, 0, 0, 0, 1, 0], 3)),
                (Tx = new Ch(0, 0.5, 1, 5, 1)),
                Tx.translate(0, -0.5, 0)),
            this.position.copy(t),
            (this.line = new Ul(Yg, new Ar({ color: r, toneMapped: !1 }))),
            (this.line.matrixAutoUpdate = !1),
            this.add(this.line),
            (this.cone = new di(Tx, new zl({ color: r, toneMapped: !1 }))),
            (this.cone.matrixAutoUpdate = !1),
            this.add(this.cone),
            this.setDirection(e),
            this.setLength(n, s, a);
    }
    setDirection(e) {
        if (e.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
        else if (e.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
        else {
            oT.set(e.z, 0, -e.x).normalize();
            const t = Math.acos(e.y);
            this.quaternion.setFromAxisAngle(oT, t);
        }
    }
    setLength(e, t = e * 0.2, n = t * 0.2) {
        this.line.scale.set(1, Math.max(1e-4, e - t), 1),
            this.line.updateMatrix(),
            this.cone.scale.set(n, t, n),
            (this.cone.position.y = e),
            this.cone.updateMatrix();
    }
    setColor(e) {
        this.line.material.color.set(e), this.cone.material.color.set(e);
    }
    copy(e) {
        return (
            super.copy(e, !1),
            this.line.copy(e.line),
            this.cone.copy(e.cone),
            this
        );
    }
    dispose() {
        this.line.geometry.dispose(),
            this.line.material.dispose(),
            this.cone.geometry.dispose(),
            this.cone.material.dispose();
    }
}
class o5 extends Vo {
    constructor(e = 1) {
        const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
            n = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
            r = new $t();
        r.setAttribute('position', new vt(t, 3)),
            r.setAttribute('color', new vt(n, 3));
        const s = new Ar({ vertexColors: !0, toneMapped: !1 });
        super(r, s), (this.type = 'AxesHelper');
    }
    setColors(e, t, n) {
        const r = new st(),
            s = this.geometry.attributes.color.array;
        return (
            r.set(e),
            r.toArray(s, 0),
            r.toArray(s, 3),
            r.set(t),
            r.toArray(s, 6),
            r.toArray(s, 9),
            r.set(n),
            r.toArray(s, 12),
            r.toArray(s, 15),
            (this.geometry.attributes.color.needsUpdate = !0),
            this
        );
    }
    dispose() {
        this.geometry.dispose(), this.material.dispose();
    }
}
class a5 {
    constructor() {
        (this.type = 'ShapePath'),
            (this.color = new st()),
            (this.subPaths = []),
            (this.currentPath = null);
    }
    moveTo(e, t) {
        return (
            (this.currentPath = new Pp()),
            this.subPaths.push(this.currentPath),
            this.currentPath.moveTo(e, t),
            this
        );
    }
    lineTo(e, t) {
        return this.currentPath.lineTo(e, t), this;
    }
    quadraticCurveTo(e, t, n, r) {
        return this.currentPath.quadraticCurveTo(e, t, n, r), this;
    }
    bezierCurveTo(e, t, n, r, s, a) {
        return this.currentPath.bezierCurveTo(e, t, n, r, s, a), this;
    }
    splineThru(e) {
        return this.currentPath.splineThru(e), this;
    }
    toShapes(e) {
        function t(w) {
            const b = [];
            for (let C = 0, L = w.length; C < L; C++) {
                const F = w[C],
                    N = new oc();
                (N.curves = F.curves), b.push(N);
            }
            return b;
        }
        function n(w, b) {
            const C = b.length;
            let L = !1;
            for (let F = C - 1, N = 0; N < C; F = N++) {
                let B = b[F],
                    z = b[N],
                    U = z.x - B.x,
                    D = z.y - B.y;
                if (Math.abs(D) > Number.EPSILON) {
                    if (
                        (D < 0 && ((B = b[N]), (U = -U), (z = b[F]), (D = -D)),
                        w.y < B.y || w.y > z.y)
                    )
                        continue;
                    if (w.y === B.y) {
                        if (w.x === B.x) return !0;
                    } else {
                        const H = D * (w.x - B.x) - U * (w.y - B.y);
                        if (H === 0) return !0;
                        if (H < 0) continue;
                        L = !L;
                    }
                } else {
                    if (w.y !== B.y) continue;
                    if (
                        (z.x <= w.x && w.x <= B.x) ||
                        (B.x <= w.x && w.x <= z.x)
                    )
                        return !0;
                }
            }
            return L;
        }
        const r = zo.isClockWise,
            s = this.subPaths;
        if (s.length === 0) return [];
        let a, l, c;
        const d = [];
        if (s.length === 1)
            return (
                (l = s[0]), (c = new oc()), (c.curves = l.curves), d.push(c), d
            );
        let p = !r(s[0].getPoints());
        p = e ? !p : p;
        const g = [],
            y = [];
        let v = [],
            S = 0,
            T;
        (y[S] = void 0), (v[S] = []);
        for (let w = 0, b = s.length; w < b; w++)
            (l = s[w]),
                (T = l.getPoints()),
                (a = r(T)),
                (a = e ? !a : a),
                a
                    ? (!p && y[S] && S++,
                      (y[S] = { s: new oc(), p: T }),
                      (y[S].s.curves = l.curves),
                      p && S++,
                      (v[S] = []))
                    : v[S].push({ h: l, p: T[0] });
        if (!y[0]) return t(s);
        if (y.length > 1) {
            let w = !1,
                b = 0;
            for (let C = 0, L = y.length; C < L; C++) g[C] = [];
            for (let C = 0, L = y.length; C < L; C++) {
                const F = v[C];
                for (let N = 0; N < F.length; N++) {
                    const B = F[N];
                    let z = !0;
                    for (let U = 0; U < y.length; U++)
                        n(B.p, y[U].p) &&
                            (C !== U && b++,
                            z ? ((z = !1), g[U].push(B)) : (w = !0));
                    z && g[C].push(B);
                }
            }
            b > 0 && w === !1 && (v = g);
        }
        let M;
        for (let w = 0, b = y.length; w < b; w++) {
            (c = y[w].s), d.push(c), (M = v[w]);
            for (let C = 0, L = M.length; C < L; C++) c.holes.push(M[C].h);
        }
        return d;
    }
}
class l5 extends lo {
    constructor(e = 1, t = 1, n = 1, r = {}) {
        console.warn(
            'THREE.WebGLMultipleRenderTargets has been deprecated and will be removed in r172. Use THREE.WebGLRenderTarget and set the "count" parameter to enable MRT.'
        ),
            super(e, t, { ...r, count: n }),
            (this.isWebGLMultipleRenderTargets = !0);
    }
    get texture() {
        return this.textures;
    }
}
typeof __THREE_DEVTOOLS__ < 'u' &&
    __THREE_DEVTOOLS__.dispatchEvent(
        new CustomEvent('register', { detail: { revision: ov } })
    );
typeof window < 'u' &&
    (window.__THREE__
        ? console.warn(
              'WARNING: Multiple instances of Three.js being imported.'
          )
        : (window.__THREE__ = ov));
const QW = Object.freeze(
    Object.defineProperty(
        {
            __proto__: null,
            ACESFilmicToneMapping: AS,
            AddEquation: Ll,
            AddOperation: wR,
            AdditiveAnimationBlendMode: kS,
            AdditiveBlending: h_,
            AgXToneMapping: CR,
            AlphaFormat: LS,
            AlwaysCompare: HR,
            AlwaysDepth: mR,
            AlwaysStencilFunc: g_,
            AmbientLight: Gb,
            AnimationAction: Zb,
            AnimationClip: Op,
            AnimationLoader: uH,
            AnimationMixer: FH,
            AnimationObjectGroup: OH,
            AnimationUtils: sH,
            ArcCurve: pb,
            ArrayCamera: rb,
            ArrowHelper: s5,
            AttachedBindMode: m_,
            Audio: Yb,
            AudioAnalyser: AH,
            AudioContext: fw,
            AudioListener: MH,
            AudioLoader: _H,
            AxesHelper: o5,
            BackSide: Er,
            BasicDepthPacking: DR,
            BasicShadowMap: YC,
            BatchedMesh: fb,
            Bone: ZS,
            BooleanKeyframeTrack: pc,
            Box2: XH,
            Box3: Tr,
            Box3Helper: i5,
            BoxGeometry: dc,
            BoxHelper: n5,
            BufferAttribute: Mn,
            BufferGeometry: $t,
            BufferGeometryLoader: $b,
            ByteType: RS,
            Cache: Ra,
            Camera: Kp,
            CameraHelper: t5,
            CanvasTexture: bV,
            CapsuleGeometry: Tv,
            CatmullRomCurve3: mb,
            CineonToneMapping: TR,
            CircleGeometry: Av,
            ClampToEdgeWrapping: Ms,
            Clock: hw,
            Color: st,
            ColorKeyframeTrack: lw,
            ColorManagement: hn,
            CompressedArrayTexture: CV,
            CompressedCubeTexture: RV,
            CompressedTexture: Mv,
            CompressedTextureLoader: cH,
            ConeGeometry: Cv,
            ConstantAlphaFactor: hR,
            ConstantColorFactor: cR,
            CubeCamera: KR,
            CubeReflectionMapping: Ua,
            CubeRefractionMapping: Nl,
            CubeTexture: Zp,
            CubeTextureLoader: fH,
            CubeUVReflectionMapping: wh,
            CubicBezierCurve: ew,
            CubicBezierCurve3: gb,
            CubicInterpolant: Ub,
            CullFaceBack: f_,
            CullFaceFront: $C,
            CullFaceFrontBack: lO,
            CullFaceNone: qC,
            Curve: fo,
            CurvePath: vb,
            CustomBlending: KC,
            CustomToneMapping: AR,
            CylinderGeometry: Ch,
            Cylindrical: WH,
            Data3DTexture: VS,
            DataArrayTexture: yv,
            DataTexture: Bo,
            DataTextureLoader: hH,
            DataUtils: vk,
            DecrementStencilOp: _O,
            DecrementWrapStencilOp: wO,
            DefaultLoadingManager: Fb,
            DepthFormat: ic,
            DepthStencilFormat: lc,
            DepthTexture: jS,
            DetachedBindMode: bR,
            DirectionalLight: Hb,
            DirectionalLightHelper: e5,
            DiscreteInterpolant: Ob,
            DisplayP3ColorSpace: gv,
            DodecahedronGeometry: Rv,
            DoubleSide: Lo,
            DstAlphaFactor: sR,
            DstColorFactor: aR,
            DynamicCopyUsage: kO,
            DynamicDrawUsage: LO,
            DynamicReadUsage: NO,
            EdgesGeometry: xb,
            EllipseCurve: Ev,
            EqualCompare: FR,
            EqualDepth: yR,
            EqualStencilFunc: AO,
            EquirectangularReflectionMapping: vp,
            EquirectangularRefractionMapping: xp,
            Euler: as,
            EventDispatcher: Ba,
            ExtrudeGeometry: Pv,
            FileLoader: ka,
            Float16BufferAttribute: Ek,
            Float32BufferAttribute: vt,
            FloatType: Vr,
            Fog: _v,
            FogExp2: xv,
            FramebufferTexture: AV,
            FrontSide: Na,
            Frustum: Jp,
            GLBufferAttribute: HH,
            GLSL1: BO,
            GLSL3: y_,
            GreaterCompare: BR,
            GreaterDepth: xR,
            GreaterEqualCompare: VR,
            GreaterEqualDepth: vR,
            GreaterEqualStencilFunc: PO,
            GreaterStencilFunc: RO,
            GridHelper: JH,
            Group: th,
            HalfFloatType: Mh,
            HemisphereLight: Bb,
            HemisphereLightHelper: ZH,
            IcosahedronGeometry: Lv,
            ImageBitmapLoader: xH,
            ImageLoader: kp,
            ImageUtils: jR,
            IncrementStencilOp: xO,
            IncrementWrapStencilOp: SO,
            InstancedBufferAttribute: dh,
            InstancedBufferGeometry: qb,
            InstancedInterleavedBuffer: VH,
            InstancedMesh: cb,
            Int16BufferAttribute: wk,
            Int32BufferAttribute: Mk,
            Int8BufferAttribute: xk,
            IntType: uv,
            InterleavedBuffer: Sv,
            InterleavedBufferAttribute: uc,
            Interpolant: im,
            InterpolateDiscrete: wp,
            InterpolateLinear: Wy,
            InterpolateSmooth: oy,
            InvertStencilOp: MO,
            KeepStencilOp: Wu,
            KeyframeTrack: ho,
            LOD: lb,
            LatheGeometry: em,
            Layers: sc,
            LessCompare: kR,
            LessDepth: gR,
            LessEqualCompare: FS,
            LessEqualDepth: yp,
            LessEqualStencilFunc: CO,
            LessStencilFunc: TO,
            Light: Hl,
            LightProbe: jb,
            Line: Ul,
            Line3: jH,
            LineBasicMaterial: Ar,
            LineCurve: tw,
            LineCurve3: yb,
            LineDashedMaterial: Ib,
            LineLoop: hb,
            LineSegments: Vo,
            LinearDisplayP3ColorSpace: Yp,
            LinearFilter: hi,
            LinearInterpolant: aw,
            LinearMipMapLinearFilter: hO,
            LinearMipMapNearestFilter: fO,
            LinearMipmapLinearFilter: Io,
            LinearMipmapNearestFilter: Jd,
            LinearSRGBColorSpace: Fa,
            LinearToneMapping: MR,
            LinearTransfer: Ep,
            Loader: Gr,
            LoaderUtils: T_,
            LoadingManager: uw,
            LoopOnce: PR,
            LoopPingPong: IR,
            LoopRepeat: LR,
            LuminanceAlphaFormat: NS,
            LuminanceFormat: DS,
            MOUSE: oO,
            Material: lr,
            MaterialLoader: Fv,
            MathUtils: GR,
            Matrix3: Wt,
            Matrix4: Pt,
            MaxEquation: eR,
            Mesh: di,
            MeshBasicMaterial: zl,
            MeshDepthMaterial: qS,
            MeshDistanceMaterial: $S,
            MeshLambertMaterial: Pb,
            MeshMatcapMaterial: Lb,
            MeshNormalMaterial: bb,
            MeshPhongMaterial: Cb,
            MeshPhysicalMaterial: Ab,
            MeshStandardMaterial: sw,
            MeshToonMaterial: Rb,
            MinEquation: QC,
            MirroredRepeatWrapping: Sp,
            MixOperation: SR,
            MultiplyBlending: p_,
            MultiplyOperation: qp,
            NearestFilter: Li,
            NearestMipMapLinearFilter: cO,
            NearestMipMapNearestFilter: uO,
            NearestMipmapLinearFilter: Jf,
            NearestMipmapNearestFilter: CS,
            NeutralToneMapping: RR,
            NeverCompare: OR,
            NeverDepth: pR,
            NeverStencilFunc: EO,
            NoBlending: Pa,
            NoColorSpace: Aa,
            NoToneMapping: Fo,
            NormalAnimationBlendMode: mv,
            NormalBlending: nc,
            NotEqualCompare: zR,
            NotEqualDepth: _R,
            NotEqualStencilFunc: bO,
            NumberKeyframeTrack: Np,
            Object3D: ln,
            ObjectLoader: yH,
            ObjectSpaceNormalMap: UR,
            OctahedronGeometry: tm,
            OneFactor: nR,
            OneMinusConstantAlphaFactor: dR,
            OneMinusConstantColorFactor: fR,
            OneMinusDstAlphaFactor: oR,
            OneMinusDstColorFactor: lR,
            OneMinusSrcAlphaFactor: yy,
            OneMinusSrcColorFactor: rR,
            OrthographicCamera: Qp,
            P3Primaries: Ap,
            PCFShadowMap: av,
            PCFSoftShadowMap: Zd,
            PMREMGenerator: v_,
            Path: Pp,
            PerspectiveCamera: Pi,
            Plane: Pl,
            PlaneGeometry: Th,
            PlaneHelper: r5,
            PointLight: Vb,
            PointLightHelper: YH,
            Points: db,
            PointsMaterial: JS,
            PolarGridHelper: QH,
            PolyhedronGeometry: Vl,
            PositionalAudio: TH,
            PropertyBinding: an,
            PropertyMixer: Kb,
            QuadraticBezierCurve: nw,
            QuadraticBezierCurve3: iw,
            Quaternion: Hr,
            QuaternionKeyframeTrack: rm,
            QuaternionLinearInterpolant: kb,
            RED_GREEN_RGTC2_Format: Hy,
            RED_RGTC1_Format: OS,
            REVISION: ov,
            RGBADepthPacking: NR,
            RGBAFormat: sr,
            RGBAIntegerFormat: pv,
            RGBA_ASTC_10x10_Format: Oy,
            RGBA_ASTC_10x5_Format: Dy,
            RGBA_ASTC_10x6_Format: Ny,
            RGBA_ASTC_10x8_Format: Uy,
            RGBA_ASTC_12x10_Format: ky,
            RGBA_ASTC_12x12_Format: Fy,
            RGBA_ASTC_4x4_Format: Ty,
            RGBA_ASTC_5x4_Format: Ay,
            RGBA_ASTC_5x5_Format: Cy,
            RGBA_ASTC_6x5_Format: Ry,
            RGBA_ASTC_6x6_Format: by,
            RGBA_ASTC_8x5_Format: Py,
            RGBA_ASTC_8x6_Format: Ly,
            RGBA_ASTC_8x8_Format: Iy,
            RGBA_BPTC_Format: ip,
            RGBA_ETC2_EAC_Format: Ey,
            RGBA_PVRTC_2BPPV1_Format: Sy,
            RGBA_PVRTC_4BPPV1_Format: _y,
            RGBA_S3TC_DXT1_Format: ep,
            RGBA_S3TC_DXT3_Format: tp,
            RGBA_S3TC_DXT5_Format: np,
            RGBFormat: IS,
            RGBIntegerFormat: dO,
            RGB_BPTC_SIGNED_Format: By,
            RGB_BPTC_UNSIGNED_Format: zy,
            RGB_ETC1_Format: wy,
            RGB_ETC2_Format: My,
            RGB_PVRTC_2BPPV1_Format: xy,
            RGB_PVRTC_4BPPV1_Format: vy,
            RGB_S3TC_DXT1_Format: Qd,
            RGFormat: US,
            RGIntegerFormat: dv,
            RawShaderMaterial: Tb,
            Ray: Eh,
            Raycaster: gw,
            Rec709Primaries: Tp,
            RectAreaLight: Wb,
            RedFormat: hv,
            RedIntegerFormat: $p,
            ReinhardToneMapping: ER,
            RenderTarget: qR,
            RepeatWrapping: _p,
            ReplaceStencilOp: vO,
            ReverseSubtractEquation: JC,
            RingGeometry: Iv,
            SIGNED_RED_GREEN_RGTC2_Format: Gy,
            SIGNED_RED_RGTC1_Format: Vy,
            SRGBColorSpace: ws,
            SRGBTransfer: Pn,
            Scene: YS,
            ShaderChunk: qt,
            ShaderLib: ro,
            ShaderMaterial: Ts,
            ShadowMaterial: Eb,
            Shape: oc,
            ShapeGeometry: Dv,
            ShapePath: a5,
            ShapeUtils: zo,
            ShortType: bS,
            Skeleton: wv,
            SkeletonHelper: $H,
            SkinnedMesh: ub,
            Source: Zu,
            Sphere: or,
            SphereGeometry: nm,
            Spherical: GH,
            SphericalHarmonics3: Xb,
            SplineCurve: rw,
            SpotLight: zb,
            SpotLightHelper: qH,
            Sprite: ab,
            SpriteMaterial: KS,
            SrcAlphaFactor: gy,
            SrcAlphaSaturateFactor: uR,
            SrcColorFactor: iR,
            StaticCopyUsage: OO,
            StaticDrawUsage: Cp,
            StaticReadUsage: DO,
            StereoCamera: SH,
            StreamCopyUsage: FO,
            StreamDrawUsage: IO,
            StreamReadUsage: UO,
            StringKeyframeTrack: mc,
            SubtractEquation: ZC,
            SubtractiveBlending: d_,
            TOUCH: aO,
            TangentSpaceNormalMap: Bl,
            TetrahedronGeometry: Nv,
            Texture: Qn,
            TextureLoader: dH,
            TextureUtils: sV,
            TorusGeometry: Uv,
            TorusKnotGeometry: Ov,
            Triangle: ss,
            TriangleFanDrawMode: gO,
            TriangleStripDrawMode: mO,
            TrianglesDrawMode: pO,
            TubeGeometry: kv,
            UVMapping: lv,
            Uint16BufferAttribute: HS,
            Uint32BufferAttribute: GS,
            Uint8BufferAttribute: _k,
            Uint8ClampedBufferAttribute: Sk,
            Uniform: mw,
            UniformsGroup: zH,
            UniformsLib: et,
            UniformsUtils: WS,
            UnsignedByteType: ao,
            UnsignedInt248Type: ac,
            UnsignedInt5999Type: PS,
            UnsignedIntType: Oa,
            UnsignedShort4444Type: cv,
            UnsignedShort5551Type: fv,
            UnsignedShortType: ch,
            VSMShadowMap: io,
            Vector2: Ce,
            Vector3: j,
            Vector4: gn,
            VectorKeyframeTrack: Up,
            VideoTexture: TV,
            WebGL3DRenderTarget: lk,
            WebGLArrayRenderTarget: ak,
            WebGLCoordinateSystem: Do,
            WebGLCubeRenderTarget: ZR,
            WebGLMultipleRenderTargets: l5,
            WebGLRenderTarget: lo,
            WebGLRenderer: sb,
            WebGLUtils: ib,
            WebGPUCoordinateSystem: Rp,
            WireframeGeometry: Mb,
            WrapAroundEnding: Mp,
            ZeroCurvatureEnding: Yu,
            ZeroFactor: tR,
            ZeroSlopeEnding: Ku,
            ZeroStencilOp: yO,
            createCanvasElement: XR,
        },
        Symbol.toStringTag,
        { value: 'Module' }
    )
);
var Ax = { exports: {} },
    Rl = {};
/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var aT;
function u5() {
    return (
        aT ||
            ((aT = 1),
            (Rl.ConcurrentRoot = 1),
            (Rl.ContinuousEventPriority = 4),
            (Rl.DefaultEventPriority = 16),
            (Rl.DiscreteEventPriority = 1),
            (Rl.IdleEventPriority = 536870912),
            (Rl.LegacyRoot = 0)),
        Rl
    );
}
var lT;
function c5() {
    return lT || ((lT = 1), (Ax.exports = u5())), Ax.exports;
}
var ih = c5();
function f5(i) {
    let e;
    const t = new Set(),
        n = (d, p) => {
            const g = typeof d == 'function' ? d(e) : d;
            if (g !== e) {
                const y = e;
                (e = p ? g : Object.assign({}, e, g)),
                    t.forEach((v) => v(e, y));
            }
        },
        r = () => e,
        s = (d, p = r, g = Object.is) => {
            console.warn(
                '[DEPRECATED] Please use `subscribeWithSelector` middleware'
            );
            let y = p(e);
            function v() {
                const S = p(e);
                if (!g(y, S)) {
                    const T = y;
                    d((y = S), T);
                }
            }
            return t.add(v), () => t.delete(v);
        },
        c = {
            setState: n,
            getState: r,
            subscribe: (d, p, g) =>
                p || g ? s(d, p, g) : (t.add(d), () => t.delete(d)),
            destroy: () => t.clear(),
        };
    return (e = i(n, r, c)), c;
}
const h5 =
        typeof window > 'u' ||
        !window.navigator ||
        /ServerSideRendering|^Deno\//.test(window.navigator.userAgent),
    uT = h5 ? K.useEffect : K.useLayoutEffect;
function Qb(i) {
    const e = typeof i == 'function' ? f5(i) : i,
        t = (n = e.getState, r = Object.is) => {
            const [, s] = K.useReducer((M) => M + 1, 0),
                a = e.getState(),
                l = K.useRef(a),
                c = K.useRef(n),
                d = K.useRef(r),
                p = K.useRef(!1),
                g = K.useRef();
            g.current === void 0 && (g.current = n(a));
            let y,
                v = !1;
            (l.current !== a ||
                c.current !== n ||
                d.current !== r ||
                p.current) &&
                ((y = n(a)), (v = !r(g.current, y))),
                uT(() => {
                    v && (g.current = y),
                        (l.current = a),
                        (c.current = n),
                        (d.current = r),
                        (p.current = !1);
                });
            const S = K.useRef(a);
            uT(() => {
                const M = () => {
                        try {
                            const b = e.getState(),
                                C = c.current(b);
                            d.current(g.current, C) ||
                                ((l.current = b), (g.current = C), s());
                        } catch {
                            (p.current = !0), s();
                        }
                    },
                    w = e.subscribe(M);
                return e.getState() !== S.current && M(), w;
            }, []);
            const T = v ? y : g.current;
            return K.useDebugValue(T), T;
        };
    return (
        Object.assign(t, e),
        (t[Symbol.iterator] = function () {
            console.warn(
                '[useStore, api] = create() is deprecated and will be removed in v4'
            );
            const n = [t, e];
            return {
                next() {
                    const r = n.length <= 0;
                    return { value: n.shift(), done: r };
                },
            };
        }),
        t
    );
}
const d5 = (i) => typeof i == 'object' && typeof i.then == 'function',
    Qu = [];
function eP(i, e, t = (n, r) => n === r) {
    if (i === e) return !0;
    if (!i || !e) return !1;
    const n = i.length;
    if (e.length !== n) return !1;
    for (let r = 0; r < n; r++) if (!t(i[r], e[r])) return !1;
    return !0;
}
function tP(i, e = null, t = !1, n = {}) {
    e === null && (e = [i]);
    for (const s of Qu)
        if (eP(e, s.keys, s.equal)) {
            if (t) return;
            if (Object.prototype.hasOwnProperty.call(s, 'error')) throw s.error;
            if (Object.prototype.hasOwnProperty.call(s, 'response'))
                return (
                    n.lifespan &&
                        n.lifespan > 0 &&
                        (s.timeout && clearTimeout(s.timeout),
                        (s.timeout = setTimeout(s.remove, n.lifespan))),
                    s.response
                );
            if (!t) throw s.promise;
        }
    const r = {
        keys: e,
        equal: n.equal,
        remove: () => {
            const s = Qu.indexOf(r);
            s !== -1 && Qu.splice(s, 1);
        },
        promise: (d5(i) ? i : i(...e))
            .then((s) => {
                (r.response = s),
                    n.lifespan &&
                        n.lifespan > 0 &&
                        (r.timeout = setTimeout(r.remove, n.lifespan));
            })
            .catch((s) => (r.error = s)),
    };
    if ((Qu.push(r), !t)) throw r.promise;
}
const p5 = (i, e, t) => tP(i, e, !1, t),
    m5 = (i, e, t) => void tP(i, e, !0, t),
    g5 = (i) => {
        if (i === void 0 || i.length === 0) Qu.splice(0, Qu.length);
        else {
            const e = Qu.find((t) => eP(i, t.keys, t.equal));
            e && e.remove();
        }
    };
var Cx = { exports: {} },
    Rx = { exports: {} },
    bx = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var cT;
function y5() {
    return (
        cT ||
            ((cT = 1),
            (function (i) {
                function e(X, oe) {
                    var Q = X.length;
                    X.push(oe);
                    e: for (; 0 < Q; ) {
                        var G = (Q - 1) >>> 1,
                            ae = X[G];
                        if (0 < r(ae, oe)) (X[G] = oe), (X[Q] = ae), (Q = G);
                        else break e;
                    }
                }
                function t(X) {
                    return X.length === 0 ? null : X[0];
                }
                function n(X) {
                    if (X.length === 0) return null;
                    var oe = X[0],
                        Q = X.pop();
                    if (Q !== oe) {
                        X[0] = Q;
                        e: for (
                            var G = 0, ae = X.length, Oe = ae >>> 1;
                            G < Oe;

                        ) {
                            var fe = 2 * (G + 1) - 1,
                                we = X[fe],
                                Pe = fe + 1,
                                Re = X[Pe];
                            if (0 > r(we, Q))
                                Pe < ae && 0 > r(Re, we)
                                    ? ((X[G] = Re), (X[Pe] = Q), (G = Pe))
                                    : ((X[G] = we), (X[fe] = Q), (G = fe));
                            else if (Pe < ae && 0 > r(Re, Q))
                                (X[G] = Re), (X[Pe] = Q), (G = Pe);
                            else break e;
                        }
                    }
                    return oe;
                }
                function r(X, oe) {
                    var Q = X.sortIndex - oe.sortIndex;
                    return Q !== 0 ? Q : X.id - oe.id;
                }
                if (
                    typeof performance == 'object' &&
                    typeof performance.now == 'function'
                ) {
                    var s = performance;
                    i.unstable_now = function () {
                        return s.now();
                    };
                } else {
                    var a = Date,
                        l = a.now();
                    i.unstable_now = function () {
                        return a.now() - l;
                    };
                }
                var c = [],
                    d = [],
                    p = 1,
                    g = null,
                    y = 3,
                    v = !1,
                    S = !1,
                    T = !1,
                    M = typeof setTimeout == 'function' ? setTimeout : null,
                    w = typeof clearTimeout == 'function' ? clearTimeout : null,
                    b = typeof setImmediate < 'u' ? setImmediate : null;
                typeof navigator < 'u' &&
                    navigator.scheduling !== void 0 &&
                    navigator.scheduling.isInputPending !== void 0 &&
                    navigator.scheduling.isInputPending.bind(
                        navigator.scheduling
                    );
                function C(X) {
                    for (var oe = t(d); oe !== null; ) {
                        if (oe.callback === null) n(d);
                        else if (oe.startTime <= X)
                            n(d), (oe.sortIndex = oe.expirationTime), e(c, oe);
                        else break;
                        oe = t(d);
                    }
                }
                function L(X) {
                    if (((T = !1), C(X), !S))
                        if (t(c) !== null) (S = !0), ce(F);
                        else {
                            var oe = t(d);
                            oe !== null && me(L, oe.startTime - X);
                        }
                }
                function F(X, oe) {
                    (S = !1), T && ((T = !1), w(z), (z = -1)), (v = !0);
                    var Q = y;
                    try {
                        for (
                            C(oe), g = t(c);
                            g !== null &&
                            (!(g.expirationTime > oe) || (X && !H()));

                        ) {
                            var G = g.callback;
                            if (typeof G == 'function') {
                                (g.callback = null), (y = g.priorityLevel);
                                var ae = G(g.expirationTime <= oe);
                                (oe = i.unstable_now()),
                                    typeof ae == 'function'
                                        ? (g.callback = ae)
                                        : g === t(c) && n(c),
                                    C(oe);
                            } else n(c);
                            g = t(c);
                        }
                        if (g !== null) var Oe = !0;
                        else {
                            var fe = t(d);
                            fe !== null && me(L, fe.startTime - oe), (Oe = !1);
                        }
                        return Oe;
                    } finally {
                        (g = null), (y = Q), (v = !1);
                    }
                }
                var N = !1,
                    B = null,
                    z = -1,
                    U = 5,
                    D = -1;
                function H() {
                    return !(i.unstable_now() - D < U);
                }
                function ie() {
                    if (B !== null) {
                        var X = i.unstable_now();
                        D = X;
                        var oe = !0;
                        try {
                            oe = B(!0, X);
                        } finally {
                            oe ? ee() : ((N = !1), (B = null));
                        }
                    } else N = !1;
                }
                var ee;
                if (typeof b == 'function')
                    ee = function () {
                        b(ie);
                    };
                else if (typeof MessageChannel < 'u') {
                    var ue = new MessageChannel(),
                        Se = ue.port2;
                    (ue.port1.onmessage = ie),
                        (ee = function () {
                            Se.postMessage(null);
                        });
                } else
                    ee = function () {
                        M(ie, 0);
                    };
                function ce(X) {
                    (B = X), N || ((N = !0), ee());
                }
                function me(X, oe) {
                    z = M(function () {
                        X(i.unstable_now());
                    }, oe);
                }
                (i.unstable_IdlePriority = 5),
                    (i.unstable_ImmediatePriority = 1),
                    (i.unstable_LowPriority = 4),
                    (i.unstable_NormalPriority = 3),
                    (i.unstable_Profiling = null),
                    (i.unstable_UserBlockingPriority = 2),
                    (i.unstable_cancelCallback = function (X) {
                        X.callback = null;
                    }),
                    (i.unstable_continueExecution = function () {
                        S || v || ((S = !0), ce(F));
                    }),
                    (i.unstable_forceFrameRate = function (X) {
                        0 > X || 125 < X
                            ? console.error(
                                  'forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported'
                              )
                            : (U = 0 < X ? Math.floor(1e3 / X) : 5);
                    }),
                    (i.unstable_getCurrentPriorityLevel = function () {
                        return y;
                    }),
                    (i.unstable_getFirstCallbackNode = function () {
                        return t(c);
                    }),
                    (i.unstable_next = function (X) {
                        switch (y) {
                            case 1:
                            case 2:
                            case 3:
                                var oe = 3;
                                break;
                            default:
                                oe = y;
                        }
                        var Q = y;
                        y = oe;
                        try {
                            return X();
                        } finally {
                            y = Q;
                        }
                    }),
                    (i.unstable_pauseExecution = function () {}),
                    (i.unstable_requestPaint = function () {}),
                    (i.unstable_runWithPriority = function (X, oe) {
                        switch (X) {
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                                break;
                            default:
                                X = 3;
                        }
                        var Q = y;
                        y = X;
                        try {
                            return oe();
                        } finally {
                            y = Q;
                        }
                    }),
                    (i.unstable_scheduleCallback = function (X, oe, Q) {
                        var G = i.unstable_now();
                        switch (
                            (typeof Q == 'object' && Q !== null
                                ? ((Q = Q.delay),
                                  (Q =
                                      typeof Q == 'number' && 0 < Q
                                          ? G + Q
                                          : G))
                                : (Q = G),
                            X)
                        ) {
                            case 1:
                                var ae = -1;
                                break;
                            case 2:
                                ae = 250;
                                break;
                            case 5:
                                ae = 1073741823;
                                break;
                            case 4:
                                ae = 1e4;
                                break;
                            default:
                                ae = 5e3;
                        }
                        return (
                            (ae = Q + ae),
                            (X = {
                                id: p++,
                                callback: oe,
                                priorityLevel: X,
                                startTime: Q,
                                expirationTime: ae,
                                sortIndex: -1,
                            }),
                            Q > G
                                ? ((X.sortIndex = Q),
                                  e(d, X),
                                  t(c) === null &&
                                      X === t(d) &&
                                      (T ? (w(z), (z = -1)) : (T = !0),
                                      me(L, Q - G)))
                                : ((X.sortIndex = ae),
                                  e(c, X),
                                  S || v || ((S = !0), ce(F))),
                            X
                        );
                    }),
                    (i.unstable_shouldYield = H),
                    (i.unstable_wrapCallback = function (X) {
                        var oe = y;
                        return function () {
                            var Q = y;
                            y = oe;
                            try {
                                return X.apply(this, arguments);
                            } finally {
                                y = Q;
                            }
                        };
                    });
            })(bx)),
        bx
    );
}
var fT;
function nP() {
    return fT || ((fT = 1), (Rx.exports = y5())), Rx.exports;
}
/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Px, hT;
function v5() {
    return (
        hT ||
            ((hT = 1),
            (Px = function (e) {
                var t = {},
                    n = Qy(),
                    r = nP(),
                    s = Object.assign;
                function a(f) {
                    for (
                        var h =
                                'https://reactjs.org/docs/error-decoder.html?invariant=' +
                                f,
                            x = 1;
                        x < arguments.length;
                        x++
                    )
                        h += '&args[]=' + encodeURIComponent(arguments[x]);
                    return (
                        'Minified React error #' +
                        f +
                        '; visit ' +
                        h +
                        ' for the full message or use the non-minified dev environment for full errors and additional helpful warnings.'
                    );
                }
                var l = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
                    c = Symbol.for('react.element'),
                    d = Symbol.for('react.portal'),
                    p = Symbol.for('react.fragment'),
                    g = Symbol.for('react.strict_mode'),
                    y = Symbol.for('react.profiler'),
                    v = Symbol.for('react.provider'),
                    S = Symbol.for('react.context'),
                    T = Symbol.for('react.forward_ref'),
                    M = Symbol.for('react.suspense'),
                    w = Symbol.for('react.suspense_list'),
                    b = Symbol.for('react.memo'),
                    C = Symbol.for('react.lazy'),
                    L = Symbol.for('react.offscreen'),
                    F = Symbol.iterator;
                function N(f) {
                    return f === null || typeof f != 'object'
                        ? null
                        : ((f = (F && f[F]) || f['@@iterator']),
                          typeof f == 'function' ? f : null);
                }
                function B(f) {
                    if (f == null) return null;
                    if (typeof f == 'function')
                        return f.displayName || f.name || null;
                    if (typeof f == 'string') return f;
                    switch (f) {
                        case p:
                            return 'Fragment';
                        case d:
                            return 'Portal';
                        case y:
                            return 'Profiler';
                        case g:
                            return 'StrictMode';
                        case M:
                            return 'Suspense';
                        case w:
                            return 'SuspenseList';
                    }
                    if (typeof f == 'object')
                        switch (f.$$typeof) {
                            case S:
                                return (
                                    (f.displayName || 'Context') + '.Consumer'
                                );
                            case v:
                                return (
                                    (f._context.displayName || 'Context') +
                                    '.Provider'
                                );
                            case T:
                                var h = f.render;
                                return (
                                    (f = f.displayName),
                                    f ||
                                        ((f = h.displayName || h.name || ''),
                                        (f =
                                            f !== ''
                                                ? 'ForwardRef(' + f + ')'
                                                : 'ForwardRef')),
                                    f
                                );
                            case b:
                                return (
                                    (h = f.displayName || null),
                                    h !== null ? h : B(f.type) || 'Memo'
                                );
                            case C:
                                (h = f._payload), (f = f._init);
                                try {
                                    return B(f(h));
                                } catch {}
                        }
                    return null;
                }
                function z(f) {
                    var h = f.type;
                    switch (f.tag) {
                        case 24:
                            return 'Cache';
                        case 9:
                            return (h.displayName || 'Context') + '.Consumer';
                        case 10:
                            return (
                                (h._context.displayName || 'Context') +
                                '.Provider'
                            );
                        case 18:
                            return 'DehydratedFragment';
                        case 11:
                            return (
                                (f = h.render),
                                (f = f.displayName || f.name || ''),
                                h.displayName ||
                                    (f !== ''
                                        ? 'ForwardRef(' + f + ')'
                                        : 'ForwardRef')
                            );
                        case 7:
                            return 'Fragment';
                        case 5:
                            return h;
                        case 4:
                            return 'Portal';
                        case 3:
                            return 'Root';
                        case 6:
                            return 'Text';
                        case 16:
                            return B(h);
                        case 8:
                            return h === g ? 'StrictMode' : 'Mode';
                        case 22:
                            return 'Offscreen';
                        case 12:
                            return 'Profiler';
                        case 21:
                            return 'Scope';
                        case 13:
                            return 'Suspense';
                        case 19:
                            return 'SuspenseList';
                        case 25:
                            return 'TracingMarker';
                        case 1:
                        case 0:
                        case 17:
                        case 2:
                        case 14:
                        case 15:
                            if (typeof h == 'function')
                                return h.displayName || h.name || null;
                            if (typeof h == 'string') return h;
                    }
                    return null;
                }
                function U(f) {
                    var h = f,
                        x = f;
                    if (f.alternate) for (; h.return; ) h = h.return;
                    else {
                        f = h;
                        do
                            (h = f),
                                (h.flags & 4098) !== 0 && (x = h.return),
                                (f = h.return);
                        while (f);
                    }
                    return h.tag === 3 ? x : null;
                }
                function D(f) {
                    if (U(f) !== f) throw Error(a(188));
                }
                function H(f) {
                    var h = f.alternate;
                    if (!h) {
                        if (((h = U(f)), h === null)) throw Error(a(188));
                        return h !== f ? null : f;
                    }
                    for (var x = f, E = h; ; ) {
                        var R = x.return;
                        if (R === null) break;
                        var I = R.alternate;
                        if (I === null) {
                            if (((E = R.return), E !== null)) {
                                x = E;
                                continue;
                            }
                            break;
                        }
                        if (R.child === I.child) {
                            for (I = R.child; I; ) {
                                if (I === x) return D(R), f;
                                if (I === E) return D(R), h;
                                I = I.sibling;
                            }
                            throw Error(a(188));
                        }
                        if (x.return !== E.return) (x = R), (E = I);
                        else {
                            for (var q = !1, te = R.child; te; ) {
                                if (te === x) {
                                    (q = !0), (x = R), (E = I);
                                    break;
                                }
                                if (te === E) {
                                    (q = !0), (E = R), (x = I);
                                    break;
                                }
                                te = te.sibling;
                            }
                            if (!q) {
                                for (te = I.child; te; ) {
                                    if (te === x) {
                                        (q = !0), (x = I), (E = R);
                                        break;
                                    }
                                    if (te === E) {
                                        (q = !0), (E = I), (x = R);
                                        break;
                                    }
                                    te = te.sibling;
                                }
                                if (!q) throw Error(a(189));
                            }
                        }
                        if (x.alternate !== E) throw Error(a(190));
                    }
                    if (x.tag !== 3) throw Error(a(188));
                    return x.stateNode.current === x ? f : h;
                }
                function ie(f) {
                    return (f = H(f)), f !== null ? ee(f) : null;
                }
                function ee(f) {
                    if (f.tag === 5 || f.tag === 6) return f;
                    for (f = f.child; f !== null; ) {
                        var h = ee(f);
                        if (h !== null) return h;
                        f = f.sibling;
                    }
                    return null;
                }
                function ue(f) {
                    if (f.tag === 5 || f.tag === 6) return f;
                    for (f = f.child; f !== null; ) {
                        if (f.tag !== 4) {
                            var h = ue(f);
                            if (h !== null) return h;
                        }
                        f = f.sibling;
                    }
                    return null;
                }
                var Se = Array.isArray,
                    ce = e.getPublicInstance,
                    me = e.getRootHostContext,
                    X = e.getChildHostContext,
                    oe = e.prepareForCommit,
                    Q = e.resetAfterCommit,
                    G = e.createInstance,
                    ae = e.appendInitialChild,
                    Oe = e.finalizeInitialChildren,
                    fe = e.prepareUpdate,
                    we = e.shouldSetTextContent,
                    Pe = e.createTextInstance,
                    Re = e.scheduleTimeout,
                    Ye = e.cancelTimeout,
                    lt = e.noTimeout,
                    dt = e.isPrimaryRenderer,
                    Lt = e.supportsMutation,
                    W = e.supportsPersistence,
                    Ie = e.supportsHydration,
                    ke = e.getInstanceFromNode,
                    Ke = e.preparePortalMount,
                    Ee = e.getCurrentEventPriority,
                    St = e.detachDeletedInstance,
                    Ze = e.supportsMicrotasks,
                    ot = e.scheduleMicrotask,
                    $ = e.supportsTestSelectors,
                    k = e.findFiberRoot,
                    ge = e.getBoundingRect,
                    De = e.getTextContent,
                    be = e.isHiddenSubtree,
                    Le = e.matchAccessibilityRole,
                    _t = e.setFocusIfFocusable,
                    $e = e.setupIntersectionObserver,
                    tt = e.appendChild,
                    Nt = e.appendChildToContainer,
                    Be = e.commitTextUpdate,
                    Je = e.commitMount,
                    Kt = e.commitUpdate,
                    bt = e.insertBefore,
                    ut = e.insertInContainerBefore,
                    Ut = e.removeChild,
                    zt = e.removeChildFromContainer,
                    dn = e.resetTextContent,
                    ne = e.hideInstance,
                    Ve = e.hideTextInstance,
                    Te = e.unhideInstance,
                    Ae = e.unhideTextInstance,
                    Ge = e.clearContainer,
                    At = e.cloneInstance,
                    Yt = e.createContainerChildSet,
                    Cn = e.appendChildToContainerChildSet,
                    jn = e.finalizeContainerChildren,
                    en = e.replaceContainerChildren,
                    Hi = e.cloneHiddenInstance,
                    Gi = e.cloneHiddenTextInstance,
                    mo = e.canHydrateInstance,
                    Wr = e.canHydrateTextInstance,
                    Cs = e.canHydrateSuspenseInstance,
                    Gl = e.isSuspenseInstancePending,
                    ls = e.isSuspenseInstanceFallback,
                    Rs = e.registerSuspenseInstanceRetry,
                    Xr = e.getNextHydratableSibling,
                    go = e.getFirstHydratableChild,
                    gc = e.getFirstHydratableChildWithinContainer,
                    yc = e.getFirstHydratableChildWithinSuspenseInstance,
                    Rh = e.hydrateInstance,
                    bs = e.hydrateTextInstance,
                    vc = e.hydrateSuspenseInstance,
                    V = e.getNextHydratableInstanceAfterSuspenseInstance,
                    re = e.commitHydratedContainer,
                    ye = e.commitHydratedSuspenseInstance,
                    ve = e.clearSuspenseBoundary,
                    le = e.clearSuspenseBoundaryFromContainer,
                    We = e.shouldDeleteUnhydratedTailInstances,
                    nt = e.didNotMatchHydratedContainerTextInstance,
                    pt = e.didNotMatchHydratedTextInstance,
                    Xe;
                function Mt(f) {
                    if (Xe === void 0)
                        try {
                            throw Error();
                        } catch (x) {
                            var h = x.stack.trim().match(/\n( *(at )?)/);
                            Xe = (h && h[1]) || '';
                        }
                    return (
                        `
` +
                        Xe +
                        f
                    );
                }
                var Et = !1;
                function wt(f, h) {
                    if (!f || Et) return '';
                    Et = !0;
                    var x = Error.prepareStackTrace;
                    Error.prepareStackTrace = void 0;
                    try {
                        if (h)
                            if (
                                ((h = function () {
                                    throw Error();
                                }),
                                Object.defineProperty(h.prototype, 'props', {
                                    set: function () {
                                        throw Error();
                                    },
                                }),
                                typeof Reflect == 'object' && Reflect.construct)
                            ) {
                                try {
                                    Reflect.construct(h, []);
                                } catch (ze) {
                                    var E = ze;
                                }
                                Reflect.construct(f, [], h);
                            } else {
                                try {
                                    h.call();
                                } catch (ze) {
                                    E = ze;
                                }
                                f.call(h.prototype);
                            }
                        else {
                            try {
                                throw Error();
                            } catch (ze) {
                                E = ze;
                            }
                            f();
                        }
                    } catch (ze) {
                        if (ze && E && typeof ze.stack == 'string') {
                            for (
                                var R = ze.stack.split(`
`),
                                    I = E.stack.split(`
`),
                                    q = R.length - 1,
                                    te = I.length - 1;
                                1 <= q && 0 <= te && R[q] !== I[te];

                            )
                                te--;
                            for (; 1 <= q && 0 <= te; q--, te--)
                                if (R[q] !== I[te]) {
                                    if (q !== 1 || te !== 1)
                                        do
                                            if (
                                                (q--,
                                                te--,
                                                0 > te || R[q] !== I[te])
                                            ) {
                                                var Me =
                                                    `
` + R[q].replace(' at new ', ' at ');
                                                return (
                                                    f.displayName &&
                                                        Me.includes(
                                                            '<anonymous>'
                                                        ) &&
                                                        (Me = Me.replace(
                                                            '<anonymous>',
                                                            f.displayName
                                                        )),
                                                    Me
                                                );
                                            }
                                        while (1 <= q && 0 <= te);
                                    break;
                                }
                        }
                    } finally {
                        (Et = !1), (Error.prepareStackTrace = x);
                    }
                    return (f = f ? f.displayName || f.name : '') ? Mt(f) : '';
                }
                var Qt = Object.prototype.hasOwnProperty,
                    vn = [],
                    un = -1;
                function En(f) {
                    return { current: f };
                }
                function ft(f) {
                    0 > un || ((f.current = vn[un]), (vn[un] = null), un--);
                }
                function je(f, h) {
                    un++, (vn[un] = f.current), (f.current = h);
                }
                var Zt = {},
                    It = En(Zt),
                    xn = En(!1),
                    Wi = Zt;
                function Dn(f, h) {
                    var x = f.type.contextTypes;
                    if (!x) return Zt;
                    var E = f.stateNode;
                    if (
                        E &&
                        E.__reactInternalMemoizedUnmaskedChildContext === h
                    )
                        return E.__reactInternalMemoizedMaskedChildContext;
                    var R = {},
                        I;
                    for (I in x) R[I] = h[I];
                    return (
                        E &&
                            ((f = f.stateNode),
                            (f.__reactInternalMemoizedUnmaskedChildContext = h),
                            (f.__reactInternalMemoizedMaskedChildContext = R)),
                        R
                    );
                }
                function zn(f) {
                    return (f = f.childContextTypes), f != null;
                }
                function fn() {
                    ft(xn), ft(It);
                }
                function Xi(f, h, x) {
                    if (It.current !== Zt) throw Error(a(168));
                    je(It, h), je(xn, x);
                }
                function za(f, h, x) {
                    var E = f.stateNode;
                    if (
                        ((h = h.childContextTypes),
                        typeof E.getChildContext != 'function')
                    )
                        return x;
                    E = E.getChildContext();
                    for (var R in E)
                        if (!(R in h))
                            throw Error(a(108, z(f) || 'Unknown', R));
                    return s({}, x, E);
                }
                function pi(f) {
                    return (
                        (f =
                            ((f = f.stateNode) &&
                                f.__reactInternalMemoizedMergedChildContext) ||
                            Zt),
                        (Wi = It.current),
                        je(It, f),
                        je(xn, xn.current),
                        !0
                    );
                }
                function yo(f, h, x) {
                    var E = f.stateNode;
                    if (!E) throw Error(a(169));
                    x
                        ? ((f = za(f, h, Wi)),
                          (E.__reactInternalMemoizedMergedChildContext = f),
                          ft(xn),
                          ft(It),
                          je(It, f))
                        : ft(xn),
                        je(xn, x);
                }
                var ji = Math.clz32 ? Math.clz32 : Xv,
                    Va = Math.log,
                    Wl = Math.LN2;
                function Xv(f) {
                    return (
                        (f >>>= 0), f === 0 ? 32 : (31 - ((Va(f) / Wl) | 0)) | 0
                    );
                }
                var Ha = 64,
                    rn = 4194304;
                function Ga(f) {
                    switch (f & -f) {
                        case 1:
                            return 1;
                        case 2:
                            return 2;
                        case 4:
                            return 4;
                        case 8:
                            return 8;
                        case 16:
                            return 16;
                        case 32:
                            return 32;
                        case 64:
                        case 128:
                        case 256:
                        case 512:
                        case 1024:
                        case 2048:
                        case 4096:
                        case 8192:
                        case 16384:
                        case 32768:
                        case 65536:
                        case 131072:
                        case 262144:
                        case 524288:
                        case 1048576:
                        case 2097152:
                            return f & 4194240;
                        case 4194304:
                        case 8388608:
                        case 16777216:
                        case 33554432:
                        case 67108864:
                            return f & 130023424;
                        case 134217728:
                            return 134217728;
                        case 268435456:
                            return 268435456;
                        case 536870912:
                            return 536870912;
                        case 1073741824:
                            return 1073741824;
                        default:
                            return f;
                    }
                }
                function Xl(f, h) {
                    var x = f.pendingLanes;
                    if (x === 0) return 0;
                    var E = 0,
                        R = f.suspendedLanes,
                        I = f.pingedLanes,
                        q = x & 268435455;
                    if (q !== 0) {
                        var te = q & ~R;
                        te !== 0
                            ? (E = Ga(te))
                            : ((I &= q), I !== 0 && (E = Ga(I)));
                    } else
                        (q = x & ~R),
                            q !== 0 ? (E = Ga(q)) : I !== 0 && (E = Ga(I));
                    if (E === 0) return 0;
                    if (
                        h !== 0 &&
                        h !== E &&
                        (h & R) === 0 &&
                        ((R = E & -E),
                        (I = h & -h),
                        R >= I || (R === 16 && (I & 4194240) !== 0))
                    )
                        return h;
                    if (
                        ((E & 4) !== 0 && (E |= x & 16),
                        (h = f.entangledLanes),
                        h !== 0)
                    )
                        for (f = f.entanglements, h &= E; 0 < h; )
                            (x = 31 - ji(h)),
                                (R = 1 << x),
                                (E |= f[x]),
                                (h &= ~R);
                    return E;
                }
                function bh(f, h) {
                    switch (f) {
                        case 1:
                        case 2:
                        case 4:
                            return h + 250;
                        case 8:
                        case 16:
                        case 32:
                        case 64:
                        case 128:
                        case 256:
                        case 512:
                        case 1024:
                        case 2048:
                        case 4096:
                        case 8192:
                        case 16384:
                        case 32768:
                        case 65536:
                        case 131072:
                        case 262144:
                        case 524288:
                        case 1048576:
                        case 2097152:
                            return h + 5e3;
                        case 4194304:
                        case 8388608:
                        case 16777216:
                        case 33554432:
                        case 67108864:
                            return -1;
                        case 134217728:
                        case 268435456:
                        case 536870912:
                        case 1073741824:
                            return -1;
                        default:
                            return -1;
                    }
                }
                function om(f, h) {
                    for (
                        var x = f.suspendedLanes,
                            E = f.pingedLanes,
                            R = f.expirationTimes,
                            I = f.pendingLanes;
                        0 < I;

                    ) {
                        var q = 31 - ji(I),
                            te = 1 << q,
                            Me = R[q];
                        Me === -1
                            ? ((te & x) === 0 || (te & E) !== 0) &&
                              (R[q] = bh(te, h))
                            : Me <= h && (f.expiredLanes |= te),
                            (I &= ~te);
                    }
                }
                function xc(f) {
                    return (
                        (f = f.pendingLanes & -1073741825),
                        f !== 0 ? f : f & 1073741824 ? 1073741824 : 0
                    );
                }
                function _c(f) {
                    for (var h = [], x = 0; 31 > x; x++) h.push(f);
                    return h;
                }
                function Ho(f, h, x) {
                    (f.pendingLanes |= h),
                        h !== 536870912 &&
                            ((f.suspendedLanes = 0), (f.pingedLanes = 0)),
                        (f = f.eventTimes),
                        (h = 31 - ji(h)),
                        (f[h] = x);
                }
                function Sc(f, h) {
                    var x = f.pendingLanes & ~h;
                    (f.pendingLanes = h),
                        (f.suspendedLanes = 0),
                        (f.pingedLanes = 0),
                        (f.expiredLanes &= h),
                        (f.mutableReadLanes &= h),
                        (f.entangledLanes &= h),
                        (h = f.entanglements);
                    var E = f.eventTimes;
                    for (f = f.expirationTimes; 0 < x; ) {
                        var R = 31 - ji(x),
                            I = 1 << R;
                        (h[R] = 0), (E[R] = -1), (f[R] = -1), (x &= ~I);
                    }
                }
                function us(f, h) {
                    var x = (f.entangledLanes |= h);
                    for (f = f.entanglements; x; ) {
                        var E = 31 - ji(x),
                            R = 1 << E;
                        (R & h) | (f[E] & h) && (f[E] |= h), (x &= ~R);
                    }
                }
                var jt = 0;
                function Ps(f) {
                    return (
                        (f &= -f),
                        1 < f
                            ? 4 < f
                                ? (f & 268435455) !== 0
                                    ? 16
                                    : 536870912
                                : 4
                            : 1
                    );
                }
                var Go = r.unstable_scheduleCallback,
                    Wa = r.unstable_cancelCallback,
                    vo = r.unstable_shouldYield,
                    jv = r.unstable_requestPaint,
                    ei = r.unstable_now,
                    Wo = r.unstable_ImmediatePriority,
                    qv = r.unstable_UserBlockingPriority,
                    wc = r.unstable_NormalPriority,
                    Mc = r.unstable_IdlePriority,
                    jl = null,
                    cs = null;
                function ql(f) {
                    if (cs && typeof cs.onCommitFiberRoot == 'function')
                        try {
                            cs.onCommitFiberRoot(
                                jl,
                                f,
                                void 0,
                                (f.current.flags & 128) === 128
                            );
                        } catch {}
                }
                function $l(f, h) {
                    return (
                        (f === h && (f !== 0 || 1 / f === 1 / h)) ||
                        (f !== f && h !== h)
                    );
                }
                var Ii = typeof Object.is == 'function' ? Object.is : $l,
                    Cr = null,
                    Ec = !1,
                    Ph = !1;
                function Tc(f) {
                    Cr === null ? (Cr = [f]) : Cr.push(f);
                }
                function Ac(f) {
                    (Ec = !0), Tc(f);
                }
                function Rr() {
                    if (!Ph && Cr !== null) {
                        Ph = !0;
                        var f = 0,
                            h = jt;
                        try {
                            var x = Cr;
                            for (jt = 1; f < x.length; f++) {
                                var E = x[f];
                                do E = E(!0);
                                while (E !== null);
                            }
                            (Cr = null), (Ec = !1);
                        } catch (R) {
                            throw (
                                (Cr !== null && (Cr = Cr.slice(f + 1)),
                                Go(Wo, Rr),
                                R)
                            );
                        } finally {
                            (jt = h), (Ph = !1);
                        }
                    }
                    return null;
                }
                var am = l.ReactCurrentBatchConfig;
                function jr(f, h) {
                    if (Ii(f, h)) return !0;
                    if (
                        typeof f != 'object' ||
                        f === null ||
                        typeof h != 'object' ||
                        h === null
                    )
                        return !1;
                    var x = Object.keys(f),
                        E = Object.keys(h);
                    if (x.length !== E.length) return !1;
                    for (E = 0; E < x.length; E++) {
                        var R = x[E];
                        if (!Qt.call(h, R) || !Ii(f[R], h[R])) return !1;
                    }
                    return !0;
                }
                function Lh(f) {
                    switch (f.tag) {
                        case 5:
                            return Mt(f.type);
                        case 16:
                            return Mt('Lazy');
                        case 13:
                            return Mt('Suspense');
                        case 19:
                            return Mt('SuspenseList');
                        case 0:
                        case 2:
                        case 15:
                            return (f = wt(f.type, !1)), f;
                        case 11:
                            return (f = wt(f.type.render, !1)), f;
                        case 1:
                            return (f = wt(f.type, !0)), f;
                        default:
                            return '';
                    }
                }
                function qi(f, h) {
                    if (f && f.defaultProps) {
                        (h = s({}, h)), (f = f.defaultProps);
                        for (var x in f) h[x] === void 0 && (h[x] = f[x]);
                        return h;
                    }
                    return h;
                }
                var Yl = En(null),
                    Xo = null,
                    Ls = null,
                    Cc = null;
                function Di() {
                    Cc = Ls = Xo = null;
                }
                function jo(f, h, x) {
                    dt
                        ? (je(Yl, h._currentValue), (h._currentValue = x))
                        : (je(Yl, h._currentValue2), (h._currentValue2 = x));
                }
                function Kl(f) {
                    var h = Yl.current;
                    ft(Yl), dt ? (f._currentValue = h) : (f._currentValue2 = h);
                }
                function qo(f, h, x) {
                    for (; f !== null; ) {
                        var E = f.alternate;
                        if (
                            ((f.childLanes & h) !== h
                                ? ((f.childLanes |= h),
                                  E !== null && (E.childLanes |= h))
                                : E !== null &&
                                  (E.childLanes & h) !== h &&
                                  (E.childLanes |= h),
                            f === x)
                        )
                            break;
                        f = f.return;
                    }
                }
                function Xa(f, h) {
                    (Xo = f),
                        (Cc = Ls = null),
                        (f = f.dependencies),
                        f !== null &&
                            f.firstContext !== null &&
                            ((f.lanes & h) !== 0 && (li = !0),
                            (f.firstContext = null));
                }
                function $i(f) {
                    var h = dt ? f._currentValue : f._currentValue2;
                    if (Cc !== f)
                        if (
                            ((f = { context: f, memoizedValue: h, next: null }),
                            Ls === null)
                        ) {
                            if (Xo === null) throw Error(a(308));
                            (Ls = f),
                                (Xo.dependencies = {
                                    lanes: 0,
                                    firstContext: f,
                                });
                        } else Ls = Ls.next = f;
                    return h;
                }
                var br = null,
                    Pr = !1;
                function ja(f) {
                    f.updateQueue = {
                        baseState: f.memoizedState,
                        firstBaseUpdate: null,
                        lastBaseUpdate: null,
                        shared: { pending: null, interleaved: null, lanes: 0 },
                        effects: null,
                    };
                }
                function Ih(f, h) {
                    (f = f.updateQueue),
                        h.updateQueue === f &&
                            (h.updateQueue = {
                                baseState: f.baseState,
                                firstBaseUpdate: f.firstBaseUpdate,
                                lastBaseUpdate: f.lastBaseUpdate,
                                shared: f.shared,
                                effects: f.effects,
                            });
                }
                function Is(f, h) {
                    return {
                        eventTime: f,
                        lane: h,
                        tag: 0,
                        payload: null,
                        callback: null,
                        next: null,
                    };
                }
                function xo(f, h) {
                    var x = f.updateQueue;
                    x !== null &&
                        ((x = x.shared),
                        Hn !== null && (f.mode & 1) !== 0 && (Ht & 2) === 0
                            ? ((f = x.interleaved),
                              f === null
                                  ? ((h.next = h),
                                    br === null ? (br = [x]) : br.push(x))
                                  : ((h.next = f.next), (f.next = h)),
                              (x.interleaved = h))
                            : ((f = x.pending),
                              f === null
                                  ? (h.next = h)
                                  : ((h.next = f.next), (f.next = h)),
                              (x.pending = h)));
                }
                function Rc(f, h, x) {
                    if (
                        ((h = h.updateQueue),
                        h !== null && ((h = h.shared), (x & 4194240) !== 0))
                    ) {
                        var E = h.lanes;
                        (E &= f.pendingLanes),
                            (x |= E),
                            (h.lanes = x),
                            us(f, x);
                    }
                }
                function bc(f, h) {
                    var x = f.updateQueue,
                        E = f.alternate;
                    if (E !== null && ((E = E.updateQueue), x === E)) {
                        var R = null,
                            I = null;
                        if (((x = x.firstBaseUpdate), x !== null)) {
                            do {
                                var q = {
                                    eventTime: x.eventTime,
                                    lane: x.lane,
                                    tag: x.tag,
                                    payload: x.payload,
                                    callback: x.callback,
                                    next: null,
                                };
                                I === null ? (R = I = q) : (I = I.next = q),
                                    (x = x.next);
                            } while (x !== null);
                            I === null ? (R = I = h) : (I = I.next = h);
                        } else R = I = h;
                        (x = {
                            baseState: E.baseState,
                            firstBaseUpdate: R,
                            lastBaseUpdate: I,
                            shared: E.shared,
                            effects: E.effects,
                        }),
                            (f.updateQueue = x);
                        return;
                    }
                    (f = x.lastBaseUpdate),
                        f === null ? (x.firstBaseUpdate = h) : (f.next = h),
                        (x.lastBaseUpdate = h);
                }
                function Pc(f, h, x, E) {
                    var R = f.updateQueue;
                    Pr = !1;
                    var I = R.firstBaseUpdate,
                        q = R.lastBaseUpdate,
                        te = R.shared.pending;
                    if (te !== null) {
                        R.shared.pending = null;
                        var Me = te,
                            ze = Me.next;
                        (Me.next = null),
                            q === null ? (I = ze) : (q.next = ze),
                            (q = Me);
                        var ct = f.alternate;
                        ct !== null &&
                            ((ct = ct.updateQueue),
                            (te = ct.lastBaseUpdate),
                            te !== q &&
                                (te === null
                                    ? (ct.firstBaseUpdate = ze)
                                    : (te.next = ze),
                                (ct.lastBaseUpdate = Me)));
                    }
                    if (I !== null) {
                        var kt = R.baseState;
                        (q = 0), (ct = ze = Me = null), (te = I);
                        do {
                            var Tt = te.lane,
                                Gt = te.eventTime;
                            if ((E & Tt) === Tt) {
                                ct !== null &&
                                    (ct = ct.next =
                                        {
                                            eventTime: Gt,
                                            lane: 0,
                                            tag: te.tag,
                                            payload: te.payload,
                                            callback: te.callback,
                                            next: null,
                                        });
                                e: {
                                    var it = f,
                                        _i = te;
                                    switch (((Tt = h), (Gt = x), _i.tag)) {
                                        case 1:
                                            if (
                                                ((it = _i.payload),
                                                typeof it == 'function')
                                            ) {
                                                kt = it.call(Gt, kt, Tt);
                                                break e;
                                            }
                                            kt = it;
                                            break e;
                                        case 3:
                                            it.flags =
                                                (it.flags & -65537) | 128;
                                        case 0:
                                            if (
                                                ((it = _i.payload),
                                                (Tt =
                                                    typeof it == 'function'
                                                        ? it.call(Gt, kt, Tt)
                                                        : it),
                                                Tt == null)
                                            )
                                                break e;
                                            kt = s({}, kt, Tt);
                                            break e;
                                        case 2:
                                            Pr = !0;
                                    }
                                }
                                te.callback !== null &&
                                    te.lane !== 0 &&
                                    ((f.flags |= 64),
                                    (Tt = R.effects),
                                    Tt === null
                                        ? (R.effects = [te])
                                        : Tt.push(te));
                            } else
                                (Gt = {
                                    eventTime: Gt,
                                    lane: Tt,
                                    tag: te.tag,
                                    payload: te.payload,
                                    callback: te.callback,
                                    next: null,
                                }),
                                    ct === null
                                        ? ((ze = ct = Gt), (Me = kt))
                                        : (ct = ct.next = Gt),
                                    (q |= Tt);
                            if (((te = te.next), te === null)) {
                                if (((te = R.shared.pending), te === null))
                                    break;
                                (Tt = te),
                                    (te = Tt.next),
                                    (Tt.next = null),
                                    (R.lastBaseUpdate = Tt),
                                    (R.shared.pending = null);
                            }
                        } while (!0);
                        if (
                            (ct === null && (Me = kt),
                            (R.baseState = Me),
                            (R.firstBaseUpdate = ze),
                            (R.lastBaseUpdate = ct),
                            (h = R.shared.interleaved),
                            h !== null)
                        ) {
                            R = h;
                            do (q |= R.lane), (R = R.next);
                            while (R !== h);
                        } else I === null && (R.shared.lanes = 0);
                        (ps |= q), (f.lanes = q), (f.memoizedState = kt);
                    }
                }
                function lm(f, h, x) {
                    if (((f = h.effects), (h.effects = null), f !== null))
                        for (h = 0; h < f.length; h++) {
                            var E = f[h],
                                R = E.callback;
                            if (R !== null) {
                                if (
                                    ((E.callback = null),
                                    (E = x),
                                    typeof R != 'function')
                                )
                                    throw Error(a(191, R));
                                R.call(E);
                            }
                        }
                }
                var um = new n.Component().refs;
                function Dh(f, h, x, E) {
                    (h = f.memoizedState),
                        (x = x(E, h)),
                        (x = x == null ? h : s({}, h, x)),
                        (f.memoizedState = x),
                        f.lanes === 0 && (f.updateQueue.baseState = x);
                }
                var Lc = {
                    isMounted: function (f) {
                        return (f = f._reactInternals) ? U(f) === f : !1;
                    },
                    enqueueSetState: function (f, h, x) {
                        f = f._reactInternals;
                        var E = sn(),
                            R = Qr(f),
                            I = Is(E, R);
                        (I.payload = h),
                            x != null && (I.callback = x),
                            xo(f, I),
                            (h = Ai(f, R, E)),
                            h !== null && Rc(h, f, R);
                    },
                    enqueueReplaceState: function (f, h, x) {
                        f = f._reactInternals;
                        var E = sn(),
                            R = Qr(f),
                            I = Is(E, R);
                        (I.tag = 1),
                            (I.payload = h),
                            x != null && (I.callback = x),
                            xo(f, I),
                            (h = Ai(f, R, E)),
                            h !== null && Rc(h, f, R);
                    },
                    enqueueForceUpdate: function (f, h) {
                        f = f._reactInternals;
                        var x = sn(),
                            E = Qr(f),
                            R = Is(x, E);
                        (R.tag = 2),
                            h != null && (R.callback = h),
                            xo(f, R),
                            (h = Ai(f, E, x)),
                            h !== null && Rc(h, f, E);
                    },
                };
                function Nh(f, h, x, E, R, I, q) {
                    return (
                        (f = f.stateNode),
                        typeof f.shouldComponentUpdate == 'function'
                            ? f.shouldComponentUpdate(E, I, q)
                            : h.prototype && h.prototype.isPureReactComponent
                              ? !jr(x, E) || !jr(R, I)
                              : !0
                    );
                }
                function cm(f, h, x) {
                    var E = !1,
                        R = Zt,
                        I = h.contextType;
                    return (
                        typeof I == 'object' && I !== null
                            ? (I = $i(I))
                            : ((R = zn(h) ? Wi : It.current),
                              (E = h.contextTypes),
                              (I = (E = E != null) ? Dn(f, R) : Zt)),
                        (h = new h(x, I)),
                        (f.memoizedState =
                            h.state !== null && h.state !== void 0
                                ? h.state
                                : null),
                        (h.updater = Lc),
                        (f.stateNode = h),
                        (h._reactInternals = f),
                        E &&
                            ((f = f.stateNode),
                            (f.__reactInternalMemoizedUnmaskedChildContext = R),
                            (f.__reactInternalMemoizedMaskedChildContext = I)),
                        h
                    );
                }
                function fm(f, h, x, E) {
                    (f = h.state),
                        typeof h.componentWillReceiveProps == 'function' &&
                            h.componentWillReceiveProps(x, E),
                        typeof h.UNSAFE_componentWillReceiveProps ==
                            'function' &&
                            h.UNSAFE_componentWillReceiveProps(x, E),
                        h.state !== f &&
                            Lc.enqueueReplaceState(h, h.state, null);
                }
                function Uh(f, h, x, E) {
                    var R = f.stateNode;
                    (R.props = x),
                        (R.state = f.memoizedState),
                        (R.refs = um),
                        ja(f);
                    var I = h.contextType;
                    typeof I == 'object' && I !== null
                        ? (R.context = $i(I))
                        : ((I = zn(h) ? Wi : It.current),
                          (R.context = Dn(f, I))),
                        (R.state = f.memoizedState),
                        (I = h.getDerivedStateFromProps),
                        typeof I == 'function' &&
                            (Dh(f, h, I, x), (R.state = f.memoizedState)),
                        typeof h.getDerivedStateFromProps == 'function' ||
                            typeof R.getSnapshotBeforeUpdate == 'function' ||
                            (typeof R.UNSAFE_componentWillMount != 'function' &&
                                typeof R.componentWillMount != 'function') ||
                            ((h = R.state),
                            typeof R.componentWillMount == 'function' &&
                                R.componentWillMount(),
                            typeof R.UNSAFE_componentWillMount == 'function' &&
                                R.UNSAFE_componentWillMount(),
                            h !== R.state &&
                                Lc.enqueueReplaceState(R, R.state, null),
                            Pc(f, x, R, E),
                            (R.state = f.memoizedState)),
                        typeof R.componentDidMount == 'function' &&
                            (f.flags |= 4194308);
                }
                var qa = [],
                    _o = 0,
                    Ic = null,
                    Dc = 0,
                    Lr = [],
                    cr = 0,
                    $o = null,
                    Ds = 1,
                    Ns = '';
                function Yo(f, h) {
                    (qa[_o++] = Dc), (qa[_o++] = Ic), (Ic = f), (Dc = h);
                }
                function hm(f, h, x) {
                    (Lr[cr++] = Ds), (Lr[cr++] = Ns), (Lr[cr++] = $o), ($o = f);
                    var E = Ds;
                    f = Ns;
                    var R = 32 - ji(E) - 1;
                    (E &= ~(1 << R)), (x += 1);
                    var I = 32 - ji(h) + R;
                    if (30 < I) {
                        var q = R - (R % 5);
                        (I = (E & ((1 << q) - 1)).toString(32)),
                            (E >>= q),
                            (R -= q),
                            (Ds = (1 << (32 - ji(h) + R)) | (x << R) | E),
                            (Ns = I + f);
                    } else (Ds = (1 << I) | (x << R) | E), (Ns = f);
                }
                function Oh(f) {
                    f.return !== null && (Yo(f, 1), hm(f, 1, 0));
                }
                function kh(f) {
                    for (; f === Ic; )
                        (Ic = qa[--_o]),
                            (qa[_o] = null),
                            (Dc = qa[--_o]),
                            (qa[_o] = null);
                    for (; f === $o; )
                        ($o = Lr[--cr]),
                            (Lr[cr] = null),
                            (Ns = Lr[--cr]),
                            (Lr[cr] = null),
                            (Ds = Lr[--cr]),
                            (Lr[cr] = null);
                }
                var Ni = null,
                    mi = null,
                    Rn = !1,
                    $a = !1,
                    Ir = null;
                function Fh(f, h) {
                    var x = yr(5, null, null, 0);
                    (x.elementType = 'DELETED'),
                        (x.stateNode = h),
                        (x.return = f),
                        (h = f.deletions),
                        h === null
                            ? ((f.deletions = [x]), (f.flags |= 16))
                            : h.push(x);
                }
                function Bh(f, h) {
                    switch (f.tag) {
                        case 5:
                            return (
                                (h = mo(h, f.type, f.pendingProps)),
                                h !== null
                                    ? ((f.stateNode = h),
                                      (Ni = f),
                                      (mi = go(h)),
                                      !0)
                                    : !1
                            );
                        case 6:
                            return (
                                (h = Wr(h, f.pendingProps)),
                                h !== null
                                    ? ((f.stateNode = h),
                                      (Ni = f),
                                      (mi = null),
                                      !0)
                                    : !1
                            );
                        case 13:
                            if (((h = Cs(h)), h !== null)) {
                                var x =
                                    $o !== null
                                        ? { id: Ds, overflow: Ns }
                                        : null;
                                return (
                                    (f.memoizedState = {
                                        dehydrated: h,
                                        treeContext: x,
                                        retryLane: 1073741824,
                                    }),
                                    (x = yr(18, null, null, 0)),
                                    (x.stateNode = h),
                                    (x.return = f),
                                    (f.child = x),
                                    (Ni = f),
                                    (mi = null),
                                    !0
                                );
                            }
                            return !1;
                        default:
                            return !1;
                    }
                }
                function Nc(f) {
                    return (f.mode & 1) !== 0 && (f.flags & 128) === 0;
                }
                function So(f) {
                    if (Rn) {
                        var h = mi;
                        if (h) {
                            var x = h;
                            if (!Bh(f, h)) {
                                if (Nc(f)) throw Error(a(418));
                                h = Xr(x);
                                var E = Ni;
                                h && Bh(f, h)
                                    ? Fh(E, x)
                                    : ((f.flags = (f.flags & -4097) | 2),
                                      (Rn = !1),
                                      (Ni = f));
                            }
                        } else {
                            if (Nc(f)) throw Error(a(418));
                            (f.flags = (f.flags & -4097) | 2),
                                (Rn = !1),
                                (Ni = f);
                        }
                    }
                }
                function dm(f) {
                    for (
                        f = f.return;
                        f !== null &&
                        f.tag !== 5 &&
                        f.tag !== 3 &&
                        f.tag !== 13;

                    )
                        f = f.return;
                    Ni = f;
                }
                function Zl(f) {
                    if (!Ie || f !== Ni) return !1;
                    if (!Rn) return dm(f), (Rn = !0), !1;
                    if (
                        f.tag !== 3 &&
                        (f.tag !== 5 ||
                            (We(f.type) && !we(f.type, f.memoizedProps)))
                    ) {
                        var h = mi;
                        if (h) {
                            if (Nc(f)) {
                                for (f = mi; f; ) f = Xr(f);
                                throw Error(a(418));
                            }
                            for (; h; ) Fh(f, h), (h = Xr(h));
                        }
                    }
                    if ((dm(f), f.tag === 13)) {
                        if (!Ie) throw Error(a(316));
                        if (
                            ((f = f.memoizedState),
                            (f = f !== null ? f.dehydrated : null),
                            !f)
                        )
                            throw Error(a(317));
                        mi = V(f);
                    } else mi = Ni ? Xr(f.stateNode) : null;
                    return !0;
                }
                function Ya() {
                    Ie && ((mi = Ni = null), ($a = Rn = !1));
                }
                function Uc(f) {
                    Ir === null ? (Ir = [f]) : Ir.push(f);
                }
                function Ka(f, h, x) {
                    if (
                        ((f = x.ref),
                        f !== null &&
                            typeof f != 'function' &&
                            typeof f != 'object')
                    ) {
                        if (x._owner) {
                            if (((x = x._owner), x)) {
                                if (x.tag !== 1) throw Error(a(309));
                                var E = x.stateNode;
                            }
                            if (!E) throw Error(a(147, f));
                            var R = E,
                                I = '' + f;
                            return h !== null &&
                                h.ref !== null &&
                                typeof h.ref == 'function' &&
                                h.ref._stringRef === I
                                ? h.ref
                                : ((h = function (q) {
                                      var te = R.refs;
                                      te === um && (te = R.refs = {}),
                                          q === null
                                              ? delete te[I]
                                              : (te[I] = q);
                                  }),
                                  (h._stringRef = I),
                                  h);
                        }
                        if (typeof f != 'string') throw Error(a(284));
                        if (!x._owner) throw Error(a(290, f));
                    }
                    return f;
                }
                function wo(f, h) {
                    throw (
                        ((f = Object.prototype.toString.call(h)),
                        Error(
                            a(
                                31,
                                f === '[object Object]'
                                    ? 'object with keys {' +
                                          Object.keys(h).join(', ') +
                                          '}'
                                    : f
                            )
                        ))
                    );
                }
                function Za(f) {
                    var h = f._init;
                    return h(f._payload);
                }
                function pm(f) {
                    function h(pe, se) {
                        if (f) {
                            var _e = pe.deletions;
                            _e === null
                                ? ((pe.deletions = [se]), (pe.flags |= 16))
                                : _e.push(se);
                        }
                    }
                    function x(pe, se) {
                        if (!f) return null;
                        for (; se !== null; ) h(pe, se), (se = se.sibling);
                        return null;
                    }
                    function E(pe, se) {
                        for (pe = new Map(); se !== null; )
                            se.key !== null
                                ? pe.set(se.key, se)
                                : pe.set(se.index, se),
                                (se = se.sibling);
                        return pe;
                    }
                    function R(pe, se) {
                        return (
                            (pe = $s(pe, se)),
                            (pe.index = 0),
                            (pe.sibling = null),
                            pe
                        );
                    }
                    function I(pe, se, _e) {
                        return (
                            (pe.index = _e),
                            f
                                ? ((_e = pe.alternate),
                                  _e !== null
                                      ? ((_e = _e.index),
                                        _e < se ? ((pe.flags |= 2), se) : _e)
                                      : ((pe.flags |= 2), se))
                                : ((pe.flags |= 1048576), se)
                        );
                    }
                    function q(pe) {
                        return (
                            f && pe.alternate === null && (pe.flags |= 2), pe
                        );
                    }
                    function te(pe, se, _e, Qe) {
                        return se === null || se.tag !== 6
                            ? ((se = uf(_e, pe.mode, Qe)), (se.return = pe), se)
                            : ((se = R(se, _e)), (se.return = pe), se);
                    }
                    function Me(pe, se, _e, Qe) {
                        var yt = _e.type;
                        return yt === p
                            ? ct(pe, se, _e.props.children, Qe, _e.key)
                            : se !== null &&
                                (se.elementType === yt ||
                                    (typeof yt == 'object' &&
                                        yt !== null &&
                                        yt.$$typeof === C &&
                                        Za(yt) === se.type))
                              ? ((Qe = R(se, _e.props)),
                                (Qe.ref = Ka(pe, se, _e)),
                                (Qe.return = pe),
                                Qe)
                              : ((Qe = lf(
                                    _e.type,
                                    _e.key,
                                    _e.props,
                                    null,
                                    pe.mode,
                                    Qe
                                )),
                                (Qe.ref = Ka(pe, se, _e)),
                                (Qe.return = pe),
                                Qe);
                    }
                    function ze(pe, se, _e, Qe) {
                        return se === null ||
                            se.tag !== 4 ||
                            se.stateNode.containerInfo !== _e.containerInfo ||
                            se.stateNode.implementation !== _e.implementation
                            ? ((se = cf(_e, pe.mode, Qe)), (se.return = pe), se)
                            : ((se = R(se, _e.children || [])),
                              (se.return = pe),
                              se);
                    }
                    function ct(pe, se, _e, Qe, yt) {
                        return se === null || se.tag !== 7
                            ? ((se = ya(_e, pe.mode, Qe, yt)),
                              (se.return = pe),
                              se)
                            : ((se = R(se, _e)), (se.return = pe), se);
                    }
                    function kt(pe, se, _e) {
                        if (
                            (typeof se == 'string' && se !== '') ||
                            typeof se == 'number'
                        )
                            return (
                                (se = uf('' + se, pe.mode, _e)),
                                (se.return = pe),
                                se
                            );
                        if (typeof se == 'object' && se !== null) {
                            switch (se.$$typeof) {
                                case c:
                                    return (
                                        (_e = lf(
                                            se.type,
                                            se.key,
                                            se.props,
                                            null,
                                            pe.mode,
                                            _e
                                        )),
                                        (_e.ref = Ka(pe, null, se)),
                                        (_e.return = pe),
                                        _e
                                    );
                                case d:
                                    return (
                                        (se = cf(se, pe.mode, _e)),
                                        (se.return = pe),
                                        se
                                    );
                                case C:
                                    var Qe = se._init;
                                    return kt(pe, Qe(se._payload), _e);
                            }
                            if (Se(se) || N(se))
                                return (
                                    (se = ya(se, pe.mode, _e, null)),
                                    (se.return = pe),
                                    se
                                );
                            wo(pe, se);
                        }
                        return null;
                    }
                    function Tt(pe, se, _e, Qe) {
                        var yt = se !== null ? se.key : null;
                        if (
                            (typeof _e == 'string' && _e !== '') ||
                            typeof _e == 'number'
                        )
                            return yt !== null ? null : te(pe, se, '' + _e, Qe);
                        if (typeof _e == 'object' && _e !== null) {
                            switch (_e.$$typeof) {
                                case c:
                                    return _e.key === yt
                                        ? Me(pe, se, _e, Qe)
                                        : null;
                                case d:
                                    return _e.key === yt
                                        ? ze(pe, se, _e, Qe)
                                        : null;
                                case C:
                                    return (
                                        (yt = _e._init),
                                        Tt(pe, se, yt(_e._payload), Qe)
                                    );
                            }
                            if (Se(_e) || N(_e))
                                return yt !== null
                                    ? null
                                    : ct(pe, se, _e, Qe, null);
                            wo(pe, _e);
                        }
                        return null;
                    }
                    function Gt(pe, se, _e, Qe, yt) {
                        if (
                            (typeof Qe == 'string' && Qe !== '') ||
                            typeof Qe == 'number'
                        )
                            return (
                                (pe = pe.get(_e) || null),
                                te(se, pe, '' + Qe, yt)
                            );
                        if (typeof Qe == 'object' && Qe !== null) {
                            switch (Qe.$$typeof) {
                                case c:
                                    return (
                                        (pe =
                                            pe.get(
                                                Qe.key === null ? _e : Qe.key
                                            ) || null),
                                        Me(se, pe, Qe, yt)
                                    );
                                case d:
                                    return (
                                        (pe =
                                            pe.get(
                                                Qe.key === null ? _e : Qe.key
                                            ) || null),
                                        ze(se, pe, Qe, yt)
                                    );
                                case C:
                                    var Vt = Qe._init;
                                    return Gt(pe, se, _e, Vt(Qe._payload), yt);
                            }
                            if (Se(Qe) || N(Qe))
                                return (
                                    (pe = pe.get(_e) || null),
                                    ct(se, pe, Qe, yt, null)
                                );
                            wo(se, Qe);
                        }
                        return null;
                    }
                    function it(pe, se, _e, Qe) {
                        for (
                            var yt = null,
                                Vt = null,
                                Ft = se,
                                nn = (se = 0),
                                $n = null;
                            Ft !== null && nn < _e.length;
                            nn++
                        ) {
                            Ft.index > nn
                                ? (($n = Ft), (Ft = null))
                                : ($n = Ft.sibling);
                            var tn = Tt(pe, Ft, _e[nn], Qe);
                            if (tn === null) {
                                Ft === null && (Ft = $n);
                                break;
                            }
                            f && Ft && tn.alternate === null && h(pe, Ft),
                                (se = I(tn, se, nn)),
                                Vt === null ? (yt = tn) : (Vt.sibling = tn),
                                (Vt = tn),
                                (Ft = $n);
                        }
                        if (nn === _e.length)
                            return x(pe, Ft), Rn && Yo(pe, nn), yt;
                        if (Ft === null) {
                            for (; nn < _e.length; nn++)
                                (Ft = kt(pe, _e[nn], Qe)),
                                    Ft !== null &&
                                        ((se = I(Ft, se, nn)),
                                        Vt === null
                                            ? (yt = Ft)
                                            : (Vt.sibling = Ft),
                                        (Vt = Ft));
                            return Rn && Yo(pe, nn), yt;
                        }
                        for (Ft = E(pe, Ft); nn < _e.length; nn++)
                            ($n = Gt(Ft, pe, nn, _e[nn], Qe)),
                                $n !== null &&
                                    (f &&
                                        $n.alternate !== null &&
                                        Ft.delete(
                                            $n.key === null ? nn : $n.key
                                        ),
                                    (se = I($n, se, nn)),
                                    Vt === null ? (yt = $n) : (Vt.sibling = $n),
                                    (Vt = $n));
                        return (
                            f &&
                                Ft.forEach(function (Ys) {
                                    return h(pe, Ys);
                                }),
                            Rn && Yo(pe, nn),
                            yt
                        );
                    }
                    function _i(pe, se, _e, Qe) {
                        var yt = N(_e);
                        if (typeof yt != 'function') throw Error(a(150));
                        if (((_e = yt.call(_e)), _e == null))
                            throw Error(a(151));
                        for (
                            var Vt = (yt = null),
                                Ft = se,
                                nn = (se = 0),
                                $n = null,
                                tn = _e.next();
                            Ft !== null && !tn.done;
                            nn++, tn = _e.next()
                        ) {
                            Ft.index > nn
                                ? (($n = Ft), (Ft = null))
                                : ($n = Ft.sibling);
                            var Ys = Tt(pe, Ft, tn.value, Qe);
                            if (Ys === null) {
                                Ft === null && (Ft = $n);
                                break;
                            }
                            f && Ft && Ys.alternate === null && h(pe, Ft),
                                (se = I(Ys, se, nn)),
                                Vt === null ? (yt = Ys) : (Vt.sibling = Ys),
                                (Vt = Ys),
                                (Ft = $n);
                        }
                        if (tn.done) return x(pe, Ft), Rn && Yo(pe, nn), yt;
                        if (Ft === null) {
                            for (; !tn.done; nn++, tn = _e.next())
                                (tn = kt(pe, tn.value, Qe)),
                                    tn !== null &&
                                        ((se = I(tn, se, nn)),
                                        Vt === null
                                            ? (yt = tn)
                                            : (Vt.sibling = tn),
                                        (Vt = tn));
                            return Rn && Yo(pe, nn), yt;
                        }
                        for (Ft = E(pe, Ft); !tn.done; nn++, tn = _e.next())
                            (tn = Gt(Ft, pe, nn, tn.value, Qe)),
                                tn !== null &&
                                    (f &&
                                        tn.alternate !== null &&
                                        Ft.delete(
                                            tn.key === null ? nn : tn.key
                                        ),
                                    (se = I(tn, se, nn)),
                                    Vt === null ? (yt = tn) : (Vt.sibling = tn),
                                    (Vt = tn));
                        return (
                            f &&
                                Ft.forEach(function (gd) {
                                    return h(pe, gd);
                                }),
                            Rn && Yo(pe, nn),
                            yt
                        );
                    }
                    function vr(pe, se, _e, Qe) {
                        if (
                            (typeof _e == 'object' &&
                                _e !== null &&
                                _e.type === p &&
                                _e.key === null &&
                                (_e = _e.props.children),
                            typeof _e == 'object' && _e !== null)
                        ) {
                            switch (_e.$$typeof) {
                                case c:
                                    e: {
                                        for (
                                            var yt = _e.key, Vt = se;
                                            Vt !== null;

                                        ) {
                                            if (Vt.key === yt) {
                                                if (
                                                    ((yt = _e.type), yt === p)
                                                ) {
                                                    if (Vt.tag === 7) {
                                                        x(pe, Vt.sibling),
                                                            (se = R(
                                                                Vt,
                                                                _e.props
                                                                    .children
                                                            )),
                                                            (se.return = pe),
                                                            (pe = se);
                                                        break e;
                                                    }
                                                } else if (
                                                    Vt.elementType === yt ||
                                                    (typeof yt == 'object' &&
                                                        yt !== null &&
                                                        yt.$$typeof === C &&
                                                        Za(yt) === Vt.type)
                                                ) {
                                                    x(pe, Vt.sibling),
                                                        (se = R(Vt, _e.props)),
                                                        (se.ref = Ka(
                                                            pe,
                                                            Vt,
                                                            _e
                                                        )),
                                                        (se.return = pe),
                                                        (pe = se);
                                                    break e;
                                                }
                                                x(pe, Vt);
                                                break;
                                            } else h(pe, Vt);
                                            Vt = Vt.sibling;
                                        }
                                        _e.type === p
                                            ? ((se = ya(
                                                  _e.props.children,
                                                  pe.mode,
                                                  Qe,
                                                  _e.key
                                              )),
                                              (se.return = pe),
                                              (pe = se))
                                            : ((Qe = lf(
                                                  _e.type,
                                                  _e.key,
                                                  _e.props,
                                                  null,
                                                  pe.mode,
                                                  Qe
                                              )),
                                              (Qe.ref = Ka(pe, se, _e)),
                                              (Qe.return = pe),
                                              (pe = Qe));
                                    }
                                    return q(pe);
                                case d:
                                    e: {
                                        for (Vt = _e.key; se !== null; ) {
                                            if (se.key === Vt)
                                                if (
                                                    se.tag === 4 &&
                                                    se.stateNode
                                                        .containerInfo ===
                                                        _e.containerInfo &&
                                                    se.stateNode
                                                        .implementation ===
                                                        _e.implementation
                                                ) {
                                                    x(pe, se.sibling),
                                                        (se = R(
                                                            se,
                                                            _e.children || []
                                                        )),
                                                        (se.return = pe),
                                                        (pe = se);
                                                    break e;
                                                } else {
                                                    x(pe, se);
                                                    break;
                                                }
                                            else h(pe, se);
                                            se = se.sibling;
                                        }
                                        (se = cf(_e, pe.mode, Qe)),
                                            (se.return = pe),
                                            (pe = se);
                                    }
                                    return q(pe);
                                case C:
                                    return (
                                        (Vt = _e._init),
                                        vr(pe, se, Vt(_e._payload), Qe)
                                    );
                            }
                            if (Se(_e)) return it(pe, se, _e, Qe);
                            if (N(_e)) return _i(pe, se, _e, Qe);
                            wo(pe, _e);
                        }
                        return (typeof _e == 'string' && _e !== '') ||
                            typeof _e == 'number'
                            ? ((_e = '' + _e),
                              se !== null && se.tag === 6
                                  ? (x(pe, se.sibling),
                                    (se = R(se, _e)),
                                    (se.return = pe),
                                    (pe = se))
                                  : (x(pe, se),
                                    (se = uf(_e, pe.mode, Qe)),
                                    (se.return = pe),
                                    (pe = se)),
                              q(pe))
                            : x(pe, se);
                    }
                    return vr;
                }
                var Us = pm(!0),
                    mm = pm(!1),
                    Ja = {},
                    Yi = En(Ja),
                    Ko = En(Ja),
                    Zo = En(Ja);
                function qr(f) {
                    if (f === Ja) throw Error(a(174));
                    return f;
                }
                function Oc(f, h) {
                    je(Zo, h),
                        je(Ko, f),
                        je(Yi, Ja),
                        (f = me(h)),
                        ft(Yi),
                        je(Yi, f);
                }
                function Qa() {
                    ft(Yi), ft(Ko), ft(Zo);
                }
                function gm(f) {
                    var h = qr(Zo.current),
                        x = qr(Yi.current);
                    (h = X(x, f.type, h)), x !== h && (je(Ko, f), je(Yi, h));
                }
                function zh(f) {
                    Ko.current === f && (ft(Yi), ft(Ko));
                }
                var Nn = En(0);
                function kc(f) {
                    for (var h = f; h !== null; ) {
                        if (h.tag === 13) {
                            var x = h.memoizedState;
                            if (
                                x !== null &&
                                ((x = x.dehydrated),
                                x === null || Gl(x) || ls(x))
                            )
                                return h;
                        } else if (
                            h.tag === 19 &&
                            h.memoizedProps.revealOrder !== void 0
                        ) {
                            if ((h.flags & 128) !== 0) return h;
                        } else if (h.child !== null) {
                            (h.child.return = h), (h = h.child);
                            continue;
                        }
                        if (h === f) break;
                        for (; h.sibling === null; ) {
                            if (h.return === null || h.return === f)
                                return null;
                            h = h.return;
                        }
                        (h.sibling.return = h.return), (h = h.sibling);
                    }
                    return null;
                }
                var fr = [];
                function Jo() {
                    for (var f = 0; f < fr.length; f++) {
                        var h = fr[f];
                        dt
                            ? (h._workInProgressVersionPrimary = null)
                            : (h._workInProgressVersionSecondary = null);
                    }
                    fr.length = 0;
                }
                var Jl = l.ReactCurrentDispatcher,
                    hr = l.ReactCurrentBatchConfig,
                    Qo = 0,
                    Un = null,
                    si = null,
                    oi = null,
                    Fc = !1,
                    fs = !1,
                    ea = 0,
                    Ql = 0;
                function ai() {
                    throw Error(a(321));
                }
                function Bc(f, h) {
                    if (h === null) return !1;
                    for (var x = 0; x < h.length && x < f.length; x++)
                        if (!Ii(f[x], h[x])) return !1;
                    return !0;
                }
                function el(f, h, x, E, R, I) {
                    if (
                        ((Qo = I),
                        (Un = h),
                        (h.memoizedState = null),
                        (h.updateQueue = null),
                        (h.lanes = 0),
                        (Jl.current =
                            f === null || f.memoizedState === null ? jh : qh),
                        (f = x(E, R)),
                        fs)
                    ) {
                        I = 0;
                        do {
                            if (((fs = !1), (ea = 0), 25 <= I))
                                throw Error(a(301));
                            (I += 1),
                                (oi = si = null),
                                (h.updateQueue = null),
                                (Jl.current = $h),
                                (f = x(E, R));
                        } while (fs);
                    }
                    if (
                        ((Jl.current = rl),
                        (h = si !== null && si.next !== null),
                        (Qo = 0),
                        (oi = si = Un = null),
                        (Fc = !1),
                        h)
                    )
                        throw Error(a(300));
                    return f;
                }
                function Mo() {
                    var f = ea !== 0;
                    return (ea = 0), f;
                }
                function $r() {
                    var f = {
                        memoizedState: null,
                        baseState: null,
                        baseQueue: null,
                        queue: null,
                        next: null,
                    };
                    return (
                        oi === null
                            ? (Un.memoizedState = oi = f)
                            : (oi = oi.next = f),
                        oi
                    );
                }
                function Yr() {
                    if (si === null) {
                        var f = Un.alternate;
                        f = f !== null ? f.memoizedState : null;
                    } else f = si.next;
                    var h = oi === null ? Un.memoizedState : oi.next;
                    if (h !== null) (oi = h), (si = f);
                    else {
                        if (f === null) throw Error(a(310));
                        (si = f),
                            (f = {
                                memoizedState: si.memoizedState,
                                baseState: si.baseState,
                                baseQueue: si.baseQueue,
                                queue: si.queue,
                                next: null,
                            }),
                            oi === null
                                ? (Un.memoizedState = oi = f)
                                : (oi = oi.next = f);
                    }
                    return oi;
                }
                function hs(f, h) {
                    return typeof h == 'function' ? h(f) : h;
                }
                function eu(f) {
                    var h = Yr(),
                        x = h.queue;
                    if (x === null) throw Error(a(311));
                    x.lastRenderedReducer = f;
                    var E = si,
                        R = E.baseQueue,
                        I = x.pending;
                    if (I !== null) {
                        if (R !== null) {
                            var q = R.next;
                            (R.next = I.next), (I.next = q);
                        }
                        (E.baseQueue = R = I), (x.pending = null);
                    }
                    if (R !== null) {
                        (I = R.next), (E = E.baseState);
                        var te = (q = null),
                            Me = null,
                            ze = I;
                        do {
                            var ct = ze.lane;
                            if ((Qo & ct) === ct)
                                Me !== null &&
                                    (Me = Me.next =
                                        {
                                            lane: 0,
                                            action: ze.action,
                                            hasEagerState: ze.hasEagerState,
                                            eagerState: ze.eagerState,
                                            next: null,
                                        }),
                                    (E = ze.hasEagerState
                                        ? ze.eagerState
                                        : f(E, ze.action));
                            else {
                                var kt = {
                                    lane: ct,
                                    action: ze.action,
                                    hasEagerState: ze.hasEagerState,
                                    eagerState: ze.eagerState,
                                    next: null,
                                };
                                Me === null
                                    ? ((te = Me = kt), (q = E))
                                    : (Me = Me.next = kt),
                                    (Un.lanes |= ct),
                                    (ps |= ct);
                            }
                            ze = ze.next;
                        } while (ze !== null && ze !== I);
                        Me === null ? (q = E) : (Me.next = te),
                            Ii(E, h.memoizedState) || (li = !0),
                            (h.memoizedState = E),
                            (h.baseState = q),
                            (h.baseQueue = Me),
                            (x.lastRenderedState = E);
                    }
                    if (((f = x.interleaved), f !== null)) {
                        R = f;
                        do
                            (I = R.lane),
                                (Un.lanes |= I),
                                (ps |= I),
                                (R = R.next);
                        while (R !== f);
                    } else R === null && (x.lanes = 0);
                    return [h.memoizedState, x.dispatch];
                }
                function tu(f) {
                    var h = Yr(),
                        x = h.queue;
                    if (x === null) throw Error(a(311));
                    x.lastRenderedReducer = f;
                    var E = x.dispatch,
                        R = x.pending,
                        I = h.memoizedState;
                    if (R !== null) {
                        x.pending = null;
                        var q = (R = R.next);
                        do (I = f(I, q.action)), (q = q.next);
                        while (q !== R);
                        Ii(I, h.memoizedState) || (li = !0),
                            (h.memoizedState = I),
                            h.baseQueue === null && (h.baseState = I),
                            (x.lastRenderedState = I);
                    }
                    return [I, E];
                }
                function Vh() {}
                function Hh(f, h) {
                    var x = Un,
                        E = Yr(),
                        R = h(),
                        I = !Ii(E.memoizedState, R);
                    if (
                        (I && ((E.memoizedState = R), (li = !0)),
                        (E = E.queue),
                        tl(Os.bind(null, x, E, f), [f]),
                        E.getSnapshot !== h ||
                            I ||
                            (oi !== null && oi.memoizedState.tag & 1))
                    ) {
                        if (
                            ((x.flags |= 2048),
                            iu(9, Wh.bind(null, x, E, R, h), void 0, null),
                            Hn === null)
                        )
                            throw Error(a(349));
                        (Qo & 30) !== 0 || Gh(x, h, R);
                    }
                    return R;
                }
                function Gh(f, h, x) {
                    (f.flags |= 16384),
                        (f = { getSnapshot: h, value: x }),
                        (h = Un.updateQueue),
                        h === null
                            ? ((h = { lastEffect: null, stores: null }),
                              (Un.updateQueue = h),
                              (h.stores = [f]))
                            : ((x = h.stores),
                              x === null ? (h.stores = [f]) : x.push(f));
                }
                function Wh(f, h, x, E) {
                    (h.value = x), (h.getSnapshot = E), zc(h) && Ai(f, 1, -1);
                }
                function Os(f, h, x) {
                    return x(function () {
                        zc(h) && Ai(f, 1, -1);
                    });
                }
                function zc(f) {
                    var h = f.getSnapshot;
                    f = f.value;
                    try {
                        var x = h();
                        return !Ii(f, x);
                    } catch {
                        return !0;
                    }
                }
                function nu(f) {
                    var h = $r();
                    return (
                        typeof f == 'function' && (f = f()),
                        (h.memoizedState = h.baseState = f),
                        (f = {
                            pending: null,
                            interleaved: null,
                            lanes: 0,
                            dispatch: null,
                            lastRenderedReducer: hs,
                            lastRenderedState: f,
                        }),
                        (h.queue = f),
                        (f = f.dispatch = $v.bind(null, Un, f)),
                        [h.memoizedState, f]
                    );
                }
                function iu(f, h, x, E) {
                    return (
                        (f = {
                            tag: f,
                            create: h,
                            destroy: x,
                            deps: E,
                            next: null,
                        }),
                        (h = Un.updateQueue),
                        h === null
                            ? ((h = { lastEffect: null, stores: null }),
                              (Un.updateQueue = h),
                              (h.lastEffect = f.next = f))
                            : ((x = h.lastEffect),
                              x === null
                                  ? (h.lastEffect = f.next = f)
                                  : ((E = x.next),
                                    (x.next = f),
                                    (f.next = E),
                                    (h.lastEffect = f))),
                        f
                    );
                }
                function ym() {
                    return Yr().memoizedState;
                }
                function Eo(f, h, x, E) {
                    var R = $r();
                    (Un.flags |= f),
                        (R.memoizedState = iu(
                            1 | h,
                            x,
                            void 0,
                            E === void 0 ? null : E
                        ));
                }
                function Vc(f, h, x, E) {
                    var R = Yr();
                    E = E === void 0 ? null : E;
                    var I = void 0;
                    if (si !== null) {
                        var q = si.memoizedState;
                        if (((I = q.destroy), E !== null && Bc(E, q.deps))) {
                            R.memoizedState = iu(h, x, I, E);
                            return;
                        }
                    }
                    (Un.flags |= f), (R.memoizedState = iu(1 | h, x, I, E));
                }
                function Hc(f, h) {
                    return Eo(8390656, 8, f, h);
                }
                function tl(f, h) {
                    return Vc(2048, 8, f, h);
                }
                function _n(f, h) {
                    return Vc(4, 2, f, h);
                }
                function Gc(f, h) {
                    return Vc(4, 4, f, h);
                }
                function ru(f, h) {
                    if (typeof h == 'function')
                        return (
                            (f = f()),
                            h(f),
                            function () {
                                h(null);
                            }
                        );
                    if (h != null)
                        return (
                            (f = f()),
                            (h.current = f),
                            function () {
                                h.current = null;
                            }
                        );
                }
                function nl(f, h, x) {
                    return (
                        (x = x != null ? x.concat([f]) : null),
                        Vc(4, 4, ru.bind(null, h, f), x)
                    );
                }
                function Wc() {}
                function Xc(f, h) {
                    var x = Yr();
                    h = h === void 0 ? null : h;
                    var E = x.memoizedState;
                    return E !== null && h !== null && Bc(h, E[1])
                        ? E[0]
                        : ((x.memoizedState = [f, h]), f);
                }
                function il(f, h) {
                    var x = Yr();
                    h = h === void 0 ? null : h;
                    var E = x.memoizedState;
                    return E !== null && h !== null && Bc(h, E[1])
                        ? E[0]
                        : ((f = f()), (x.memoizedState = [f, h]), f);
                }
                function jc(f, h) {
                    var x = jt;
                    (jt = x !== 0 && 4 > x ? x : 4), f(!0);
                    var E = hr.transition;
                    hr.transition = {};
                    try {
                        f(!1), h();
                    } finally {
                        (jt = x), (hr.transition = E);
                    }
                }
                function ta() {
                    return Yr().memoizedState;
                }
                function vm(f, h, x) {
                    var E = Qr(f);
                    (x = {
                        lane: E,
                        action: x,
                        hasEagerState: !1,
                        eagerState: null,
                        next: null,
                    }),
                        xm(f)
                            ? Xh(h, x)
                            : (su(f, h, x),
                              (x = sn()),
                              (f = Ai(f, E, x)),
                              f !== null && ou(f, h, E));
                }
                function $v(f, h, x) {
                    var E = Qr(f),
                        R = {
                            lane: E,
                            action: x,
                            hasEagerState: !1,
                            eagerState: null,
                            next: null,
                        };
                    if (xm(f)) Xh(h, R);
                    else {
                        su(f, h, R);
                        var I = f.alternate;
                        if (
                            f.lanes === 0 &&
                            (I === null || I.lanes === 0) &&
                            ((I = h.lastRenderedReducer), I !== null)
                        )
                            try {
                                var q = h.lastRenderedState,
                                    te = I(q, x);
                                if (
                                    ((R.hasEagerState = !0),
                                    (R.eagerState = te),
                                    Ii(te, q))
                                )
                                    return;
                            } catch {
                            } finally {
                            }
                        (x = sn()),
                            (f = Ai(f, E, x)),
                            f !== null && ou(f, h, E);
                    }
                }
                function xm(f) {
                    var h = f.alternate;
                    return f === Un || (h !== null && h === Un);
                }
                function Xh(f, h) {
                    fs = Fc = !0;
                    var x = f.pending;
                    x === null
                        ? (h.next = h)
                        : ((h.next = x.next), (x.next = h)),
                        (f.pending = h);
                }
                function su(f, h, x) {
                    Hn !== null && (f.mode & 1) !== 0 && (Ht & 2) === 0
                        ? ((f = h.interleaved),
                          f === null
                              ? ((x.next = x),
                                br === null ? (br = [h]) : br.push(h))
                              : ((x.next = f.next), (f.next = x)),
                          (h.interleaved = x))
                        : ((f = h.pending),
                          f === null
                              ? (x.next = x)
                              : ((x.next = f.next), (f.next = x)),
                          (h.pending = x));
                }
                function ou(f, h, x) {
                    if ((x & 4194240) !== 0) {
                        var E = h.lanes;
                        (E &= f.pendingLanes),
                            (x |= E),
                            (h.lanes = x),
                            us(f, x);
                    }
                }
                var rl = {
                        readContext: $i,
                        useCallback: ai,
                        useContext: ai,
                        useEffect: ai,
                        useImperativeHandle: ai,
                        useInsertionEffect: ai,
                        useLayoutEffect: ai,
                        useMemo: ai,
                        useReducer: ai,
                        useRef: ai,
                        useState: ai,
                        useDebugValue: ai,
                        useDeferredValue: ai,
                        useTransition: ai,
                        useMutableSource: ai,
                        useSyncExternalStore: ai,
                        useId: ai,
                        unstable_isNewReconciler: !1,
                    },
                    jh = {
                        readContext: $i,
                        useCallback: function (f, h) {
                            return (
                                ($r().memoizedState = [
                                    f,
                                    h === void 0 ? null : h,
                                ]),
                                f
                            );
                        },
                        useContext: $i,
                        useEffect: Hc,
                        useImperativeHandle: function (f, h, x) {
                            return (
                                (x = x != null ? x.concat([f]) : null),
                                Eo(4194308, 4, ru.bind(null, h, f), x)
                            );
                        },
                        useLayoutEffect: function (f, h) {
                            return Eo(4194308, 4, f, h);
                        },
                        useInsertionEffect: function (f, h) {
                            return Eo(4, 2, f, h);
                        },
                        useMemo: function (f, h) {
                            var x = $r();
                            return (
                                (h = h === void 0 ? null : h),
                                (f = f()),
                                (x.memoizedState = [f, h]),
                                f
                            );
                        },
                        useReducer: function (f, h, x) {
                            var E = $r();
                            return (
                                (h = x !== void 0 ? x(h) : h),
                                (E.memoizedState = E.baseState = h),
                                (f = {
                                    pending: null,
                                    interleaved: null,
                                    lanes: 0,
                                    dispatch: null,
                                    lastRenderedReducer: f,
                                    lastRenderedState: h,
                                }),
                                (E.queue = f),
                                (f = f.dispatch = vm.bind(null, Un, f)),
                                [E.memoizedState, f]
                            );
                        },
                        useRef: function (f) {
                            var h = $r();
                            return (f = { current: f }), (h.memoizedState = f);
                        },
                        useState: nu,
                        useDebugValue: Wc,
                        useDeferredValue: function (f) {
                            var h = nu(f),
                                x = h[0],
                                E = h[1];
                            return (
                                Hc(
                                    function () {
                                        var R = hr.transition;
                                        hr.transition = {};
                                        try {
                                            E(f);
                                        } finally {
                                            hr.transition = R;
                                        }
                                    },
                                    [f]
                                ),
                                x
                            );
                        },
                        useTransition: function () {
                            var f = nu(!1),
                                h = f[0];
                            return (
                                (f = jc.bind(null, f[1])),
                                ($r().memoizedState = f),
                                [h, f]
                            );
                        },
                        useMutableSource: function () {},
                        useSyncExternalStore: function (f, h, x) {
                            var E = Un,
                                R = $r();
                            if (Rn) {
                                if (x === void 0) throw Error(a(407));
                                x = x();
                            } else {
                                if (((x = h()), Hn === null))
                                    throw Error(a(349));
                                (Qo & 30) !== 0 || Gh(E, h, x);
                            }
                            R.memoizedState = x;
                            var I = { value: x, getSnapshot: h };
                            return (
                                (R.queue = I),
                                Hc(Os.bind(null, E, I, f), [f]),
                                (E.flags |= 2048),
                                iu(9, Wh.bind(null, E, I, x, h), void 0, null),
                                x
                            );
                        },
                        useId: function () {
                            var f = $r(),
                                h = Hn.identifierPrefix;
                            if (Rn) {
                                var x = Ns,
                                    E = Ds;
                                (x =
                                    (E & ~(1 << (32 - ji(E) - 1))).toString(
                                        32
                                    ) + x),
                                    (h = ':' + h + 'R' + x),
                                    (x = ea++),
                                    0 < x && (h += 'H' + x.toString(32)),
                                    (h += ':');
                            } else
                                (x = Ql++),
                                    (h = ':' + h + 'r' + x.toString(32) + ':');
                            return (f.memoizedState = h);
                        },
                        unstable_isNewReconciler: !1,
                    },
                    qh = {
                        readContext: $i,
                        useCallback: Xc,
                        useContext: $i,
                        useEffect: tl,
                        useImperativeHandle: nl,
                        useInsertionEffect: _n,
                        useLayoutEffect: Gc,
                        useMemo: il,
                        useReducer: eu,
                        useRef: ym,
                        useState: function () {
                            return eu(hs);
                        },
                        useDebugValue: Wc,
                        useDeferredValue: function (f) {
                            var h = eu(hs),
                                x = h[0],
                                E = h[1];
                            return (
                                tl(
                                    function () {
                                        var R = hr.transition;
                                        hr.transition = {};
                                        try {
                                            E(f);
                                        } finally {
                                            hr.transition = R;
                                        }
                                    },
                                    [f]
                                ),
                                x
                            );
                        },
                        useTransition: function () {
                            var f = eu(hs)[0],
                                h = Yr().memoizedState;
                            return [f, h];
                        },
                        useMutableSource: Vh,
                        useSyncExternalStore: Hh,
                        useId: ta,
                        unstable_isNewReconciler: !1,
                    },
                    $h = {
                        readContext: $i,
                        useCallback: Xc,
                        useContext: $i,
                        useEffect: tl,
                        useImperativeHandle: nl,
                        useInsertionEffect: _n,
                        useLayoutEffect: Gc,
                        useMemo: il,
                        useReducer: tu,
                        useRef: ym,
                        useState: function () {
                            return tu(hs);
                        },
                        useDebugValue: Wc,
                        useDeferredValue: function (f) {
                            var h = tu(hs),
                                x = h[0],
                                E = h[1];
                            return (
                                tl(
                                    function () {
                                        var R = hr.transition;
                                        hr.transition = {};
                                        try {
                                            E(f);
                                        } finally {
                                            hr.transition = R;
                                        }
                                    },
                                    [f]
                                ),
                                x
                            );
                        },
                        useTransition: function () {
                            var f = tu(hs)[0],
                                h = Yr().memoizedState;
                            return [f, h];
                        },
                        useMutableSource: Vh,
                        useSyncExternalStore: Hh,
                        useId: ta,
                        unstable_isNewReconciler: !1,
                    };
                function Yh(f, h) {
                    try {
                        var x = '',
                            E = h;
                        do (x += Lh(E)), (E = E.return);
                        while (E);
                        var R = x;
                    } catch (I) {
                        R =
                            `
Error generating stack: ` +
                            I.message +
                            `
` +
                            I.stack;
                    }
                    return { value: f, source: h, stack: R };
                }
                function qc(f, h) {
                    try {
                        console.error(h.value);
                    } catch (x) {
                        setTimeout(function () {
                            throw x;
                        });
                    }
                }
                var Yv = typeof WeakMap == 'function' ? WeakMap : Map;
                function _m(f, h, x) {
                    (x = Is(-1, x)),
                        (x.tag = 3),
                        (x.payload = { element: null });
                    var E = h.value;
                    return (
                        (x.callback = function () {
                            cl || ((cl = !0), (An = E)), qc(f, h);
                        }),
                        x
                    );
                }
                function $c(f, h, x) {
                    (x = Is(-1, x)), (x.tag = 3);
                    var E = f.type.getDerivedStateFromError;
                    if (typeof E == 'function') {
                        var R = h.value;
                        (x.payload = function () {
                            return E(R);
                        }),
                            (x.callback = function () {
                                qc(f, h);
                            });
                    }
                    var I = f.stateNode;
                    return (
                        I !== null &&
                            typeof I.componentDidCatch == 'function' &&
                            (x.callback = function () {
                                qc(f, h),
                                    typeof E != 'function' &&
                                        (Jr === null
                                            ? (Jr = new Set([this]))
                                            : Jr.add(this));
                                var q = h.stack;
                                this.componentDidCatch(h.value, {
                                    componentStack: q !== null ? q : '',
                                });
                            }),
                        x
                    );
                }
                function ks(f, h, x) {
                    var E = f.pingCache;
                    if (E === null) {
                        E = f.pingCache = new Yv();
                        var R = new Set();
                        E.set(h, R);
                    } else
                        (R = E.get(h)),
                            R === void 0 && ((R = new Set()), E.set(h, R));
                    R.has(x) ||
                        (R.add(x), (f = dd.bind(null, f, h, x)), h.then(f, f));
                }
                function Kh(f) {
                    do {
                        var h;
                        if (
                            ((h = f.tag === 13) &&
                                ((h = f.memoizedState),
                                (h = h !== null ? h.dehydrated !== null : !0)),
                            h)
                        )
                            return f;
                        f = f.return;
                    } while (f !== null);
                    return null;
                }
                function na(f, h, x, E, R) {
                    return (f.mode & 1) === 0
                        ? (f === h
                              ? (f.flags |= 65536)
                              : ((f.flags |= 128),
                                (x.flags |= 131072),
                                (x.flags &= -52805),
                                x.tag === 1 &&
                                    (x.alternate === null
                                        ? (x.tag = 17)
                                        : ((h = Is(-1, 1)),
                                          (h.tag = 2),
                                          xo(x, h))),
                                (x.lanes |= 1)),
                          f)
                        : ((f.flags |= 65536), (f.lanes = R), f);
                }
                function ti(f) {
                    f.flags |= 4;
                }
                function sl(f, h) {
                    if (f !== null && f.child === h.child) return !0;
                    if ((h.flags & 16) !== 0) return !1;
                    for (f = h.child; f !== null; ) {
                        if (
                            (f.flags & 12854) !== 0 ||
                            (f.subtreeFlags & 12854) !== 0
                        )
                            return !1;
                        f = f.sibling;
                    }
                    return !0;
                }
                var dr, ia, Yc, Kc;
                if (Lt)
                    (dr = function (f, h) {
                        for (var x = h.child; x !== null; ) {
                            if (x.tag === 5 || x.tag === 6) ae(f, x.stateNode);
                            else if (x.tag !== 4 && x.child !== null) {
                                (x.child.return = x), (x = x.child);
                                continue;
                            }
                            if (x === h) break;
                            for (; x.sibling === null; ) {
                                if (x.return === null || x.return === h) return;
                                x = x.return;
                            }
                            (x.sibling.return = x.return), (x = x.sibling);
                        }
                    }),
                        (ia = function () {}),
                        (Yc = function (f, h, x, E, R) {
                            if (((f = f.memoizedProps), f !== E)) {
                                var I = h.stateNode,
                                    q = qr(Yi.current);
                                (x = fe(I, x, f, E, R, q)),
                                    (h.updateQueue = x) && ti(h);
                            }
                        }),
                        (Kc = function (f, h, x, E) {
                            x !== E && ti(h);
                        });
                else if (W) {
                    dr = function (f, h, x, E) {
                        for (var R = h.child; R !== null; ) {
                            if (R.tag === 5) {
                                var I = R.stateNode;
                                x &&
                                    E &&
                                    (I = Hi(I, R.type, R.memoizedProps, R)),
                                    ae(f, I);
                            } else if (R.tag === 6)
                                (I = R.stateNode),
                                    x && E && (I = Gi(I, R.memoizedProps, R)),
                                    ae(f, I);
                            else if (R.tag !== 4) {
                                if (R.tag === 22 && R.memoizedState !== null)
                                    (I = R.child),
                                        I !== null && (I.return = R),
                                        dr(f, R, !0, !0);
                                else if (R.child !== null) {
                                    (R.child.return = R), (R = R.child);
                                    continue;
                                }
                            }
                            if (R === h) break;
                            for (; R.sibling === null; ) {
                                if (R.return === null || R.return === h) return;
                                R = R.return;
                            }
                            (R.sibling.return = R.return), (R = R.sibling);
                        }
                    };
                    var To = function (f, h, x, E) {
                        for (var R = h.child; R !== null; ) {
                            if (R.tag === 5) {
                                var I = R.stateNode;
                                x &&
                                    E &&
                                    (I = Hi(I, R.type, R.memoizedProps, R)),
                                    Cn(f, I);
                            } else if (R.tag === 6)
                                (I = R.stateNode),
                                    x && E && (I = Gi(I, R.memoizedProps, R)),
                                    Cn(f, I);
                            else if (R.tag !== 4) {
                                if (R.tag === 22 && R.memoizedState !== null)
                                    (I = R.child),
                                        I !== null && (I.return = R),
                                        To(f, R, !0, !0);
                                else if (R.child !== null) {
                                    (R.child.return = R), (R = R.child);
                                    continue;
                                }
                            }
                            if (R === h) break;
                            for (; R.sibling === null; ) {
                                if (R.return === null || R.return === h) return;
                                R = R.return;
                            }
                            (R.sibling.return = R.return), (R = R.sibling);
                        }
                    };
                    (ia = function (f, h) {
                        var x = h.stateNode;
                        if (!sl(f, h)) {
                            f = x.containerInfo;
                            var E = Yt(f);
                            To(E, h, !1, !1),
                                (x.pendingChildren = E),
                                ti(h),
                                jn(f, E);
                        }
                    }),
                        (Yc = function (f, h, x, E, R) {
                            var I = f.stateNode,
                                q = f.memoizedProps;
                            if ((f = sl(f, h)) && q === E) h.stateNode = I;
                            else {
                                var te = h.stateNode,
                                    Me = qr(Yi.current),
                                    ze = null;
                                q !== E && (ze = fe(te, x, q, E, R, Me)),
                                    f && ze === null
                                        ? (h.stateNode = I)
                                        : ((I = At(I, ze, x, q, E, h, f, te)),
                                          Oe(I, x, E, R, Me) && ti(h),
                                          (h.stateNode = I),
                                          f ? ti(h) : dr(I, h, !1, !1));
                            }
                        }),
                        (Kc = function (f, h, x, E) {
                            x !== E
                                ? ((f = qr(Zo.current)),
                                  (x = qr(Yi.current)),
                                  (h.stateNode = Pe(E, f, x, h)),
                                  ti(h))
                                : (h.stateNode = f.stateNode);
                        });
                } else
                    (ia = function () {}),
                        (Yc = function () {}),
                        (Kc = function () {});
                function Fs(f, h) {
                    if (!Rn)
                        switch (f.tailMode) {
                            case 'hidden':
                                h = f.tail;
                                for (var x = null; h !== null; )
                                    h.alternate !== null && (x = h),
                                        (h = h.sibling);
                                x === null
                                    ? (f.tail = null)
                                    : (x.sibling = null);
                                break;
                            case 'collapsed':
                                x = f.tail;
                                for (var E = null; x !== null; )
                                    x.alternate !== null && (E = x),
                                        (x = x.sibling);
                                E === null
                                    ? h || f.tail === null
                                        ? (f.tail = null)
                                        : (f.tail.sibling = null)
                                    : (E.sibling = null);
                        }
                }
                function Vn(f) {
                    var h =
                            f.alternate !== null &&
                            f.alternate.child === f.child,
                        x = 0,
                        E = 0;
                    if (h)
                        for (var R = f.child; R !== null; )
                            (x |= R.lanes | R.childLanes),
                                (E |= R.subtreeFlags & 14680064),
                                (E |= R.flags & 14680064),
                                (R.return = f),
                                (R = R.sibling);
                    else
                        for (R = f.child; R !== null; )
                            (x |= R.lanes | R.childLanes),
                                (E |= R.subtreeFlags),
                                (E |= R.flags),
                                (R.return = f),
                                (R = R.sibling);
                    return (f.subtreeFlags |= E), (f.childLanes = x), h;
                }
                function Zc(f, h, x) {
                    var E = h.pendingProps;
                    switch ((kh(h), h.tag)) {
                        case 2:
                        case 16:
                        case 15:
                        case 0:
                        case 11:
                        case 7:
                        case 8:
                        case 12:
                        case 9:
                        case 14:
                            return Vn(h), null;
                        case 1:
                            return zn(h.type) && fn(), Vn(h), null;
                        case 3:
                            return (
                                (E = h.stateNode),
                                Qa(),
                                ft(xn),
                                ft(It),
                                Jo(),
                                E.pendingContext &&
                                    ((E.context = E.pendingContext),
                                    (E.pendingContext = null)),
                                (f === null || f.child === null) &&
                                    (Zl(h)
                                        ? ti(h)
                                        : f === null ||
                                          (f.memoizedState.isDehydrated &&
                                              (h.flags & 256) === 0) ||
                                          ((h.flags |= 1024),
                                          Ir !== null &&
                                              (xu(Ir), (Ir = null)))),
                                ia(f, h),
                                Vn(h),
                                null
                            );
                        case 5:
                            zh(h), (x = qr(Zo.current));
                            var R = h.type;
                            if (f !== null && h.stateNode != null)
                                Yc(f, h, R, E, x),
                                    f.ref !== h.ref &&
                                        ((h.flags |= 512),
                                        (h.flags |= 2097152));
                            else {
                                if (!E) {
                                    if (h.stateNode === null)
                                        throw Error(a(166));
                                    return Vn(h), null;
                                }
                                if (((f = qr(Yi.current)), Zl(h))) {
                                    if (!Ie) throw Error(a(175));
                                    (f = Rh(
                                        h.stateNode,
                                        h.type,
                                        h.memoizedProps,
                                        x,
                                        f,
                                        h,
                                        !$a
                                    )),
                                        (h.updateQueue = f),
                                        f !== null && ti(h);
                                } else {
                                    var I = G(R, E, x, f, h);
                                    dr(I, h, !1, !1),
                                        (h.stateNode = I),
                                        Oe(I, R, E, x, f) && ti(h);
                                }
                                h.ref !== null &&
                                    ((h.flags |= 512), (h.flags |= 2097152));
                            }
                            return Vn(h), null;
                        case 6:
                            if (f && h.stateNode != null)
                                Kc(f, h, f.memoizedProps, E);
                            else {
                                if (
                                    typeof E != 'string' &&
                                    h.stateNode === null
                                )
                                    throw Error(a(166));
                                if (
                                    ((f = qr(Zo.current)),
                                    (x = qr(Yi.current)),
                                    Zl(h))
                                ) {
                                    if (!Ie) throw Error(a(176));
                                    if (
                                        ((f = h.stateNode),
                                        (E = h.memoizedProps),
                                        (x = bs(f, E, h, !$a)) &&
                                            ((R = Ni), R !== null))
                                    )
                                        switch (
                                            ((I = (R.mode & 1) !== 0), R.tag)
                                        ) {
                                            case 3:
                                                nt(
                                                    R.stateNode.containerInfo,
                                                    f,
                                                    E,
                                                    I
                                                );
                                                break;
                                            case 5:
                                                pt(
                                                    R.type,
                                                    R.memoizedProps,
                                                    R.stateNode,
                                                    f,
                                                    E,
                                                    I
                                                );
                                        }
                                    x && ti(h);
                                } else h.stateNode = Pe(E, f, x, h);
                            }
                            return Vn(h), null;
                        case 13:
                            if (
                                (ft(Nn),
                                (E = h.memoizedState),
                                Rn &&
                                    mi !== null &&
                                    (h.mode & 1) !== 0 &&
                                    (h.flags & 128) === 0)
                            ) {
                                for (f = mi; f; ) f = Xr(f);
                                return Ya(), (h.flags |= 98560), h;
                            }
                            if (E !== null && E.dehydrated !== null) {
                                if (((E = Zl(h)), f === null)) {
                                    if (!E) throw Error(a(318));
                                    if (!Ie) throw Error(a(344));
                                    if (
                                        ((f = h.memoizedState),
                                        (f = f !== null ? f.dehydrated : null),
                                        !f)
                                    )
                                        throw Error(a(317));
                                    vc(f, h);
                                } else
                                    Ya(),
                                        (h.flags & 128) === 0 &&
                                            (h.memoizedState = null),
                                        (h.flags |= 4);
                                return Vn(h), null;
                            }
                            return (
                                Ir !== null && (xu(Ir), (Ir = null)),
                                (h.flags & 128) !== 0
                                    ? ((h.lanes = x), h)
                                    : ((E = E !== null),
                                      (x = !1),
                                      f === null
                                          ? Zl(h)
                                          : (x = f.memoizedState !== null),
                                      E &&
                                          !x &&
                                          ((h.child.flags |= 8192),
                                          (h.mode & 1) !== 0 &&
                                              (f === null ||
                                              (Nn.current & 1) !== 0
                                                  ? kn === 0 && (kn = 3)
                                                  : sf())),
                                      h.updateQueue !== null && (h.flags |= 4),
                                      Vn(h),
                                      null)
                            );
                        case 4:
                            return (
                                Qa(),
                                ia(f, h),
                                f === null && Ke(h.stateNode.containerInfo),
                                Vn(h),
                                null
                            );
                        case 10:
                            return Kl(h.type._context), Vn(h), null;
                        case 17:
                            return zn(h.type) && fn(), Vn(h), null;
                        case 19:
                            if ((ft(Nn), (R = h.memoizedState), R === null))
                                return Vn(h), null;
                            if (
                                ((E = (h.flags & 128) !== 0),
                                (I = R.rendering),
                                I === null)
                            )
                                if (E) Fs(R, !1);
                                else {
                                    if (
                                        kn !== 0 ||
                                        (f !== null && (f.flags & 128) !== 0)
                                    )
                                        for (f = h.child; f !== null; ) {
                                            if (((I = kc(f)), I !== null)) {
                                                for (
                                                    h.flags |= 128,
                                                        Fs(R, !1),
                                                        f = I.updateQueue,
                                                        f !== null &&
                                                            ((h.updateQueue =
                                                                f),
                                                            (h.flags |= 4)),
                                                        h.subtreeFlags = 0,
                                                        f = x,
                                                        E = h.child;
                                                    E !== null;

                                                )
                                                    (x = E),
                                                        (R = f),
                                                        (x.flags &= 14680066),
                                                        (I = x.alternate),
                                                        I === null
                                                            ? ((x.childLanes = 0),
                                                              (x.lanes = R),
                                                              (x.child = null),
                                                              (x.subtreeFlags = 0),
                                                              (x.memoizedProps =
                                                                  null),
                                                              (x.memoizedState =
                                                                  null),
                                                              (x.updateQueue =
                                                                  null),
                                                              (x.dependencies =
                                                                  null),
                                                              (x.stateNode =
                                                                  null))
                                                            : ((x.childLanes =
                                                                  I.childLanes),
                                                              (x.lanes =
                                                                  I.lanes),
                                                              (x.child =
                                                                  I.child),
                                                              (x.subtreeFlags = 0),
                                                              (x.deletions =
                                                                  null),
                                                              (x.memoizedProps =
                                                                  I.memoizedProps),
                                                              (x.memoizedState =
                                                                  I.memoizedState),
                                                              (x.updateQueue =
                                                                  I.updateQueue),
                                                              (x.type = I.type),
                                                              (R =
                                                                  I.dependencies),
                                                              (x.dependencies =
                                                                  R === null
                                                                      ? null
                                                                      : {
                                                                            lanes: R.lanes,
                                                                            firstContext:
                                                                                R.firstContext,
                                                                        })),
                                                        (E = E.sibling);
                                                return (
                                                    je(
                                                        Nn,
                                                        (Nn.current & 1) | 2
                                                    ),
                                                    h.child
                                                );
                                            }
                                            f = f.sibling;
                                        }
                                    R.tail !== null &&
                                        ei() > Ro &&
                                        ((h.flags |= 128),
                                        (E = !0),
                                        Fs(R, !1),
                                        (h.lanes = 4194304));
                                }
                            else {
                                if (!E)
                                    if (((f = kc(I)), f !== null)) {
                                        if (
                                            ((h.flags |= 128),
                                            (E = !0),
                                            (f = f.updateQueue),
                                            f !== null &&
                                                ((h.updateQueue = f),
                                                (h.flags |= 4)),
                                            Fs(R, !0),
                                            R.tail === null &&
                                                R.tailMode === 'hidden' &&
                                                !I.alternate &&
                                                !Rn)
                                        )
                                            return Vn(h), null;
                                    } else
                                        2 * ei() - R.renderingStartTime > Ro &&
                                            x !== 1073741824 &&
                                            ((h.flags |= 128),
                                            (E = !0),
                                            Fs(R, !1),
                                            (h.lanes = 4194304));
                                R.isBackwards
                                    ? ((I.sibling = h.child), (h.child = I))
                                    : ((f = R.last),
                                      f !== null
                                          ? (f.sibling = I)
                                          : (h.child = I),
                                      (R.last = I));
                            }
                            return R.tail !== null
                                ? ((h = R.tail),
                                  (R.rendering = h),
                                  (R.tail = h.sibling),
                                  (R.renderingStartTime = ei()),
                                  (h.sibling = null),
                                  (f = Nn.current),
                                  je(Nn, E ? (f & 1) | 2 : f & 1),
                                  h)
                                : (Vn(h), null);
                        case 22:
                        case 23:
                            return (
                                _u(),
                                (E = h.memoizedState !== null),
                                f !== null &&
                                    (f.memoizedState !== null) !== E &&
                                    (h.flags |= 8192),
                                E && (h.mode & 1) !== 0
                                    ? (Ti & 1073741824) !== 0 &&
                                      (Vn(h),
                                      Lt &&
                                          h.subtreeFlags & 6 &&
                                          (h.flags |= 8192))
                                    : Vn(h),
                                null
                            );
                        case 24:
                            return null;
                        case 25:
                            return null;
                    }
                    throw Error(a(156, h.tag));
                }
                var Zh = l.ReactCurrentOwner,
                    li = !1;
                function On(f, h, x, E) {
                    h.child =
                        f === null ? mm(h, null, x, E) : Us(h, f.child, x, E);
                }
                function Sn(f, h, x, E, R) {
                    x = x.render;
                    var I = h.ref;
                    return (
                        Xa(h, R),
                        (E = el(f, h, x, E, I, R)),
                        (x = Mo()),
                        f !== null && !li
                            ? ((h.updateQueue = f.updateQueue),
                              (h.flags &= -2053),
                              (f.lanes &= ~R),
                              Ki(f, h, R))
                            : (Rn && x && Oh(h),
                              (h.flags |= 1),
                              On(f, h, E, R),
                              h.child)
                    );
                }
                function yn(f, h, x, E, R) {
                    if (f === null) {
                        var I = x.type;
                        return typeof I == 'function' &&
                            !af(I) &&
                            I.defaultProps === void 0 &&
                            x.compare === null &&
                            x.defaultProps === void 0
                            ? ((h.tag = 15), (h.type = I), Bs(f, h, I, E, R))
                            : ((f = lf(x.type, null, E, h, h.mode, R)),
                              (f.ref = h.ref),
                              (f.return = h),
                              (h.child = f));
                    }
                    if (((I = f.child), (f.lanes & R) === 0)) {
                        var q = I.memoizedProps;
                        if (
                            ((x = x.compare),
                            (x = x !== null ? x : jr),
                            x(q, E) && f.ref === h.ref)
                        )
                            return Ki(f, h, R);
                    }
                    return (
                        (h.flags |= 1),
                        (f = $s(I, E)),
                        (f.ref = h.ref),
                        (f.return = h),
                        (h.child = f)
                    );
                }
                function Bs(f, h, x, E, R) {
                    if (f !== null && jr(f.memoizedProps, E) && f.ref === h.ref)
                        if (((li = !1), (f.lanes & R) !== 0))
                            (f.flags & 131072) !== 0 && (li = !0);
                        else return (h.lanes = f.lanes), Ki(f, h, R);
                    return zs(f, h, x, E, R);
                }
                function gi(f, h, x) {
                    var E = h.pendingProps,
                        R = E.children,
                        I = f !== null ? f.memoizedState : null;
                    if (E.mode === 'hidden')
                        if ((h.mode & 1) === 0)
                            (h.memoizedState = {
                                baseLanes: 0,
                                cachePool: null,
                            }),
                                je(ha, Ti),
                                (Ti |= x);
                        else if ((x & 1073741824) !== 0)
                            (h.memoizedState = {
                                baseLanes: 0,
                                cachePool: null,
                            }),
                                (E = I !== null ? I.baseLanes : x),
                                je(ha, Ti),
                                (Ti |= E);
                        else
                            return (
                                (f = I !== null ? I.baseLanes | x : x),
                                (h.lanes = h.childLanes = 1073741824),
                                (h.memoizedState = {
                                    baseLanes: f,
                                    cachePool: null,
                                }),
                                (h.updateQueue = null),
                                je(ha, Ti),
                                (Ti |= f),
                                null
                            );
                    else
                        I !== null
                            ? ((E = I.baseLanes | x), (h.memoizedState = null))
                            : (E = x),
                            je(ha, Ti),
                            (Ti |= E);
                    return On(f, h, R, x), h.child;
                }
                function Ui(f, h) {
                    var x = h.ref;
                    ((f === null && x !== null) ||
                        (f !== null && f.ref !== x)) &&
                        ((h.flags |= 512), (h.flags |= 2097152));
                }
                function zs(f, h, x, E, R) {
                    var I = zn(x) ? Wi : It.current;
                    return (
                        (I = Dn(h, I)),
                        Xa(h, R),
                        (x = el(f, h, x, E, I, R)),
                        (E = Mo()),
                        f !== null && !li
                            ? ((h.updateQueue = f.updateQueue),
                              (h.flags &= -2053),
                              (f.lanes &= ~R),
                              Ki(f, h, R))
                            : (Rn && E && Oh(h),
                              (h.flags |= 1),
                              On(f, h, x, R),
                              h.child)
                    );
                }
                function ra(f, h, x, E, R) {
                    if (zn(x)) {
                        var I = !0;
                        pi(h);
                    } else I = !1;
                    if ((Xa(h, R), h.stateNode === null))
                        f !== null &&
                            ((f.alternate = null),
                            (h.alternate = null),
                            (h.flags |= 2)),
                            cm(h, x, E),
                            Uh(h, x, E, R),
                            (E = !0);
                    else if (f === null) {
                        var q = h.stateNode,
                            te = h.memoizedProps;
                        q.props = te;
                        var Me = q.context,
                            ze = x.contextType;
                        typeof ze == 'object' && ze !== null
                            ? (ze = $i(ze))
                            : ((ze = zn(x) ? Wi : It.current),
                              (ze = Dn(h, ze)));
                        var ct = x.getDerivedStateFromProps,
                            kt =
                                typeof ct == 'function' ||
                                typeof q.getSnapshotBeforeUpdate == 'function';
                        kt ||
                            (typeof q.UNSAFE_componentWillReceiveProps !=
                                'function' &&
                                typeof q.componentWillReceiveProps !=
                                    'function') ||
                            ((te !== E || Me !== ze) && fm(h, q, E, ze)),
                            (Pr = !1);
                        var Tt = h.memoizedState;
                        (q.state = Tt),
                            Pc(h, E, q, R),
                            (Me = h.memoizedState),
                            te !== E || Tt !== Me || xn.current || Pr
                                ? (typeof ct == 'function' &&
                                      (Dh(h, x, ct, E), (Me = h.memoizedState)),
                                  (te = Pr || Nh(h, x, te, E, Tt, Me, ze))
                                      ? (kt ||
                                            (typeof q.UNSAFE_componentWillMount !=
                                                'function' &&
                                                typeof q.componentWillMount !=
                                                    'function') ||
                                            (typeof q.componentWillMount ==
                                                'function' &&
                                                q.componentWillMount(),
                                            typeof q.UNSAFE_componentWillMount ==
                                                'function' &&
                                                q.UNSAFE_componentWillMount()),
                                        typeof q.componentDidMount ==
                                            'function' && (h.flags |= 4194308))
                                      : (typeof q.componentDidMount ==
                                            'function' && (h.flags |= 4194308),
                                        (h.memoizedProps = E),
                                        (h.memoizedState = Me)),
                                  (q.props = E),
                                  (q.state = Me),
                                  (q.context = ze),
                                  (E = te))
                                : (typeof q.componentDidMount == 'function' &&
                                      (h.flags |= 4194308),
                                  (E = !1));
                    } else {
                        (q = h.stateNode),
                            Ih(f, h),
                            (te = h.memoizedProps),
                            (ze =
                                h.type === h.elementType ? te : qi(h.type, te)),
                            (q.props = ze),
                            (kt = h.pendingProps),
                            (Tt = q.context),
                            (Me = x.contextType),
                            typeof Me == 'object' && Me !== null
                                ? (Me = $i(Me))
                                : ((Me = zn(x) ? Wi : It.current),
                                  (Me = Dn(h, Me)));
                        var Gt = x.getDerivedStateFromProps;
                        (ct =
                            typeof Gt == 'function' ||
                            typeof q.getSnapshotBeforeUpdate == 'function') ||
                            (typeof q.UNSAFE_componentWillReceiveProps !=
                                'function' &&
                                typeof q.componentWillReceiveProps !=
                                    'function') ||
                            ((te !== kt || Tt !== Me) && fm(h, q, E, Me)),
                            (Pr = !1),
                            (Tt = h.memoizedState),
                            (q.state = Tt),
                            Pc(h, E, q, R);
                        var it = h.memoizedState;
                        te !== kt || Tt !== it || xn.current || Pr
                            ? (typeof Gt == 'function' &&
                                  (Dh(h, x, Gt, E), (it = h.memoizedState)),
                              (ze = Pr || Nh(h, x, ze, E, Tt, it, Me) || !1)
                                  ? (ct ||
                                        (typeof q.UNSAFE_componentWillUpdate !=
                                            'function' &&
                                            typeof q.componentWillUpdate !=
                                                'function') ||
                                        (typeof q.componentWillUpdate ==
                                            'function' &&
                                            q.componentWillUpdate(E, it, Me),
                                        typeof q.UNSAFE_componentWillUpdate ==
                                            'function' &&
                                            q.UNSAFE_componentWillUpdate(
                                                E,
                                                it,
                                                Me
                                            )),
                                    typeof q.componentDidUpdate == 'function' &&
                                        (h.flags |= 4),
                                    typeof q.getSnapshotBeforeUpdate ==
                                        'function' && (h.flags |= 1024))
                                  : (typeof q.componentDidUpdate !=
                                        'function' ||
                                        (te === f.memoizedProps &&
                                            Tt === f.memoizedState) ||
                                        (h.flags |= 4),
                                    typeof q.getSnapshotBeforeUpdate !=
                                        'function' ||
                                        (te === f.memoizedProps &&
                                            Tt === f.memoizedState) ||
                                        (h.flags |= 1024),
                                    (h.memoizedProps = E),
                                    (h.memoizedState = it)),
                              (q.props = E),
                              (q.state = it),
                              (q.context = Me),
                              (E = ze))
                            : (typeof q.componentDidUpdate != 'function' ||
                                  (te === f.memoizedProps &&
                                      Tt === f.memoizedState) ||
                                  (h.flags |= 4),
                              typeof q.getSnapshotBeforeUpdate != 'function' ||
                                  (te === f.memoizedProps &&
                                      Tt === f.memoizedState) ||
                                  (h.flags |= 1024),
                              (E = !1));
                    }
                    return Ei(f, h, x, E, I, R);
                }
                function Ei(f, h, x, E, R, I) {
                    Ui(f, h);
                    var q = (h.flags & 128) !== 0;
                    if (!E && !q) return R && yo(h, x, !1), Ki(f, h, I);
                    (E = h.stateNode), (Zh.current = h);
                    var te =
                        q && typeof x.getDerivedStateFromError != 'function'
                            ? null
                            : E.render();
                    return (
                        (h.flags |= 1),
                        f !== null && q
                            ? ((h.child = Us(h, f.child, null, I)),
                              (h.child = Us(h, null, te, I)))
                            : On(f, h, te, I),
                        (h.memoizedState = E.state),
                        R && yo(h, x, !0),
                        h.child
                    );
                }
                function au(f) {
                    var h = f.stateNode;
                    h.pendingContext
                        ? Xi(
                              f,
                              h.pendingContext,
                              h.pendingContext !== h.context
                          )
                        : h.context && Xi(f, h.context, !1),
                        Oc(f, h.containerInfo);
                }
                function Jh(f, h, x, E, R) {
                    return (
                        Ya(), Uc(R), (h.flags |= 256), On(f, h, x, E), h.child
                    );
                }
                var lu = { dehydrated: null, treeContext: null, retryLane: 0 };
                function sa(f) {
                    return { baseLanes: f, cachePool: null };
                }
                function Qh(f, h, x) {
                    var E = h.pendingProps,
                        R = Nn.current,
                        I = !1,
                        q = (h.flags & 128) !== 0,
                        te;
                    if (
                        ((te = q) ||
                            (te =
                                f !== null && f.memoizedState === null
                                    ? !1
                                    : (R & 2) !== 0),
                        te
                            ? ((I = !0), (h.flags &= -129))
                            : (f === null || f.memoizedState !== null) &&
                              (R |= 1),
                        je(Nn, R & 1),
                        f === null)
                    )
                        return (
                            So(h),
                            (f = h.memoizedState),
                            f !== null && ((f = f.dehydrated), f !== null)
                                ? ((h.mode & 1) === 0
                                      ? (h.lanes = 1)
                                      : ls(f)
                                        ? (h.lanes = 8)
                                        : (h.lanes = 1073741824),
                                  null)
                                : ((R = E.children),
                                  (f = E.fallback),
                                  I
                                      ? ((E = h.mode),
                                        (I = h.child),
                                        (R = { mode: 'hidden', children: R }),
                                        (E & 1) === 0 && I !== null
                                            ? ((I.childLanes = 0),
                                              (I.pendingProps = R))
                                            : (I = Mu(R, E, 0, null)),
                                        (f = ya(f, E, x, null)),
                                        (I.return = h),
                                        (f.return = h),
                                        (I.sibling = f),
                                        (h.child = I),
                                        (h.child.memoizedState = sa(x)),
                                        (h.memoizedState = lu),
                                        f)
                                      : Kr(h, R))
                        );
                    if (((R = f.memoizedState), R !== null)) {
                        if (((te = R.dehydrated), te !== null)) {
                            if (q)
                                return h.flags & 256
                                    ? ((h.flags &= -257),
                                      cu(f, h, x, Error(a(422))))
                                    : h.memoizedState !== null
                                      ? ((h.child = f.child),
                                        (h.flags |= 128),
                                        null)
                                      : ((I = E.fallback),
                                        (R = h.mode),
                                        (E = Mu(
                                            {
                                                mode: 'visible',
                                                children: E.children,
                                            },
                                            R,
                                            0,
                                            null
                                        )),
                                        (I = ya(I, R, x, null)),
                                        (I.flags |= 2),
                                        (E.return = h),
                                        (I.return = h),
                                        (E.sibling = I),
                                        (h.child = E),
                                        (h.mode & 1) !== 0 &&
                                            Us(h, f.child, null, x),
                                        (h.child.memoizedState = sa(x)),
                                        (h.memoizedState = lu),
                                        I);
                            if ((h.mode & 1) === 0) h = cu(f, h, x, null);
                            else if (ls(te)) h = cu(f, h, x, Error(a(419)));
                            else if (
                                ((E = (x & f.childLanes) !== 0), li || E)
                            ) {
                                if (((E = Hn), E !== null)) {
                                    switch (x & -x) {
                                        case 4:
                                            I = 2;
                                            break;
                                        case 16:
                                            I = 8;
                                            break;
                                        case 64:
                                        case 128:
                                        case 256:
                                        case 512:
                                        case 1024:
                                        case 2048:
                                        case 4096:
                                        case 8192:
                                        case 16384:
                                        case 32768:
                                        case 65536:
                                        case 131072:
                                        case 262144:
                                        case 524288:
                                        case 1048576:
                                        case 2097152:
                                        case 4194304:
                                        case 8388608:
                                        case 16777216:
                                        case 33554432:
                                        case 67108864:
                                            I = 32;
                                            break;
                                        case 536870912:
                                            I = 268435456;
                                            break;
                                        default:
                                            I = 0;
                                    }
                                    (E =
                                        (I & (E.suspendedLanes | x)) !== 0
                                            ? 0
                                            : I),
                                        E !== 0 &&
                                            E !== R.retryLane &&
                                            ((R.retryLane = E), Ai(f, E, -1));
                                }
                                sf(), (h = cu(f, h, x, Error(a(421))));
                            } else
                                Gl(te)
                                    ? ((h.flags |= 128),
                                      (h.child = f.child),
                                      (h = Tm.bind(null, f)),
                                      Rs(te, h),
                                      (h = null))
                                    : ((x = R.treeContext),
                                      Ie &&
                                          ((mi = yc(te)),
                                          (Ni = h),
                                          (Rn = !0),
                                          (Ir = null),
                                          ($a = !1),
                                          x !== null &&
                                              ((Lr[cr++] = Ds),
                                              (Lr[cr++] = Ns),
                                              (Lr[cr++] = $o),
                                              (Ds = x.id),
                                              (Ns = x.overflow),
                                              ($o = h))),
                                      (h = Kr(h, h.pendingProps.children)),
                                      (h.flags |= 4096));
                            return h;
                        }
                        return I
                            ? ((E = Jc(f, h, E.children, E.fallback, x)),
                              (I = h.child),
                              (R = f.child.memoizedState),
                              (I.memoizedState =
                                  R === null
                                      ? sa(x)
                                      : {
                                            baseLanes: R.baseLanes | x,
                                            cachePool: null,
                                        }),
                              (I.childLanes = f.childLanes & ~x),
                              (h.memoizedState = lu),
                              E)
                            : ((x = uu(f, h, E.children, x)),
                              (h.memoizedState = null),
                              x);
                    }
                    return I
                        ? ((E = Jc(f, h, E.children, E.fallback, x)),
                          (I = h.child),
                          (R = f.child.memoizedState),
                          (I.memoizedState =
                              R === null
                                  ? sa(x)
                                  : {
                                        baseLanes: R.baseLanes | x,
                                        cachePool: null,
                                    }),
                          (I.childLanes = f.childLanes & ~x),
                          (h.memoizedState = lu),
                          E)
                        : ((x = uu(f, h, E.children, x)),
                          (h.memoizedState = null),
                          x);
                }
                function Kr(f, h) {
                    return (
                        (h = Mu(
                            { mode: 'visible', children: h },
                            f.mode,
                            0,
                            null
                        )),
                        (h.return = f),
                        (f.child = h)
                    );
                }
                function uu(f, h, x, E) {
                    var R = f.child;
                    return (
                        (f = R.sibling),
                        (x = $s(R, { mode: 'visible', children: x })),
                        (h.mode & 1) === 0 && (x.lanes = E),
                        (x.return = h),
                        (x.sibling = null),
                        f !== null &&
                            ((E = h.deletions),
                            E === null
                                ? ((h.deletions = [f]), (h.flags |= 16))
                                : E.push(f)),
                        (h.child = x)
                    );
                }
                function Jc(f, h, x, E, R) {
                    var I = h.mode;
                    f = f.child;
                    var q = f.sibling,
                        te = { mode: 'hidden', children: x };
                    return (
                        (I & 1) === 0 && h.child !== f
                            ? ((x = h.child),
                              (x.childLanes = 0),
                              (x.pendingProps = te),
                              (h.deletions = null))
                            : ((x = $s(f, te)),
                              (x.subtreeFlags = f.subtreeFlags & 14680064)),
                        q !== null
                            ? (E = $s(q, E))
                            : ((E = ya(E, I, R, null)), (E.flags |= 2)),
                        (E.return = h),
                        (x.return = h),
                        (x.sibling = E),
                        (h.child = x),
                        E
                    );
                }
                function cu(f, h, x, E) {
                    return (
                        E !== null && Uc(E),
                        Us(h, f.child, null, x),
                        (f = Kr(h, h.pendingProps.children)),
                        (f.flags |= 2),
                        (h.memoizedState = null),
                        f
                    );
                }
                function Sm(f, h, x) {
                    f.lanes |= h;
                    var E = f.alternate;
                    E !== null && (E.lanes |= h), qo(f.return, h, x);
                }
                function ds(f, h, x, E, R) {
                    var I = f.memoizedState;
                    I === null
                        ? (f.memoizedState = {
                              isBackwards: h,
                              rendering: null,
                              renderingStartTime: 0,
                              last: E,
                              tail: x,
                              tailMode: R,
                          })
                        : ((I.isBackwards = h),
                          (I.rendering = null),
                          (I.renderingStartTime = 0),
                          (I.last = E),
                          (I.tail = x),
                          (I.tailMode = R));
                }
                function oa(f, h, x) {
                    var E = h.pendingProps,
                        R = E.revealOrder,
                        I = E.tail;
                    if (
                        (On(f, h, E.children, x),
                        (E = Nn.current),
                        (E & 2) !== 0)
                    )
                        (E = (E & 1) | 2), (h.flags |= 128);
                    else {
                        if (f !== null && (f.flags & 128) !== 0)
                            e: for (f = h.child; f !== null; ) {
                                if (f.tag === 13)
                                    f.memoizedState !== null && Sm(f, x, h);
                                else if (f.tag === 19) Sm(f, x, h);
                                else if (f.child !== null) {
                                    (f.child.return = f), (f = f.child);
                                    continue;
                                }
                                if (f === h) break e;
                                for (; f.sibling === null; ) {
                                    if (f.return === null || f.return === h)
                                        break e;
                                    f = f.return;
                                }
                                (f.sibling.return = f.return), (f = f.sibling);
                            }
                        E &= 1;
                    }
                    if ((je(Nn, E), (h.mode & 1) === 0)) h.memoizedState = null;
                    else
                        switch (R) {
                            case 'forwards':
                                for (x = h.child, R = null; x !== null; )
                                    (f = x.alternate),
                                        f !== null && kc(f) === null && (R = x),
                                        (x = x.sibling);
                                (x = R),
                                    x === null
                                        ? ((R = h.child), (h.child = null))
                                        : ((R = x.sibling), (x.sibling = null)),
                                    ds(h, !1, R, x, I);
                                break;
                            case 'backwards':
                                for (
                                    x = null, R = h.child, h.child = null;
                                    R !== null;

                                ) {
                                    if (
                                        ((f = R.alternate),
                                        f !== null && kc(f) === null)
                                    ) {
                                        h.child = R;
                                        break;
                                    }
                                    (f = R.sibling),
                                        (R.sibling = x),
                                        (x = R),
                                        (R = f);
                                }
                                ds(h, !0, x, null, I);
                                break;
                            case 'together':
                                ds(h, !1, null, null, void 0);
                                break;
                            default:
                                h.memoizedState = null;
                        }
                    return h.child;
                }
                function Ki(f, h, x) {
                    if (
                        (f !== null && (h.dependencies = f.dependencies),
                        (ps |= h.lanes),
                        (x & h.childLanes) === 0)
                    )
                        return null;
                    if (f !== null && h.child !== f.child) throw Error(a(153));
                    if (h.child !== null) {
                        for (
                            f = h.child,
                                x = $s(f, f.pendingProps),
                                h.child = x,
                                x.return = h;
                            f.sibling !== null;

                        )
                            (f = f.sibling),
                                (x = x.sibling = $s(f, f.pendingProps)),
                                (x.return = h);
                        x.sibling = null;
                    }
                    return h.child;
                }
                function Qc(f, h, x) {
                    switch (h.tag) {
                        case 3:
                            au(h), Ya();
                            break;
                        case 5:
                            gm(h);
                            break;
                        case 1:
                            zn(h.type) && pi(h);
                            break;
                        case 4:
                            Oc(h, h.stateNode.containerInfo);
                            break;
                        case 10:
                            jo(h, h.type._context, h.memoizedProps.value);
                            break;
                        case 13:
                            var E = h.memoizedState;
                            if (E !== null)
                                return E.dehydrated !== null
                                    ? (je(Nn, Nn.current & 1),
                                      (h.flags |= 128),
                                      null)
                                    : (x & h.child.childLanes) !== 0
                                      ? Qh(f, h, x)
                                      : (je(Nn, Nn.current & 1),
                                        (f = Ki(f, h, x)),
                                        f !== null ? f.sibling : null);
                            je(Nn, Nn.current & 1);
                            break;
                        case 19:
                            if (
                                ((E = (x & h.childLanes) !== 0),
                                (f.flags & 128) !== 0)
                            ) {
                                if (E) return oa(f, h, x);
                                h.flags |= 128;
                            }
                            var R = h.memoizedState;
                            if (
                                (R !== null &&
                                    ((R.rendering = null),
                                    (R.tail = null),
                                    (R.lastEffect = null)),
                                je(Nn, Nn.current),
                                E)
                            )
                                break;
                            return null;
                        case 22:
                        case 23:
                            return (h.lanes = 0), gi(f, h, x);
                    }
                    return Ki(f, h, x);
                }
                function ef(f, h) {
                    switch ((kh(h), h.tag)) {
                        case 1:
                            return (
                                zn(h.type) && fn(),
                                (f = h.flags),
                                f & 65536
                                    ? ((h.flags = (f & -65537) | 128), h)
                                    : null
                            );
                        case 3:
                            return (
                                Qa(),
                                ft(xn),
                                ft(It),
                                Jo(),
                                (f = h.flags),
                                (f & 65536) !== 0 && (f & 128) === 0
                                    ? ((h.flags = (f & -65537) | 128), h)
                                    : null
                            );
                        case 5:
                            return zh(h), null;
                        case 13:
                            if (
                                (ft(Nn),
                                (f = h.memoizedState),
                                f !== null && f.dehydrated !== null)
                            ) {
                                if (h.alternate === null) throw Error(a(340));
                                Ya();
                            }
                            return (
                                (f = h.flags),
                                f & 65536
                                    ? ((h.flags = (f & -65537) | 128), h)
                                    : null
                            );
                        case 19:
                            return ft(Nn), null;
                        case 4:
                            return Qa(), null;
                        case 10:
                            return Kl(h.type._context), null;
                        case 22:
                        case 23:
                            return _u(), null;
                        case 24:
                            return null;
                        default:
                            return null;
                    }
                }
                var Oi = !1,
                    ui = !1,
                    aa = typeof WeakSet == 'function' ? WeakSet : Set,
                    qe = null;
                function Dr(f, h) {
                    var x = f.ref;
                    if (x !== null)
                        if (typeof x == 'function')
                            try {
                                x(null);
                            } catch (E) {
                                Fi(f, h, E);
                            }
                        else x.current = null;
                }
                function Vs(f, h, x) {
                    try {
                        x();
                    } catch (E) {
                        Fi(f, h, E);
                    }
                }
                var ed = !1;
                function td(f, h) {
                    for (oe(f.containerInfo), qe = h; qe !== null; )
                        if (
                            ((f = qe),
                            (h = f.child),
                            (f.subtreeFlags & 1028) !== 0 && h !== null)
                        )
                            (h.return = f), (qe = h);
                        else
                            for (; qe !== null; ) {
                                f = qe;
                                try {
                                    var x = f.alternate;
                                    if ((f.flags & 1024) !== 0)
                                        switch (f.tag) {
                                            case 0:
                                            case 11:
                                            case 15:
                                                break;
                                            case 1:
                                                if (x !== null) {
                                                    var E = x.memoizedProps,
                                                        R = x.memoizedState,
                                                        I = f.stateNode,
                                                        q =
                                                            I.getSnapshotBeforeUpdate(
                                                                f.elementType ===
                                                                    f.type
                                                                    ? E
                                                                    : qi(
                                                                          f.type,
                                                                          E
                                                                      ),
                                                                R
                                                            );
                                                    I.__reactInternalSnapshotBeforeUpdate =
                                                        q;
                                                }
                                                break;
                                            case 3:
                                                Lt &&
                                                    Ge(
                                                        f.stateNode
                                                            .containerInfo
                                                    );
                                                break;
                                            case 5:
                                            case 6:
                                            case 4:
                                            case 17:
                                                break;
                                            default:
                                                throw Error(a(163));
                                        }
                                } catch (te) {
                                    Fi(f, f.return, te);
                                }
                                if (((h = f.sibling), h !== null)) {
                                    (h.return = f.return), (qe = h);
                                    break;
                                }
                                qe = f.return;
                            }
                    return (x = ed), (ed = !1), x;
                }
                function Hs(f, h, x) {
                    var E = h.updateQueue;
                    if (((E = E !== null ? E.lastEffect : null), E !== null)) {
                        var R = (E = E.next);
                        do {
                            if ((R.tag & f) === f) {
                                var I = R.destroy;
                                (R.destroy = void 0),
                                    I !== void 0 && Vs(h, x, I);
                            }
                            R = R.next;
                        } while (R !== E);
                    }
                }
                function yi(f, h) {
                    if (
                        ((h = h.updateQueue),
                        (h = h !== null ? h.lastEffect : null),
                        h !== null)
                    ) {
                        var x = (h = h.next);
                        do {
                            if ((x.tag & f) === f) {
                                var E = x.create;
                                x.destroy = E();
                            }
                            x = x.next;
                        } while (x !== h);
                    }
                }
                function ki(f) {
                    var h = f.ref;
                    if (h !== null) {
                        var x = f.stateNode;
                        switch (f.tag) {
                            case 5:
                                f = ce(x);
                                break;
                            default:
                                f = x;
                        }
                        typeof h == 'function' ? h(f) : (h.current = f);
                    }
                }
                function Tn(f, h, x) {
                    if (cs && typeof cs.onCommitFiberUnmount == 'function')
                        try {
                            cs.onCommitFiberUnmount(jl, h);
                        } catch {}
                    switch (h.tag) {
                        case 0:
                        case 11:
                        case 14:
                        case 15:
                            if (
                                ((f = h.updateQueue),
                                f !== null && ((f = f.lastEffect), f !== null))
                            ) {
                                var E = (f = f.next);
                                do {
                                    var R = E,
                                        I = R.destroy;
                                    (R = R.tag),
                                        I !== void 0 &&
                                            ((R & 2) !== 0 || (R & 4) !== 0) &&
                                            Vs(h, x, I),
                                        (E = E.next);
                                } while (E !== f);
                            }
                            break;
                        case 1:
                            if (
                                (Dr(h, x),
                                (f = h.stateNode),
                                typeof f.componentWillUnmount == 'function')
                            )
                                try {
                                    (f.props = h.memoizedProps),
                                        (f.state = h.memoizedState),
                                        f.componentWillUnmount();
                                } catch (q) {
                                    Fi(h, x, q);
                                }
                            break;
                        case 5:
                            Dr(h, x);
                            break;
                        case 4:
                            Lt
                                ? rd(f, h, x)
                                : W &&
                                  W &&
                                  ((h = h.stateNode.containerInfo),
                                  (x = Yt(h)),
                                  en(h, x));
                    }
                }
                function Nr(f, h, x) {
                    for (var E = h; ; )
                        if (
                            (Tn(f, E, x),
                            E.child === null || (Lt && E.tag === 4))
                        ) {
                            if (E === h) break;
                            for (; E.sibling === null; ) {
                                if (E.return === null || E.return === h) return;
                                E = E.return;
                            }
                            (E.sibling.return = E.return), (E = E.sibling);
                        } else (E.child.return = E), (E = E.child);
                }
                function nd(f) {
                    var h = f.alternate;
                    h !== null && ((f.alternate = null), nd(h)),
                        (f.child = null),
                        (f.deletions = null),
                        (f.sibling = null),
                        f.tag === 5 && ((h = f.stateNode), h !== null && St(h)),
                        (f.stateNode = null),
                        (f.return = null),
                        (f.dependencies = null),
                        (f.memoizedProps = null),
                        (f.memoizedState = null),
                        (f.pendingProps = null),
                        (f.stateNode = null),
                        (f.updateQueue = null);
                }
                function id(f) {
                    return f.tag === 5 || f.tag === 3 || f.tag === 4;
                }
                function tf(f) {
                    e: for (;;) {
                        for (; f.sibling === null; ) {
                            if (f.return === null || id(f.return)) return null;
                            f = f.return;
                        }
                        for (
                            f.sibling.return = f.return, f = f.sibling;
                            f.tag !== 5 && f.tag !== 6 && f.tag !== 18;

                        ) {
                            if (f.flags & 2 || f.child === null || f.tag === 4)
                                continue e;
                            (f.child.return = f), (f = f.child);
                        }
                        if (!(f.flags & 2)) return f.stateNode;
                    }
                }
                function nf(f) {
                    if (Lt) {
                        e: {
                            for (var h = f.return; h !== null; ) {
                                if (id(h)) break e;
                                h = h.return;
                            }
                            throw Error(a(160));
                        }
                        var x = h;
                        switch (x.tag) {
                            case 5:
                                (h = x.stateNode),
                                    x.flags & 32 && (dn(h), (x.flags &= -33)),
                                    (x = tf(f)),
                                    ol(f, x, h);
                                break;
                            case 3:
                            case 4:
                                (h = x.stateNode.containerInfo),
                                    (x = tf(f)),
                                    rf(f, x, h);
                                break;
                            default:
                                throw Error(a(161));
                        }
                    }
                }
                function rf(f, h, x) {
                    var E = f.tag;
                    if (E === 5 || E === 6)
                        (f = f.stateNode), h ? ut(x, f, h) : Nt(x, f);
                    else if (E !== 4 && ((f = f.child), f !== null))
                        for (rf(f, h, x), f = f.sibling; f !== null; )
                            rf(f, h, x), (f = f.sibling);
                }
                function ol(f, h, x) {
                    var E = f.tag;
                    if (E === 5 || E === 6)
                        (f = f.stateNode), h ? bt(x, f, h) : tt(x, f);
                    else if (E !== 4 && ((f = f.child), f !== null))
                        for (ol(f, h, x), f = f.sibling; f !== null; )
                            ol(f, h, x), (f = f.sibling);
                }
                function rd(f, h, x) {
                    for (var E = h, R = !1, I, q; ; ) {
                        if (!R) {
                            R = E.return;
                            e: for (;;) {
                                if (R === null) throw Error(a(160));
                                switch (((I = R.stateNode), R.tag)) {
                                    case 5:
                                        q = !1;
                                        break e;
                                    case 3:
                                        (I = I.containerInfo), (q = !0);
                                        break e;
                                    case 4:
                                        (I = I.containerInfo), (q = !0);
                                        break e;
                                }
                                R = R.return;
                            }
                            R = !0;
                        }
                        if (E.tag === 5 || E.tag === 6)
                            Nr(f, E, x),
                                q ? zt(I, E.stateNode) : Ut(I, E.stateNode);
                        else if (E.tag === 18)
                            q ? le(I, E.stateNode) : ve(I, E.stateNode);
                        else if (E.tag === 4) {
                            if (E.child !== null) {
                                (I = E.stateNode.containerInfo),
                                    (q = !0),
                                    (E.child.return = E),
                                    (E = E.child);
                                continue;
                            }
                        } else if ((Tn(f, E, x), E.child !== null)) {
                            (E.child.return = E), (E = E.child);
                            continue;
                        }
                        if (E === h) break;
                        for (; E.sibling === null; ) {
                            if (E.return === null || E.return === h) return;
                            (E = E.return), E.tag === 4 && (R = !1);
                        }
                        (E.sibling.return = E.return), (E = E.sibling);
                    }
                }
                function Ao(f, h) {
                    if (Lt) {
                        switch (h.tag) {
                            case 0:
                            case 11:
                            case 14:
                            case 15:
                                Hs(3, h, h.return),
                                    yi(3, h),
                                    Hs(5, h, h.return);
                                return;
                            case 1:
                                return;
                            case 5:
                                var x = h.stateNode;
                                if (x != null) {
                                    var E = h.memoizedProps;
                                    f = f !== null ? f.memoizedProps : E;
                                    var R = h.type,
                                        I = h.updateQueue;
                                    (h.updateQueue = null),
                                        I !== null && Kt(x, I, R, f, E, h);
                                }
                                return;
                            case 6:
                                if (h.stateNode === null) throw Error(a(162));
                                (x = h.memoizedProps),
                                    Be(
                                        h.stateNode,
                                        f !== null ? f.memoizedProps : x,
                                        x
                                    );
                                return;
                            case 3:
                                Ie &&
                                    f !== null &&
                                    f.memoizedState.isDehydrated &&
                                    re(h.stateNode.containerInfo);
                                return;
                            case 12:
                                return;
                            case 13:
                                al(h);
                                return;
                            case 19:
                                al(h);
                                return;
                            case 17:
                                return;
                        }
                        throw Error(a(163));
                    }
                    switch (h.tag) {
                        case 0:
                        case 11:
                        case 14:
                        case 15:
                            Hs(3, h, h.return), yi(3, h), Hs(5, h, h.return);
                            return;
                        case 12:
                            return;
                        case 13:
                            al(h);
                            return;
                        case 19:
                            al(h);
                            return;
                        case 3:
                            Ie &&
                                f !== null &&
                                f.memoizedState.isDehydrated &&
                                re(h.stateNode.containerInfo);
                            break;
                        case 22:
                        case 23:
                            return;
                    }
                    e: if (W) {
                        switch (h.tag) {
                            case 1:
                            case 5:
                            case 6:
                                break e;
                            case 3:
                            case 4:
                                (h = h.stateNode),
                                    en(h.containerInfo, h.pendingChildren);
                                break e;
                        }
                        throw Error(a(163));
                    }
                }
                function al(f) {
                    var h = f.updateQueue;
                    if (h !== null) {
                        f.updateQueue = null;
                        var x = f.stateNode;
                        x === null && (x = f.stateNode = new aa()),
                            h.forEach(function (E) {
                                var R = Am.bind(null, f, E);
                                x.has(E) || (x.add(E), E.then(R, R));
                            });
                    }
                }
                function Kv(f, h) {
                    for (qe = h; qe !== null; ) {
                        h = qe;
                        var x = h.deletions;
                        if (x !== null)
                            for (var E = 0; E < x.length; E++) {
                                var R = x[E];
                                try {
                                    var I = f;
                                    Lt ? rd(I, R, h) : Nr(I, R, h);
                                    var q = R.alternate;
                                    q !== null && (q.return = null),
                                        (R.return = null);
                                } catch (yt) {
                                    Fi(R, h, yt);
                                }
                            }
                        if (
                            ((x = h.child),
                            (h.subtreeFlags & 12854) !== 0 && x !== null)
                        )
                            (x.return = h), (qe = x);
                        else
                            for (; qe !== null; ) {
                                h = qe;
                                try {
                                    var te = h.flags;
                                    if (
                                        (te & 32 && Lt && dn(h.stateNode),
                                        te & 512)
                                    ) {
                                        var Me = h.alternate;
                                        if (Me !== null) {
                                            var ze = Me.ref;
                                            ze !== null &&
                                                (typeof ze == 'function'
                                                    ? ze(null)
                                                    : (ze.current = null));
                                        }
                                    }
                                    if (te & 8192)
                                        switch (h.tag) {
                                            case 13:
                                                if (h.memoizedState !== null) {
                                                    var ct = h.alternate;
                                                    (ct === null ||
                                                        ct.memoizedState ===
                                                            null) &&
                                                        (yu = ei());
                                                }
                                                break;
                                            case 22:
                                                var kt =
                                                        h.memoizedState !==
                                                        null,
                                                    Tt = h.alternate,
                                                    Gt =
                                                        Tt !== null &&
                                                        Tt.memoizedState !==
                                                            null;
                                                if (((x = h), Lt)) {
                                                    e: if (
                                                        ((E = x),
                                                        (R = kt),
                                                        (I = null),
                                                        Lt)
                                                    )
                                                        for (var it = E; ; ) {
                                                            if (it.tag === 5) {
                                                                if (
                                                                    I === null
                                                                ) {
                                                                    I = it;
                                                                    var _i =
                                                                        it.stateNode;
                                                                    R
                                                                        ? ne(_i)
                                                                        : Te(
                                                                              it.stateNode,
                                                                              it.memoizedProps
                                                                          );
                                                                }
                                                            } else if (
                                                                it.tag === 6
                                                            ) {
                                                                if (
                                                                    I === null
                                                                ) {
                                                                    var vr =
                                                                        it.stateNode;
                                                                    R
                                                                        ? Ve(vr)
                                                                        : Ae(
                                                                              vr,
                                                                              it.memoizedProps
                                                                          );
                                                                }
                                                            } else if (
                                                                ((it.tag !==
                                                                    22 &&
                                                                    it.tag !==
                                                                        23) ||
                                                                    it.memoizedState ===
                                                                        null ||
                                                                    it === E) &&
                                                                it.child !==
                                                                    null
                                                            ) {
                                                                (it.child.return =
                                                                    it),
                                                                    (it =
                                                                        it.child);
                                                                continue;
                                                            }
                                                            if (it === E) break;
                                                            for (
                                                                ;
                                                                it.sibling ===
                                                                null;

                                                            ) {
                                                                if (
                                                                    it.return ===
                                                                        null ||
                                                                    it.return ===
                                                                        E
                                                                )
                                                                    break e;
                                                                I === it &&
                                                                    (I = null),
                                                                    (it =
                                                                        it.return);
                                                            }
                                                            I === it &&
                                                                (I = null),
                                                                (it.sibling.return =
                                                                    it.return),
                                                                (it =
                                                                    it.sibling);
                                                        }
                                                }
                                                if (
                                                    kt &&
                                                    !Gt &&
                                                    (x.mode & 1) !== 0
                                                ) {
                                                    qe = x;
                                                    for (
                                                        var pe = x.child;
                                                        pe !== null;

                                                    ) {
                                                        for (
                                                            x = qe = pe;
                                                            qe !== null;

                                                        ) {
                                                            E = qe;
                                                            var se = E.child;
                                                            switch (E.tag) {
                                                                case 0:
                                                                case 11:
                                                                case 14:
                                                                case 15:
                                                                    Hs(
                                                                        4,
                                                                        E,
                                                                        E.return
                                                                    );
                                                                    break;
                                                                case 1:
                                                                    Dr(
                                                                        E,
                                                                        E.return
                                                                    );
                                                                    var _e =
                                                                        E.stateNode;
                                                                    if (
                                                                        typeof _e.componentWillUnmount ==
                                                                        'function'
                                                                    ) {
                                                                        var Qe =
                                                                            E.return;
                                                                        try {
                                                                            (_e.props =
                                                                                E.memoizedProps),
                                                                                (_e.state =
                                                                                    E.memoizedState),
                                                                                _e.componentWillUnmount();
                                                                        } catch (yt) {
                                                                            Fi(
                                                                                E,
                                                                                Qe,
                                                                                yt
                                                                            );
                                                                        }
                                                                    }
                                                                    break;
                                                                case 5:
                                                                    Dr(
                                                                        E,
                                                                        E.return
                                                                    );
                                                                    break;
                                                                case 22:
                                                                    if (
                                                                        E.memoizedState !==
                                                                        null
                                                                    ) {
                                                                        od(x);
                                                                        continue;
                                                                    }
                                                            }
                                                            se !== null
                                                                ? ((se.return =
                                                                      E),
                                                                  (qe = se))
                                                                : od(x);
                                                        }
                                                        pe = pe.sibling;
                                                    }
                                                }
                                        }
                                    switch (te & 4102) {
                                        case 2:
                                            nf(h), (h.flags &= -3);
                                            break;
                                        case 6:
                                            nf(h),
                                                (h.flags &= -3),
                                                Ao(h.alternate, h);
                                            break;
                                        case 4096:
                                            h.flags &= -4097;
                                            break;
                                        case 4100:
                                            (h.flags &= -4097),
                                                Ao(h.alternate, h);
                                            break;
                                        case 4:
                                            Ao(h.alternate, h);
                                    }
                                } catch (yt) {
                                    Fi(h, h.return, yt);
                                }
                                if (((x = h.sibling), x !== null)) {
                                    (x.return = h.return), (qe = x);
                                    break;
                                }
                                qe = h.return;
                            }
                    }
                }
                function fu(f, h, x) {
                    (qe = f), hu(f);
                }
                function hu(f, h, x) {
                    for (var E = (f.mode & 1) !== 0; qe !== null; ) {
                        var R = qe,
                            I = R.child;
                        if (R.tag === 22 && E) {
                            var q = R.memoizedState !== null || Oi;
                            if (!q) {
                                var te = R.alternate,
                                    Me =
                                        (te !== null &&
                                            te.memoizedState !== null) ||
                                        ui;
                                te = Oi;
                                var ze = ui;
                                if (((Oi = q), (ui = Me) && !ze))
                                    for (qe = R; qe !== null; )
                                        (q = qe),
                                            (Me = q.child),
                                            q.tag === 22 &&
                                            q.memoizedState !== null
                                                ? la(R)
                                                : Me !== null
                                                  ? ((Me.return = q), (qe = Me))
                                                  : la(R);
                                for (; I !== null; )
                                    (qe = I), hu(I), (I = I.sibling);
                                (qe = R), (Oi = te), (ui = ze);
                            }
                            sd(f);
                        } else
                            (R.subtreeFlags & 8772) !== 0 && I !== null
                                ? ((I.return = R), (qe = I))
                                : sd(f);
                    }
                }
                function sd(f) {
                    for (; qe !== null; ) {
                        var h = qe;
                        if ((h.flags & 8772) !== 0) {
                            var x = h.alternate;
                            try {
                                if ((h.flags & 8772) !== 0)
                                    switch (h.tag) {
                                        case 0:
                                        case 11:
                                        case 15:
                                            ui || yi(5, h);
                                            break;
                                        case 1:
                                            var E = h.stateNode;
                                            if (h.flags & 4 && !ui)
                                                if (x === null)
                                                    E.componentDidMount();
                                                else {
                                                    var R =
                                                        h.elementType === h.type
                                                            ? x.memoizedProps
                                                            : qi(
                                                                  h.type,
                                                                  x.memoizedProps
                                                              );
                                                    E.componentDidUpdate(
                                                        R,
                                                        x.memoizedState,
                                                        E.__reactInternalSnapshotBeforeUpdate
                                                    );
                                                }
                                            var I = h.updateQueue;
                                            I !== null && lm(h, I, E);
                                            break;
                                        case 3:
                                            var q = h.updateQueue;
                                            if (q !== null) {
                                                if (
                                                    ((x = null),
                                                    h.child !== null)
                                                )
                                                    switch (h.child.tag) {
                                                        case 5:
                                                            x = ce(
                                                                h.child
                                                                    .stateNode
                                                            );
                                                            break;
                                                        case 1:
                                                            x =
                                                                h.child
                                                                    .stateNode;
                                                    }
                                                lm(h, q, x);
                                            }
                                            break;
                                        case 5:
                                            var te = h.stateNode;
                                            x === null &&
                                                h.flags & 4 &&
                                                Je(
                                                    te,
                                                    h.type,
                                                    h.memoizedProps,
                                                    h
                                                );
                                            break;
                                        case 6:
                                            break;
                                        case 4:
                                            break;
                                        case 12:
                                            break;
                                        case 13:
                                            if (
                                                Ie &&
                                                h.memoizedState === null
                                            ) {
                                                var Me = h.alternate;
                                                if (Me !== null) {
                                                    var ze = Me.memoizedState;
                                                    if (ze !== null) {
                                                        var ct = ze.dehydrated;
                                                        ct !== null && ye(ct);
                                                    }
                                                }
                                            }
                                            break;
                                        case 19:
                                        case 17:
                                        case 21:
                                        case 22:
                                        case 23:
                                            break;
                                        default:
                                            throw Error(a(163));
                                    }
                                ui || (h.flags & 512 && ki(h));
                            } catch (kt) {
                                Fi(h, h.return, kt);
                            }
                        }
                        if (h === f) {
                            qe = null;
                            break;
                        }
                        if (((x = h.sibling), x !== null)) {
                            (x.return = h.return), (qe = x);
                            break;
                        }
                        qe = h.return;
                    }
                }
                function od(f) {
                    for (; qe !== null; ) {
                        var h = qe;
                        if (h === f) {
                            qe = null;
                            break;
                        }
                        var x = h.sibling;
                        if (x !== null) {
                            (x.return = h.return), (qe = x);
                            break;
                        }
                        qe = h.return;
                    }
                }
                function la(f) {
                    for (; qe !== null; ) {
                        var h = qe;
                        try {
                            switch (h.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    var x = h.return;
                                    try {
                                        yi(4, h);
                                    } catch (Me) {
                                        Fi(h, x, Me);
                                    }
                                    break;
                                case 1:
                                    var E = h.stateNode;
                                    if (
                                        typeof E.componentDidMount == 'function'
                                    ) {
                                        var R = h.return;
                                        try {
                                            E.componentDidMount();
                                        } catch (Me) {
                                            Fi(h, R, Me);
                                        }
                                    }
                                    var I = h.return;
                                    try {
                                        ki(h);
                                    } catch (Me) {
                                        Fi(h, I, Me);
                                    }
                                    break;
                                case 5:
                                    var q = h.return;
                                    try {
                                        ki(h);
                                    } catch (Me) {
                                        Fi(h, q, Me);
                                    }
                            }
                        } catch (Me) {
                            Fi(h, h.return, Me);
                        }
                        if (h === f) {
                            qe = null;
                            break;
                        }
                        var te = h.sibling;
                        if (te !== null) {
                            (te.return = h.return), (qe = te);
                            break;
                        }
                        qe = h.return;
                    }
                }
                var du = 0,
                    ua = 1,
                    ca = 2,
                    Gs = 3,
                    ll = 4;
                if (typeof Symbol == 'function' && Symbol.for) {
                    var fa = Symbol.for;
                    (du = fa('selector.component')),
                        (ua = fa('selector.has_pseudo_class')),
                        (ca = fa('selector.role')),
                        (Gs = fa('selector.test_id')),
                        (ll = fa('selector.text'));
                }
                function pu(f) {
                    var h = ke(f);
                    if (h != null) {
                        if (typeof h.memoizedProps['data-testname'] != 'string')
                            throw Error(a(364));
                        return h;
                    }
                    if (((f = k(f)), f === null)) throw Error(a(362));
                    return f.stateNode.current;
                }
                function mu(f, h) {
                    switch (h.$$typeof) {
                        case du:
                            if (f.type === h.value) return !0;
                            break;
                        case ua:
                            e: {
                                (h = h.value), (f = [f, 0]);
                                for (var x = 0; x < f.length; ) {
                                    var E = f[x++],
                                        R = f[x++],
                                        I = h[R];
                                    if (E.tag !== 5 || !be(E)) {
                                        for (; I != null && mu(E, I); )
                                            R++, (I = h[R]);
                                        if (R === h.length) {
                                            h = !0;
                                            break e;
                                        } else
                                            for (E = E.child; E !== null; )
                                                f.push(E, R), (E = E.sibling);
                                    }
                                }
                                h = !1;
                            }
                            return h;
                        case ca:
                            if (f.tag === 5 && Le(f.stateNode, h.value))
                                return !0;
                            break;
                        case ll:
                            if (
                                (f.tag === 5 || f.tag === 6) &&
                                ((f = De(f)),
                                f !== null && 0 <= f.indexOf(h.value))
                            )
                                return !0;
                            break;
                        case Gs:
                            if (
                                f.tag === 5 &&
                                ((f = f.memoizedProps['data-testname']),
                                typeof f == 'string' &&
                                    f.toLowerCase() === h.value.toLowerCase())
                            )
                                return !0;
                            break;
                        default:
                            throw Error(a(365));
                    }
                    return !1;
                }
                function Co(f) {
                    switch (f.$$typeof) {
                        case du:
                            return '<' + (B(f.value) || 'Unknown') + '>';
                        case ua:
                            return ':has(' + (Co(f) || '') + ')';
                        case ca:
                            return '[role="' + f.value + '"]';
                        case ll:
                            return '"' + f.value + '"';
                        case Gs:
                            return '[data-testname="' + f.value + '"]';
                        default:
                            throw Error(a(365));
                    }
                }
                function pr(f, h) {
                    var x = [];
                    f = [f, 0];
                    for (var E = 0; E < f.length; ) {
                        var R = f[E++],
                            I = f[E++],
                            q = h[I];
                        if (R.tag !== 5 || !be(R)) {
                            for (; q != null && mu(R, q); ) I++, (q = h[I]);
                            if (I === h.length) x.push(R);
                            else
                                for (R = R.child; R !== null; )
                                    f.push(R, I), (R = R.sibling);
                        }
                    }
                    return x;
                }
                function Ws(f, h) {
                    if (!$) throw Error(a(363));
                    (f = pu(f)), (f = pr(f, h)), (h = []), (f = Array.from(f));
                    for (var x = 0; x < f.length; ) {
                        var E = f[x++];
                        if (E.tag === 5) be(E) || h.push(E.stateNode);
                        else
                            for (E = E.child; E !== null; )
                                f.push(E), (E = E.sibling);
                    }
                    return h;
                }
                var ad = Math.ceil,
                    gu = l.ReactCurrentDispatcher,
                    Zr = l.ReactCurrentOwner,
                    pn = l.ReactCurrentBatchConfig,
                    Ht = 0,
                    Hn = null,
                    mn = null,
                    bn = 0,
                    Ti = 0,
                    ha = En(0),
                    kn = 0,
                    ul = null,
                    ps = 0,
                    mr = 0,
                    da = 0,
                    Xs = null,
                    qn = null,
                    yu = 0,
                    Ro = 1 / 0;
                function pa() {
                    Ro = ei() + 500;
                }
                var cl = !1,
                    An = null,
                    Jr = null,
                    fl = !1,
                    ms = null,
                    ma = 0,
                    ga = 0,
                    js = null,
                    wn = -1,
                    Fn = 0;
                function sn() {
                    return (Ht & 6) !== 0 ? ei() : wn !== -1 ? wn : (wn = ei());
                }
                function Qr(f) {
                    return (f.mode & 1) === 0
                        ? 1
                        : (Ht & 2) !== 0 && bn !== 0
                          ? bn & -bn
                          : am.transition !== null
                            ? (Fn === 0 &&
                                  ((f = Ha),
                                  (Ha <<= 1),
                                  (Ha & 4194240) === 0 && (Ha = 64),
                                  (Fn = f)),
                              Fn)
                            : ((f = jt), f !== 0 ? f : Ee());
                }
                function Ai(f, h, x) {
                    if (50 < ga) throw ((ga = 0), (js = null), Error(a(185)));
                    var E = bo(f, h);
                    return E === null
                        ? null
                        : (Ho(E, h, x),
                          ((Ht & 2) === 0 || E !== Hn) &&
                              (E === Hn &&
                                  ((Ht & 2) === 0 && (mr |= h),
                                  kn === 4 && xi(E, bn)),
                              Zi(E, x),
                              h === 1 &&
                                  Ht === 0 &&
                                  (f.mode & 1) === 0 &&
                                  (pa(), Ec && Rr())),
                          E);
                }
                function bo(f, h) {
                    f.lanes |= h;
                    var x = f.alternate;
                    for (
                        x !== null && (x.lanes |= h), x = f, f = f.return;
                        f !== null;

                    )
                        (f.childLanes |= h),
                            (x = f.alternate),
                            x !== null && (x.childLanes |= h),
                            (x = f),
                            (f = f.return);
                    return x.tag === 3 ? x.stateNode : null;
                }
                function Zi(f, h) {
                    var x = f.callbackNode;
                    om(f, h);
                    var E = Xl(f, f === Hn ? bn : 0);
                    if (E === 0)
                        x !== null && Wa(x),
                            (f.callbackNode = null),
                            (f.callbackPriority = 0);
                    else if (((h = E & -E), f.callbackPriority !== h)) {
                        if ((x != null && Wa(x), h === 1))
                            f.tag === 0
                                ? Ac(gr.bind(null, f))
                                : Tc(gr.bind(null, f)),
                                Ze
                                    ? ot(function () {
                                          Ht === 0 && Rr();
                                      })
                                    : Go(Wo, Rr),
                                (x = null);
                        else {
                            switch (Ps(E)) {
                                case 1:
                                    x = Wo;
                                    break;
                                case 4:
                                    x = qv;
                                    break;
                                case 16:
                                    x = wc;
                                    break;
                                case 536870912:
                                    x = Mc;
                                    break;
                                default:
                                    x = wc;
                            }
                            x = of(x, vi.bind(null, f));
                        }
                        (f.callbackPriority = h), (f.callbackNode = x);
                    }
                }
                function vi(f, h) {
                    if (((wn = -1), (Fn = 0), (Ht & 6) !== 0))
                        throw Error(a(327));
                    var x = f.callbackNode;
                    if (gs() && f.callbackNode !== x) return null;
                    var E = Xl(f, f === Hn ? bn : 0);
                    if (E === 0) return null;
                    if ((E & 30) !== 0 || (E & f.expiredLanes) !== 0 || h)
                        h = Su(f, E);
                    else {
                        h = E;
                        var R = Ht;
                        Ht |= 2;
                        var I = cd();
                        (Hn !== f || bn !== h) && (pa(), qs(f, h));
                        do
                            try {
                                Mm();
                                break;
                            } catch (te) {
                                ud(f, te);
                            }
                        while (!0);
                        Di(),
                            (gu.current = I),
                            (Ht = R),
                            mn !== null
                                ? (h = 0)
                                : ((Hn = null), (bn = 0), (h = kn));
                    }
                    if (h !== 0) {
                        if (
                            (h === 2 &&
                                ((R = xc(f)),
                                R !== 0 && ((E = R), (h = vu(f, R)))),
                            h === 1)
                        )
                            throw (
                                ((x = ul), qs(f, 0), xi(f, E), Zi(f, ei()), x)
                            );
                        if (h === 6) xi(f, E);
                        else {
                            if (
                                ((R = f.current.alternate),
                                (E & 30) === 0 &&
                                    !ld(R) &&
                                    ((h = Su(f, E)),
                                    h === 2 &&
                                        ((I = xc(f)),
                                        I !== 0 && ((E = I), (h = vu(f, I)))),
                                    h === 1))
                            )
                                throw (
                                    ((x = ul),
                                    qs(f, 0),
                                    xi(f, E),
                                    Zi(f, ei()),
                                    x)
                                );
                            switch (
                                ((f.finishedWork = R), (f.finishedLanes = E), h)
                            ) {
                                case 0:
                                case 1:
                                    throw Error(a(345));
                                case 2:
                                    es(f, qn);
                                    break;
                                case 3:
                                    if (
                                        (xi(f, E),
                                        (E & 130023424) === E &&
                                            ((h = yu + 500 - ei()), 10 < h))
                                    ) {
                                        if (Xl(f, 0) !== 0) break;
                                        if (
                                            ((R = f.suspendedLanes),
                                            (R & E) !== E)
                                        ) {
                                            sn(),
                                                (f.pingedLanes |=
                                                    f.suspendedLanes & R);
                                            break;
                                        }
                                        f.timeoutHandle = Re(
                                            es.bind(null, f, qn),
                                            h
                                        );
                                        break;
                                    }
                                    es(f, qn);
                                    break;
                                case 4:
                                    if ((xi(f, E), (E & 4194240) === E)) break;
                                    for (h = f.eventTimes, R = -1; 0 < E; ) {
                                        var q = 31 - ji(E);
                                        (I = 1 << q),
                                            (q = h[q]),
                                            q > R && (R = q),
                                            (E &= ~I);
                                    }
                                    if (
                                        ((E = R),
                                        (E = ei() - E),
                                        (E =
                                            (120 > E
                                                ? 120
                                                : 480 > E
                                                  ? 480
                                                  : 1080 > E
                                                    ? 1080
                                                    : 1920 > E
                                                      ? 1920
                                                      : 3e3 > E
                                                        ? 3e3
                                                        : 4320 > E
                                                          ? 4320
                                                          : 1960 *
                                                            ad(E / 1960)) - E),
                                        10 < E)
                                    ) {
                                        f.timeoutHandle = Re(
                                            es.bind(null, f, qn),
                                            E
                                        );
                                        break;
                                    }
                                    es(f, qn);
                                    break;
                                case 5:
                                    es(f, qn);
                                    break;
                                default:
                                    throw Error(a(329));
                            }
                        }
                    }
                    return (
                        Zi(f, ei()),
                        f.callbackNode === x ? vi.bind(null, f) : null
                    );
                }
                function vu(f, h) {
                    var x = Xs;
                    return (
                        f.current.memoizedState.isDehydrated &&
                            (qs(f, h).flags |= 256),
                        (f = Su(f, h)),
                        f !== 2 && ((h = qn), (qn = x), h !== null && xu(h)),
                        f
                    );
                }
                function xu(f) {
                    qn === null ? (qn = f) : qn.push.apply(qn, f);
                }
                function ld(f) {
                    for (var h = f; ; ) {
                        if (h.flags & 16384) {
                            var x = h.updateQueue;
                            if (x !== null && ((x = x.stores), x !== null))
                                for (var E = 0; E < x.length; E++) {
                                    var R = x[E],
                                        I = R.getSnapshot;
                                    R = R.value;
                                    try {
                                        if (!Ii(I(), R)) return !1;
                                    } catch {
                                        return !1;
                                    }
                                }
                        }
                        if (
                            ((x = h.child),
                            h.subtreeFlags & 16384 && x !== null)
                        )
                            (x.return = h), (h = x);
                        else {
                            if (h === f) break;
                            for (; h.sibling === null; ) {
                                if (h.return === null || h.return === f)
                                    return !0;
                                h = h.return;
                            }
                            (h.sibling.return = h.return), (h = h.sibling);
                        }
                    }
                    return !0;
                }
                function xi(f, h) {
                    for (
                        h &= ~da,
                            h &= ~mr,
                            f.suspendedLanes |= h,
                            f.pingedLanes &= ~h,
                            f = f.expirationTimes;
                        0 < h;

                    ) {
                        var x = 31 - ji(h),
                            E = 1 << x;
                        (f[x] = -1), (h &= ~E);
                    }
                }
                function gr(f) {
                    if ((Ht & 6) !== 0) throw Error(a(327));
                    gs();
                    var h = Xl(f, 0);
                    if ((h & 1) === 0) return Zi(f, ei()), null;
                    var x = Su(f, h);
                    if (f.tag !== 0 && x === 2) {
                        var E = xc(f);
                        E !== 0 && ((h = E), (x = vu(f, E)));
                    }
                    if (x === 1)
                        throw ((x = ul), qs(f, 0), xi(f, h), Zi(f, ei()), x);
                    if (x === 6) throw Error(a(345));
                    return (
                        (f.finishedWork = f.current.alternate),
                        (f.finishedLanes = h),
                        es(f, qn),
                        Zi(f, ei()),
                        null
                    );
                }
                function hl(f) {
                    ms !== null && ms.tag === 0 && (Ht & 6) === 0 && gs();
                    var h = Ht;
                    Ht |= 1;
                    var x = pn.transition,
                        E = jt;
                    try {
                        if (((pn.transition = null), (jt = 1), f)) return f();
                    } finally {
                        (jt = E),
                            (pn.transition = x),
                            (Ht = h),
                            (Ht & 6) === 0 && Rr();
                    }
                }
                function _u() {
                    (Ti = ha.current), ft(ha);
                }
                function qs(f, h) {
                    (f.finishedWork = null), (f.finishedLanes = 0);
                    var x = f.timeoutHandle;
                    if (
                        (x !== lt && ((f.timeoutHandle = lt), Ye(x)),
                        mn !== null)
                    )
                        for (x = mn.return; x !== null; ) {
                            var E = x;
                            switch ((kh(E), E.tag)) {
                                case 1:
                                    (E = E.type.childContextTypes),
                                        E != null && fn();
                                    break;
                                case 3:
                                    Qa(), ft(xn), ft(It), Jo();
                                    break;
                                case 5:
                                    zh(E);
                                    break;
                                case 4:
                                    Qa();
                                    break;
                                case 13:
                                    ft(Nn);
                                    break;
                                case 19:
                                    ft(Nn);
                                    break;
                                case 10:
                                    Kl(E.type._context);
                                    break;
                                case 22:
                                case 23:
                                    _u();
                            }
                            x = x.return;
                        }
                    if (
                        ((Hn = f),
                        (mn = f = $s(f.current, null)),
                        (bn = Ti = h),
                        (kn = 0),
                        (ul = null),
                        (da = mr = ps = 0),
                        (qn = Xs = null),
                        br !== null)
                    ) {
                        for (h = 0; h < br.length; h++)
                            if (
                                ((x = br[h]), (E = x.interleaved), E !== null)
                            ) {
                                x.interleaved = null;
                                var R = E.next,
                                    I = x.pending;
                                if (I !== null) {
                                    var q = I.next;
                                    (I.next = R), (E.next = q);
                                }
                                x.pending = E;
                            }
                        br = null;
                    }
                    return f;
                }
                function ud(f, h) {
                    do {
                        var x = mn;
                        try {
                            if ((Di(), (Jl.current = rl), Fc)) {
                                for (var E = Un.memoizedState; E !== null; ) {
                                    var R = E.queue;
                                    R !== null && (R.pending = null),
                                        (E = E.next);
                                }
                                Fc = !1;
                            }
                            if (
                                ((Qo = 0),
                                (oi = si = Un = null),
                                (fs = !1),
                                (ea = 0),
                                (Zr.current = null),
                                x === null || x.return === null)
                            ) {
                                (kn = 1), (ul = h), (mn = null);
                                break;
                            }
                            e: {
                                var I = f,
                                    q = x.return,
                                    te = x,
                                    Me = h;
                                if (
                                    ((h = bn),
                                    (te.flags |= 32768),
                                    Me !== null &&
                                        typeof Me == 'object' &&
                                        typeof Me.then == 'function')
                                ) {
                                    var ze = Me,
                                        ct = te,
                                        kt = ct.tag;
                                    if (
                                        (ct.mode & 1) === 0 &&
                                        (kt === 0 || kt === 11 || kt === 15)
                                    ) {
                                        var Tt = ct.alternate;
                                        Tt
                                            ? ((ct.updateQueue =
                                                  Tt.updateQueue),
                                              (ct.memoizedState =
                                                  Tt.memoizedState),
                                              (ct.lanes = Tt.lanes))
                                            : ((ct.updateQueue = null),
                                              (ct.memoizedState = null));
                                    }
                                    var Gt = Kh(q);
                                    if (Gt !== null) {
                                        (Gt.flags &= -257),
                                            na(Gt, q, te, I, h),
                                            Gt.mode & 1 && ks(I, ze, h),
                                            (h = Gt),
                                            (Me = ze);
                                        var it = h.updateQueue;
                                        if (it === null) {
                                            var _i = new Set();
                                            _i.add(Me), (h.updateQueue = _i);
                                        } else it.add(Me);
                                        break e;
                                    } else {
                                        if ((h & 1) === 0) {
                                            ks(I, ze, h), sf();
                                            break e;
                                        }
                                        Me = Error(a(426));
                                    }
                                } else if (Rn && te.mode & 1) {
                                    var vr = Kh(q);
                                    if (vr !== null) {
                                        (vr.flags & 65536) === 0 &&
                                            (vr.flags |= 256),
                                            na(vr, q, te, I, h),
                                            Uc(Me);
                                        break e;
                                    }
                                }
                                (I = Me),
                                    kn !== 4 && (kn = 2),
                                    Xs === null ? (Xs = [I]) : Xs.push(I),
                                    (Me = Yh(Me, te)),
                                    (te = q);
                                do {
                                    switch (te.tag) {
                                        case 3:
                                            (te.flags |= 65536),
                                                (h &= -h),
                                                (te.lanes |= h);
                                            var pe = _m(te, Me, h);
                                            bc(te, pe);
                                            break e;
                                        case 1:
                                            I = Me;
                                            var se = te.type,
                                                _e = te.stateNode;
                                            if (
                                                (te.flags & 128) === 0 &&
                                                (typeof se.getDerivedStateFromError ==
                                                    'function' ||
                                                    (_e !== null &&
                                                        typeof _e.componentDidCatch ==
                                                            'function' &&
                                                        (Jr === null ||
                                                            !Jr.has(_e))))
                                            ) {
                                                (te.flags |= 65536),
                                                    (h &= -h),
                                                    (te.lanes |= h);
                                                var Qe = $c(te, I, h);
                                                bc(te, Qe);
                                                break e;
                                            }
                                    }
                                    te = te.return;
                                } while (te !== null);
                            }
                            hd(x);
                        } catch (yt) {
                            (h = yt),
                                mn === x && x !== null && (mn = x = x.return);
                            continue;
                        }
                        break;
                    } while (!0);
                }
                function cd() {
                    var f = gu.current;
                    return (gu.current = rl), f === null ? rl : f;
                }
                function sf() {
                    (kn === 0 || kn === 3 || kn === 2) && (kn = 4),
                        Hn === null ||
                            ((ps & 268435455) === 0 &&
                                (mr & 268435455) === 0) ||
                            xi(Hn, bn);
                }
                function Su(f, h) {
                    var x = Ht;
                    Ht |= 2;
                    var E = cd();
                    (Hn === f && bn === h) || qs(f, h);
                    do
                        try {
                            wm();
                            break;
                        } catch (R) {
                            ud(f, R);
                        }
                    while (!0);
                    if ((Di(), (Ht = x), (gu.current = E), mn !== null))
                        throw Error(a(261));
                    return (Hn = null), (bn = 0), kn;
                }
                function wm() {
                    for (; mn !== null; ) fd(mn);
                }
                function Mm() {
                    for (; mn !== null && !vo(); ) fd(mn);
                }
                function fd(f) {
                    var h = md(f.alternate, f, Ti);
                    (f.memoizedProps = f.pendingProps),
                        h === null ? hd(f) : (mn = h),
                        (Zr.current = null);
                }
                function hd(f) {
                    var h = f;
                    do {
                        var x = h.alternate;
                        if (((f = h.return), (h.flags & 32768) === 0)) {
                            if (((x = Zc(x, h, Ti)), x !== null)) {
                                mn = x;
                                return;
                            }
                        } else {
                            if (((x = ef(x, h)), x !== null)) {
                                (x.flags &= 32767), (mn = x);
                                return;
                            }
                            if (f !== null)
                                (f.flags |= 32768),
                                    (f.subtreeFlags = 0),
                                    (f.deletions = null);
                            else {
                                (kn = 6), (mn = null);
                                return;
                            }
                        }
                        if (((h = h.sibling), h !== null)) {
                            mn = h;
                            return;
                        }
                        mn = h = f;
                    } while (h !== null);
                    kn === 0 && (kn = 5);
                }
                function es(f, h) {
                    var x = jt,
                        E = pn.transition;
                    try {
                        (pn.transition = null), (jt = 1), Em(f, h, x);
                    } finally {
                        (pn.transition = E), (jt = x);
                    }
                    return null;
                }
                function Em(f, h, x) {
                    do gs();
                    while (ms !== null);
                    if ((Ht & 6) !== 0) throw Error(a(327));
                    var E = f.finishedWork,
                        R = f.finishedLanes;
                    if (E === null) return null;
                    if (
                        ((f.finishedWork = null),
                        (f.finishedLanes = 0),
                        E === f.current)
                    )
                        throw Error(a(177));
                    (f.callbackNode = null), (f.callbackPriority = 0);
                    var I = E.lanes | E.childLanes;
                    if (
                        (Sc(f, I),
                        f === Hn && ((mn = Hn = null), (bn = 0)),
                        ((E.subtreeFlags & 2064) === 0 &&
                            (E.flags & 2064) === 0) ||
                            fl ||
                            ((fl = !0),
                            of(wc, function () {
                                return gs(), null;
                            })),
                        (I = (E.flags & 15990) !== 0),
                        (E.subtreeFlags & 15990) !== 0 || I)
                    ) {
                        (I = pn.transition), (pn.transition = null);
                        var q = jt;
                        jt = 1;
                        var te = Ht;
                        (Ht |= 4),
                            (Zr.current = null),
                            td(f, E),
                            Kv(f, E),
                            Q(f.containerInfo),
                            (f.current = E),
                            fu(E),
                            jv(),
                            (Ht = te),
                            (jt = q),
                            (pn.transition = I);
                    } else f.current = E;
                    if (
                        (fl && ((fl = !1), (ms = f), (ma = R)),
                        (I = f.pendingLanes),
                        I === 0 && (Jr = null),
                        ql(E.stateNode),
                        Zi(f, ei()),
                        h !== null)
                    )
                        for (x = f.onRecoverableError, E = 0; E < h.length; E++)
                            x(h[E]);
                    if (cl) throw ((cl = !1), (f = An), (An = null), f);
                    return (
                        (ma & 1) !== 0 && f.tag !== 0 && gs(),
                        (I = f.pendingLanes),
                        (I & 1) !== 0
                            ? f === js
                                ? ga++
                                : ((ga = 0), (js = f))
                            : (ga = 0),
                        Rr(),
                        null
                    );
                }
                function gs() {
                    if (ms !== null) {
                        var f = Ps(ma),
                            h = pn.transition,
                            x = jt;
                        try {
                            if (
                                ((pn.transition = null),
                                (jt = 16 > f ? 16 : f),
                                ms === null)
                            )
                                var E = !1;
                            else {
                                if (
                                    ((f = ms),
                                    (ms = null),
                                    (ma = 0),
                                    (Ht & 6) !== 0)
                                )
                                    throw Error(a(331));
                                var R = Ht;
                                for (Ht |= 4, qe = f.current; qe !== null; ) {
                                    var I = qe,
                                        q = I.child;
                                    if ((qe.flags & 16) !== 0) {
                                        var te = I.deletions;
                                        if (te !== null) {
                                            for (
                                                var Me = 0;
                                                Me < te.length;
                                                Me++
                                            ) {
                                                var ze = te[Me];
                                                for (qe = ze; qe !== null; ) {
                                                    var ct = qe;
                                                    switch (ct.tag) {
                                                        case 0:
                                                        case 11:
                                                        case 15:
                                                            Hs(8, ct, I);
                                                    }
                                                    var kt = ct.child;
                                                    if (kt !== null)
                                                        (kt.return = ct),
                                                            (qe = kt);
                                                    else
                                                        for (; qe !== null; ) {
                                                            ct = qe;
                                                            var Tt = ct.sibling,
                                                                Gt = ct.return;
                                                            if (
                                                                (nd(ct),
                                                                ct === ze)
                                                            ) {
                                                                qe = null;
                                                                break;
                                                            }
                                                            if (Tt !== null) {
                                                                (Tt.return =
                                                                    Gt),
                                                                    (qe = Tt);
                                                                break;
                                                            }
                                                            qe = Gt;
                                                        }
                                                }
                                            }
                                            var it = I.alternate;
                                            if (it !== null) {
                                                var _i = it.child;
                                                if (_i !== null) {
                                                    it.child = null;
                                                    do {
                                                        var vr = _i.sibling;
                                                        (_i.sibling = null),
                                                            (_i = vr);
                                                    } while (_i !== null);
                                                }
                                            }
                                            qe = I;
                                        }
                                    }
                                    if (
                                        (I.subtreeFlags & 2064) !== 0 &&
                                        q !== null
                                    )
                                        (q.return = I), (qe = q);
                                    else
                                        e: for (; qe !== null; ) {
                                            if (
                                                ((I = qe),
                                                (I.flags & 2048) !== 0)
                                            )
                                                switch (I.tag) {
                                                    case 0:
                                                    case 11:
                                                    case 15:
                                                        Hs(9, I, I.return);
                                                }
                                            var pe = I.sibling;
                                            if (pe !== null) {
                                                (pe.return = I.return),
                                                    (qe = pe);
                                                break e;
                                            }
                                            qe = I.return;
                                        }
                                }
                                var se = f.current;
                                for (qe = se; qe !== null; ) {
                                    q = qe;
                                    var _e = q.child;
                                    if (
                                        (q.subtreeFlags & 2064) !== 0 &&
                                        _e !== null
                                    )
                                        (_e.return = q), (qe = _e);
                                    else
                                        e: for (q = se; qe !== null; ) {
                                            if (
                                                ((te = qe),
                                                (te.flags & 2048) !== 0)
                                            )
                                                try {
                                                    switch (te.tag) {
                                                        case 0:
                                                        case 11:
                                                        case 15:
                                                            yi(9, te);
                                                    }
                                                } catch (yt) {
                                                    Fi(te, te.return, yt);
                                                }
                                            if (te === q) {
                                                qe = null;
                                                break e;
                                            }
                                            var Qe = te.sibling;
                                            if (Qe !== null) {
                                                (Qe.return = te.return),
                                                    (qe = Qe);
                                                break e;
                                            }
                                            qe = te.return;
                                        }
                                }
                                if (
                                    ((Ht = R),
                                    Rr(),
                                    cs &&
                                        typeof cs.onPostCommitFiberRoot ==
                                            'function')
                                )
                                    try {
                                        cs.onPostCommitFiberRoot(jl, f);
                                    } catch {}
                                E = !0;
                            }
                            return E;
                        } finally {
                            (jt = x), (pn.transition = h);
                        }
                    }
                    return !1;
                }
                function wu(f, h, x) {
                    (h = Yh(x, h)),
                        (h = _m(f, h, 1)),
                        xo(f, h),
                        (h = sn()),
                        (f = bo(f, 1)),
                        f !== null && (Ho(f, 1, h), Zi(f, h));
                }
                function Fi(f, h, x) {
                    if (f.tag === 3) wu(f, f, x);
                    else
                        for (; h !== null; ) {
                            if (h.tag === 3) {
                                wu(h, f, x);
                                break;
                            } else if (h.tag === 1) {
                                var E = h.stateNode;
                                if (
                                    typeof h.type.getDerivedStateFromError ==
                                        'function' ||
                                    (typeof E.componentDidCatch == 'function' &&
                                        (Jr === null || !Jr.has(E)))
                                ) {
                                    (f = Yh(x, f)),
                                        (f = $c(h, f, 1)),
                                        xo(h, f),
                                        (f = sn()),
                                        (h = bo(h, 1)),
                                        h !== null && (Ho(h, 1, f), Zi(h, f));
                                    break;
                                }
                            }
                            h = h.return;
                        }
                }
                function dd(f, h, x) {
                    var E = f.pingCache;
                    E !== null && E.delete(h),
                        (h = sn()),
                        (f.pingedLanes |= f.suspendedLanes & x),
                        Hn === f &&
                            (bn & x) === x &&
                            (kn === 4 ||
                            (kn === 3 &&
                                (bn & 130023424) === bn &&
                                500 > ei() - yu)
                                ? qs(f, 0)
                                : (da |= x)),
                        Zi(f, h);
                }
                function pd(f, h) {
                    h === 0 &&
                        ((f.mode & 1) === 0
                            ? (h = 1)
                            : ((h = rn),
                              (rn <<= 1),
                              (rn & 130023424) === 0 && (rn = 4194304)));
                    var x = sn();
                    (f = bo(f, h)), f !== null && (Ho(f, h, x), Zi(f, x));
                }
                function Tm(f) {
                    var h = f.memoizedState,
                        x = 0;
                    h !== null && (x = h.retryLane), pd(f, x);
                }
                function Am(f, h) {
                    var x = 0;
                    switch (f.tag) {
                        case 13:
                            var E = f.stateNode,
                                R = f.memoizedState;
                            R !== null && (x = R.retryLane);
                            break;
                        case 19:
                            E = f.stateNode;
                            break;
                        default:
                            throw Error(a(314));
                    }
                    E !== null && E.delete(h), pd(f, x);
                }
                var md;
                md = function (f, h, x) {
                    if (f !== null)
                        if (f.memoizedProps !== h.pendingProps || xn.current)
                            li = !0;
                        else {
                            if ((f.lanes & x) === 0 && (h.flags & 128) === 0)
                                return (li = !1), Qc(f, h, x);
                            li = (f.flags & 131072) !== 0;
                        }
                    else
                        (li = !1),
                            Rn &&
                                (h.flags & 1048576) !== 0 &&
                                hm(h, Dc, h.index);
                    switch (((h.lanes = 0), h.tag)) {
                        case 2:
                            var E = h.type;
                            f !== null &&
                                ((f.alternate = null),
                                (h.alternate = null),
                                (h.flags |= 2)),
                                (f = h.pendingProps);
                            var R = Dn(h, It.current);
                            Xa(h, x), (R = el(null, h, E, f, R, x));
                            var I = Mo();
                            return (
                                (h.flags |= 1),
                                typeof R == 'object' &&
                                R !== null &&
                                typeof R.render == 'function' &&
                                R.$$typeof === void 0
                                    ? ((h.tag = 1),
                                      (h.memoizedState = null),
                                      (h.updateQueue = null),
                                      zn(E) ? ((I = !0), pi(h)) : (I = !1),
                                      (h.memoizedState =
                                          R.state !== null && R.state !== void 0
                                              ? R.state
                                              : null),
                                      ja(h),
                                      (R.updater = Lc),
                                      (h.stateNode = R),
                                      (R._reactInternals = h),
                                      Uh(h, E, f, x),
                                      (h = Ei(null, h, E, !0, I, x)))
                                    : ((h.tag = 0),
                                      Rn && I && Oh(h),
                                      On(null, h, R, x),
                                      (h = h.child)),
                                h
                            );
                        case 16:
                            E = h.elementType;
                            e: {
                                switch (
                                    (f !== null &&
                                        ((f.alternate = null),
                                        (h.alternate = null),
                                        (h.flags |= 2)),
                                    (f = h.pendingProps),
                                    (R = E._init),
                                    (E = R(E._payload)),
                                    (h.type = E),
                                    (R = h.tag = Zv(E)),
                                    (f = qi(E, f)),
                                    R)
                                ) {
                                    case 0:
                                        h = zs(null, h, E, f, x);
                                        break e;
                                    case 1:
                                        h = ra(null, h, E, f, x);
                                        break e;
                                    case 11:
                                        h = Sn(null, h, E, f, x);
                                        break e;
                                    case 14:
                                        h = yn(null, h, E, qi(E.type, f), x);
                                        break e;
                                }
                                throw Error(a(306, E, ''));
                            }
                            return h;
                        case 0:
                            return (
                                (E = h.type),
                                (R = h.pendingProps),
                                (R = h.elementType === E ? R : qi(E, R)),
                                zs(f, h, E, R, x)
                            );
                        case 1:
                            return (
                                (E = h.type),
                                (R = h.pendingProps),
                                (R = h.elementType === E ? R : qi(E, R)),
                                ra(f, h, E, R, x)
                            );
                        case 3:
                            e: {
                                if ((au(h), f === null)) throw Error(a(387));
                                (E = h.pendingProps),
                                    (I = h.memoizedState),
                                    (R = I.element),
                                    Ih(f, h),
                                    Pc(h, E, null, x);
                                var q = h.memoizedState;
                                if (((E = q.element), Ie && I.isDehydrated))
                                    if (
                                        ((I = {
                                            element: E,
                                            isDehydrated: !1,
                                            cache: q.cache,
                                            transitions: q.transitions,
                                        }),
                                        (h.updateQueue.baseState = I),
                                        (h.memoizedState = I),
                                        h.flags & 256)
                                    ) {
                                        (R = Error(a(423))),
                                            (h = Jh(f, h, E, x, R));
                                        break e;
                                    } else if (E !== R) {
                                        (R = Error(a(424))),
                                            (h = Jh(f, h, E, x, R));
                                        break e;
                                    } else
                                        for (
                                            Ie &&
                                                ((mi = gc(
                                                    h.stateNode.containerInfo
                                                )),
                                                (Ni = h),
                                                (Rn = !0),
                                                (Ir = null),
                                                ($a = !1)),
                                                x = mm(h, null, E, x),
                                                h.child = x;
                                            x;

                                        )
                                            (x.flags = (x.flags & -3) | 4096),
                                                (x = x.sibling);
                                else {
                                    if ((Ya(), E === R)) {
                                        h = Ki(f, h, x);
                                        break e;
                                    }
                                    On(f, h, E, x);
                                }
                                h = h.child;
                            }
                            return h;
                        case 5:
                            return (
                                gm(h),
                                f === null && So(h),
                                (E = h.type),
                                (R = h.pendingProps),
                                (I = f !== null ? f.memoizedProps : null),
                                (q = R.children),
                                we(E, R)
                                    ? (q = null)
                                    : I !== null && we(E, I) && (h.flags |= 32),
                                Ui(f, h),
                                On(f, h, q, x),
                                h.child
                            );
                        case 6:
                            return f === null && So(h), null;
                        case 13:
                            return Qh(f, h, x);
                        case 4:
                            return (
                                Oc(h, h.stateNode.containerInfo),
                                (E = h.pendingProps),
                                f === null
                                    ? (h.child = Us(h, null, E, x))
                                    : On(f, h, E, x),
                                h.child
                            );
                        case 11:
                            return (
                                (E = h.type),
                                (R = h.pendingProps),
                                (R = h.elementType === E ? R : qi(E, R)),
                                Sn(f, h, E, R, x)
                            );
                        case 7:
                            return On(f, h, h.pendingProps, x), h.child;
                        case 8:
                            return (
                                On(f, h, h.pendingProps.children, x), h.child
                            );
                        case 12:
                            return (
                                On(f, h, h.pendingProps.children, x), h.child
                            );
                        case 10:
                            e: {
                                if (
                                    ((E = h.type._context),
                                    (R = h.pendingProps),
                                    (I = h.memoizedProps),
                                    (q = R.value),
                                    jo(h, E, q),
                                    I !== null)
                                )
                                    if (Ii(I.value, q)) {
                                        if (
                                            I.children === R.children &&
                                            !xn.current
                                        ) {
                                            h = Ki(f, h, x);
                                            break e;
                                        }
                                    } else
                                        for (
                                            I = h.child,
                                                I !== null && (I.return = h);
                                            I !== null;

                                        ) {
                                            var te = I.dependencies;
                                            if (te !== null) {
                                                q = I.child;
                                                for (
                                                    var Me = te.firstContext;
                                                    Me !== null;

                                                ) {
                                                    if (Me.context === E) {
                                                        if (I.tag === 1) {
                                                            (Me = Is(
                                                                -1,
                                                                x & -x
                                                            )),
                                                                (Me.tag = 2);
                                                            var ze =
                                                                I.updateQueue;
                                                            if (ze !== null) {
                                                                ze = ze.shared;
                                                                var ct =
                                                                    ze.pending;
                                                                ct === null
                                                                    ? (Me.next =
                                                                          Me)
                                                                    : ((Me.next =
                                                                          ct.next),
                                                                      (ct.next =
                                                                          Me)),
                                                                    (ze.pending =
                                                                        Me);
                                                            }
                                                        }
                                                        (I.lanes |= x),
                                                            (Me = I.alternate),
                                                            Me !== null &&
                                                                (Me.lanes |= x),
                                                            qo(I.return, x, h),
                                                            (te.lanes |= x);
                                                        break;
                                                    }
                                                    Me = Me.next;
                                                }
                                            } else if (I.tag === 10)
                                                q =
                                                    I.type === h.type
                                                        ? null
                                                        : I.child;
                                            else if (I.tag === 18) {
                                                if (
                                                    ((q = I.return), q === null)
                                                )
                                                    throw Error(a(341));
                                                (q.lanes |= x),
                                                    (te = q.alternate),
                                                    te !== null &&
                                                        (te.lanes |= x),
                                                    qo(q, x, h),
                                                    (q = I.sibling);
                                            } else q = I.child;
                                            if (q !== null) q.return = I;
                                            else
                                                for (q = I; q !== null; ) {
                                                    if (q === h) {
                                                        q = null;
                                                        break;
                                                    }
                                                    if (
                                                        ((I = q.sibling),
                                                        I !== null)
                                                    ) {
                                                        (I.return = q.return),
                                                            (q = I);
                                                        break;
                                                    }
                                                    q = q.return;
                                                }
                                            I = q;
                                        }
                                On(f, h, R.children, x), (h = h.child);
                            }
                            return h;
                        case 9:
                            return (
                                (R = h.type),
                                (E = h.pendingProps.children),
                                Xa(h, x),
                                (R = $i(R)),
                                (E = E(R)),
                                (h.flags |= 1),
                                On(f, h, E, x),
                                h.child
                            );
                        case 14:
                            return (
                                (E = h.type),
                                (R = qi(E, h.pendingProps)),
                                (R = qi(E.type, R)),
                                yn(f, h, E, R, x)
                            );
                        case 15:
                            return Bs(f, h, h.type, h.pendingProps, x);
                        case 17:
                            return (
                                (E = h.type),
                                (R = h.pendingProps),
                                (R = h.elementType === E ? R : qi(E, R)),
                                f !== null &&
                                    ((f.alternate = null),
                                    (h.alternate = null),
                                    (h.flags |= 2)),
                                (h.tag = 1),
                                zn(E) ? ((f = !0), pi(h)) : (f = !1),
                                Xa(h, x),
                                cm(h, E, R),
                                Uh(h, E, R, x),
                                Ei(null, h, E, !0, f, x)
                            );
                        case 19:
                            return oa(f, h, x);
                        case 22:
                            return gi(f, h, x);
                    }
                    throw Error(a(156, h.tag));
                };
                function of(f, h) {
                    return Go(f, h);
                }
                function Cm(f, h, x, E) {
                    (this.tag = f),
                        (this.key = x),
                        (this.sibling =
                            this.child =
                            this.return =
                            this.stateNode =
                            this.type =
                            this.elementType =
                                null),
                        (this.index = 0),
                        (this.ref = null),
                        (this.pendingProps = h),
                        (this.dependencies =
                            this.memoizedState =
                            this.updateQueue =
                            this.memoizedProps =
                                null),
                        (this.mode = E),
                        (this.subtreeFlags = this.flags = 0),
                        (this.deletions = null),
                        (this.childLanes = this.lanes = 0),
                        (this.alternate = null);
                }
                function yr(f, h, x, E) {
                    return new Cm(f, h, x, E);
                }
                function af(f) {
                    return (f = f.prototype), !(!f || !f.isReactComponent);
                }
                function Zv(f) {
                    if (typeof f == 'function') return af(f) ? 1 : 0;
                    if (f != null) {
                        if (((f = f.$$typeof), f === T)) return 11;
                        if (f === b) return 14;
                    }
                    return 2;
                }
                function $s(f, h) {
                    var x = f.alternate;
                    return (
                        x === null
                            ? ((x = yr(f.tag, h, f.key, f.mode)),
                              (x.elementType = f.elementType),
                              (x.type = f.type),
                              (x.stateNode = f.stateNode),
                              (x.alternate = f),
                              (f.alternate = x))
                            : ((x.pendingProps = h),
                              (x.type = f.type),
                              (x.flags = 0),
                              (x.subtreeFlags = 0),
                              (x.deletions = null)),
                        (x.flags = f.flags & 14680064),
                        (x.childLanes = f.childLanes),
                        (x.lanes = f.lanes),
                        (x.child = f.child),
                        (x.memoizedProps = f.memoizedProps),
                        (x.memoizedState = f.memoizedState),
                        (x.updateQueue = f.updateQueue),
                        (h = f.dependencies),
                        (x.dependencies =
                            h === null
                                ? null
                                : {
                                      lanes: h.lanes,
                                      firstContext: h.firstContext,
                                  }),
                        (x.sibling = f.sibling),
                        (x.index = f.index),
                        (x.ref = f.ref),
                        x
                    );
                }
                function lf(f, h, x, E, R, I) {
                    var q = 2;
                    if (((E = f), typeof f == 'function')) af(f) && (q = 1);
                    else if (typeof f == 'string') q = 5;
                    else
                        e: switch (f) {
                            case p:
                                return ya(x.children, R, I, h);
                            case g:
                                (q = 8), (R |= 8);
                                break;
                            case y:
                                return (
                                    (f = yr(12, x, h, R | 2)),
                                    (f.elementType = y),
                                    (f.lanes = I),
                                    f
                                );
                            case M:
                                return (
                                    (f = yr(13, x, h, R)),
                                    (f.elementType = M),
                                    (f.lanes = I),
                                    f
                                );
                            case w:
                                return (
                                    (f = yr(19, x, h, R)),
                                    (f.elementType = w),
                                    (f.lanes = I),
                                    f
                                );
                            case L:
                                return Mu(x, R, I, h);
                            default:
                                if (typeof f == 'object' && f !== null)
                                    switch (f.$$typeof) {
                                        case v:
                                            q = 10;
                                            break e;
                                        case S:
                                            q = 9;
                                            break e;
                                        case T:
                                            q = 11;
                                            break e;
                                        case b:
                                            q = 14;
                                            break e;
                                        case C:
                                            (q = 16), (E = null);
                                            break e;
                                    }
                                throw Error(
                                    a(130, f == null ? f : typeof f, '')
                                );
                        }
                    return (
                        (h = yr(q, x, h, R)),
                        (h.elementType = f),
                        (h.type = E),
                        (h.lanes = I),
                        h
                    );
                }
                function ya(f, h, x, E) {
                    return (f = yr(7, f, E, h)), (f.lanes = x), f;
                }
                function Mu(f, h, x, E) {
                    return (
                        (f = yr(22, f, E, h)),
                        (f.elementType = L),
                        (f.lanes = x),
                        (f.stateNode = {}),
                        f
                    );
                }
                function uf(f, h, x) {
                    return (f = yr(6, f, null, h)), (f.lanes = x), f;
                }
                function cf(f, h, x) {
                    return (
                        (h = yr(
                            4,
                            f.children !== null ? f.children : [],
                            f.key,
                            h
                        )),
                        (h.lanes = x),
                        (h.stateNode = {
                            containerInfo: f.containerInfo,
                            pendingChildren: null,
                            implementation: f.implementation,
                        }),
                        h
                    );
                }
                function ff(f, h, x, E, R) {
                    (this.tag = h),
                        (this.containerInfo = f),
                        (this.finishedWork =
                            this.pingCache =
                            this.current =
                            this.pendingChildren =
                                null),
                        (this.timeoutHandle = lt),
                        (this.callbackNode =
                            this.pendingContext =
                            this.context =
                                null),
                        (this.callbackPriority = 0),
                        (this.eventTimes = _c(0)),
                        (this.expirationTimes = _c(-1)),
                        (this.entangledLanes =
                            this.finishedLanes =
                            this.mutableReadLanes =
                            this.expiredLanes =
                            this.pingedLanes =
                            this.suspendedLanes =
                            this.pendingLanes =
                                0),
                        (this.entanglements = _c(0)),
                        (this.identifierPrefix = E),
                        (this.onRecoverableError = R),
                        Ie && (this.mutableSourceEagerHydrationData = null);
                }
                function Rm(f, h, x, E, R, I, q, te, Me) {
                    return (
                        (f = new ff(f, h, x, te, Me)),
                        h === 1 ? ((h = 1), I === !0 && (h |= 8)) : (h = 0),
                        (I = yr(3, null, null, h)),
                        (f.current = I),
                        (I.stateNode = f),
                        (I.memoizedState = {
                            element: E,
                            isDehydrated: x,
                            cache: null,
                            transitions: null,
                        }),
                        ja(I),
                        f
                    );
                }
                function bm(f) {
                    if (!f) return Zt;
                    f = f._reactInternals;
                    e: {
                        if (U(f) !== f || f.tag !== 1) throw Error(a(170));
                        var h = f;
                        do {
                            switch (h.tag) {
                                case 3:
                                    h = h.stateNode.context;
                                    break e;
                                case 1:
                                    if (zn(h.type)) {
                                        h =
                                            h.stateNode
                                                .__reactInternalMemoizedMergedChildContext;
                                        break e;
                                    }
                            }
                            h = h.return;
                        } while (h !== null);
                        throw Error(a(171));
                    }
                    if (f.tag === 1) {
                        var x = f.type;
                        if (zn(x)) return za(f, x, h);
                    }
                    return h;
                }
                function Pm(f) {
                    var h = f._reactInternals;
                    if (h === void 0)
                        throw typeof f.render == 'function'
                            ? Error(a(188))
                            : ((f = Object.keys(f).join(',')),
                              Error(a(268, f)));
                    return (f = ie(h)), f === null ? null : f.stateNode;
                }
                function Ur(f, h) {
                    if (
                        ((f = f.memoizedState),
                        f !== null && f.dehydrated !== null)
                    ) {
                        var x = f.retryLane;
                        f.retryLane = x !== 0 && x < h ? x : h;
                    }
                }
                function Eu(f, h) {
                    Ur(f, h), (f = f.alternate) && Ur(f, h);
                }
                function hf(f) {
                    return (f = ie(f)), f === null ? null : f.stateNode;
                }
                function Lm() {
                    return null;
                }
                return (
                    (t.attemptContinuousHydration = function (f) {
                        if (f.tag === 13) {
                            var h = sn();
                            Ai(f, 134217728, h), Eu(f, 134217728);
                        }
                    }),
                    (t.attemptHydrationAtCurrentPriority = function (f) {
                        if (f.tag === 13) {
                            var h = sn(),
                                x = Qr(f);
                            Ai(f, x, h), Eu(f, x);
                        }
                    }),
                    (t.attemptSynchronousHydration = function (f) {
                        switch (f.tag) {
                            case 3:
                                var h = f.stateNode;
                                if (h.current.memoizedState.isDehydrated) {
                                    var x = Ga(h.pendingLanes);
                                    x !== 0 &&
                                        (us(h, x | 1),
                                        Zi(h, ei()),
                                        (Ht & 6) === 0 && (pa(), Rr()));
                                }
                                break;
                            case 13:
                                var E = sn();
                                hl(function () {
                                    return Ai(f, 1, E);
                                }),
                                    Eu(f, 1);
                        }
                    }),
                    (t.batchedUpdates = function (f, h) {
                        var x = Ht;
                        Ht |= 1;
                        try {
                            return f(h);
                        } finally {
                            (Ht = x), Ht === 0 && (pa(), Ec && Rr());
                        }
                    }),
                    (t.createComponentSelector = function (f) {
                        return { $$typeof: du, value: f };
                    }),
                    (t.createContainer = function (f, h, x, E, R, I, q) {
                        return Rm(f, h, !1, null, x, E, R, I, q);
                    }),
                    (t.createHasPseudoClassSelector = function (f) {
                        return { $$typeof: ua, value: f };
                    }),
                    (t.createHydrationContainer = function (
                        f,
                        h,
                        x,
                        E,
                        R,
                        I,
                        q,
                        te,
                        Me
                    ) {
                        return (
                            (f = Rm(x, E, !0, f, R, I, q, te, Me)),
                            (f.context = bm(null)),
                            (x = f.current),
                            (E = sn()),
                            (R = Qr(x)),
                            (I = Is(E, R)),
                            (I.callback = h ?? null),
                            xo(x, I),
                            (f.current.lanes = R),
                            Ho(f, R, E),
                            Zi(f, E),
                            f
                        );
                    }),
                    (t.createPortal = function (f, h, x) {
                        var E =
                            3 < arguments.length && arguments[3] !== void 0
                                ? arguments[3]
                                : null;
                        return {
                            $$typeof: d,
                            key: E == null ? null : '' + E,
                            children: f,
                            containerInfo: h,
                            implementation: x,
                        };
                    }),
                    (t.createRoleSelector = function (f) {
                        return { $$typeof: ca, value: f };
                    }),
                    (t.createTestNameSelector = function (f) {
                        return { $$typeof: Gs, value: f };
                    }),
                    (t.createTextSelector = function (f) {
                        return { $$typeof: ll, value: f };
                    }),
                    (t.deferredUpdates = function (f) {
                        var h = jt,
                            x = pn.transition;
                        try {
                            return (pn.transition = null), (jt = 16), f();
                        } finally {
                            (jt = h), (pn.transition = x);
                        }
                    }),
                    (t.discreteUpdates = function (f, h, x, E, R) {
                        var I = jt,
                            q = pn.transition;
                        try {
                            return (
                                (pn.transition = null), (jt = 1), f(h, x, E, R)
                            );
                        } finally {
                            (jt = I), (pn.transition = q), Ht === 0 && pa();
                        }
                    }),
                    (t.findAllNodes = Ws),
                    (t.findBoundingRects = function (f, h) {
                        if (!$) throw Error(a(363));
                        (h = Ws(f, h)), (f = []);
                        for (var x = 0; x < h.length; x++) f.push(ge(h[x]));
                        for (h = f.length - 1; 0 < h; h--) {
                            x = f[h];
                            for (
                                var E = x.x,
                                    R = E + x.width,
                                    I = x.y,
                                    q = I + x.height,
                                    te = h - 1;
                                0 <= te;
                                te--
                            )
                                if (h !== te) {
                                    var Me = f[te],
                                        ze = Me.x,
                                        ct = ze + Me.width,
                                        kt = Me.y,
                                        Tt = kt + Me.height;
                                    if (
                                        E >= ze &&
                                        I >= kt &&
                                        R <= ct &&
                                        q <= Tt
                                    ) {
                                        f.splice(h, 1);
                                        break;
                                    } else if (
                                        E !== ze ||
                                        x.width !== Me.width ||
                                        Tt < I ||
                                        kt > q
                                    ) {
                                        if (
                                            !(
                                                I !== kt ||
                                                x.height !== Me.height ||
                                                ct < E ||
                                                ze > R
                                            )
                                        ) {
                                            ze > E &&
                                                ((Me.width += ze - E),
                                                (Me.x = E)),
                                                ct < R && (Me.width = R - ze),
                                                f.splice(h, 1);
                                            break;
                                        }
                                    } else {
                                        kt > I &&
                                            ((Me.height += kt - I), (Me.y = I)),
                                            Tt < q && (Me.height = q - kt),
                                            f.splice(h, 1);
                                        break;
                                    }
                                }
                        }
                        return f;
                    }),
                    (t.findHostInstance = Pm),
                    (t.findHostInstanceWithNoPortals = function (f) {
                        return (
                            (f = H(f)),
                            (f = f !== null ? ue(f) : null),
                            f === null ? null : f.stateNode
                        );
                    }),
                    (t.findHostInstanceWithWarning = function (f) {
                        return Pm(f);
                    }),
                    (t.flushControlled = function (f) {
                        var h = Ht;
                        Ht |= 1;
                        var x = pn.transition,
                            E = jt;
                        try {
                            (pn.transition = null), (jt = 1), f();
                        } finally {
                            (jt = E),
                                (pn.transition = x),
                                (Ht = h),
                                Ht === 0 && (pa(), Rr());
                        }
                    }),
                    (t.flushPassiveEffects = gs),
                    (t.flushSync = hl),
                    (t.focusWithin = function (f, h) {
                        if (!$) throw Error(a(363));
                        for (
                            f = pu(f), h = pr(f, h), h = Array.from(h), f = 0;
                            f < h.length;

                        ) {
                            var x = h[f++];
                            if (!be(x)) {
                                if (x.tag === 5 && _t(x.stateNode)) return !0;
                                for (x = x.child; x !== null; )
                                    h.push(x), (x = x.sibling);
                            }
                        }
                        return !1;
                    }),
                    (t.getCurrentUpdatePriority = function () {
                        return jt;
                    }),
                    (t.getFindAllNodesFailureDescription = function (f, h) {
                        if (!$) throw Error(a(363));
                        var x = 0,
                            E = [];
                        f = [pu(f), 0];
                        for (var R = 0; R < f.length; ) {
                            var I = f[R++],
                                q = f[R++],
                                te = h[q];
                            if (
                                (I.tag !== 5 || !be(I)) &&
                                (mu(I, te) &&
                                    (E.push(Co(te)), q++, q > x && (x = q)),
                                q < h.length)
                            )
                                for (I = I.child; I !== null; )
                                    f.push(I, q), (I = I.sibling);
                        }
                        if (x < h.length) {
                            for (f = []; x < h.length; x++) f.push(Co(h[x]));
                            return (
                                `findAllNodes was able to match part of the selector:
  ` +
                                (E.join(' > ') +
                                    `

No matching component was found for:
  `) +
                                f.join(' > ')
                            );
                        }
                        return null;
                    }),
                    (t.getPublicRootInstance = function (f) {
                        if (((f = f.current), !f.child)) return null;
                        switch (f.child.tag) {
                            case 5:
                                return ce(f.child.stateNode);
                            default:
                                return f.child.stateNode;
                        }
                    }),
                    (t.injectIntoDevTools = function (f) {
                        if (
                            ((f = {
                                bundleType: f.bundleType,
                                version: f.version,
                                rendererPackageName: f.rendererPackageName,
                                rendererConfig: f.rendererConfig,
                                overrideHookState: null,
                                overrideHookStateDeletePath: null,
                                overrideHookStateRenamePath: null,
                                overrideProps: null,
                                overridePropsDeletePath: null,
                                overridePropsRenamePath: null,
                                setErrorHandler: null,
                                setSuspenseHandler: null,
                                scheduleUpdate: null,
                                currentDispatcherRef: l.ReactCurrentDispatcher,
                                findHostInstanceByFiber: hf,
                                findFiberByHostInstance:
                                    f.findFiberByHostInstance || Lm,
                                findHostInstancesForRefresh: null,
                                scheduleRefresh: null,
                                scheduleRoot: null,
                                setRefreshHandler: null,
                                getCurrentFiber: null,
                                reconcilerVersion: '18.0.0-fc46dba67-20220329',
                            }),
                            typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > 'u')
                        )
                            f = !1;
                        else {
                            var h = __REACT_DEVTOOLS_GLOBAL_HOOK__;
                            if (h.isDisabled || !h.supportsFiber) f = !0;
                            else {
                                try {
                                    (jl = h.inject(f)), (cs = h);
                                } catch {}
                                f = !!h.checkDCE;
                            }
                        }
                        return f;
                    }),
                    (t.isAlreadyRendering = function () {
                        return !1;
                    }),
                    (t.observeVisibleRects = function (f, h, x, E) {
                        if (!$) throw Error(a(363));
                        f = Ws(f, h);
                        var R = $e(f, x, E).disconnect;
                        return {
                            disconnect: function () {
                                R();
                            },
                        };
                    }),
                    (t.registerMutableSourceForHydration = function (f, h) {
                        var x = h._getVersion;
                        (x = x(h._source)),
                            f.mutableSourceEagerHydrationData == null
                                ? (f.mutableSourceEagerHydrationData = [h, x])
                                : f.mutableSourceEagerHydrationData.push(h, x);
                    }),
                    (t.runWithPriority = function (f, h) {
                        var x = jt;
                        try {
                            return (jt = f), h();
                        } finally {
                            jt = x;
                        }
                    }),
                    (t.shouldError = function () {
                        return null;
                    }),
                    (t.shouldSuspend = function () {
                        return !1;
                    }),
                    (t.updateContainer = function (f, h, x, E) {
                        var R = h.current,
                            I = sn(),
                            q = Qr(R);
                        return (
                            (x = bm(x)),
                            h.context === null
                                ? (h.context = x)
                                : (h.pendingContext = x),
                            (h = Is(I, q)),
                            (h.payload = { element: f }),
                            (E = E === void 0 ? null : E),
                            E !== null && (h.callback = E),
                            xo(R, h),
                            (f = Ai(R, q, I)),
                            f !== null && Rc(f, R, q),
                            q
                        );
                    }),
                    t
                );
            })),
        Px
    );
}
var dT;
function x5() {
    return dT || ((dT = 1), (Cx.exports = v5())), Cx.exports;
}
var _5 = x5();
const S5 = k_(_5);
var pT = nP();
const yw = {},
    w5 = (i) => void Object.assign(yw, i);
function M5(i, e) {
    function t(p, { args: g = [], attach: y, ...v }, S) {
        let T = `${p[0].toUpperCase()}${p.slice(1)}`,
            M;
        if (p === 'primitive') {
            if (v.object === void 0)
                throw new Error(
                    "R3F: Primitives without 'object' are invalid!"
                );
            const w = v.object;
            M = Wf(w, { type: p, root: S, attach: y, primitive: !0 });
        } else {
            const w = yw[T];
            if (!w)
                throw new Error(
                    `R3F: ${T} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`
                );
            if (!Array.isArray(g))
                throw new Error('R3F: The args prop must be an array!');
            M = Wf(new w(...g), {
                type: p,
                root: S,
                attach: y,
                memoizedProps: { args: g },
            });
        }
        return (
            M.__r3f.attach === void 0 &&
                (M.isBufferGeometry
                    ? (M.__r3f.attach = 'geometry')
                    : M.isMaterial && (M.__r3f.attach = 'material')),
            T !== 'inject' && Dx(M, v),
            M
        );
    }
    function n(p, g) {
        let y = !1;
        if (g) {
            var v, S;
            (v = g.__r3f) != null && v.attach
                ? Ix(p, g, g.__r3f.attach)
                : g.isObject3D && p.isObject3D && (p.add(g), (y = !0)),
                y || (S = p.__r3f) == null || S.objects.push(g),
                g.__r3f || Wf(g, {}),
                (g.__r3f.parent = p),
                R_(g),
                Xf(g);
        }
    }
    function r(p, g, y) {
        let v = !1;
        if (g) {
            var S, T;
            if ((S = g.__r3f) != null && S.attach) Ix(p, g, g.__r3f.attach);
            else if (g.isObject3D && p.isObject3D) {
                (g.parent = p),
                    g.dispatchEvent({ type: 'added' }),
                    p.dispatchEvent({ type: 'childadded', child: g });
                const M = p.children.filter((b) => b !== g),
                    w = M.indexOf(y);
                (p.children = [...M.slice(0, w), g, ...M.slice(w)]), (v = !0);
            }
            v || (T = p.__r3f) == null || T.objects.push(g),
                g.__r3f || Wf(g, {}),
                (g.__r3f.parent = p),
                R_(g),
                Xf(g);
        }
    }
    function s(p, g, y = !1) {
        p && [...p].forEach((v) => a(g, v, y));
    }
    function a(p, g, y) {
        if (g) {
            var v, S, T;
            if (
                (g.__r3f && (g.__r3f.parent = null),
                (v = p.__r3f) != null &&
                    v.objects &&
                    (p.__r3f.objects = p.__r3f.objects.filter((L) => L !== g)),
                (S = g.__r3f) != null && S.attach)
            )
                xT(p, g, g.__r3f.attach);
            else if (g.isObject3D && p.isObject3D) {
                var M;
                p.remove(g), (M = g.__r3f) != null && M.root && P5(ly(g), g);
            }
            const b = (T = g.__r3f) == null ? void 0 : T.primitive,
                C = !b && (y === void 0 ? g.dispose !== null : y);
            if (!b) {
                var w;
                s((w = g.__r3f) == null ? void 0 : w.objects, g, C),
                    s(g.children, g, C);
            }
            if ((delete g.__r3f, C && g.dispose && g.type !== 'Scene')) {
                const L = () => {
                    try {
                        g.dispose();
                    } catch {}
                };
                typeof IS_REACT_ACT_ENVIRONMENT > 'u'
                    ? pT.unstable_scheduleCallback(pT.unstable_IdlePriority, L)
                    : L();
            }
            Xf(p);
        }
    }
    function l(p, g, y, v) {
        var S;
        const T = (S = p.__r3f) == null ? void 0 : S.parent;
        if (!T) return;
        const M = t(g, y, p.__r3f.root);
        if (p.children) {
            for (const w of p.children) w.__r3f && n(M, w);
            p.children = p.children.filter((w) => !w.__r3f);
        }
        p.__r3f.objects.forEach((w) => n(M, w)),
            (p.__r3f.objects = []),
            p.__r3f.autoRemovedBeforeAppend || a(T, p),
            M.parent && (M.__r3f.autoRemovedBeforeAppend = !0),
            n(T, M),
            M.raycast &&
                M.__r3f.eventCount &&
                ly(M).getState().internal.interaction.push(M),
            [v, v.alternate].forEach((w) => {
                w !== null &&
                    ((w.stateNode = M),
                    w.ref &&
                        (typeof w.ref == 'function'
                            ? w.ref(M)
                            : (w.ref.current = M)));
            });
    }
    const c = () => {};
    return {
        reconciler: S5({
            createInstance: t,
            removeChild: a,
            appendChild: n,
            appendInitialChild: n,
            insertBefore: r,
            supportsMutation: !0,
            isPrimaryRenderer: !1,
            supportsPersistence: !1,
            supportsHydration: !1,
            noTimeout: -1,
            appendChildToContainer: (p, g) => {
                if (!g) return;
                const y = p.getState().scene;
                y.__r3f && ((y.__r3f.root = p), n(y, g));
            },
            removeChildFromContainer: (p, g) => {
                g && a(p.getState().scene, g);
            },
            insertInContainerBefore: (p, g, y) => {
                if (!g || !y) return;
                const v = p.getState().scene;
                v.__r3f && r(v, g, y);
            },
            getRootHostContext: () => null,
            getChildHostContext: (p) => p,
            finalizeInitialChildren(p) {
                var g;
                return !!((g = p == null ? void 0 : p.__r3f) != null ? g : {})
                    .handlers;
            },
            prepareUpdate(p, g, y, v) {
                var S;
                if (
                    ((S = p == null ? void 0 : p.__r3f) != null ? S : {})
                        .primitive &&
                    v.object &&
                    v.object !== p
                )
                    return [!0];
                {
                    const { args: M = [], children: w, ...b } = v,
                        { args: C = [], children: L, ...F } = y;
                    if (!Array.isArray(M))
                        throw new Error('R3F: the args prop must be an array!');
                    if (M.some((B, z) => B !== C[z])) return [!0];
                    const N = aP(p, b, F, !0);
                    return N.changes.length ? [!1, N] : null;
                }
            },
            commitUpdate(p, [g, y], v, S, T, M) {
                g ? l(p, v, T, M) : Dx(p, y);
            },
            commitMount(p, g, y, v) {
                var S;
                const T = (S = p.__r3f) != null ? S : {};
                p.raycast &&
                    T.handlers &&
                    T.eventCount &&
                    ly(p).getState().internal.interaction.push(p);
            },
            getPublicInstance: (p) => p,
            prepareForCommit: () => null,
            preparePortalMount: (p) => Wf(p.getState().scene),
            resetAfterCommit: () => {},
            shouldSetTextContent: () => !1,
            clearContainer: () => !1,
            hideInstance(p) {
                var g;
                const { attach: y, parent: v } = (g = p.__r3f) != null ? g : {};
                y && v && xT(v, p, y), p.isObject3D && (p.visible = !1), Xf(p);
            },
            unhideInstance(p, g) {
                var y;
                const { attach: v, parent: S } = (y = p.__r3f) != null ? y : {};
                v && S && Ix(S, p, v),
                    ((p.isObject3D && g.visible == null) || g.visible) &&
                        (p.visible = !0),
                    Xf(p);
            },
            createTextInstance: c,
            hideTextInstance: c,
            unhideTextInstance: c,
            getCurrentEventPriority: () => (e ? e() : ih.DefaultEventPriority),
            beforeActiveInstanceBlur: () => {},
            afterActiveInstanceBlur: () => {},
            detachDeletedInstance: () => {},
            now:
                typeof performance < 'u' && Ln.fun(performance.now)
                    ? performance.now
                    : Ln.fun(Date.now)
                      ? Date.now
                      : () => 0,
            scheduleTimeout: Ln.fun(setTimeout) ? setTimeout : void 0,
            cancelTimeout: Ln.fun(clearTimeout) ? clearTimeout : void 0,
        }),
        applyProps: Dx,
    };
}
var mT, gT;
const Lx = (i) => 'colorSpace' in i || 'outputColorSpace' in i,
    iP = () => {
        var i;
        return (i = yw.ColorManagement) != null ? i : null;
    },
    rP = (i) => i && i.isOrthographicCamera,
    e8 = (i) => i && i.hasOwnProperty('current'),
    Bv =
        typeof window < 'u' &&
        (((mT = window.document) != null && mT.createElement) ||
            ((gT = window.navigator) == null ? void 0 : gT.product) ===
                'ReactNative')
            ? K.useLayoutEffect
            : K.useEffect;
function E5(i) {
    const e = K.useRef(i);
    return Bv(() => void (e.current = i), [i]), e;
}
function t8({ set: i }) {
    return Bv(() => (i(new Promise(() => null)), () => i(!1)), [i]), null;
}
class T5 extends K.Component {
    constructor(...e) {
        super(...e), (this.state = { error: !1 });
    }
    componentDidCatch(e) {
        this.props.set(e);
    }
    render() {
        return this.state.error ? null : this.props.children;
    }
}
T5.getDerivedStateFromError = () => ({ error: !0 });
const sP = '__default',
    yT = new Map(),
    A5 = (i) => i && !!i.memoized && !!i.changes;
function oP(i) {
    var e;
    const t =
        typeof window < 'u'
            ? (e = window.devicePixelRatio) != null
                ? e
                : 2
            : 1;
    return Array.isArray(i) ? Math.min(Math.max(i[0], t), i[1]) : i;
}
const Bd = (i) => {
    var e;
    return (e = i.__r3f) == null ? void 0 : e.root.getState();
};
function ly(i) {
    let e = i.__r3f.root;
    for (; e.getState().previousRoot; ) e = e.getState().previousRoot;
    return e;
}
const Ln = {
    obj: (i) => i === Object(i) && !Ln.arr(i) && typeof i != 'function',
    fun: (i) => typeof i == 'function',
    str: (i) => typeof i == 'string',
    num: (i) => typeof i == 'number',
    boo: (i) => typeof i == 'boolean',
    und: (i) => i === void 0,
    arr: (i) => Array.isArray(i),
    equ(
        i,
        e,
        { arrays: t = 'shallow', objects: n = 'reference', strict: r = !0 } = {}
    ) {
        if (typeof i != typeof e || !!i != !!e) return !1;
        if (Ln.str(i) || Ln.num(i) || Ln.boo(i)) return i === e;
        const s = Ln.obj(i);
        if (s && n === 'reference') return i === e;
        const a = Ln.arr(i);
        if (a && t === 'reference') return i === e;
        if ((a || s) && i === e) return !0;
        let l;
        for (l in i) if (!(l in e)) return !1;
        if (s && t === 'shallow' && n === 'shallow') {
            for (l in r ? e : i)
                if (!Ln.equ(i[l], e[l], { strict: r, objects: 'reference' }))
                    return !1;
        } else for (l in r ? e : i) if (i[l] !== e[l]) return !1;
        if (Ln.und(l)) {
            if (
                (a && i.length === 0 && e.length === 0) ||
                (s &&
                    Object.keys(i).length === 0 &&
                    Object.keys(e).length === 0)
            )
                return !0;
            if (i !== e) return !1;
        }
        return !0;
    },
};
function C5(i) {
    const e = { nodes: {}, materials: {} };
    return (
        i &&
            i.traverse((t) => {
                t.name && (e.nodes[t.name] = t),
                    t.material &&
                        !e.materials[t.material.name] &&
                        (e.materials[t.material.name] = t.material);
            }),
        e
    );
}
function R5(i) {
    i.dispose && i.type !== 'Scene' && i.dispose();
    for (const e in i) e.dispose == null || e.dispose(), delete i[e];
}
function Wf(i, e) {
    const t = i;
    return (
        (t.__r3f = {
            type: '',
            root: null,
            previousAttach: null,
            memoizedProps: {},
            eventCount: 0,
            handlers: {},
            objects: [],
            parent: null,
            ...e,
        }),
        i
    );
}
function C_(i, e) {
    let t = i;
    if (e.includes('-')) {
        const n = e.split('-'),
            r = n.pop();
        return (t = n.reduce((s, a) => s[a], i)), { target: t, key: r };
    } else return { target: t, key: e };
}
const vT = /-\d+$/;
function Ix(i, e, t) {
    if (Ln.str(t)) {
        if (vT.test(t)) {
            const s = t.replace(vT, ''),
                { target: a, key: l } = C_(i, s);
            Array.isArray(a[l]) || (a[l] = []);
        }
        const { target: n, key: r } = C_(i, t);
        (e.__r3f.previousAttach = n[r]), (n[r] = e);
    } else e.__r3f.previousAttach = t(i, e);
}
function xT(i, e, t) {
    var n, r;
    if (Ln.str(t)) {
        const { target: s, key: a } = C_(i, t),
            l = e.__r3f.previousAttach;
        l === void 0 ? delete s[a] : (s[a] = l);
    } else
        (n = e.__r3f) == null ||
            n.previousAttach == null ||
            n.previousAttach(i, e);
    (r = e.__r3f) == null || delete r.previousAttach;
}
function aP(
    i,
    { children: e, key: t, ref: n, ...r },
    { children: s, key: a, ref: l, ...c } = {},
    d = !1
) {
    const p = i.__r3f,
        g = Object.entries(r),
        y = [];
    if (d) {
        const S = Object.keys(c);
        for (let T = 0; T < S.length; T++)
            r.hasOwnProperty(S[T]) || g.unshift([S[T], sP + 'remove']);
    }
    g.forEach(([S, T]) => {
        var M;
        if (
            ((M = i.__r3f) != null && M.primitive && S === 'object') ||
            Ln.equ(T, c[S])
        )
            return;
        if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(S))
            return y.push([S, T, !0, []]);
        let w = [];
        S.includes('-') && (w = S.split('-')), y.push([S, T, !1, w]);
        for (const b in r) {
            const C = r[b];
            b.startsWith(`${S}-`) && y.push([b, C, !1, b.split('-')]);
        }
    });
    const v = { ...r };
    return (
        p != null &&
            p.memoizedProps &&
            p != null &&
            p.memoizedProps.args &&
            (v.args = p.memoizedProps.args),
        p != null &&
            p.memoizedProps &&
            p != null &&
            p.memoizedProps.attach &&
            (v.attach = p.memoizedProps.attach),
        { memoized: v, changes: y }
    );
}
function Dx(i, e) {
    var t;
    const n = i.__r3f,
        r = n == null ? void 0 : n.root,
        s = r == null || r.getState == null ? void 0 : r.getState(),
        { memoized: a, changes: l } = A5(e) ? e : aP(i, e),
        c = n == null ? void 0 : n.eventCount;
    i.__r3f && (i.__r3f.memoizedProps = a);
    for (let y = 0; y < l.length; y++) {
        let [v, S, T, M] = l[y];
        if (Lx(i)) {
            const L = 'srgb',
                F = 'srgb-linear';
            v === 'encoding'
                ? ((v = 'colorSpace'), (S = S === 3001 ? L : F))
                : v === 'outputEncoding' &&
                  ((v = 'outputColorSpace'), (S = S === 3001 ? L : F));
        }
        let w = i,
            b = w[v];
        if (M.length && ((b = M.reduce((C, L) => C[L], i)), !(b && b.set))) {
            const [C, ...L] = M.reverse();
            (w = L.reverse().reduce((F, N) => F[N], i)), (v = C);
        }
        if (S === sP + 'remove')
            if (w.constructor) {
                let C = yT.get(w.constructor);
                C || ((C = new w.constructor()), yT.set(w.constructor, C)),
                    (S = C[v]);
            } else S = 0;
        if (T && n)
            S ? (n.handlers[v] = S) : delete n.handlers[v],
                (n.eventCount = Object.keys(n.handlers).length);
        else if (b && b.set && (b.copy || b instanceof sc)) {
            if (Array.isArray(S)) b.fromArray ? b.fromArray(S) : b.set(...S);
            else if (
                b.copy &&
                S &&
                S.constructor &&
                b.constructor === S.constructor
            )
                b.copy(S);
            else if (S !== void 0) {
                var d;
                const C = (d = b) == null ? void 0 : d.isColor;
                !C && b.setScalar
                    ? b.setScalar(S)
                    : b instanceof sc && S instanceof sc
                      ? (b.mask = S.mask)
                      : b.set(S),
                    !iP() && s && !s.linear && C && b.convertSRGBToLinear();
            }
        } else {
            var p;
            if (
                ((w[v] = S),
                (p = w[v]) != null &&
                    p.isTexture &&
                    w[v].format === sr &&
                    w[v].type === ao &&
                    s)
            ) {
                const C = w[v];
                Lx(C) && Lx(s.gl)
                    ? (C.colorSpace = s.gl.outputColorSpace)
                    : (C.encoding = s.gl.outputEncoding);
            }
        }
        Xf(i);
    }
    if (n && n.parent && i.raycast && c !== n.eventCount) {
        const y = ly(i).getState().internal,
            v = y.interaction.indexOf(i);
        v > -1 && y.interaction.splice(v, 1),
            n.eventCount && y.interaction.push(i);
    }
    return (
        !(l.length === 1 && l[0][0] === 'onUpdate') &&
            l.length &&
            (t = i.__r3f) != null &&
            t.parent &&
            R_(i),
        i
    );
}
function Xf(i) {
    var e, t;
    const n =
        (e = i.__r3f) == null || (t = e.root) == null || t.getState == null
            ? void 0
            : t.getState();
    n && n.internal.frames === 0 && n.invalidate();
}
function R_(i) {
    i.onUpdate == null || i.onUpdate(i);
}
function lP(i, e) {
    i.manual ||
        (rP(i)
            ? ((i.left = e.width / -2),
              (i.right = e.width / 2),
              (i.top = e.height / 2),
              (i.bottom = e.height / -2))
            : (i.aspect = e.width / e.height),
        i.updateProjectionMatrix(),
        i.updateMatrixWorld());
}
function Kg(i) {
    return (i.eventObject || i.object).uuid + '/' + i.index + i.instanceId;
}
function b5() {
    var i;
    const e = (typeof self < 'u' && self) || (typeof window < 'u' && window);
    if (!e) return ih.DefaultEventPriority;
    switch ((i = e.event) == null ? void 0 : i.type) {
        case 'click':
        case 'contextmenu':
        case 'dblclick':
        case 'pointercancel':
        case 'pointerdown':
        case 'pointerup':
            return ih.DiscreteEventPriority;
        case 'pointermove':
        case 'pointerout':
        case 'pointerover':
        case 'pointerenter':
        case 'pointerleave':
        case 'wheel':
            return ih.ContinuousEventPriority;
        default:
            return ih.DefaultEventPriority;
    }
}
function uP(i, e, t, n) {
    const r = t.get(e);
    r &&
        (t.delete(e),
        t.size === 0 && (i.delete(n), r.target.releasePointerCapture(n)));
}
function P5(i, e) {
    const { internal: t } = i.getState();
    (t.interaction = t.interaction.filter((n) => n !== e)),
        (t.initialHits = t.initialHits.filter((n) => n !== e)),
        t.hovered.forEach((n, r) => {
            (n.eventObject === e || n.object === e) && t.hovered.delete(r);
        }),
        t.capturedMap.forEach((n, r) => {
            uP(t.capturedMap, e, n, r);
        });
}
function L5(i) {
    function e(c) {
        const { internal: d } = i.getState(),
            p = c.offsetX - d.initialClick[0],
            g = c.offsetY - d.initialClick[1];
        return Math.round(Math.sqrt(p * p + g * g));
    }
    function t(c) {
        return c.filter((d) =>
            ['Move', 'Over', 'Enter', 'Out', 'Leave'].some((p) => {
                var g;
                return (g = d.__r3f) == null
                    ? void 0
                    : g.handlers['onPointer' + p];
            })
        );
    }
    function n(c, d) {
        const p = i.getState(),
            g = new Set(),
            y = [],
            v = d ? d(p.internal.interaction) : p.internal.interaction;
        for (let w = 0; w < v.length; w++) {
            const b = Bd(v[w]);
            b && (b.raycaster.camera = void 0);
        }
        p.previousRoot || p.events.compute == null || p.events.compute(c, p);
        function S(w) {
            const b = Bd(w);
            if (!b || !b.events.enabled || b.raycaster.camera === null)
                return [];
            if (b.raycaster.camera === void 0) {
                var C;
                b.events.compute == null ||
                    b.events.compute(
                        c,
                        b,
                        (C = b.previousRoot) == null ? void 0 : C.getState()
                    ),
                    b.raycaster.camera === void 0 &&
                        (b.raycaster.camera = null);
            }
            return b.raycaster.camera ? b.raycaster.intersectObject(w, !0) : [];
        }
        let T = v
            .flatMap(S)
            .sort((w, b) => {
                const C = Bd(w.object),
                    L = Bd(b.object);
                return !C || !L
                    ? w.distance - b.distance
                    : L.events.priority - C.events.priority ||
                          w.distance - b.distance;
            })
            .filter((w) => {
                const b = Kg(w);
                return g.has(b) ? !1 : (g.add(b), !0);
            });
        p.events.filter && (T = p.events.filter(T, p));
        for (const w of T) {
            let b = w.object;
            for (; b; ) {
                var M;
                (M = b.__r3f) != null &&
                    M.eventCount &&
                    y.push({ ...w, eventObject: b }),
                    (b = b.parent);
            }
        }
        if ('pointerId' in c && p.internal.capturedMap.has(c.pointerId))
            for (let w of p.internal.capturedMap.get(c.pointerId).values())
                g.has(Kg(w.intersection)) || y.push(w.intersection);
        return y;
    }
    function r(c, d, p, g) {
        const y = i.getState();
        if (c.length) {
            const v = { stopped: !1 };
            for (const S of c) {
                const T = Bd(S.object) || y,
                    { raycaster: M, pointer: w, camera: b, internal: C } = T,
                    L = new j(w.x, w.y, 0).unproject(b),
                    F = (D) => {
                        var H, ie;
                        return (H =
                            (ie = C.capturedMap.get(D)) == null
                                ? void 0
                                : ie.has(S.eventObject)) != null
                            ? H
                            : !1;
                    },
                    N = (D) => {
                        const H = { intersection: S, target: d.target };
                        C.capturedMap.has(D)
                            ? C.capturedMap.get(D).set(S.eventObject, H)
                            : C.capturedMap.set(
                                  D,
                                  new Map([[S.eventObject, H]])
                              ),
                            d.target.setPointerCapture(D);
                    },
                    B = (D) => {
                        const H = C.capturedMap.get(D);
                        H && uP(C.capturedMap, S.eventObject, H, D);
                    };
                let z = {};
                for (let D in d) {
                    let H = d[D];
                    typeof H != 'function' && (z[D] = H);
                }
                let U = {
                    ...S,
                    ...z,
                    pointer: w,
                    intersections: c,
                    stopped: v.stopped,
                    delta: p,
                    unprojectedPoint: L,
                    ray: M.ray,
                    camera: b,
                    stopPropagation() {
                        const D =
                            'pointerId' in d && C.capturedMap.get(d.pointerId);
                        if (
                            (!D || D.has(S.eventObject)) &&
                            ((U.stopped = v.stopped = !0),
                            C.hovered.size &&
                                Array.from(C.hovered.values()).find(
                                    (H) => H.eventObject === S.eventObject
                                ))
                        ) {
                            const H = c.slice(0, c.indexOf(S));
                            s([...H, S]);
                        }
                    },
                    target: {
                        hasPointerCapture: F,
                        setPointerCapture: N,
                        releasePointerCapture: B,
                    },
                    currentTarget: {
                        hasPointerCapture: F,
                        setPointerCapture: N,
                        releasePointerCapture: B,
                    },
                    nativeEvent: d,
                };
                if ((g(U), v.stopped === !0)) break;
            }
        }
        return c;
    }
    function s(c) {
        const { internal: d } = i.getState();
        for (const p of d.hovered.values())
            if (
                !c.length ||
                !c.find(
                    (g) =>
                        g.object === p.object &&
                        g.index === p.index &&
                        g.instanceId === p.instanceId
                )
            ) {
                const y = p.eventObject.__r3f,
                    v = y == null ? void 0 : y.handlers;
                if ((d.hovered.delete(Kg(p)), y != null && y.eventCount)) {
                    const S = { ...p, intersections: c };
                    v.onPointerOut == null || v.onPointerOut(S),
                        v.onPointerLeave == null || v.onPointerLeave(S);
                }
            }
    }
    function a(c, d) {
        for (let p = 0; p < d.length; p++) {
            const g = d[p].__r3f;
            g == null ||
                g.handlers.onPointerMissed == null ||
                g.handlers.onPointerMissed(c);
        }
    }
    function l(c) {
        switch (c) {
            case 'onPointerLeave':
            case 'onPointerCancel':
                return () => s([]);
            case 'onLostPointerCapture':
                return (d) => {
                    const { internal: p } = i.getState();
                    'pointerId' in d &&
                        p.capturedMap.has(d.pointerId) &&
                        requestAnimationFrame(() => {
                            p.capturedMap.has(d.pointerId) &&
                                (p.capturedMap.delete(d.pointerId), s([]));
                        });
                };
        }
        return function (p) {
            const { onPointerMissed: g, internal: y } = i.getState();
            y.lastEvent.current = p;
            const v = c === 'onPointerMove',
                S =
                    c === 'onClick' ||
                    c === 'onContextMenu' ||
                    c === 'onDoubleClick',
                M = n(p, v ? t : void 0),
                w = S ? e(p) : 0;
            c === 'onPointerDown' &&
                ((y.initialClick = [p.offsetX, p.offsetY]),
                (y.initialHits = M.map((C) => C.eventObject))),
                S && !M.length && w <= 2 && (a(p, y.interaction), g && g(p)),
                v && s(M);
            function b(C) {
                const L = C.eventObject,
                    F = L.__r3f,
                    N = F == null ? void 0 : F.handlers;
                if (F != null && F.eventCount)
                    if (v) {
                        if (
                            N.onPointerOver ||
                            N.onPointerEnter ||
                            N.onPointerOut ||
                            N.onPointerLeave
                        ) {
                            const B = Kg(C),
                                z = y.hovered.get(B);
                            z
                                ? z.stopped && C.stopPropagation()
                                : (y.hovered.set(B, C),
                                  N.onPointerOver == null || N.onPointerOver(C),
                                  N.onPointerEnter == null ||
                                      N.onPointerEnter(C));
                        }
                        N.onPointerMove == null || N.onPointerMove(C);
                    } else {
                        const B = N[c];
                        B
                            ? (!S || y.initialHits.includes(L)) &&
                              (a(
                                  p,
                                  y.interaction.filter(
                                      (z) => !y.initialHits.includes(z)
                                  )
                              ),
                              B(C))
                            : S &&
                              y.initialHits.includes(L) &&
                              a(
                                  p,
                                  y.interaction.filter(
                                      (z) => !y.initialHits.includes(z)
                                  )
                              );
                    }
            }
            r(M, p, w, b);
        };
    }
    return { handlePointer: l };
}
const I5 = [
        'set',
        'get',
        'setSize',
        'setFrameloop',
        'setDpr',
        'events',
        'invalidate',
        'advance',
        'size',
        'viewport',
    ],
    cP = (i) => !!(i != null && i.render),
    vw = K.createContext(null),
    D5 = (i, e) => {
        const t = Qb((l, c) => {
                const d = new j(),
                    p = new j(),
                    g = new j();
                function y(w = c().camera, b = p, C = c().size) {
                    const { width: L, height: F, top: N, left: B } = C,
                        z = L / F;
                    b.isVector3 ? g.copy(b) : g.set(...b);
                    const U = w.getWorldPosition(d).distanceTo(g);
                    if (rP(w))
                        return {
                            width: L / w.zoom,
                            height: F / w.zoom,
                            top: N,
                            left: B,
                            factor: 1,
                            distance: U,
                            aspect: z,
                        };
                    {
                        const D = (w.fov * Math.PI) / 180,
                            H = 2 * Math.tan(D / 2) * U,
                            ie = H * (L / F);
                        return {
                            width: ie,
                            height: H,
                            top: N,
                            left: B,
                            factor: L / ie,
                            distance: U,
                            aspect: z,
                        };
                    }
                }
                let v;
                const S = (w) =>
                        l((b) => ({
                            performance: { ...b.performance, current: w },
                        })),
                    T = new Ce();
                return {
                    set: l,
                    get: c,
                    gl: null,
                    camera: null,
                    raycaster: null,
                    events: { priority: 1, enabled: !0, connected: !1 },
                    xr: null,
                    scene: null,
                    invalidate: (w = 1) => i(c(), w),
                    advance: (w, b) => e(w, b, c()),
                    legacy: !1,
                    linear: !1,
                    flat: !1,
                    controls: null,
                    clock: new hw(),
                    pointer: T,
                    mouse: T,
                    frameloop: 'always',
                    onPointerMissed: void 0,
                    performance: {
                        current: 1,
                        min: 0.5,
                        max: 1,
                        debounce: 200,
                        regress: () => {
                            const w = c();
                            v && clearTimeout(v),
                                w.performance.current !== w.performance.min &&
                                    S(w.performance.min),
                                (v = setTimeout(
                                    () => S(c().performance.max),
                                    w.performance.debounce
                                ));
                        },
                    },
                    size: {
                        width: 0,
                        height: 0,
                        top: 0,
                        left: 0,
                        updateStyle: !1,
                    },
                    viewport: {
                        initialDpr: 0,
                        dpr: 0,
                        width: 0,
                        height: 0,
                        top: 0,
                        left: 0,
                        aspect: 0,
                        distance: 0,
                        factor: 0,
                        getCurrentViewport: y,
                    },
                    setEvents: (w) =>
                        l((b) => ({ ...b, events: { ...b.events, ...w } })),
                    setSize: (w, b, C, L, F) => {
                        const N = c().camera,
                            B = {
                                width: w,
                                height: b,
                                top: L || 0,
                                left: F || 0,
                                updateStyle: C,
                            };
                        l((z) => ({
                            size: B,
                            viewport: { ...z.viewport, ...y(N, p, B) },
                        }));
                    },
                    setDpr: (w) =>
                        l((b) => {
                            const C = oP(w);
                            return {
                                viewport: {
                                    ...b.viewport,
                                    dpr: C,
                                    initialDpr: b.viewport.initialDpr || C,
                                },
                            };
                        }),
                    setFrameloop: (w = 'always') => {
                        const b = c().clock;
                        b.stop(),
                            (b.elapsedTime = 0),
                            w !== 'never' && (b.start(), (b.elapsedTime = 0)),
                            l(() => ({ frameloop: w }));
                    },
                    previousRoot: void 0,
                    internal: {
                        active: !1,
                        priority: 0,
                        frames: 0,
                        lastEvent: K.createRef(),
                        interaction: [],
                        hovered: new Map(),
                        subscribers: [],
                        initialClick: [0, 0],
                        initialHits: [],
                        capturedMap: new Map(),
                        subscribe: (w, b, C) => {
                            const L = c().internal;
                            return (
                                (L.priority = L.priority + (b > 0 ? 1 : 0)),
                                L.subscribers.push({
                                    ref: w,
                                    priority: b,
                                    store: C,
                                }),
                                (L.subscribers = L.subscribers.sort(
                                    (F, N) => F.priority - N.priority
                                )),
                                () => {
                                    const F = c().internal;
                                    F != null &&
                                        F.subscribers &&
                                        ((F.priority =
                                            F.priority - (b > 0 ? 1 : 0)),
                                        (F.subscribers = F.subscribers.filter(
                                            (N) => N.ref !== w
                                        )));
                                }
                            );
                        },
                    },
                };
            }),
            n = t.getState();
        let r = n.size,
            s = n.viewport.dpr,
            a = n.camera;
        return (
            t.subscribe(() => {
                const {
                    camera: l,
                    size: c,
                    viewport: d,
                    gl: p,
                    set: g,
                } = t.getState();
                if (
                    c.width !== r.width ||
                    c.height !== r.height ||
                    d.dpr !== s
                ) {
                    var y;
                    (r = c), (s = d.dpr), lP(l, c), p.setPixelRatio(d.dpr);
                    const v =
                        (y = c.updateStyle) != null
                            ? y
                            : typeof HTMLCanvasElement < 'u' &&
                              p.domElement instanceof HTMLCanvasElement;
                    p.setSize(c.width, c.height, v);
                }
                l !== a &&
                    ((a = l),
                    g((v) => ({
                        viewport: {
                            ...v.viewport,
                            ...v.viewport.getCurrentViewport(l),
                        },
                    })));
            }),
            t.subscribe((l) => i(l)),
            t
        );
    };
let Zg,
    N5 = new Set(),
    U5 = new Set(),
    O5 = new Set();
function Nx(i, e) {
    if (i.size) for (const { callback: t } of i.values()) t(e);
}
function zd(i, e) {
    switch (i) {
        case 'before':
            return Nx(N5, e);
        case 'after':
            return Nx(U5, e);
        case 'tail':
            return Nx(O5, e);
    }
}
let Ux, Ox;
function kx(i, e, t) {
    let n = e.clock.getDelta();
    for (
        e.frameloop === 'never' &&
            typeof i == 'number' &&
            ((n = i - e.clock.elapsedTime),
            (e.clock.oldTime = e.clock.elapsedTime),
            (e.clock.elapsedTime = i)),
            Ux = e.internal.subscribers,
            Zg = 0;
        Zg < Ux.length;
        Zg++
    )
        (Ox = Ux[Zg]), Ox.ref.current(Ox.store.getState(), n, t);
    return (
        !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera),
        (e.internal.frames = Math.max(0, e.internal.frames - 1)),
        e.frameloop === 'always' ? 1 : e.internal.frames
    );
}
function k5(i) {
    let e = !1,
        t = !1,
        n,
        r,
        s;
    function a(d) {
        (r = requestAnimationFrame(a)),
            (e = !0),
            (n = 0),
            zd('before', d),
            (t = !0);
        for (const g of i.values()) {
            var p;
            (s = g.store.getState()),
                s.internal.active &&
                    (s.frameloop === 'always' || s.internal.frames > 0) &&
                    !((p = s.gl.xr) != null && p.isPresenting) &&
                    (n += kx(d, s));
        }
        if (((t = !1), zd('after', d), n === 0))
            return zd('tail', d), (e = !1), cancelAnimationFrame(r);
    }
    function l(d, p = 1) {
        var g;
        if (!d) return i.forEach((y) => l(y.store.getState(), p));
        ((g = d.gl.xr) != null && g.isPresenting) ||
            !d.internal.active ||
            d.frameloop === 'never' ||
            (p > 1
                ? (d.internal.frames = Math.min(60, d.internal.frames + p))
                : t
                  ? (d.internal.frames = 2)
                  : (d.internal.frames = 1),
            e || ((e = !0), requestAnimationFrame(a)));
    }
    function c(d, p = !0, g, y) {
        if ((p && zd('before', d), g)) kx(d, g, y);
        else for (const v of i.values()) kx(d, v.store.getState());
        p && zd('after', d);
    }
    return { loop: a, invalidate: l, advance: c };
}
function xw() {
    const i = K.useContext(vw);
    if (!i)
        throw new Error(
            'R3F: Hooks can only be used within the Canvas component!'
        );
    return i;
}
function n8(i = (t) => t, e) {
    return xw()(i, e);
}
function i8(i, e = 0) {
    const t = xw(),
        n = t.getState().internal.subscribe,
        r = E5(i);
    return Bv(() => n(r, e, t), [e, n, t]), null;
}
const _T = new WeakMap();
function fP(i, e) {
    return function (t, ...n) {
        let r = _T.get(t);
        return (
            r || ((r = new t()), _T.set(t, r)),
            i && i(r),
            Promise.all(
                n.map(
                    (s) =>
                        new Promise((a, l) =>
                            r.load(
                                s,
                                (c) => {
                                    c.scene && Object.assign(c, C5(c.scene)),
                                        a(c);
                                },
                                e,
                                (c) =>
                                    l(
                                        new Error(
                                            `Could not load ${s}: ${c == null ? void 0 : c.message}`
                                        )
                                    )
                            )
                        )
                )
            )
        );
    };
}
function hP(i, e, t, n) {
    const r = Array.isArray(e) ? e : [e],
        s = p5(fP(t, n), [i, ...r], { equal: Ln.equ });
    return Array.isArray(e) ? s : s[0];
}
hP.preload = function (i, e, t) {
    const n = Array.isArray(e) ? e : [e];
    return m5(fP(t), [i, ...n]);
};
hP.clear = function (i, e) {
    const t = Array.isArray(e) ? e : [e];
    return g5([i, ...t]);
};
const ph = new Map(),
    { invalidate: ST, advance: wT } = k5(ph),
    { reconciler: Fp, applyProps: Ff } = M5(ph, b5),
    Bf = { objects: 'shallow', strict: !1 },
    F5 = (i, e) => {
        const t = typeof i == 'function' ? i(e) : i;
        return cP(t)
            ? t
            : new sb({
                  powerPreference: 'high-performance',
                  canvas: e,
                  antialias: !0,
                  alpha: !0,
                  ...i,
              });
    };
function B5(i, e) {
    const t = typeof HTMLCanvasElement < 'u' && i instanceof HTMLCanvasElement;
    if (e) {
        const { width: n, height: r, top: s, left: a, updateStyle: l = t } = e;
        return { width: n, height: r, top: s, left: a, updateStyle: l };
    } else if (
        typeof HTMLCanvasElement < 'u' &&
        i instanceof HTMLCanvasElement &&
        i.parentElement
    ) {
        const {
            width: n,
            height: r,
            top: s,
            left: a,
        } = i.parentElement.getBoundingClientRect();
        return { width: n, height: r, top: s, left: a, updateStyle: t };
    } else if (typeof OffscreenCanvas < 'u' && i instanceof OffscreenCanvas)
        return {
            width: i.width,
            height: i.height,
            top: 0,
            left: 0,
            updateStyle: t,
        };
    return { width: 0, height: 0, top: 0, left: 0 };
}
function r8(i) {
    const e = ph.get(i),
        t = e == null ? void 0 : e.fiber,
        n = e == null ? void 0 : e.store;
    e && console.warn('R3F.createRoot should only be called once!');
    const r = typeof reportError == 'function' ? reportError : console.error,
        s = n || D5(ST, wT),
        a =
            t ||
            Fp.createContainer(
                s,
                ih.ConcurrentRoot,
                null,
                !1,
                null,
                '',
                r,
                null
            );
    e || ph.set(i, { fiber: a, store: s });
    let l,
        c = !1,
        d;
    return {
        configure(p = {}) {
            let {
                    gl: g,
                    size: y,
                    scene: v,
                    events: S,
                    onCreated: T,
                    shadows: M = !1,
                    linear: w = !1,
                    flat: b = !1,
                    legacy: C = !1,
                    orthographic: L = !1,
                    frameloop: F = 'always',
                    dpr: N = [1, 2],
                    performance: B,
                    raycaster: z,
                    camera: U,
                    onPointerMissed: D,
                } = p,
                H = s.getState(),
                ie = H.gl;
            H.gl || H.set({ gl: (ie = F5(g, i)) });
            let ee = H.raycaster;
            ee || H.set({ raycaster: (ee = new gw()) });
            const { params: ue, ...Se } = z || {};
            if (
                (Ln.equ(Se, ee, Bf) || Ff(ee, { ...Se }),
                Ln.equ(ue, ee.params, Bf) ||
                    Ff(ee, { params: { ...ee.params, ...ue } }),
                !H.camera || (H.camera === d && !Ln.equ(d, U, Bf)))
            ) {
                d = U;
                const Q = U instanceof Kp,
                    G = Q
                        ? U
                        : L
                          ? new Qp(0, 0, 0, 0, 0.1, 1e3)
                          : new Pi(75, 0, 0.1, 1e3);
                Q ||
                    ((G.position.z = 5),
                    U &&
                        (Ff(G, U),
                        ('aspect' in U ||
                            'left' in U ||
                            'right' in U ||
                            'bottom' in U ||
                            'top' in U) &&
                            ((G.manual = !0), G.updateProjectionMatrix())),
                    !H.camera &&
                        !(U != null && U.rotation) &&
                        G.lookAt(0, 0, 0)),
                    H.set({ camera: G }),
                    (ee.camera = G);
            }
            if (!H.scene) {
                let Q;
                v != null && v.isScene
                    ? (Q = v)
                    : ((Q = new YS()), v && Ff(Q, v)),
                    H.set({ scene: Wf(Q) });
            }
            if (!H.xr) {
                var ce;
                const Q = (Oe, fe) => {
                        const we = s.getState();
                        we.frameloop !== 'never' && wT(Oe, !0, we, fe);
                    },
                    G = () => {
                        const Oe = s.getState();
                        (Oe.gl.xr.enabled = Oe.gl.xr.isPresenting),
                            Oe.gl.xr.setAnimationLoop(
                                Oe.gl.xr.isPresenting ? Q : null
                            ),
                            Oe.gl.xr.isPresenting || ST(Oe);
                    },
                    ae = {
                        connect() {
                            const Oe = s.getState().gl;
                            Oe.xr.addEventListener('sessionstart', G),
                                Oe.xr.addEventListener('sessionend', G);
                        },
                        disconnect() {
                            const Oe = s.getState().gl;
                            Oe.xr.removeEventListener('sessionstart', G),
                                Oe.xr.removeEventListener('sessionend', G);
                        },
                    };
                typeof ((ce = ie.xr) == null ? void 0 : ce.addEventListener) ==
                    'function' && ae.connect(),
                    H.set({ xr: ae });
            }
            if (ie.shadowMap) {
                const Q = ie.shadowMap.enabled,
                    G = ie.shadowMap.type;
                if (((ie.shadowMap.enabled = !!M), Ln.boo(M)))
                    ie.shadowMap.type = Zd;
                else if (Ln.str(M)) {
                    var me;
                    const ae = {
                        basic: YC,
                        percentage: av,
                        soft: Zd,
                        variance: io,
                    };
                    ie.shadowMap.type = (me = ae[M]) != null ? me : Zd;
                } else Ln.obj(M) && Object.assign(ie.shadowMap, M);
                (Q !== ie.shadowMap.enabled || G !== ie.shadowMap.type) &&
                    (ie.shadowMap.needsUpdate = !0);
            }
            const X = iP();
            X &&
                ('enabled' in X
                    ? (X.enabled = !C)
                    : 'legacyMode' in X && (X.legacyMode = C)),
                c ||
                    Ff(ie, {
                        outputEncoding: w ? 3e3 : 3001,
                        toneMapping: b ? Fo : AS,
                    }),
                H.legacy !== C && H.set(() => ({ legacy: C })),
                H.linear !== w && H.set(() => ({ linear: w })),
                H.flat !== b && H.set(() => ({ flat: b })),
                g && !Ln.fun(g) && !cP(g) && !Ln.equ(g, ie, Bf) && Ff(ie, g),
                S && !H.events.handlers && H.set({ events: S(s) });
            const oe = B5(i, y);
            return (
                Ln.equ(oe, H.size, Bf) ||
                    H.setSize(
                        oe.width,
                        oe.height,
                        oe.updateStyle,
                        oe.top,
                        oe.left
                    ),
                N && H.viewport.dpr !== oP(N) && H.setDpr(N),
                H.frameloop !== F && H.setFrameloop(F),
                H.onPointerMissed || H.set({ onPointerMissed: D }),
                B &&
                    !Ln.equ(B, H.performance, Bf) &&
                    H.set((Q) => ({ performance: { ...Q.performance, ...B } })),
                (l = T),
                (c = !0),
                this
            );
        },
        render(p) {
            return (
                c || this.configure(),
                Fp.updateContainer(
                    rt.jsx(z5, {
                        store: s,
                        children: p,
                        onCreated: l,
                        rootElement: i,
                    }),
                    a,
                    null,
                    () => {}
                ),
                s
            );
        },
        unmount() {
            V5(i);
        },
    };
}
function z5({ store: i, children: e, onCreated: t, rootElement: n }) {
    return (
        Bv(() => {
            const r = i.getState();
            r.set((s) => ({ internal: { ...s.internal, active: !0 } })),
                t && t(r),
                i.getState().events.connected ||
                    r.events.connect == null ||
                    r.events.connect(n);
        }, []),
        rt.jsx(vw.Provider, { value: i, children: e })
    );
}
function V5(i, e) {
    const t = ph.get(i),
        n = t == null ? void 0 : t.fiber;
    if (n) {
        const r = t == null ? void 0 : t.store.getState();
        r && (r.internal.active = !1),
            Fp.updateContainer(null, n, null, () => {
                r &&
                    setTimeout(() => {
                        try {
                            var s, a, l, c;
                            r.events.disconnect == null ||
                                r.events.disconnect(),
                                (s = r.gl) == null ||
                                    (a = s.renderLists) == null ||
                                    a.dispose == null ||
                                    a.dispose(),
                                (l = r.gl) == null ||
                                    l.forceContextLoss == null ||
                                    l.forceContextLoss(),
                                (c = r.gl) != null && c.xr && r.xr.disconnect(),
                                R5(r),
                                ph.delete(i);
                        } catch {}
                    }, 500);
            });
    }
}
function s8(i, e, t) {
    return rt.jsx(H5, { children: i, container: e, state: t }, e.uuid);
}
function H5({ state: i = {}, children: e, container: t }) {
    const { events: n, size: r, ...s } = i,
        a = xw(),
        [l] = K.useState(() => new gw()),
        [c] = K.useState(() => new Ce()),
        d = K.useCallback(
            (g, y) => {
                const v = { ...g };
                Object.keys(g).forEach((T) => {
                    (I5.includes(T) || (g[T] !== y[T] && y[T])) && delete v[T];
                });
                let S;
                if (y && r) {
                    const T = y.camera;
                    (S = g.viewport.getCurrentViewport(T, new j(), r)),
                        T !== g.camera && lP(T, r);
                }
                return {
                    ...v,
                    scene: t,
                    raycaster: l,
                    pointer: c,
                    mouse: c,
                    previousRoot: a,
                    events: {
                        ...g.events,
                        ...(y == null ? void 0 : y.events),
                        ...n,
                    },
                    size: { ...g.size, ...r },
                    viewport: { ...g.viewport, ...S },
                    ...s,
                };
            },
            [i]
        ),
        [p] = K.useState(() => {
            const g = a.getState();
            return Qb((v, S) => ({
                ...g,
                scene: t,
                raycaster: l,
                pointer: c,
                mouse: c,
                previousRoot: a,
                events: { ...g.events, ...n },
                size: { ...g.size, ...r },
                ...s,
                set: v,
                get: S,
                setEvents: (T) =>
                    v((M) => ({ ...M, events: { ...M.events, ...T } })),
            }));
        });
    return (
        K.useEffect(() => {
            const g = a.subscribe((y) => p.setState((v) => d(y, v)));
            return () => {
                g();
            };
        }, [d]),
        K.useEffect(() => {
            p.setState((g) => d(a.getState(), g));
        }, [d]),
        K.useEffect(
            () => () => {
                p.destroy();
            },
            []
        ),
        rt.jsx(rt.Fragment, {
            children: Fp.createPortal(
                rt.jsx(vw.Provider, { value: p, children: e }),
                p,
                null
            ),
        })
    );
}
Fp.injectIntoDevTools({
    bundleType: 0,
    rendererPackageName: '@react-three/fiber',
    version: K.version,
});
const Fx = {
    onClick: ['click', !1],
    onContextMenu: ['contextmenu', !1],
    onDoubleClick: ['dblclick', !1],
    onWheel: ['wheel', !0],
    onPointerDown: ['pointerdown', !0],
    onPointerUp: ['pointerup', !0],
    onPointerLeave: ['pointerleave', !0],
    onPointerMove: ['pointermove', !0],
    onPointerCancel: ['pointercancel', !0],
    onLostPointerCapture: ['lostpointercapture', !0],
};
function o8(i) {
    const { handlePointer: e } = L5(i);
    return {
        priority: 1,
        enabled: !0,
        compute(t, n, r) {
            n.pointer.set(
                (t.offsetX / n.size.width) * 2 - 1,
                -(t.offsetY / n.size.height) * 2 + 1
            ),
                n.raycaster.setFromCamera(n.pointer, n.camera);
        },
        connected: void 0,
        handlers: Object.keys(Fx).reduce((t, n) => ({ ...t, [n]: e(n) }), {}),
        update: () => {
            var t;
            const { events: n, internal: r } = i.getState();
            (t = r.lastEvent) != null &&
                t.current &&
                n.handlers &&
                n.handlers.onPointerMove(r.lastEvent.current);
        },
        connect: (t) => {
            var n;
            const { set: r, events: s } = i.getState();
            s.disconnect == null || s.disconnect(),
                r((a) => ({ events: { ...a.events, connected: t } })),
                Object.entries((n = s.handlers) != null ? n : []).forEach(
                    ([a, l]) => {
                        const [c, d] = Fx[a];
                        t.addEventListener(c, l, { passive: d });
                    }
                );
        },
        disconnect: () => {
            const { set: t, events: n } = i.getState();
            if (n.connected) {
                var r;
                Object.entries((r = n.handlers) != null ? r : []).forEach(
                    ([s, a]) => {
                        if (n && n.connected instanceof HTMLElement) {
                            const [l] = Fx[s];
                            n.connected.removeEventListener(l, a);
                        }
                    }
                ),
                    t((s) => ({ events: { ...s.events, connected: void 0 } }));
            }
        },
    };
}
function G5(i, e, t, n) {
    const r = class extends Ts {
        constructor(a = {}) {
            const l = Object.entries(i);
            super({
                uniforms: l.reduce((c, [d, p]) => {
                    const g = WS.clone({ [d]: { value: p } });
                    return { ...c, ...g };
                }, {}),
                vertexShader: e,
                fragmentShader: t,
            }),
                (this.key = ''),
                l.forEach(([c]) =>
                    Object.defineProperty(this, c, {
                        get: () => this.uniforms[c].value,
                        set: (d) => (this.uniforms[c].value = d),
                    })
                ),
                Object.assign(this, a);
        }
    };
    return (r.key = GR.generateUUID()), r;
}
const W5 = G5(
    {
        uTime: 0,
        uDistort: 0.3,
        uSpeed: 1,
        colorA: new st('#ff69b4'),
        colorB: new st('#0000ff'),
    },
    `
  uniform float uTime;
  uniform float uDistort;
  uniform float uSpeed;
  varying vec2 vUv;
  varying float vDistort;

  void main() {
    vUv = uv;
    vec3 newPosition = position + normal * sin(position.y * 10.0 + uTime * uSpeed) * uDistort;
    vDistort = newPosition.y;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
  }
  `,
    `
  uniform vec3 colorA;
  uniform vec3 colorB;
  varying vec2 vUv;
  varying float vDistort;

  void main() {
    float strength = smoothstep(-1.0, 1.0, vDistort);
    vec3 color = mix(colorA, colorB, strength);
    gl_FragColor = vec4(color, 1.0);
  }
  `
);
w5({ DistortGradientMaterial: W5 });
/**
 * @license lucide-react v0.509.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const X5 = (i) => i.replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase(),
    j5 = (i) =>
        i.replace(/^([A-Z])|[\s-_]+(\w)/g, (e, t, n) =>
            n ? n.toUpperCase() : t.toLowerCase()
        ),
    MT = (i) => {
        const e = j5(i);
        return e.charAt(0).toUpperCase() + e.slice(1);
    },
    dP = (...i) =>
        i
            .filter((e, t, n) => !!e && e.trim() !== '' && n.indexOf(e) === t)
            .join(' ')
            .trim(),
    q5 = (i) => {
        for (const e in i)
            if (e.startsWith('aria-') || e === 'role' || e === 'title')
                return !0;
    };
/**
 * @license lucide-react v0.509.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ var $5 = {
    xmlns: 'http://www.w3.org/2000/svg',
    width: 24,
    height: 24,
    viewBox: '0 0 24 24',
    fill: 'none',
    stroke: 'currentColor',
    strokeWidth: 2,
    strokeLinecap: 'round',
    strokeLinejoin: 'round',
};
/**
 * @license lucide-react v0.509.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const Y5 = K.forwardRef(
    (
        {
            color: i = 'currentColor',
            size: e = 24,
            strokeWidth: t = 2,
            absoluteStrokeWidth: n,
            className: r = '',
            children: s,
            iconNode: a,
            ...l
        },
        c
    ) =>
        K.createElement(
            'svg',
            {
                ref: c,
                ...$5,
                width: e,
                height: e,
                stroke: i,
                strokeWidth: n ? (Number(t) * 24) / Number(e) : t,
                className: dP('lucide', r),
                ...(!s && !q5(l) && { 'aria-hidden': 'true' }),
                ...l,
            },
            [
                ...a.map(([d, p]) => K.createElement(d, p)),
                ...(Array.isArray(s) ? s : [s]),
            ]
        )
);
/**
 * @license lucide-react v0.509.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const zv = (i, e) => {
    const t = K.forwardRef(({ className: n, ...r }, s) =>
        K.createElement(Y5, {
            ref: s,
            iconNode: e,
            className: dP(`lucide-${X5(MT(i))}`, `lucide-${i}`, n),
            ...r,
        })
    );
    return (t.displayName = MT(i)), t;
};
/**
 * @license lucide-react v0.509.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const K5 = [['path', { d: 'M20 6 9 17l-5-5', key: '1gmf2c' }]],
    Z5 = zv('check', K5);
/**
 * @license lucide-react v0.509.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const J5 = [
        ['circle', { cx: '12', cy: '12', r: '10', key: '1mglay' }],
        ['line', { x1: '12', x2: '12', y1: '8', y2: '12', key: '1pkeuh' }],
        ['line', { x1: '12', x2: '12.01', y1: '16', y2: '16', key: '4dfq90' }],
    ],
    Q5 = zv('circle-alert', J5);
/**
 * @license lucide-react v0.509.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const eG = [
        ['circle', { cx: '12', cy: '12', r: '10', key: '1mglay' }],
        ['path', { d: 'M12 16v-4', key: '1dtifu' }],
        ['path', { d: 'M12 8h.01', key: 'e9boi3' }],
    ],
    tG = zv('info', eG);
/**
 * @license lucide-react v0.509.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const nG = [
        ['path', { d: 'M18 6 6 18', key: '1bl5f8' }],
        ['path', { d: 'm6 6 12 12', key: 'd8bk6v' }],
    ],
    iG = zv('x', nG),
    jf = '0.22.0';
let ET = !1,
    ap,
    pP,
    mP,
    b_,
    gP,
    yP,
    vP,
    xP,
    _P;
function rG(i, e = { auto: !1 }) {
    if (ET)
        throw new Error(
            `you must \`import 'groq-sdk/shims/${i.kind}'\` before importing anything else from groq-sdk`
        );
    if (ap)
        throw new Error(
            `can't \`import 'groq-sdk/shims/${i.kind}'\` after \`import 'groq-sdk/shims/${ap}'\``
        );
    (ET = e.auto),
        (ap = i.kind),
        (pP = i.fetch),
        (mP = i.FormData),
        (b_ = i.File),
        (gP = i.ReadableStream),
        (yP = i.getMultipartRequestOptions),
        (vP = i.getDefaultAgent),
        (xP = i.fileFromPath),
        (_P = i.isFsReadStream);
}
class sG {
    constructor(e) {
        this.body = e;
    }
    get [Symbol.toStringTag]() {
        return 'MultipartBody';
    }
}
function oG({ manuallyImported: i } = {}) {
    const e = i
        ? 'You may need to use polyfills'
        : "Add one of these imports before your first `import … from 'groq-sdk'`:\n- `import 'groq-sdk/shims/node'` (if you're running on Node)\n- `import 'groq-sdk/shims/web'` (otherwise)\n";
    let t, n, r, s;
    try {
        (t = fetch), (n = Request), (r = Response), (s = Headers);
    } catch (a) {
        throw new Error(
            `this environment is missing the following Web Fetch API type: ${a.message}. ${e}`
        );
    }
    return {
        kind: 'web',
        fetch: t,
        Request: n,
        Response: r,
        Headers: s,
        FormData:
            typeof FormData < 'u'
                ? FormData
                : class {
                      constructor() {
                          throw new Error(
                              `file uploads aren't supported in this environment yet as 'FormData' is undefined. ${e}`
                          );
                      }
                  },
        Blob:
            typeof Blob < 'u'
                ? Blob
                : class {
                      constructor() {
                          throw new Error(
                              `file uploads aren't supported in this environment yet as 'Blob' is undefined. ${e}`
                          );
                      }
                  },
        File:
            typeof File < 'u'
                ? File
                : class {
                      constructor() {
                          throw new Error(
                              `file uploads aren't supported in this environment yet as 'File' is undefined. ${e}`
                          );
                      }
                  },
        ReadableStream:
            typeof ReadableStream < 'u'
                ? ReadableStream
                : class {
                      constructor() {
                          throw new Error(
                              `streaming isn't supported in this environment yet as 'ReadableStream' is undefined. ${e}`
                          );
                      }
                  },
        getMultipartRequestOptions: async (a, l) => ({ ...l, body: new sG(a) }),
        getDefaultAgent: (a) => {},
        fileFromPath: () => {
            throw new Error(
                'The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/groq/groq-typescript#file-uploads'
            );
        },
        isFsReadStream: (a) => !1,
    };
}
const SP = () => {
    ap || rG(oG(), { auto: !0 });
};
SP();
class so extends Error {}
class ar extends so {
    constructor(e, t, n, r) {
        super(`${ar.makeMessage(e, t, n)}`),
            (this.status = e),
            (this.headers = r),
            (this.error = t);
    }
    static makeMessage(e, t, n) {
        const r =
            t != null && t.message
                ? typeof t.message == 'string'
                    ? t.message
                    : JSON.stringify(t.message)
                : t
                  ? JSON.stringify(t)
                  : n;
        return e && r
            ? `${e} ${r}`
            : e
              ? `${e} status code (no body)`
              : r || '(no status code or body)';
    }
    static generate(e, t, n, r) {
        if (!e || !r) return new Vv({ message: n, cause: I_(t) });
        const s = t;
        return e === 400
            ? new MP(e, s, n, r)
            : e === 401
              ? new EP(e, s, n, r)
              : e === 403
                ? new TP(e, s, n, r)
                : e === 404
                  ? new AP(e, s, n, r)
                  : e === 409
                    ? new CP(e, s, n, r)
                    : e === 422
                      ? new RP(e, s, n, r)
                      : e === 429
                        ? new bP(e, s, n, r)
                        : e >= 500
                          ? new PP(e, s, n, r)
                          : new ar(e, s, n, r);
    }
}
class P_ extends ar {
    constructor({ message: e } = {}) {
        super(void 0, void 0, e || 'Request was aborted.', void 0);
    }
}
class Vv extends ar {
    constructor({ message: e, cause: t }) {
        super(void 0, void 0, e || 'Connection error.', void 0),
            t && (this.cause = t);
    }
}
class wP extends Vv {
    constructor({ message: e } = {}) {
        super({ message: e ?? 'Request timed out.' });
    }
}
class MP extends ar {}
class EP extends ar {}
class TP extends ar {}
class AP extends ar {}
class CP extends ar {}
class RP extends ar {}
class bP extends ar {}
class PP extends ar {}
class rh {
    constructor(e, t) {
        (this.iterator = e), (this.controller = t);
    }
    static fromSSEResponse(e, t) {
        let n = !1;
        const r = new aG();
        async function* s() {
            if (!e.body)
                throw (
                    (t.abort(),
                    new so('Attempted to iterate over a response with no body'))
                );
            const l = new fc(),
                c = TT(e.body);
            for await (const d of c)
                for (const p of l.decode(d)) {
                    const g = r.decode(p);
                    g && (yield g);
                }
            for (const d of l.flush()) {
                const p = r.decode(d);
                p && (yield p);
            }
        }
        async function* a() {
            if (n)
                throw new Error(
                    'Cannot iterate over a consumed stream, use `.tee()` to split the stream.'
                );
            n = !0;
            let l = !1;
            try {
                for await (const c of s())
                    if (!l) {
                        if (c.data.startsWith('[DONE]')) {
                            l = !0;
                            continue;
                        }
                        if (c.event === null || c.event === 'error') {
                            let d;
                            try {
                                d = JSON.parse(c.data);
                            } catch (p) {
                                throw (
                                    (console.error(
                                        'Could not parse message into JSON:',
                                        c.data
                                    ),
                                    console.error('From chunk:', c.raw),
                                    p)
                                );
                            }
                            if (d && d.error)
                                throw new ar(
                                    d.error.status_code,
                                    d.error,
                                    d.error.message,
                                    void 0
                                );
                            yield d;
                        }
                    }
                l = !0;
            } catch (c) {
                if (c instanceof Error && c.name === 'AbortError') return;
                throw c;
            } finally {
                l || t.abort();
            }
        }
        return new rh(a, t);
    }
    static fromReadableStream(e, t) {
        let n = !1;
        async function* r() {
            const a = new fc(),
                l = TT(e);
            for await (const c of l) for (const d of a.decode(c)) yield d;
            for (const c of a.flush()) yield c;
        }
        async function* s() {
            if (n)
                throw new Error(
                    'Cannot iterate over a consumed stream, use `.tee()` to split the stream.'
                );
            n = !0;
            let a = !1;
            try {
                for await (const l of r()) a || (l && (yield JSON.parse(l)));
                a = !0;
            } catch (l) {
                if (l instanceof Error && l.name === 'AbortError') return;
                throw l;
            } finally {
                a || t.abort();
            }
        }
        return new rh(s, t);
    }
    [Symbol.asyncIterator]() {
        return this.iterator();
    }
    tee() {
        const e = [],
            t = [],
            n = this.iterator(),
            r = (s) => ({
                next: () => {
                    if (s.length === 0) {
                        const a = n.next();
                        e.push(a), t.push(a);
                    }
                    return s.shift();
                },
            });
        return [
            new rh(() => r(e), this.controller),
            new rh(() => r(t), this.controller),
        ];
    }
    toReadableStream() {
        const e = this;
        let t;
        const n = new TextEncoder();
        return new gP({
            async start() {
                t = e[Symbol.asyncIterator]();
            },
            async pull(r) {
                try {
                    const { value: s, done: a } = await t.next();
                    if (a) return r.close();
                    const l = n.encode(
                        JSON.stringify(s) +
                            `
`
                    );
                    r.enqueue(l);
                } catch (s) {
                    r.error(s);
                }
            },
            async cancel() {
                var r;
                await ((r = t.return) == null ? void 0 : r.call(t));
            },
        });
    }
}
class aG {
    constructor() {
        (this.event = null), (this.data = []), (this.chunks = []);
    }
    decode(e) {
        if ((e.endsWith('\r') && (e = e.substring(0, e.length - 1)), !e)) {
            if (!this.event && !this.data.length) return null;
            const s = {
                event: this.event,
                data: this.data.join(`
`),
                raw: this.chunks,
            };
            return (this.event = null), (this.data = []), (this.chunks = []), s;
        }
        if ((this.chunks.push(e), e.startsWith(':'))) return null;
        let [t, n, r] = lG(e, ':');
        return (
            r.startsWith(' ') && (r = r.substring(1)),
            t === 'event'
                ? (this.event = r)
                : t === 'data' && this.data.push(r),
            null
        );
    }
}
class fc {
    constructor() {
        (this.buffer = []), (this.trailingCR = !1);
    }
    decode(e) {
        let t = this.decodeText(e);
        if (
            (this.trailingCR && ((t = '\r' + t), (this.trailingCR = !1)),
            t.endsWith('\r') && ((this.trailingCR = !0), (t = t.slice(0, -1))),
            !t)
        )
            return [];
        const n = fc.NEWLINE_CHARS.has(t[t.length - 1] || '');
        let r = t.split(fc.NEWLINE_REGEXP);
        return r.length === 1 && !n
            ? (this.buffer.push(r[0]), [])
            : (this.buffer.length > 0 &&
                  ((r = [this.buffer.join('') + r[0], ...r.slice(1)]),
                  (this.buffer = [])),
              n || (this.buffer = [r.pop() || '']),
              r);
    }
    decodeText(e) {
        if (e == null) return '';
        if (typeof e == 'string') return e;
        if (typeof Buffer < 'u') {
            if (e instanceof Buffer) return e.toString();
            if (e instanceof Uint8Array) return Buffer.from(e).toString();
            throw new so(
                `Unexpected: received non-Uint8Array (${e.constructor.name}) stream chunk in an environment with a global "Buffer" defined, which this library assumes to be Node. Please report this error.`
            );
        }
        if (typeof TextDecoder < 'u') {
            if (e instanceof Uint8Array || e instanceof ArrayBuffer)
                return (
                    this.textDecoder ??
                        (this.textDecoder = new TextDecoder('utf8')),
                    this.textDecoder.decode(e)
                );
            throw new so(
                `Unexpected: received non-Uint8Array/ArrayBuffer (${e.constructor.name}) in a web platform. Please report this error.`
            );
        }
        throw new so(
            'Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.'
        );
    }
    flush() {
        if (!this.buffer.length && !this.trailingCR) return [];
        const e = [this.buffer.join('')];
        return (this.buffer = []), (this.trailingCR = !1), e;
    }
}
fc.NEWLINE_CHARS = new Set([
    `
`,
    '\r',
    '\v',
    '\f',
    '',
    '',
    '',
    '',
    '\u2028',
    '\u2029',
]);
fc.NEWLINE_REGEXP = /\r\n|[\n\r\x0b\x0c\x1c\x1d\x1e\x85\u2028\u2029]/g;
function lG(i, e) {
    const t = i.indexOf(e);
    return t !== -1
        ? [i.substring(0, t), e, i.substring(t + e.length)]
        : [i, '', ''];
}
function TT(i) {
    if (i[Symbol.asyncIterator]) return i;
    const e = i.getReader();
    return {
        async next() {
            try {
                const t = await e.read();
                return t != null && t.done && e.releaseLock(), t;
            } catch (t) {
                throw (e.releaseLock(), t);
            }
        },
        async return() {
            const t = e.cancel();
            return e.releaseLock(), await t, { done: !0, value: void 0 };
        },
        [Symbol.asyncIterator]() {
            return this;
        },
    };
}
const LP = (i) =>
        i != null &&
        typeof i == 'object' &&
        typeof i.url == 'string' &&
        typeof i.blob == 'function',
    IP = (i) =>
        i != null &&
        typeof i == 'object' &&
        typeof i.name == 'string' &&
        typeof i.lastModified == 'number' &&
        Hv(i),
    Hv = (i) =>
        i != null &&
        typeof i == 'object' &&
        typeof i.size == 'number' &&
        typeof i.type == 'string' &&
        typeof i.text == 'function' &&
        typeof i.slice == 'function' &&
        typeof i.arrayBuffer == 'function',
    uG = (i) => IP(i) || LP(i) || _P(i);
async function DP(i, e, t) {
    var r;
    if (((i = await i), IP(i))) return i;
    if (LP(i)) {
        const s = await i.blob();
        e ||
            (e =
                new URL(i.url).pathname.split(/[\\/]/).pop() ?? 'unknown_file');
        const a = Hv(s) ? [await s.arrayBuffer()] : [s];
        return new b_(a, e, t);
    }
    const n = await cG(i);
    if ((e || (e = hG(i) ?? 'unknown_file'), !(t != null && t.type))) {
        const s = (r = n[0]) == null ? void 0 : r.type;
        typeof s == 'string' && (t = { ...t, type: s });
    }
    return new b_(n, e, t);
}
async function cG(i) {
    var t;
    let e = [];
    if (
        typeof i == 'string' ||
        ArrayBuffer.isView(i) ||
        i instanceof ArrayBuffer
    )
        e.push(i);
    else if (Hv(i)) e.push(await i.arrayBuffer());
    else if (dG(i)) for await (const n of i) e.push(n);
    else
        throw new Error(
            `Unexpected data type: ${typeof i}; constructor: ${(t = i == null ? void 0 : i.constructor) == null ? void 0 : t.name}; props: ${fG(i)}`
        );
    return e;
}
function fG(i) {
    return `[${Object.getOwnPropertyNames(i)
        .map((t) => `"${t}"`)
        .join(', ')}]`;
}
function hG(i) {
    var e;
    return (
        Bx(i.name) ||
        Bx(i.filename) ||
        ((e = Bx(i.path)) == null ? void 0 : e.split(/[\\/]/).pop())
    );
}
const Bx = (i) => {
        if (typeof i == 'string') return i;
        if (typeof Buffer < 'u' && i instanceof Buffer) return String(i);
    },
    dG = (i) =>
        i != null &&
        typeof i == 'object' &&
        typeof i[Symbol.asyncIterator] == 'function',
    AT = (i) =>
        i &&
        typeof i == 'object' &&
        i.body &&
        i[Symbol.toStringTag] === 'MultipartBody',
    _w = async (i) => {
        const e = await pG(i.body);
        return yP(e, i);
    },
    pG = async (i) => {
        const e = new mP();
        return (
            await Promise.all(
                Object.entries(i || {}).map(([t, n]) => L_(e, t, n))
            ),
            e
        );
    },
    L_ = async (i, e, t) => {
        if (t !== void 0) {
            if (t == null)
                throw new TypeError(
                    `Received null for "${e}"; to pass null in FormData, you must use the string 'null'`
                );
            if (
                typeof t == 'string' ||
                typeof t == 'number' ||
                typeof t == 'boolean'
            )
                i.append(e, String(t));
            else if (uG(t)) {
                const n = await DP(t);
                i.append(e, n);
            } else if (Array.isArray(t))
                await Promise.all(t.map((n) => L_(i, e + '[]', n)));
            else if (typeof t == 'object')
                await Promise.all(
                    Object.entries(t).map(([n, r]) => L_(i, `${e}[${n}]`, r))
                );
            else
                throw new TypeError(
                    `Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${t} instead`
                );
        }
    };
var oh = {};
SP();
async function NP(i) {
    var a;
    const { response: e } = i;
    if (i.options.stream)
        return (
            ah('response', e.status, e.url, e.headers, e.body),
            i.options.__streamClass
                ? i.options.__streamClass.fromSSEResponse(e, i.controller)
                : rh.fromSSEResponse(e, i.controller)
        );
    if (e.status === 204) return null;
    if (i.options.__binaryResponse) return e;
    const t = e.headers.get('content-type'),
        n =
            (a = t == null ? void 0 : t.split(';')[0]) == null
                ? void 0
                : a.trim();
    if (
        (n == null ? void 0 : n.includes('application/json')) ||
        (n == null ? void 0 : n.endsWith('+json'))
    ) {
        const l = await e.json();
        return ah('response', e.status, e.url, e.headers, l), l;
    }
    const s = await e.text();
    return ah('response', e.status, e.url, e.headers, s), s;
}
class Gv extends Promise {
    constructor(e, t = NP) {
        super((n) => {
            n(null);
        }),
            (this.responsePromise = e),
            (this.parseResponse = t);
    }
    _thenUnwrap(e) {
        return new Gv(this.responsePromise, async (t) =>
            e(await this.parseResponse(t), t)
        );
    }
    asResponse() {
        return this.responsePromise.then((e) => e.response);
    }
    async withResponse() {
        const [e, t] = await Promise.all([this.parse(), this.asResponse()]);
        return { data: e, response: t };
    }
    parse() {
        return (
            this.parsedPromise ||
                (this.parsedPromise = this.responsePromise.then(
                    this.parseResponse
                )),
            this.parsedPromise
        );
    }
    then(e, t) {
        return this.parse().then(e, t);
    }
    catch(e) {
        return this.parse().catch(e);
    }
    finally(e) {
        return this.parse().finally(e);
    }
}
class mG {
    constructor({
        baseURL: e,
        maxRetries: t = 2,
        timeout: n = 6e4,
        httpAgent: r,
        fetch: s,
    }) {
        (this.baseURL = e),
            (this.maxRetries = zx('maxRetries', t)),
            (this.timeout = zx('timeout', n)),
            (this.httpAgent = r),
            (this.fetch = s ?? pP);
    }
    authHeaders(e) {
        return {};
    }
    defaultHeaders(e) {
        return {
            Accept: 'application/json',
            'Content-Type': 'application/json',
            'User-Agent': this.getUserAgent(),
            ..._G(),
            ...this.authHeaders(e),
        };
    }
    validateHeaders(e, t) {}
    defaultIdempotencyKey() {
        return `stainless-node-retry-${CG()}`;
    }
    get(e, t) {
        return this.methodRequest('get', e, t);
    }
    post(e, t) {
        return this.methodRequest('post', e, t);
    }
    patch(e, t) {
        return this.methodRequest('patch', e, t);
    }
    put(e, t) {
        return this.methodRequest('put', e, t);
    }
    delete(e, t) {
        return this.methodRequest('delete', e, t);
    }
    methodRequest(e, t, n) {
        return this.request(
            Promise.resolve(n).then(async (r) => {
                const s =
                    r && Hv(r == null ? void 0 : r.body)
                        ? new DataView(await r.body.arrayBuffer())
                        : (r == null ? void 0 : r.body) instanceof DataView
                          ? r.body
                          : (r == null ? void 0 : r.body) instanceof ArrayBuffer
                            ? new DataView(r.body)
                            : r &&
                                ArrayBuffer.isView(r == null ? void 0 : r.body)
                              ? new DataView(r.body.buffer)
                              : r == null
                                ? void 0
                                : r.body;
                return { method: e, path: t, ...r, body: s };
            })
        );
    }
    getAPIList(e, t, n) {
        return this.requestAPIList(t, { method: 'get', path: e, ...n });
    }
    calculateContentLength(e) {
        if (typeof e == 'string') {
            if (typeof Buffer < 'u')
                return Buffer.byteLength(e, 'utf8').toString();
            if (typeof TextEncoder < 'u')
                return new TextEncoder().encode(e).length.toString();
        } else if (ArrayBuffer.isView(e)) return e.byteLength.toString();
        return null;
    }
    buildRequest(e, { retryCount: t = 0 } = {}) {
        var T;
        const n = { ...e },
            { method: r, path: s, query: a, headers: l = {} } = n,
            c =
                ArrayBuffer.isView(n.body) ||
                (n.__binaryRequest && typeof n.body == 'string')
                    ? n.body
                    : AT(n.body)
                      ? n.body.body
                      : n.body
                        ? JSON.stringify(n.body, null, 2)
                        : null,
            d = this.calculateContentLength(c),
            p = this.buildURL(s, a);
        'timeout' in n && zx('timeout', n.timeout),
            (n.timeout = n.timeout ?? this.timeout);
        const g = n.httpAgent ?? this.httpAgent ?? vP(p),
            y = n.timeout + 1e3;
        typeof ((T = g == null ? void 0 : g.options) == null
            ? void 0
            : T.timeout) == 'number' &&
            y > (g.options.timeout ?? 0) &&
            (g.options.timeout = y),
            this.idempotencyHeader &&
                r !== 'get' &&
                (e.idempotencyKey ||
                    (e.idempotencyKey = this.defaultIdempotencyKey()),
                (l[this.idempotencyHeader] = e.idempotencyKey));
        const v = this.buildHeaders({
            options: n,
            headers: l,
            contentLength: d,
            retryCount: t,
        });
        return {
            req: {
                method: r,
                ...(c && { body: c }),
                headers: v,
                ...(g && { agent: g }),
                signal: n.signal ?? null,
            },
            url: p,
            timeout: n.timeout,
        };
    }
    buildHeaders({ options: e, headers: t, contentLength: n, retryCount: r }) {
        const s = {};
        n && (s['content-length'] = n);
        const a = this.defaultHeaders(e);
        return (
            LT(s, a),
            LT(s, t),
            AT(e.body) && ap !== 'node' && delete s['content-type'],
            Jg(a, 'x-stainless-retry-count') === void 0 &&
                Jg(t, 'x-stainless-retry-count') === void 0 &&
                (s['x-stainless-retry-count'] = String(r)),
            Jg(a, 'x-stainless-timeout') === void 0 &&
                Jg(t, 'x-stainless-timeout') === void 0 &&
                e.timeout &&
                (s['x-stainless-timeout'] = String(
                    Math.trunc(e.timeout / 1e3)
                )),
            this.validateHeaders(s, t),
            s
        );
    }
    async prepareOptions(e) {}
    async prepareRequest(e, { url: t, options: n }) {}
    parseHeaders(e) {
        return e
            ? Symbol.iterator in e
                ? Object.fromEntries(Array.from(e).map((t) => [...t]))
                : { ...e }
            : {};
    }
    makeStatusError(e, t, n, r) {
        return ar.generate(e, t, n, r);
    }
    request(e, t = null) {
        return new Gv(this.makeRequest(e, t));
    }
    async makeRequest(e, t) {
        var g, y;
        const n = await e,
            r = n.maxRetries ?? this.maxRetries;
        t == null && (t = r), await this.prepareOptions(n);
        const {
            req: s,
            url: a,
            timeout: l,
        } = this.buildRequest(n, { retryCount: r - t });
        if (
            (await this.prepareRequest(s, { url: a, options: n }),
            ah('request', a, n, s.headers),
            (g = n.signal) != null && g.aborted)
        )
            throw new P_();
        const c = new AbortController(),
            d = await this.fetchWithTimeout(a, s, l, c).catch(I_);
        if (d instanceof Error) {
            if ((y = n.signal) != null && y.aborted) throw new P_();
            if (t) return this.retryRequest(n, t);
            throw d.name === 'AbortError' ? new wP() : new Vv({ cause: d });
        }
        const p = yG(d.headers);
        if (!d.ok) {
            if (t && this.shouldRetry(d)) {
                const b = `retrying, ${t} attempts remaining`;
                return (
                    ah(`response (error; ${b})`, d.status, a, p),
                    this.retryRequest(n, t, p)
                );
            }
            const v = await d.text().catch((b) => I_(b).message),
                S = SG(v),
                T = S ? void 0 : v;
            throw (
                (ah(
                    `response (error; ${t ? '(error; no more retries left)' : '(error; not retryable)'})`,
                    d.status,
                    a,
                    p,
                    T
                ),
                this.makeStatusError(d.status, S, T, p))
            );
        }
        return { response: d, options: n, controller: c };
    }
    requestAPIList(e, t) {
        const n = this.makeRequest(t, null);
        return new gG(this, n, e);
    }
    buildURL(e, t) {
        const n = MG(e)
                ? new URL(e)
                : new URL(
                      this.baseURL +
                          (this.baseURL.endsWith('/') && e.startsWith('/')
                              ? e.slice(1)
                              : e)
                  ),
            r = this.defaultQuery();
        return (
            TG(r) || (t = { ...r, ...t }),
            typeof t == 'object' &&
                t &&
                !Array.isArray(t) &&
                (n.search = this.stringifyQuery(t)),
            n.toString()
        );
    }
    stringifyQuery(e) {
        return Object.entries(e)
            .filter(([t, n]) => typeof n < 'u')
            .map(([t, n]) => {
                if (
                    typeof n == 'string' ||
                    typeof n == 'number' ||
                    typeof n == 'boolean'
                )
                    return `${encodeURIComponent(t)}=${encodeURIComponent(n)}`;
                if (n === null) return `${encodeURIComponent(t)}=`;
                throw new so(
                    `Cannot stringify type ${typeof n}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`
                );
            })
            .join('&');
    }
    async fetchWithTimeout(e, t, n, r) {
        const { signal: s, ...a } = t || {};
        s && s.addEventListener('abort', () => r.abort());
        const l = setTimeout(() => r.abort(), n),
            c = { signal: r.signal, ...a };
        return (
            c.method && (c.method = c.method.toUpperCase()),
            this.fetch.call(void 0, e, c).finally(() => {
                clearTimeout(l);
            })
        );
    }
    shouldRetry(e) {
        const t = e.headers.get('x-should-retry');
        return t === 'true'
            ? !0
            : t === 'false'
              ? !1
              : e.status === 408 ||
                e.status === 409 ||
                e.status === 429 ||
                e.status >= 500;
    }
    async retryRequest(e, t, n) {
        let r;
        const s = n == null ? void 0 : n['retry-after-ms'];
        if (s) {
            const l = parseFloat(s);
            Number.isNaN(l) || (r = l);
        }
        const a = n == null ? void 0 : n['retry-after'];
        if (a && !r) {
            const l = parseFloat(a);
            Number.isNaN(l) ? (r = Date.parse(a) - Date.now()) : (r = l * 1e3);
        }
        if (!(r && 0 <= r && r < 60 * 1e3)) {
            const l = e.maxRetries ?? this.maxRetries;
            r = this.calculateDefaultRetryTimeoutMillis(t, l);
        }
        return await EG(r), this.makeRequest(e, t - 1);
    }
    calculateDefaultRetryTimeoutMillis(e, t) {
        const s = t - e,
            a = Math.min(0.5 * Math.pow(2, s), 8),
            l = 1 - Math.random() * 0.25;
        return a * l * 1e3;
    }
    getUserAgent() {
        return `${this.constructor.name}/JS ${jf}`;
    }
}
class gG extends Gv {
    constructor(e, t, n) {
        super(t, async (r) => new n(e, r.response, await NP(r), r.options));
    }
    async *[Symbol.asyncIterator]() {
        const e = await this;
        for await (const t of e) yield t;
    }
}
const yG = (i) =>
        new Proxy(Object.fromEntries(i.entries()), {
            get(e, t) {
                const n = t.toString();
                return e[n.toLowerCase()] || e[n];
            },
        }),
    vG = () => {
        var e;
        if (typeof Deno < 'u' && Deno.build != null)
            return {
                'X-Stainless-Lang': 'js',
                'X-Stainless-Package-Version': jf,
                'X-Stainless-OS': RT(Deno.build.os),
                'X-Stainless-Arch': CT(Deno.build.arch),
                'X-Stainless-Runtime': 'deno',
                'X-Stainless-Runtime-Version':
                    typeof Deno.version == 'string'
                        ? Deno.version
                        : (((e = Deno.version) == null ? void 0 : e.deno) ??
                          'unknown'),
            };
        if (typeof EdgeRuntime < 'u')
            return {
                'X-Stainless-Lang': 'js',
                'X-Stainless-Package-Version': jf,
                'X-Stainless-OS': 'Unknown',
                'X-Stainless-Arch': `other:${EdgeRuntime}`,
                'X-Stainless-Runtime': 'edge',
                'X-Stainless-Runtime-Version': process.version,
            };
        if (
            Object.prototype.toString.call(
                typeof process < 'u' ? process : 0
            ) === '[object process]'
        )
            return {
                'X-Stainless-Lang': 'js',
                'X-Stainless-Package-Version': jf,
                'X-Stainless-OS': RT(process.platform),
                'X-Stainless-Arch': CT(process.arch),
                'X-Stainless-Runtime': 'node',
                'X-Stainless-Runtime-Version': process.version,
            };
        const i = xG();
        return i
            ? {
                  'X-Stainless-Lang': 'js',
                  'X-Stainless-Package-Version': jf,
                  'X-Stainless-OS': 'Unknown',
                  'X-Stainless-Arch': 'unknown',
                  'X-Stainless-Runtime': `browser:${i.browser}`,
                  'X-Stainless-Runtime-Version': i.version,
              }
            : {
                  'X-Stainless-Lang': 'js',
                  'X-Stainless-Package-Version': jf,
                  'X-Stainless-OS': 'Unknown',
                  'X-Stainless-Arch': 'unknown',
                  'X-Stainless-Runtime': 'unknown',
                  'X-Stainless-Runtime-Version': 'unknown',
              };
    };
function xG() {
    if (typeof navigator > 'u' || !navigator) return null;
    const i = [
        { key: 'edge', pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
        { key: 'ie', pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
        { key: 'ie', pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
        { key: 'chrome', pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
        { key: 'firefox', pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
        {
            key: 'safari',
            pattern:
                /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/,
        },
    ];
    for (const { key: e, pattern: t } of i) {
        const n = t.exec(navigator.userAgent);
        if (n) {
            const r = n[1] || 0,
                s = n[2] || 0,
                a = n[3] || 0;
            return { browser: e, version: `${r}.${s}.${a}` };
        }
    }
    return null;
}
const CT = (i) =>
        i === 'x32'
            ? 'x32'
            : i === 'x86_64' || i === 'x64'
              ? 'x64'
              : i === 'arm'
                ? 'arm'
                : i === 'aarch64' || i === 'arm64'
                  ? 'arm64'
                  : i
                    ? `other:${i}`
                    : 'unknown',
    RT = (i) => (
        (i = i.toLowerCase()),
        i.includes('ios')
            ? 'iOS'
            : i === 'android'
              ? 'Android'
              : i === 'darwin'
                ? 'MacOS'
                : i === 'win32'
                  ? 'Windows'
                  : i === 'freebsd'
                    ? 'FreeBSD'
                    : i === 'openbsd'
                      ? 'OpenBSD'
                      : i === 'linux'
                        ? 'Linux'
                        : i
                          ? `Other:${i}`
                          : 'Unknown'
    );
let bT;
const _G = () => bT ?? (bT = vG()),
    SG = (i) => {
        try {
            return JSON.parse(i);
        } catch {
            return;
        }
    },
    wG = /^[a-z][a-z0-9+.-]*:/i,
    MG = (i) => wG.test(i),
    EG = (i) => new Promise((e) => setTimeout(e, i)),
    zx = (i, e) => {
        if (typeof e != 'number' || !Number.isInteger(e))
            throw new so(`${i} must be an integer`);
        if (e < 0) throw new so(`${i} must be a positive integer`);
        return e;
    },
    I_ = (i) => {
        if (i instanceof Error) return i;
        if (typeof i == 'object' && i !== null)
            try {
                return new Error(JSON.stringify(i));
            } catch {}
        return new Error(i);
    },
    PT = (i) => {
        var e, t, n, r;
        if (typeof process < 'u')
            return (
                ((e = oh == null ? void 0 : oh[i]) == null
                    ? void 0
                    : e.trim()) ?? void 0
            );
        if (typeof Deno < 'u')
            return (r =
                (n = (t = Deno.env) == null ? void 0 : t.get) == null
                    ? void 0
                    : n.call(t, i)) == null
                ? void 0
                : r.trim();
    };
function TG(i) {
    if (!i) return !0;
    for (const e in i) return !1;
    return !0;
}
function AG(i, e) {
    return Object.prototype.hasOwnProperty.call(i, e);
}
function LT(i, e) {
    for (const t in e) {
        if (!AG(e, t)) continue;
        const n = t.toLowerCase();
        if (!n) continue;
        const r = e[t];
        r === null ? delete i[n] : r !== void 0 && (i[n] = r);
    }
}
function ah(i, ...e) {
    typeof process < 'u' &&
        (oh == null ? void 0 : oh.DEBUG) === 'true' &&
        console.log(`Groq:DEBUG:${i}`, ...e);
}
const CG = () =>
        'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (i) => {
            const e = (Math.random() * 16) | 0;
            return (i === 'x' ? e : (e & 3) | 8).toString(16);
        }),
    RG = () =>
        typeof window < 'u' &&
        typeof window.document < 'u' &&
        typeof navigator < 'u',
    bG = (i) => typeof (i == null ? void 0 : i.get) == 'function',
    Jg = (i, e) => {
        var n;
        const t = e.toLowerCase();
        if (bG(i)) {
            const r =
                ((n = e[0]) == null ? void 0 : n.toUpperCase()) +
                e
                    .substring(1)
                    .replace(/([^\w])(\w)/g, (s, a, l) => a + l.toUpperCase());
            for (const s of [e, t, e.toUpperCase(), r]) {
                const a = i.get(s);
                if (a) return a;
            }
        }
        for (const [r, s] of Object.entries(i))
            if (r.toLowerCase() === t)
                return Array.isArray(s)
                    ? (s.length <= 1 ||
                          console.warn(
                              `Received ${s.length} entries for the ${e} header, using the first entry.`
                          ),
                      s[0])
                    : s;
    };
class po {
    constructor(e) {
        this._client = e;
    }
}
class UP extends po {
    create(e, t) {
        return this._client.post('/openai/v1/audio/speech', {
            body: e,
            ...t,
            headers: {
                Accept: 'audio/wav',
                ...(t == null ? void 0 : t.headers),
            },
            __binaryResponse: !0,
        });
    }
}
class OP extends po {
    create(e, t) {
        return this._client.post(
            '/openai/v1/audio/transcriptions',
            _w({ body: e, ...t })
        );
    }
}
class kP extends po {
    create(e, t) {
        return this._client.post(
            '/openai/v1/audio/translations',
            _w({ body: e, ...t })
        );
    }
}
let sm = class extends po {
    constructor() {
        super(...arguments),
            (this.speech = new UP(this._client)),
            (this.transcriptions = new OP(this._client)),
            (this.translations = new kP(this._client));
    }
};
sm.Speech = UP;
sm.Transcriptions = OP;
sm.Translations = kP;
class FP extends po {
    create(e, t) {
        return this._client.post('/openai/v1/batches', { body: e, ...t });
    }
    retrieve(e, t) {
        return this._client.get(`/openai/v1/batches/${e}`, t);
    }
    list(e) {
        return this._client.get('/openai/v1/batches', e);
    }
    cancel(e, t) {
        return this._client.post(`/openai/v1/batches/${e}/cancel`, t);
    }
}
let BP = class extends po {
    create(e, t) {
        return this._client.post('/openai/v1/chat/completions', {
            body: e,
            ...t,
            stream: e.stream ?? !1,
        });
    }
};
class Sw extends po {
    constructor() {
        super(...arguments), (this.completions = new BP(this._client));
    }
}
Sw.Completions = BP;
class zP extends po {}
class VP extends po {
    create(e, t) {
        return this._client.post('/openai/v1/embeddings', { body: e, ...t });
    }
}
class HP extends po {
    create(e, t) {
        return this._client.post('/openai/v1/files', _w({ body: e, ...t }));
    }
    list(e) {
        return this._client.get('/openai/v1/files', e);
    }
    delete(e, t) {
        return this._client.delete(`/openai/v1/files/${e}`, t);
    }
    content(e, t) {
        return this._client.get(`/openai/v1/files/${e}/content`, {
            ...t,
            headers: {
                Accept: 'application/octet-stream',
                ...(t == null ? void 0 : t.headers),
            },
            __binaryResponse: !0,
        });
    }
    info(e, t) {
        return this._client.get(`/openai/v1/files/${e}`, t);
    }
}
class GP extends po {
    retrieve(e, t) {
        return this._client.get(`/openai/v1/models/${e}`, t);
    }
    list(e) {
        return this._client.get('/openai/v1/models', e);
    }
    delete(e, t) {
        return this._client.delete(`/openai/v1/models/${e}`, t);
    }
}
var WP;
class In extends mG {
    constructor({
        baseURL: e = PT('GROQ_BASE_URL'),
        apiKey: t = PT('GROQ_API_KEY'),
        ...n
    } = {}) {
        if (t === void 0)
            throw new so(
                "The GROQ_API_KEY environment variable is missing or empty; either provide it, or instantiate the Groq client with an apiKey option, like new Groq({ apiKey: 'My API Key' })."
            );
        const r = { apiKey: t, ...n, baseURL: e || 'https://api.groq.com' };
        if (!r.dangerouslyAllowBrowser && RG())
            throw new so(`It looks like you're running in a browser-like environment.

This is disabled by default, as it risks exposing your secret API credentials to attackers.
If you understand the risks and have appropriate mitigations in place,
you can set the \`dangerouslyAllowBrowser\` option to \`true\`, e.g.,

new Groq({ apiKey, dangerouslyAllowBrowser: true })`);
        super({
            baseURL: r.baseURL,
            timeout: r.timeout ?? 6e4,
            httpAgent: r.httpAgent,
            maxRetries: r.maxRetries,
            fetch: r.fetch,
        }),
            (this.completions = new zP(this)),
            (this.chat = new Sw(this)),
            (this.embeddings = new VP(this)),
            (this.audio = new sm(this)),
            (this.models = new GP(this)),
            (this.batches = new FP(this)),
            (this.files = new HP(this)),
            (this._options = r),
            (this.apiKey = t);
    }
    defaultQuery() {
        return this._options.defaultQuery;
    }
    defaultHeaders(e) {
        return { ...super.defaultHeaders(e), ...this._options.defaultHeaders };
    }
    authHeaders(e) {
        return { Authorization: `Bearer ${this.apiKey}` };
    }
}
WP = In;
In.Groq = WP;
In.DEFAULT_TIMEOUT = 6e4;
In.GroqError = so;
In.APIError = ar;
In.APIConnectionError = Vv;
In.APIConnectionTimeoutError = wP;
In.APIUserAbortError = P_;
In.NotFoundError = AP;
In.ConflictError = CP;
In.RateLimitError = bP;
In.BadRequestError = MP;
In.AuthenticationError = EP;
In.InternalServerError = PP;
In.PermissionDeniedError = TP;
In.UnprocessableEntityError = RP;
In.toFile = DP;
In.fileFromPath = xP;
In.Completions = zP;
In.Chat = Sw;
In.Embeddings = VP;
In.Audio = sm;
In.Models = GP;
In.Batches = FP;
In.Files = HP;
const PG = new In({
    apiKey: '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',
    dangerouslyAllowBrowser: !0,
});
async function p8(i, e) {
    var n, r;
    return (
        ((r = (n = (await LG(i, e)).choices[0]) == null ? void 0 : n.message) ==
        null
            ? void 0
            : r.content) || ''
    );
}
async function LG(i, e = '') {
    return PG.chat.completions.create({
        messages: [{ role: 'user', content: i + e }],
        model: 'llama3-70b-8192',
    });
}
const IG = K.lazy(() => uo(() => import('./index-AKVfj3xA.js'), [])),
    DG = K.lazy(() => uo(() => import('./index-B_JV5x7i.js'), [])),
    NG = K.lazy(() => uo(() => import('./index-DgTfMI2i.js'), [])),
    UG = K.lazy(() => uo(() => import('./index-Bo-4Tudt.js'), [])),
    OG = K.lazy(() => uo(() => import('./index-CiDcUICq.js'), [])),
    kG = K.lazy(() => uo(() => import('./index-BHyNRCtM.js'), [])),
    FG = K.lazy(() => uo(() => import('./index-CUdCO01F.js'), [])),
    BG = K.lazy(() => uo(() => import('./index-DTZHTy6H.js'), [])),
    zG = K.lazy(() => uo(() => import('./index-BhWMW9e5.js'), [])),
    VG = K.lazy(() =>
        uo(
            () => import('./index-YUhooQEv.js'),
            __vite__mapDeps([0, 1, 2, 3, 4, 5])
        )
    ),
    HG = () => (
        BL(),
        rt.jsx(VU, {
            children: rt.jsxs(XA, {
                mode: 'wait',
                children: [
                    rt.jsx(ZU, {}),
                    rt.jsxs(yU, {
                        children: [
                            rt.jsx(rs, {
                                path: '/',
                                element: rt.jsx(my, {
                                    to: '/landing',
                                    replace: !0,
                                }),
                            }),
                            rt.jsxs(rs, {
                                path: '/',
                                element: rt.jsx(IG, {}),
                                children: [
                                    rt.jsx(rs, {
                                        path: 'landing/*',
                                        element: rt.jsx(kG, {}),
                                    }),
                                    rt.jsx(rs, {
                                        path: 'auth/*',
                                        element: localStorage.getItem('token')
                                            ? rt.jsx(my, {
                                                  to: '/dashboard',
                                                  replace: !0,
                                              })
                                            : rt.jsx(DG, {}),
                                    }),
                                    rt.jsx(rs, {
                                        element: rt.jsx(sO, {}),
                                        children: rt.jsx(rs, {
                                            path: 'dashboard/*',
                                            element: rt.jsx(NG, {}),
                                        }),
                                    }),
                                    rt.jsx(rs, {
                                        path: 'assitance/ai',
                                        element: rt.jsx(OG, {}),
                                    }),
                                    rt.jsx(rs, {
                                        path: 'builder/*',
                                        element: rt.jsx(FG, {}),
                                    }),
                                    rt.jsx(rs, {
                                        path: 'blog/*',
                                        element: rt.jsx(BG, {}),
                                    }),
                                    rt.jsx(rs, {
                                        path: 'souvenir/*',
                                        element: rt.jsx(zG, {}),
                                    }),
                                    rt.jsx(rs, {
                                        path: 'redirect/*',
                                        element: rt.jsx(UG, {}),
                                    }),
                                    rt.jsx(rs, {
                                        path: '*',
                                        element: rt.jsx(VG, {}),
                                    }),
                                ],
                            }),
                        ],
                    }),
                ],
            }),
        })
    ),
    Bt = (i) => typeof i == 'string',
    Vd = () => {
        let i, e;
        const t = new Promise((n, r) => {
            (i = n), (e = r);
        });
        return (t.resolve = i), (t.reject = e), t;
    },
    IT = (i) => (i == null ? '' : '' + i),
    GG = (i, e, t) => {
        i.forEach((n) => {
            e[n] && (t[n] = e[n]);
        });
    },
    WG = /###/g,
    DT = (i) => (i && i.indexOf('###') > -1 ? i.replace(WG, '.') : i),
    NT = (i) => !i || Bt(i),
    lp = (i, e, t) => {
        const n = Bt(e) ? e.split('.') : e;
        let r = 0;
        for (; r < n.length - 1; ) {
            if (NT(i)) return {};
            const s = DT(n[r]);
            !i[s] && t && (i[s] = new t()),
                Object.prototype.hasOwnProperty.call(i, s)
                    ? (i = i[s])
                    : (i = {}),
                ++r;
        }
        return NT(i) ? {} : { obj: i, k: DT(n[r]) };
    },
    UT = (i, e, t) => {
        const { obj: n, k: r } = lp(i, e, Object);
        if (n !== void 0 || e.length === 1) {
            n[r] = t;
            return;
        }
        let s = e[e.length - 1],
            a = e.slice(0, e.length - 1),
            l = lp(i, a, Object);
        for (; l.obj === void 0 && a.length; )
            (s = `${a[a.length - 1]}.${s}`),
                (a = a.slice(0, a.length - 1)),
                (l = lp(i, a, Object)),
                l != null &&
                    l.obj &&
                    typeof l.obj[`${l.k}.${s}`] < 'u' &&
                    (l.obj = void 0);
        l.obj[`${l.k}.${s}`] = t;
    },
    XG = (i, e, t, n) => {
        const { obj: r, k: s } = lp(i, e, Object);
        (r[s] = r[s] || []), r[s].push(t);
    },
    $y = (i, e) => {
        const { obj: t, k: n } = lp(i, e);
        if (t && Object.prototype.hasOwnProperty.call(t, n)) return t[n];
    },
    jG = (i, e, t) => {
        const n = $y(i, t);
        return n !== void 0 ? n : $y(e, t);
    },
    XP = (i, e, t) => {
        for (const n in e)
            n !== '__proto__' &&
                n !== 'constructor' &&
                (n in i
                    ? Bt(i[n]) ||
                      i[n] instanceof String ||
                      Bt(e[n]) ||
                      e[n] instanceof String
                        ? t && (i[n] = e[n])
                        : XP(i[n], e[n], t)
                    : (i[n] = e[n]));
        return i;
    },
    zf = (i) => i.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
var qG = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;',
    '/': '&#x2F;',
};
const $G = (i) => (Bt(i) ? i.replace(/[&<>"'\/]/g, (e) => qG[e]) : i);
class YG {
    constructor(e) {
        (this.capacity = e),
            (this.regExpMap = new Map()),
            (this.regExpQueue = []);
    }
    getRegExp(e) {
        const t = this.regExpMap.get(e);
        if (t !== void 0) return t;
        const n = new RegExp(e);
        return (
            this.regExpQueue.length === this.capacity &&
                this.regExpMap.delete(this.regExpQueue.shift()),
            this.regExpMap.set(e, n),
            this.regExpQueue.push(e),
            n
        );
    }
}
const KG = [' ', ',', '?', '!', ';'],
    ZG = new YG(20),
    JG = (i, e, t) => {
        (e = e || ''), (t = t || '');
        const n = KG.filter((a) => e.indexOf(a) < 0 && t.indexOf(a) < 0);
        if (n.length === 0) return !0;
        const r = ZG.getRegExp(
            `(${n.map((a) => (a === '?' ? '\\?' : a)).join('|')})`
        );
        let s = !r.test(i);
        if (!s) {
            const a = i.indexOf(t);
            a > 0 && !r.test(i.substring(0, a)) && (s = !0);
        }
        return s;
    },
    D_ = (i, e, t = '.') => {
        if (!i) return;
        if (i[e])
            return Object.prototype.hasOwnProperty.call(i, e) ? i[e] : void 0;
        const n = e.split(t);
        let r = i;
        for (let s = 0; s < n.length; ) {
            if (!r || typeof r != 'object') return;
            let a,
                l = '';
            for (let c = s; c < n.length; ++c)
                if (
                    (c !== s && (l += t), (l += n[c]), (a = r[l]), a !== void 0)
                ) {
                    if (
                        ['string', 'number', 'boolean'].indexOf(typeof a) >
                            -1 &&
                        c < n.length - 1
                    )
                        continue;
                    s += c - s + 1;
                    break;
                }
            r = a;
        }
        return r;
    },
    Yy = (i) => (i == null ? void 0 : i.replace('_', '-')),
    QG = {
        type: 'logger',
        log(i) {
            this.output('log', i);
        },
        warn(i) {
            this.output('warn', i);
        },
        error(i) {
            this.output('error', i);
        },
        output(i, e) {
            var t, n;
            (n =
                (t = console == null ? void 0 : console[i]) == null
                    ? void 0
                    : t.apply) == null || n.call(t, console, e);
        },
    };
class Ky {
    constructor(e, t = {}) {
        this.init(e, t);
    }
    init(e, t = {}) {
        (this.prefix = t.prefix || 'i18next:'),
            (this.logger = e || QG),
            (this.options = t),
            (this.debug = t.debug);
    }
    log(...e) {
        return this.forward(e, 'log', '', !0);
    }
    warn(...e) {
        return this.forward(e, 'warn', '', !0);
    }
    error(...e) {
        return this.forward(e, 'error', '');
    }
    deprecate(...e) {
        return this.forward(e, 'warn', 'WARNING DEPRECATED: ', !0);
    }
    forward(e, t, n, r) {
        return r && !this.debug
            ? null
            : (Bt(e[0]) && (e[0] = `${n}${this.prefix} ${e[0]}`),
              this.logger[t](e));
    }
    create(e) {
        return new Ky(this.logger, {
            prefix: `${this.prefix}:${e}:`,
            ...this.options,
        });
    }
    clone(e) {
        return (
            (e = e || this.options),
            (e.prefix = e.prefix || this.prefix),
            new Ky(this.logger, e)
        );
    }
}
var No = new Ky();
class Wv {
    constructor() {
        this.observers = {};
    }
    on(e, t) {
        return (
            e.split(' ').forEach((n) => {
                this.observers[n] || (this.observers[n] = new Map());
                const r = this.observers[n].get(t) || 0;
                this.observers[n].set(t, r + 1);
            }),
            this
        );
    }
    off(e, t) {
        if (this.observers[e]) {
            if (!t) {
                delete this.observers[e];
                return;
            }
            this.observers[e].delete(t);
        }
    }
    emit(e, ...t) {
        this.observers[e] &&
            Array.from(this.observers[e].entries()).forEach(([r, s]) => {
                for (let a = 0; a < s; a++) r(...t);
            }),
            this.observers['*'] &&
                Array.from(this.observers['*'].entries()).forEach(([r, s]) => {
                    for (let a = 0; a < s; a++) r.apply(r, [e, ...t]);
                });
    }
}
class OT extends Wv {
    constructor(e, t = { ns: ['translation'], defaultNS: 'translation' }) {
        super(),
            (this.data = e || {}),
            (this.options = t),
            this.options.keySeparator === void 0 &&
                (this.options.keySeparator = '.'),
            this.options.ignoreJSONStructure === void 0 &&
                (this.options.ignoreJSONStructure = !0);
    }
    addNamespaces(e) {
        this.options.ns.indexOf(e) < 0 && this.options.ns.push(e);
    }
    removeNamespaces(e) {
        const t = this.options.ns.indexOf(e);
        t > -1 && this.options.ns.splice(t, 1);
    }
    getResource(e, t, n, r = {}) {
        var d, p;
        const s =
                r.keySeparator !== void 0
                    ? r.keySeparator
                    : this.options.keySeparator,
            a =
                r.ignoreJSONStructure !== void 0
                    ? r.ignoreJSONStructure
                    : this.options.ignoreJSONStructure;
        let l;
        e.indexOf('.') > -1
            ? (l = e.split('.'))
            : ((l = [e, t]),
              n &&
                  (Array.isArray(n)
                      ? l.push(...n)
                      : Bt(n) && s
                        ? l.push(...n.split(s))
                        : l.push(n)));
        const c = $y(this.data, l);
        return (
            !c &&
                !t &&
                !n &&
                e.indexOf('.') > -1 &&
                ((e = l[0]), (t = l[1]), (n = l.slice(2).join('.'))),
            c || !a || !Bt(n)
                ? c
                : D_(
                      (p = (d = this.data) == null ? void 0 : d[e]) == null
                          ? void 0
                          : p[t],
                      n,
                      s
                  )
        );
    }
    addResource(e, t, n, r, s = { silent: !1 }) {
        const a =
            s.keySeparator !== void 0
                ? s.keySeparator
                : this.options.keySeparator;
        let l = [e, t];
        n && (l = l.concat(a ? n.split(a) : n)),
            e.indexOf('.') > -1 && ((l = e.split('.')), (r = t), (t = l[1])),
            this.addNamespaces(t),
            UT(this.data, l, r),
            s.silent || this.emit('added', e, t, n, r);
    }
    addResources(e, t, n, r = { silent: !1 }) {
        for (const s in n)
            (Bt(n[s]) || Array.isArray(n[s])) &&
                this.addResource(e, t, s, n[s], { silent: !0 });
        r.silent || this.emit('added', e, t, n);
    }
    addResourceBundle(e, t, n, r, s, a = { silent: !1, skipCopy: !1 }) {
        let l = [e, t];
        e.indexOf('.') > -1 &&
            ((l = e.split('.')), (r = n), (n = t), (t = l[1])),
            this.addNamespaces(t);
        let c = $y(this.data, l) || {};
        a.skipCopy || (n = JSON.parse(JSON.stringify(n))),
            r ? XP(c, n, s) : (c = { ...c, ...n }),
            UT(this.data, l, c),
            a.silent || this.emit('added', e, t, n);
    }
    removeResourceBundle(e, t) {
        this.hasResourceBundle(e, t) && delete this.data[e][t],
            this.removeNamespaces(t),
            this.emit('removed', e, t);
    }
    hasResourceBundle(e, t) {
        return this.getResource(e, t) !== void 0;
    }
    getResourceBundle(e, t) {
        return t || (t = this.options.defaultNS), this.getResource(e, t);
    }
    getDataByLanguage(e) {
        return this.data[e];
    }
    hasLanguageSomeTranslations(e) {
        const t = this.getDataByLanguage(e);
        return !!((t && Object.keys(t)) || []).find(
            (r) => t[r] && Object.keys(t[r]).length > 0
        );
    }
    toJSON() {
        return this.data;
    }
}
var jP = {
    processors: {},
    addPostProcessor(i) {
        this.processors[i.name] = i;
    },
    handle(i, e, t, n, r) {
        return (
            i.forEach((s) => {
                var a;
                e =
                    ((a = this.processors[s]) == null
                        ? void 0
                        : a.process(e, t, n, r)) ?? e;
            }),
            e
        );
    },
};
const kT = {},
    FT = (i) => !Bt(i) && typeof i != 'boolean' && typeof i != 'number';
class Zy extends Wv {
    constructor(e, t = {}) {
        super(),
            GG(
                [
                    'resourceStore',
                    'languageUtils',
                    'pluralResolver',
                    'interpolator',
                    'backendConnector',
                    'i18nFormat',
                    'utils',
                ],
                e,
                this
            ),
            (this.options = t),
            this.options.keySeparator === void 0 &&
                (this.options.keySeparator = '.'),
            (this.logger = No.create('translator'));
    }
    changeLanguage(e) {
        e && (this.language = e);
    }
    exists(e, t = { interpolation: {} }) {
        const n = { ...t };
        if (e == null) return !1;
        const r = this.resolve(e, n);
        return (r == null ? void 0 : r.res) !== void 0;
    }
    extractFromKey(e, t) {
        let n =
            t.nsSeparator !== void 0 ? t.nsSeparator : this.options.nsSeparator;
        n === void 0 && (n = ':');
        const r =
            t.keySeparator !== void 0
                ? t.keySeparator
                : this.options.keySeparator;
        let s = t.ns || this.options.defaultNS || [];
        const a = n && e.indexOf(n) > -1,
            l =
                !this.options.userDefinedKeySeparator &&
                !t.keySeparator &&
                !this.options.userDefinedNsSeparator &&
                !t.nsSeparator &&
                !JG(e, n, r);
        if (a && !l) {
            const c = e.match(this.interpolator.nestingRegexp);
            if (c && c.length > 0)
                return { key: e, namespaces: Bt(s) ? [s] : s };
            const d = e.split(n);
            (n !== r || (n === r && this.options.ns.indexOf(d[0]) > -1)) &&
                (s = d.shift()),
                (e = d.join(r));
        }
        return { key: e, namespaces: Bt(s) ? [s] : s };
    }
    translate(e, t, n) {
        let r = typeof t == 'object' ? { ...t } : t;
        if (
            (typeof r != 'object' &&
                this.options.overloadTranslationOptionHandler &&
                (r = this.options.overloadTranslationOptionHandler(arguments)),
            typeof options == 'object' && (r = { ...r }),
            r || (r = {}),
            e == null)
        )
            return '';
        Array.isArray(e) || (e = [String(e)]);
        const s =
                r.returnDetails !== void 0
                    ? r.returnDetails
                    : this.options.returnDetails,
            a =
                r.keySeparator !== void 0
                    ? r.keySeparator
                    : this.options.keySeparator,
            { key: l, namespaces: c } = this.extractFromKey(e[e.length - 1], r),
            d = c[c.length - 1];
        let p =
            r.nsSeparator !== void 0 ? r.nsSeparator : this.options.nsSeparator;
        p === void 0 && (p = ':');
        const g = r.lng || this.language,
            y =
                r.appendNamespaceToCIMode ||
                this.options.appendNamespaceToCIMode;
        if ((g == null ? void 0 : g.toLowerCase()) === 'cimode')
            return y
                ? s
                    ? {
                          res: `${d}${p}${l}`,
                          usedKey: l,
                          exactUsedKey: l,
                          usedLng: g,
                          usedNS: d,
                          usedParams: this.getUsedParamsDetails(r),
                      }
                    : `${d}${p}${l}`
                : s
                  ? {
                        res: l,
                        usedKey: l,
                        exactUsedKey: l,
                        usedLng: g,
                        usedNS: d,
                        usedParams: this.getUsedParamsDetails(r),
                    }
                  : l;
        const v = this.resolve(e, r);
        let S = v == null ? void 0 : v.res;
        const T = (v == null ? void 0 : v.usedKey) || l,
            M = (v == null ? void 0 : v.exactUsedKey) || l,
            w = ['[object Number]', '[object Function]', '[object RegExp]'],
            b =
                r.joinArrays !== void 0
                    ? r.joinArrays
                    : this.options.joinArrays,
            C = !this.i18nFormat || this.i18nFormat.handleAsObject,
            L = r.count !== void 0 && !Bt(r.count),
            F = Zy.hasDefaultValue(r),
            N = L ? this.pluralResolver.getSuffix(g, r.count, r) : '',
            B =
                r.ordinal && L
                    ? this.pluralResolver.getSuffix(g, r.count, { ordinal: !1 })
                    : '',
            z = L && !r.ordinal && r.count === 0,
            U =
                (z && r[`defaultValue${this.options.pluralSeparator}zero`]) ||
                r[`defaultValue${N}`] ||
                r[`defaultValue${B}`] ||
                r.defaultValue;
        let D = S;
        C && !S && F && (D = U);
        const H = FT(D),
            ie = Object.prototype.toString.apply(D);
        if (C && D && H && w.indexOf(ie) < 0 && !(Bt(b) && Array.isArray(D))) {
            if (!r.returnObjects && !this.options.returnObjects) {
                this.options.returnedObjectHandler ||
                    this.logger.warn(
                        'accessing an object - but returnObjects options is not enabled!'
                    );
                const ee = this.options.returnedObjectHandler
                    ? this.options.returnedObjectHandler(T, D, { ...r, ns: c })
                    : `key '${l} (${this.language})' returned an object instead of string.`;
                return s
                    ? ((v.res = ee),
                      (v.usedParams = this.getUsedParamsDetails(r)),
                      v)
                    : ee;
            }
            if (a) {
                const ee = Array.isArray(D),
                    ue = ee ? [] : {},
                    Se = ee ? M : T;
                for (const ce in D)
                    if (Object.prototype.hasOwnProperty.call(D, ce)) {
                        const me = `${Se}${a}${ce}`;
                        F && !S
                            ? (ue[ce] = this.translate(me, {
                                  ...r,
                                  defaultValue: FT(U) ? U[ce] : void 0,
                                  joinArrays: !1,
                                  ns: c,
                              }))
                            : (ue[ce] = this.translate(me, {
                                  ...r,
                                  joinArrays: !1,
                                  ns: c,
                              })),
                            ue[ce] === me && (ue[ce] = D[ce]);
                    }
                S = ue;
            }
        } else if (C && Bt(b) && Array.isArray(S))
            (S = S.join(b)), S && (S = this.extendTranslation(S, e, r, n));
        else {
            let ee = !1,
                ue = !1;
            !this.isValidLookup(S) && F && ((ee = !0), (S = U)),
                this.isValidLookup(S) || ((ue = !0), (S = l));
            const ce =
                    (r.missingKeyNoValueFallbackToKey ||
                        this.options.missingKeyNoValueFallbackToKey) &&
                    ue
                        ? void 0
                        : S,
                me = F && U !== S && this.options.updateMissing;
            if (ue || ee || me) {
                if (
                    (this.logger.log(
                        me ? 'updateKey' : 'missingKey',
                        g,
                        d,
                        l,
                        me ? U : S
                    ),
                    a)
                ) {
                    const G = this.resolve(l, { ...r, keySeparator: !1 });
                    G &&
                        G.res &&
                        this.logger.warn(
                            'Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.'
                        );
                }
                let X = [];
                const oe = this.languageUtils.getFallbackCodes(
                    this.options.fallbackLng,
                    r.lng || this.language
                );
                if (this.options.saveMissingTo === 'fallback' && oe && oe[0])
                    for (let G = 0; G < oe.length; G++) X.push(oe[G]);
                else
                    this.options.saveMissingTo === 'all'
                        ? (X = this.languageUtils.toResolveHierarchy(
                              r.lng || this.language
                          ))
                        : X.push(r.lng || this.language);
                const Q = (G, ae, Oe) => {
                    var we;
                    const fe = F && Oe !== S ? Oe : ce;
                    this.options.missingKeyHandler
                        ? this.options.missingKeyHandler(G, d, ae, fe, me, r)
                        : (we = this.backendConnector) != null &&
                          we.saveMissing &&
                          this.backendConnector.saveMissing(
                              G,
                              d,
                              ae,
                              fe,
                              me,
                              r
                          ),
                        this.emit('missingKey', G, d, ae, S);
                };
                this.options.saveMissing &&
                    (this.options.saveMissingPlurals && L
                        ? X.forEach((G) => {
                              const ae = this.pluralResolver.getSuffixes(G, r);
                              z &&
                                  r[
                                      `defaultValue${this.options.pluralSeparator}zero`
                                  ] &&
                                  ae.indexOf(
                                      `${this.options.pluralSeparator}zero`
                                  ) < 0 &&
                                  ae.push(
                                      `${this.options.pluralSeparator}zero`
                                  ),
                                  ae.forEach((Oe) => {
                                      Q(
                                          [G],
                                          l + Oe,
                                          r[`defaultValue${Oe}`] || U
                                      );
                                  });
                          })
                        : Q(X, l, U));
            }
            (S = this.extendTranslation(S, e, r, v, n)),
                ue &&
                    S === l &&
                    this.options.appendNamespaceToMissingKey &&
                    (S = `${d}${p}${l}`),
                (ue || ee) &&
                    this.options.parseMissingKeyHandler &&
                    (S = this.options.parseMissingKeyHandler(
                        this.options.appendNamespaceToMissingKey
                            ? `${d}${p}${l}`
                            : l,
                        ee ? S : void 0,
                        r
                    ));
        }
        return s
            ? ((v.res = S), (v.usedParams = this.getUsedParamsDetails(r)), v)
            : S;
    }
    extendTranslation(e, t, n, r, s) {
        var c, d;
        if ((c = this.i18nFormat) != null && c.parse)
            e = this.i18nFormat.parse(
                e,
                { ...this.options.interpolation.defaultVariables, ...n },
                n.lng || this.language || r.usedLng,
                r.usedNS,
                r.usedKey,
                { resolved: r }
            );
        else if (!n.skipInterpolation) {
            n.interpolation &&
                this.interpolator.init({
                    ...n,
                    interpolation: {
                        ...this.options.interpolation,
                        ...n.interpolation,
                    },
                });
            const p =
                Bt(e) &&
                (((d = n == null ? void 0 : n.interpolation) == null
                    ? void 0
                    : d.skipOnVariables) !== void 0
                    ? n.interpolation.skipOnVariables
                    : this.options.interpolation.skipOnVariables);
            let g;
            if (p) {
                const v = e.match(this.interpolator.nestingRegexp);
                g = v && v.length;
            }
            let y = n.replace && !Bt(n.replace) ? n.replace : n;
            if (
                (this.options.interpolation.defaultVariables &&
                    (y = {
                        ...this.options.interpolation.defaultVariables,
                        ...y,
                    }),
                (e = this.interpolator.interpolate(
                    e,
                    y,
                    n.lng || this.language || r.usedLng,
                    n
                )),
                p)
            ) {
                const v = e.match(this.interpolator.nestingRegexp),
                    S = v && v.length;
                g < S && (n.nest = !1);
            }
            !n.lng && r && r.res && (n.lng = this.language || r.usedLng),
                n.nest !== !1 &&
                    (e = this.interpolator.nest(
                        e,
                        (...v) =>
                            (s == null ? void 0 : s[0]) === v[0] && !n.context
                                ? (this.logger.warn(
                                      `It seems you are nesting recursively key: ${v[0]} in key: ${t[0]}`
                                  ),
                                  null)
                                : this.translate(...v, t),
                        n
                    )),
                n.interpolation && this.interpolator.reset();
        }
        const a = n.postProcess || this.options.postProcess,
            l = Bt(a) ? [a] : a;
        return (
            e != null &&
                l != null &&
                l.length &&
                n.applyPostProcessor !== !1 &&
                (e = jP.handle(
                    l,
                    e,
                    t,
                    this.options && this.options.postProcessPassResolved
                        ? {
                              i18nResolved: {
                                  ...r,
                                  usedParams: this.getUsedParamsDetails(n),
                              },
                              ...n,
                          }
                        : n,
                    this
                )),
            e
        );
    }
    resolve(e, t = {}) {
        let n, r, s, a, l;
        return (
            Bt(e) && (e = [e]),
            e.forEach((c) => {
                if (this.isValidLookup(n)) return;
                const d = this.extractFromKey(c, t),
                    p = d.key;
                r = p;
                let g = d.namespaces;
                this.options.fallbackNS &&
                    (g = g.concat(this.options.fallbackNS));
                const y = t.count !== void 0 && !Bt(t.count),
                    v = y && !t.ordinal && t.count === 0,
                    S =
                        t.context !== void 0 &&
                        (Bt(t.context) || typeof t.context == 'number') &&
                        t.context !== '',
                    T = t.lngs
                        ? t.lngs
                        : this.languageUtils.toResolveHierarchy(
                              t.lng || this.language,
                              t.fallbackLng
                          );
                g.forEach((M) => {
                    var w, b;
                    this.isValidLookup(n) ||
                        ((l = M),
                        !kT[`${T[0]}-${M}`] &&
                            (w = this.utils) != null &&
                            w.hasLoadedNamespace &&
                            !(
                                (b = this.utils) != null &&
                                b.hasLoadedNamespace(l)
                            ) &&
                            ((kT[`${T[0]}-${M}`] = !0),
                            this.logger.warn(
                                `key "${r}" for languages "${T.join(', ')}" won't get resolved as namespace "${l}" was not yet loaded`,
                                'This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!'
                            )),
                        T.forEach((C) => {
                            var N;
                            if (this.isValidLookup(n)) return;
                            a = C;
                            const L = [p];
                            if (
                                (N = this.i18nFormat) != null &&
                                N.addLookupKeys
                            )
                                this.i18nFormat.addLookupKeys(L, p, C, M, t);
                            else {
                                let B;
                                y &&
                                    (B = this.pluralResolver.getSuffix(
                                        C,
                                        t.count,
                                        t
                                    ));
                                const z = `${this.options.pluralSeparator}zero`,
                                    U = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
                                if (
                                    (y &&
                                        (L.push(p + B),
                                        t.ordinal &&
                                            B.indexOf(U) === 0 &&
                                            L.push(
                                                p +
                                                    B.replace(
                                                        U,
                                                        this.options
                                                            .pluralSeparator
                                                    )
                                            ),
                                        v && L.push(p + z)),
                                    S)
                                ) {
                                    const D = `${p}${this.options.contextSeparator}${t.context}`;
                                    L.push(D),
                                        y &&
                                            (L.push(D + B),
                                            t.ordinal &&
                                                B.indexOf(U) === 0 &&
                                                L.push(
                                                    D +
                                                        B.replace(
                                                            U,
                                                            this.options
                                                                .pluralSeparator
                                                        )
                                                ),
                                            v && L.push(D + z));
                                }
                            }
                            let F;
                            for (; (F = L.pop()); )
                                this.isValidLookup(n) ||
                                    ((s = F),
                                    (n = this.getResource(C, M, F, t)));
                        }));
                });
            }),
            { res: n, usedKey: r, exactUsedKey: s, usedLng: a, usedNS: l }
        );
    }
    isValidLookup(e) {
        return (
            e !== void 0 &&
            !(!this.options.returnNull && e === null) &&
            !(!this.options.returnEmptyString && e === '')
        );
    }
    getResource(e, t, n, r = {}) {
        var s;
        return (s = this.i18nFormat) != null && s.getResource
            ? this.i18nFormat.getResource(e, t, n, r)
            : this.resourceStore.getResource(e, t, n, r);
    }
    getUsedParamsDetails(e = {}) {
        const t = [
                'defaultValue',
                'ordinal',
                'context',
                'replace',
                'lng',
                'lngs',
                'fallbackLng',
                'ns',
                'keySeparator',
                'nsSeparator',
                'returnObjects',
                'returnDetails',
                'joinArrays',
                'postProcess',
                'interpolation',
            ],
            n = e.replace && !Bt(e.replace);
        let r = n ? e.replace : e;
        if (
            (n && typeof e.count < 'u' && (r.count = e.count),
            this.options.interpolation.defaultVariables &&
                (r = { ...this.options.interpolation.defaultVariables, ...r }),
            !n)
        ) {
            r = { ...r };
            for (const s of t) delete r[s];
        }
        return r;
    }
    static hasDefaultValue(e) {
        const t = 'defaultValue';
        for (const n in e)
            if (
                Object.prototype.hasOwnProperty.call(e, n) &&
                t === n.substring(0, t.length) &&
                e[n] !== void 0
            )
                return !0;
        return !1;
    }
}
class BT {
    constructor(e) {
        (this.options = e),
            (this.supportedLngs = this.options.supportedLngs || !1),
            (this.logger = No.create('languageUtils'));
    }
    getScriptPartFromCode(e) {
        if (((e = Yy(e)), !e || e.indexOf('-') < 0)) return null;
        const t = e.split('-');
        return t.length === 2 ||
            (t.pop(), t[t.length - 1].toLowerCase() === 'x')
            ? null
            : this.formatLanguageCode(t.join('-'));
    }
    getLanguagePartFromCode(e) {
        if (((e = Yy(e)), !e || e.indexOf('-') < 0)) return e;
        const t = e.split('-');
        return this.formatLanguageCode(t[0]);
    }
    formatLanguageCode(e) {
        if (Bt(e) && e.indexOf('-') > -1) {
            let t;
            try {
                t = Intl.getCanonicalLocales(e)[0];
            } catch {}
            return (
                t && this.options.lowerCaseLng && (t = t.toLowerCase()),
                t || (this.options.lowerCaseLng ? e.toLowerCase() : e)
            );
        }
        return this.options.cleanCode || this.options.lowerCaseLng
            ? e.toLowerCase()
            : e;
    }
    isSupportedCode(e) {
        return (
            (this.options.load === 'languageOnly' ||
                this.options.nonExplicitSupportedLngs) &&
                (e = this.getLanguagePartFromCode(e)),
            !this.supportedLngs ||
                !this.supportedLngs.length ||
                this.supportedLngs.indexOf(e) > -1
        );
    }
    getBestMatchFromCodes(e) {
        if (!e) return null;
        let t;
        return (
            e.forEach((n) => {
                if (t) return;
                const r = this.formatLanguageCode(n);
                (!this.options.supportedLngs || this.isSupportedCode(r)) &&
                    (t = r);
            }),
            !t &&
                this.options.supportedLngs &&
                e.forEach((n) => {
                    if (t) return;
                    const r = this.getScriptPartFromCode(n);
                    if (this.isSupportedCode(r)) return (t = r);
                    const s = this.getLanguagePartFromCode(n);
                    if (this.isSupportedCode(s)) return (t = s);
                    t = this.options.supportedLngs.find((a) => {
                        if (a === s) return a;
                        if (
                            !(a.indexOf('-') < 0 && s.indexOf('-') < 0) &&
                            ((a.indexOf('-') > 0 &&
                                s.indexOf('-') < 0 &&
                                a.substring(0, a.indexOf('-')) === s) ||
                                (a.indexOf(s) === 0 && s.length > 1))
                        )
                            return a;
                    });
                }),
            t || (t = this.getFallbackCodes(this.options.fallbackLng)[0]),
            t
        );
    }
    getFallbackCodes(e, t) {
        if (!e) return [];
        if (
            (typeof e == 'function' && (e = e(t)),
            Bt(e) && (e = [e]),
            Array.isArray(e))
        )
            return e;
        if (!t) return e.default || [];
        let n = e[t];
        return (
            n || (n = e[this.getScriptPartFromCode(t)]),
            n || (n = e[this.formatLanguageCode(t)]),
            n || (n = e[this.getLanguagePartFromCode(t)]),
            n || (n = e.default),
            n || []
        );
    }
    toResolveHierarchy(e, t) {
        const n = this.getFallbackCodes(t || this.options.fallbackLng || [], e),
            r = [],
            s = (a) => {
                a &&
                    (this.isSupportedCode(a)
                        ? r.push(a)
                        : this.logger.warn(
                              `rejecting language code not found in supportedLngs: ${a}`
                          ));
            };
        return (
            Bt(e) && (e.indexOf('-') > -1 || e.indexOf('_') > -1)
                ? (this.options.load !== 'languageOnly' &&
                      s(this.formatLanguageCode(e)),
                  this.options.load !== 'languageOnly' &&
                      this.options.load !== 'currentOnly' &&
                      s(this.getScriptPartFromCode(e)),
                  this.options.load !== 'currentOnly' &&
                      s(this.getLanguagePartFromCode(e)))
                : Bt(e) && s(this.formatLanguageCode(e)),
            n.forEach((a) => {
                r.indexOf(a) < 0 && s(this.formatLanguageCode(a));
            }),
            r
        );
    }
}
const zT = { zero: 0, one: 1, two: 2, few: 3, many: 4, other: 5 },
    VT = {
        select: (i) => (i === 1 ? 'one' : 'other'),
        resolvedOptions: () => ({ pluralCategories: ['one', 'other'] }),
    };
class eW {
    constructor(e, t = {}) {
        (this.languageUtils = e),
            (this.options = t),
            (this.logger = No.create('pluralResolver')),
            (this.pluralRulesCache = {});
    }
    addRule(e, t) {
        this.rules[e] = t;
    }
    clearCache() {
        this.pluralRulesCache = {};
    }
    getRule(e, t = {}) {
        const n = Yy(e === 'dev' ? 'en' : e),
            r = t.ordinal ? 'ordinal' : 'cardinal',
            s = JSON.stringify({ cleanedCode: n, type: r });
        if (s in this.pluralRulesCache) return this.pluralRulesCache[s];
        let a;
        try {
            a = new Intl.PluralRules(n, { type: r });
        } catch {
            if (!Intl)
                return (
                    this.logger.error(
                        'No Intl support, please use an Intl polyfill!'
                    ),
                    VT
                );
            if (!e.match(/-|_/)) return VT;
            const c = this.languageUtils.getLanguagePartFromCode(e);
            a = this.getRule(c, t);
        }
        return (this.pluralRulesCache[s] = a), a;
    }
    needsPlural(e, t = {}) {
        let n = this.getRule(e, t);
        return (
            n || (n = this.getRule('dev', t)),
            (n == null ? void 0 : n.resolvedOptions().pluralCategories.length) >
                1
        );
    }
    getPluralFormsOfKey(e, t, n = {}) {
        return this.getSuffixes(e, n).map((r) => `${t}${r}`);
    }
    getSuffixes(e, t = {}) {
        let n = this.getRule(e, t);
        return (
            n || (n = this.getRule('dev', t)),
            n
                ? n
                      .resolvedOptions()
                      .pluralCategories.sort((r, s) => zT[r] - zT[s])
                      .map(
                          (r) =>
                              `${this.options.prepend}${t.ordinal ? `ordinal${this.options.prepend}` : ''}${r}`
                      )
                : []
        );
    }
    getSuffix(e, t, n = {}) {
        const r = this.getRule(e, n);
        return r
            ? `${this.options.prepend}${n.ordinal ? `ordinal${this.options.prepend}` : ''}${r.select(t)}`
            : (this.logger.warn(`no plural rule found for: ${e}`),
              this.getSuffix('dev', t, n));
    }
}
const HT = (i, e, t, n = '.', r = !0) => {
        let s = jG(i, e, t);
        return (
            !s &&
                r &&
                Bt(t) &&
                ((s = D_(i, t, n)), s === void 0 && (s = D_(e, t, n))),
            s
        );
    },
    Vx = (i) => i.replace(/\$/g, '$$$$');
class tW {
    constructor(e = {}) {
        var t;
        (this.logger = No.create('interpolator')),
            (this.options = e),
            (this.format =
                ((t = e == null ? void 0 : e.interpolation) == null
                    ? void 0
                    : t.format) || ((n) => n)),
            this.init(e);
    }
    init(e = {}) {
        e.interpolation || (e.interpolation = { escapeValue: !0 });
        const {
            escape: t,
            escapeValue: n,
            useRawValueToEscape: r,
            prefix: s,
            prefixEscaped: a,
            suffix: l,
            suffixEscaped: c,
            formatSeparator: d,
            unescapeSuffix: p,
            unescapePrefix: g,
            nestingPrefix: y,
            nestingPrefixEscaped: v,
            nestingSuffix: S,
            nestingSuffixEscaped: T,
            nestingOptionsSeparator: M,
            maxReplaces: w,
            alwaysFormat: b,
        } = e.interpolation;
        (this.escape = t !== void 0 ? t : $G),
            (this.escapeValue = n !== void 0 ? n : !0),
            (this.useRawValueToEscape = r !== void 0 ? r : !1),
            (this.prefix = s ? zf(s) : a || '{{'),
            (this.suffix = l ? zf(l) : c || '}}'),
            (this.formatSeparator = d || ','),
            (this.unescapePrefix = p ? '' : g || '-'),
            (this.unescapeSuffix = this.unescapePrefix ? '' : p || ''),
            (this.nestingPrefix = y ? zf(y) : v || zf('$t(')),
            (this.nestingSuffix = S ? zf(S) : T || zf(')')),
            (this.nestingOptionsSeparator = M || ','),
            (this.maxReplaces = w || 1e3),
            (this.alwaysFormat = b !== void 0 ? b : !1),
            this.resetRegExp();
    }
    reset() {
        this.options && this.init(this.options);
    }
    resetRegExp() {
        const e = (t, n) =>
            (t == null ? void 0 : t.source) === n
                ? ((t.lastIndex = 0), t)
                : new RegExp(n, 'g');
        (this.regexp = e(this.regexp, `${this.prefix}(.+?)${this.suffix}`)),
            (this.regexpUnescape = e(
                this.regexpUnescape,
                `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`
            )),
            (this.nestingRegexp = e(
                this.nestingRegexp,
                `${this.nestingPrefix}(.+?)${this.nestingSuffix}`
            ));
    }
    interpolate(e, t, n, r) {
        var v;
        let s, a, l;
        const c =
                (this.options &&
                    this.options.interpolation &&
                    this.options.interpolation.defaultVariables) ||
                {},
            d = (S) => {
                if (S.indexOf(this.formatSeparator) < 0) {
                    const b = HT(
                        t,
                        c,
                        S,
                        this.options.keySeparator,
                        this.options.ignoreJSONStructure
                    );
                    return this.alwaysFormat
                        ? this.format(b, void 0, n, {
                              ...r,
                              ...t,
                              interpolationkey: S,
                          })
                        : b;
                }
                const T = S.split(this.formatSeparator),
                    M = T.shift().trim(),
                    w = T.join(this.formatSeparator).trim();
                return this.format(
                    HT(
                        t,
                        c,
                        M,
                        this.options.keySeparator,
                        this.options.ignoreJSONStructure
                    ),
                    w,
                    n,
                    { ...r, ...t, interpolationkey: M }
                );
            };
        this.resetRegExp();
        const p =
                (r == null ? void 0 : r.missingInterpolationHandler) ||
                this.options.missingInterpolationHandler,
            g =
                ((v = r == null ? void 0 : r.interpolation) == null
                    ? void 0
                    : v.skipOnVariables) !== void 0
                    ? r.interpolation.skipOnVariables
                    : this.options.interpolation.skipOnVariables;
        return (
            [
                { regex: this.regexpUnescape, safeValue: (S) => Vx(S) },
                {
                    regex: this.regexp,
                    safeValue: (S) =>
                        this.escapeValue ? Vx(this.escape(S)) : Vx(S),
                },
            ].forEach((S) => {
                for (l = 0; (s = S.regex.exec(e)); ) {
                    const T = s[1].trim();
                    if (((a = d(T)), a === void 0))
                        if (typeof p == 'function') {
                            const w = p(e, s, r);
                            a = Bt(w) ? w : '';
                        } else if (
                            r &&
                            Object.prototype.hasOwnProperty.call(r, T)
                        )
                            a = '';
                        else if (g) {
                            a = s[0];
                            continue;
                        } else
                            this.logger.warn(
                                `missed to pass in variable ${T} for interpolating ${e}`
                            ),
                                (a = '');
                    else !Bt(a) && !this.useRawValueToEscape && (a = IT(a));
                    const M = S.safeValue(a);
                    if (
                        ((e = e.replace(s[0], M)),
                        g
                            ? ((S.regex.lastIndex += a.length),
                              (S.regex.lastIndex -= s[0].length))
                            : (S.regex.lastIndex = 0),
                        l++,
                        l >= this.maxReplaces)
                    )
                        break;
                }
            }),
            e
        );
    }
    nest(e, t, n = {}) {
        let r, s, a;
        const l = (c, d) => {
            const p = this.nestingOptionsSeparator;
            if (c.indexOf(p) < 0) return c;
            const g = c.split(new RegExp(`${p}[ ]*{`));
            let y = `{${g[1]}`;
            (c = g[0]), (y = this.interpolate(y, a));
            const v = y.match(/'/g),
                S = y.match(/"/g);
            ((((v == null ? void 0 : v.length) ?? 0) % 2 === 0 && !S) ||
                S.length % 2 !== 0) &&
                (y = y.replace(/'/g, '"'));
            try {
                (a = JSON.parse(y)), d && (a = { ...d, ...a });
            } catch (T) {
                return (
                    this.logger.warn(
                        `failed parsing options string in nesting for key ${c}`,
                        T
                    ),
                    `${c}${p}${y}`
                );
            }
            return (
                a.defaultValue &&
                    a.defaultValue.indexOf(this.prefix) > -1 &&
                    delete a.defaultValue,
                c
            );
        };
        for (; (r = this.nestingRegexp.exec(e)); ) {
            let c = [];
            (a = { ...n }),
                (a = a.replace && !Bt(a.replace) ? a.replace : a),
                (a.applyPostProcessor = !1),
                delete a.defaultValue;
            let d = !1;
            if (
                r[0].indexOf(this.formatSeparator) !== -1 &&
                !/{.*}/.test(r[1])
            ) {
                const p = r[1].split(this.formatSeparator).map((g) => g.trim());
                (r[1] = p.shift()), (c = p), (d = !0);
            }
            if (
                ((s = t(l.call(this, r[1].trim(), a), a)),
                s && r[0] === e && !Bt(s))
            )
                return s;
            Bt(s) || (s = IT(s)),
                s ||
                    (this.logger.warn(
                        `missed to resolve ${r[1]} for nesting ${e}`
                    ),
                    (s = '')),
                d &&
                    (s = c.reduce(
                        (p, g) =>
                            this.format(p, g, n.lng, {
                                ...n,
                                interpolationkey: r[1].trim(),
                            }),
                        s.trim()
                    )),
                (e = e.replace(r[0], s)),
                (this.regexp.lastIndex = 0);
        }
        return e;
    }
}
const nW = (i) => {
        let e = i.toLowerCase().trim();
        const t = {};
        if (i.indexOf('(') > -1) {
            const n = i.split('(');
            e = n[0].toLowerCase().trim();
            const r = n[1].substring(0, n[1].length - 1);
            e === 'currency' && r.indexOf(':') < 0
                ? t.currency || (t.currency = r.trim())
                : e === 'relativetime' && r.indexOf(':') < 0
                  ? t.range || (t.range = r.trim())
                  : r.split(';').forEach((a) => {
                        if (a) {
                            const [l, ...c] = a.split(':'),
                                d = c
                                    .join(':')
                                    .trim()
                                    .replace(/^'+|'+$/g, ''),
                                p = l.trim();
                            t[p] || (t[p] = d),
                                d === 'false' && (t[p] = !1),
                                d === 'true' && (t[p] = !0),
                                isNaN(d) || (t[p] = parseInt(d, 10));
                        }
                    });
        }
        return { formatName: e, formatOptions: t };
    },
    Vf = (i) => {
        const e = {};
        return (t, n, r) => {
            let s = r;
            r &&
                r.interpolationkey &&
                r.formatParams &&
                r.formatParams[r.interpolationkey] &&
                r[r.interpolationkey] &&
                (s = { ...s, [r.interpolationkey]: void 0 });
            const a = n + JSON.stringify(s);
            let l = e[a];
            return l || ((l = i(Yy(n), r)), (e[a] = l)), l(t);
        };
    };
class iW {
    constructor(e = {}) {
        (this.logger = No.create('formatter')),
            (this.options = e),
            (this.formats = {
                number: Vf((t, n) => {
                    const r = new Intl.NumberFormat(t, { ...n });
                    return (s) => r.format(s);
                }),
                currency: Vf((t, n) => {
                    const r = new Intl.NumberFormat(t, {
                        ...n,
                        style: 'currency',
                    });
                    return (s) => r.format(s);
                }),
                datetime: Vf((t, n) => {
                    const r = new Intl.DateTimeFormat(t, { ...n });
                    return (s) => r.format(s);
                }),
                relativetime: Vf((t, n) => {
                    const r = new Intl.RelativeTimeFormat(t, { ...n });
                    return (s) => r.format(s, n.range || 'day');
                }),
                list: Vf((t, n) => {
                    const r = new Intl.ListFormat(t, { ...n });
                    return (s) => r.format(s);
                }),
            }),
            this.init(e);
    }
    init(e, t = { interpolation: {} }) {
        this.formatSeparator = t.interpolation.formatSeparator || ',';
    }
    add(e, t) {
        this.formats[e.toLowerCase().trim()] = t;
    }
    addCached(e, t) {
        this.formats[e.toLowerCase().trim()] = Vf(t);
    }
    format(e, t, n, r = {}) {
        const s = t.split(this.formatSeparator);
        if (
            s.length > 1 &&
            s[0].indexOf('(') > 1 &&
            s[0].indexOf(')') < 0 &&
            s.find((l) => l.indexOf(')') > -1)
        ) {
            const l = s.findIndex((c) => c.indexOf(')') > -1);
            s[0] = [s[0], ...s.splice(1, l)].join(this.formatSeparator);
        }
        return s.reduce((l, c) => {
            var g;
            const { formatName: d, formatOptions: p } = nW(c);
            if (this.formats[d]) {
                let y = l;
                try {
                    const v =
                            ((g = r == null ? void 0 : r.formatParams) == null
                                ? void 0
                                : g[r.interpolationkey]) || {},
                        S = v.locale || v.lng || r.locale || r.lng || n;
                    y = this.formats[d](l, S, { ...p, ...r, ...v });
                } catch (v) {
                    this.logger.warn(v);
                }
                return y;
            } else this.logger.warn(`there was no format function for ${d}`);
            return l;
        }, e);
    }
}
const rW = (i, e) => {
    i.pending[e] !== void 0 && (delete i.pending[e], i.pendingCount--);
};
class sW extends Wv {
    constructor(e, t, n, r = {}) {
        var s, a;
        super(),
            (this.backend = e),
            (this.store = t),
            (this.services = n),
            (this.languageUtils = n.languageUtils),
            (this.options = r),
            (this.logger = No.create('backendConnector')),
            (this.waitingReads = []),
            (this.maxParallelReads = r.maxParallelReads || 10),
            (this.readingCalls = 0),
            (this.maxRetries = r.maxRetries >= 0 ? r.maxRetries : 5),
            (this.retryTimeout = r.retryTimeout >= 1 ? r.retryTimeout : 350),
            (this.state = {}),
            (this.queue = []),
            (a = (s = this.backend) == null ? void 0 : s.init) == null ||
                a.call(s, n, r.backend, r);
    }
    queueLoad(e, t, n, r) {
        const s = {},
            a = {},
            l = {},
            c = {};
        return (
            e.forEach((d) => {
                let p = !0;
                t.forEach((g) => {
                    const y = `${d}|${g}`;
                    !n.reload && this.store.hasResourceBundle(d, g)
                        ? (this.state[y] = 2)
                        : this.state[y] < 0 ||
                          (this.state[y] === 1
                              ? a[y] === void 0 && (a[y] = !0)
                              : ((this.state[y] = 1),
                                (p = !1),
                                a[y] === void 0 && (a[y] = !0),
                                s[y] === void 0 && (s[y] = !0),
                                c[g] === void 0 && (c[g] = !0)));
                }),
                    p || (l[d] = !0);
            }),
            (Object.keys(s).length || Object.keys(a).length) &&
                this.queue.push({
                    pending: a,
                    pendingCount: Object.keys(a).length,
                    loaded: {},
                    errors: [],
                    callback: r,
                }),
            {
                toLoad: Object.keys(s),
                pending: Object.keys(a),
                toLoadLanguages: Object.keys(l),
                toLoadNamespaces: Object.keys(c),
            }
        );
    }
    loaded(e, t, n) {
        const r = e.split('|'),
            s = r[0],
            a = r[1];
        t && this.emit('failedLoading', s, a, t),
            !t &&
                n &&
                this.store.addResourceBundle(s, a, n, void 0, void 0, {
                    skipCopy: !0,
                }),
            (this.state[e] = t ? -1 : 2),
            t && n && (this.state[e] = 0);
        const l = {};
        this.queue.forEach((c) => {
            XG(c.loaded, [s], a),
                rW(c, e),
                t && c.errors.push(t),
                c.pendingCount === 0 &&
                    !c.done &&
                    (Object.keys(c.loaded).forEach((d) => {
                        l[d] || (l[d] = {});
                        const p = c.loaded[d];
                        p.length &&
                            p.forEach((g) => {
                                l[d][g] === void 0 && (l[d][g] = !0);
                            });
                    }),
                    (c.done = !0),
                    c.errors.length ? c.callback(c.errors) : c.callback());
        }),
            this.emit('loaded', l),
            (this.queue = this.queue.filter((c) => !c.done));
    }
    read(e, t, n, r = 0, s = this.retryTimeout, a) {
        if (!e.length) return a(null, {});
        if (this.readingCalls >= this.maxParallelReads) {
            this.waitingReads.push({
                lng: e,
                ns: t,
                fcName: n,
                tried: r,
                wait: s,
                callback: a,
            });
            return;
        }
        this.readingCalls++;
        const l = (d, p) => {
                if ((this.readingCalls--, this.waitingReads.length > 0)) {
                    const g = this.waitingReads.shift();
                    this.read(
                        g.lng,
                        g.ns,
                        g.fcName,
                        g.tried,
                        g.wait,
                        g.callback
                    );
                }
                if (d && p && r < this.maxRetries) {
                    setTimeout(() => {
                        this.read.call(this, e, t, n, r + 1, s * 2, a);
                    }, s);
                    return;
                }
                a(d, p);
            },
            c = this.backend[n].bind(this.backend);
        if (c.length === 2) {
            try {
                const d = c(e, t);
                d && typeof d.then == 'function'
                    ? d.then((p) => l(null, p)).catch(l)
                    : l(null, d);
            } catch (d) {
                l(d);
            }
            return;
        }
        return c(e, t, l);
    }
    prepareLoading(e, t, n = {}, r) {
        if (!this.backend)
            return (
                this.logger.warn(
                    'No backend was added via i18next.use. Will not load resources.'
                ),
                r && r()
            );
        Bt(e) && (e = this.languageUtils.toResolveHierarchy(e)),
            Bt(t) && (t = [t]);
        const s = this.queueLoad(e, t, n, r);
        if (!s.toLoad.length) return s.pending.length || r(), null;
        s.toLoad.forEach((a) => {
            this.loadOne(a);
        });
    }
    load(e, t, n) {
        this.prepareLoading(e, t, {}, n);
    }
    reload(e, t, n) {
        this.prepareLoading(e, t, { reload: !0 }, n);
    }
    loadOne(e, t = '') {
        const n = e.split('|'),
            r = n[0],
            s = n[1];
        this.read(r, s, 'read', void 0, void 0, (a, l) => {
            a &&
                this.logger.warn(
                    `${t}loading namespace ${s} for language ${r} failed`,
                    a
                ),
                !a &&
                    l &&
                    this.logger.log(
                        `${t}loaded namespace ${s} for language ${r}`,
                        l
                    ),
                this.loaded(e, a, l);
        });
    }
    saveMissing(e, t, n, r, s, a = {}, l = () => {}) {
        var c, d, p, g, y;
        if (
            (d = (c = this.services) == null ? void 0 : c.utils) != null &&
            d.hasLoadedNamespace &&
            !(
                (g = (p = this.services) == null ? void 0 : p.utils) != null &&
                g.hasLoadedNamespace(t)
            )
        ) {
            this.logger.warn(
                `did not save key "${n}" as the namespace "${t}" was not yet loaded`,
                'This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!'
            );
            return;
        }
        if (!(n == null || n === '')) {
            if ((y = this.backend) != null && y.create) {
                const v = { ...a, isUpdate: s },
                    S = this.backend.create.bind(this.backend);
                if (S.length < 6)
                    try {
                        let T;
                        S.length === 5
                            ? (T = S(e, t, n, r, v))
                            : (T = S(e, t, n, r)),
                            T && typeof T.then == 'function'
                                ? T.then((M) => l(null, M)).catch(l)
                                : l(null, T);
                    } catch (T) {
                        l(T);
                    }
                else S(e, t, n, r, l, v);
            }
            !e || !e[0] || this.store.addResource(e[0], t, n, r);
        }
    }
}
const GT = () => ({
        debug: !1,
        initAsync: !0,
        ns: ['translation'],
        defaultNS: ['translation'],
        fallbackLng: ['dev'],
        fallbackNS: !1,
        supportedLngs: !1,
        nonExplicitSupportedLngs: !1,
        load: 'all',
        preload: !1,
        simplifyPluralSuffix: !0,
        keySeparator: '.',
        nsSeparator: ':',
        pluralSeparator: '_',
        contextSeparator: '_',
        partialBundledLanguages: !1,
        saveMissing: !1,
        updateMissing: !1,
        saveMissingTo: 'fallback',
        saveMissingPlurals: !0,
        missingKeyHandler: !1,
        missingInterpolationHandler: !1,
        postProcess: !1,
        postProcessPassResolved: !1,
        returnNull: !1,
        returnEmptyString: !0,
        returnObjects: !1,
        joinArrays: !1,
        returnedObjectHandler: !1,
        parseMissingKeyHandler: !1,
        appendNamespaceToMissingKey: !1,
        appendNamespaceToCIMode: !1,
        overloadTranslationOptionHandler: (i) => {
            let e = {};
            if (
                (typeof i[1] == 'object' && (e = i[1]),
                Bt(i[1]) && (e.defaultValue = i[1]),
                Bt(i[2]) && (e.tDescription = i[2]),
                typeof i[2] == 'object' || typeof i[3] == 'object')
            ) {
                const t = i[3] || i[2];
                Object.keys(t).forEach((n) => {
                    e[n] = t[n];
                });
            }
            return e;
        },
        interpolation: {
            escapeValue: !0,
            format: (i) => i,
            prefix: '{{',
            suffix: '}}',
            formatSeparator: ',',
            unescapePrefix: '-',
            nestingPrefix: '$t(',
            nestingSuffix: ')',
            nestingOptionsSeparator: ',',
            maxReplaces: 1e3,
            skipOnVariables: !0,
        },
    }),
    WT = (i) => {
        var e, t;
        return (
            Bt(i.ns) && (i.ns = [i.ns]),
            Bt(i.fallbackLng) && (i.fallbackLng = [i.fallbackLng]),
            Bt(i.fallbackNS) && (i.fallbackNS = [i.fallbackNS]),
            ((t = (e = i.supportedLngs) == null ? void 0 : e.indexOf) == null
                ? void 0
                : t.call(e, 'cimode')) < 0 &&
                (i.supportedLngs = i.supportedLngs.concat(['cimode'])),
            typeof i.initImmediate == 'boolean' &&
                (i.initAsync = i.initImmediate),
            i
        );
    },
    Qg = () => {},
    oW = (i) => {
        Object.getOwnPropertyNames(Object.getPrototypeOf(i)).forEach((t) => {
            typeof i[t] == 'function' && (i[t] = i[t].bind(i));
        });
    };
class Bp extends Wv {
    constructor(e = {}, t) {
        if (
            (super(),
            (this.options = WT(e)),
            (this.services = {}),
            (this.logger = No),
            (this.modules = { external: [] }),
            oW(this),
            t && !this.isInitialized && !e.isClone)
        ) {
            if (!this.options.initAsync) return this.init(e, t), this;
            setTimeout(() => {
                this.init(e, t);
            }, 0);
        }
    }
    init(e = {}, t) {
        (this.isInitializing = !0),
            typeof e == 'function' && ((t = e), (e = {})),
            e.defaultNS == null &&
                e.ns &&
                (Bt(e.ns)
                    ? (e.defaultNS = e.ns)
                    : e.ns.indexOf('translation') < 0 &&
                      (e.defaultNS = e.ns[0]));
        const n = GT();
        (this.options = { ...n, ...this.options, ...WT(e) }),
            (this.options.interpolation = {
                ...n.interpolation,
                ...this.options.interpolation,
            }),
            e.keySeparator !== void 0 &&
                (this.options.userDefinedKeySeparator = e.keySeparator),
            e.nsSeparator !== void 0 &&
                (this.options.userDefinedNsSeparator = e.nsSeparator);
        const r = (d) => (d ? (typeof d == 'function' ? new d() : d) : null);
        if (!this.options.isClone) {
            this.modules.logger
                ? No.init(r(this.modules.logger), this.options)
                : No.init(null, this.options);
            let d;
            this.modules.formatter ? (d = this.modules.formatter) : (d = iW);
            const p = new BT(this.options);
            this.store = new OT(this.options.resources, this.options);
            const g = this.services;
            (g.logger = No),
                (g.resourceStore = this.store),
                (g.languageUtils = p),
                (g.pluralResolver = new eW(p, {
                    prepend: this.options.pluralSeparator,
                    simplifyPluralSuffix: this.options.simplifyPluralSuffix,
                })),
                d &&
                    (!this.options.interpolation.format ||
                        this.options.interpolation.format ===
                            n.interpolation.format) &&
                    ((g.formatter = r(d)),
                    g.formatter.init(g, this.options),
                    (this.options.interpolation.format =
                        g.formatter.format.bind(g.formatter))),
                (g.interpolator = new tW(this.options)),
                (g.utils = {
                    hasLoadedNamespace: this.hasLoadedNamespace.bind(this),
                }),
                (g.backendConnector = new sW(
                    r(this.modules.backend),
                    g.resourceStore,
                    g,
                    this.options
                )),
                g.backendConnector.on('*', (y, ...v) => {
                    this.emit(y, ...v);
                }),
                this.modules.languageDetector &&
                    ((g.languageDetector = r(this.modules.languageDetector)),
                    g.languageDetector.init &&
                        g.languageDetector.init(
                            g,
                            this.options.detection,
                            this.options
                        )),
                this.modules.i18nFormat &&
                    ((g.i18nFormat = r(this.modules.i18nFormat)),
                    g.i18nFormat.init && g.i18nFormat.init(this)),
                (this.translator = new Zy(this.services, this.options)),
                this.translator.on('*', (y, ...v) => {
                    this.emit(y, ...v);
                }),
                this.modules.external.forEach((y) => {
                    y.init && y.init(this);
                });
        }
        if (
            ((this.format = this.options.interpolation.format),
            t || (t = Qg),
            this.options.fallbackLng &&
                !this.services.languageDetector &&
                !this.options.lng)
        ) {
            const d = this.services.languageUtils.getFallbackCodes(
                this.options.fallbackLng
            );
            d.length > 0 && d[0] !== 'dev' && (this.options.lng = d[0]);
        }
        !this.services.languageDetector &&
            !this.options.lng &&
            this.logger.warn(
                'init: no languageDetector is used and no lng is defined'
            ),
            [
                'getResource',
                'hasResourceBundle',
                'getResourceBundle',
                'getDataByLanguage',
            ].forEach((d) => {
                this[d] = (...p) => this.store[d](...p);
            }),
            [
                'addResource',
                'addResources',
                'addResourceBundle',
                'removeResourceBundle',
            ].forEach((d) => {
                this[d] = (...p) => (this.store[d](...p), this);
            });
        const l = Vd(),
            c = () => {
                const d = (p, g) => {
                    (this.isInitializing = !1),
                        this.isInitialized &&
                            !this.initializedStoreOnce &&
                            this.logger.warn(
                                'init: i18next is already initialized. You should call init just once!'
                            ),
                        (this.isInitialized = !0),
                        this.options.isClone ||
                            this.logger.log('initialized', this.options),
                        this.emit('initialized', this.options),
                        l.resolve(g),
                        t(p, g);
                };
                if (this.languages && !this.isInitialized)
                    return d(null, this.t.bind(this));
                this.changeLanguage(this.options.lng, d);
            };
        return (
            this.options.resources || !this.options.initAsync
                ? c()
                : setTimeout(c, 0),
            l
        );
    }
    loadResources(e, t = Qg) {
        var s, a;
        let n = t;
        const r = Bt(e) ? e : this.language;
        if (
            (typeof e == 'function' && (n = e),
            !this.options.resources || this.options.partialBundledLanguages)
        ) {
            if (
                (r == null ? void 0 : r.toLowerCase()) === 'cimode' &&
                (!this.options.preload || this.options.preload.length === 0)
            )
                return n();
            const l = [],
                c = (d) => {
                    if (!d || d === 'cimode') return;
                    this.services.languageUtils
                        .toResolveHierarchy(d)
                        .forEach((g) => {
                            g !== 'cimode' && l.indexOf(g) < 0 && l.push(g);
                        });
                };
            r
                ? c(r)
                : this.services.languageUtils
                      .getFallbackCodes(this.options.fallbackLng)
                      .forEach((p) => c(p)),
                (a = (s = this.options.preload) == null ? void 0 : s.forEach) ==
                    null || a.call(s, (d) => c(d)),
                this.services.backendConnector.load(l, this.options.ns, (d) => {
                    !d &&
                        !this.resolvedLanguage &&
                        this.language &&
                        this.setResolvedLanguage(this.language),
                        n(d);
                });
        } else n(null);
    }
    reloadResources(e, t, n) {
        const r = Vd();
        return (
            typeof e == 'function' && ((n = e), (e = void 0)),
            typeof t == 'function' && ((n = t), (t = void 0)),
            e || (e = this.languages),
            t || (t = this.options.ns),
            n || (n = Qg),
            this.services.backendConnector.reload(e, t, (s) => {
                r.resolve(), n(s);
            }),
            r
        );
    }
    use(e) {
        if (!e)
            throw new Error(
                'You are passing an undefined module! Please check the object you are passing to i18next.use()'
            );
        if (!e.type)
            throw new Error(
                'You are passing a wrong module! Please check the object you are passing to i18next.use()'
            );
        return (
            e.type === 'backend' && (this.modules.backend = e),
            (e.type === 'logger' || (e.log && e.warn && e.error)) &&
                (this.modules.logger = e),
            e.type === 'languageDetector' &&
                (this.modules.languageDetector = e),
            e.type === 'i18nFormat' && (this.modules.i18nFormat = e),
            e.type === 'postProcessor' && jP.addPostProcessor(e),
            e.type === 'formatter' && (this.modules.formatter = e),
            e.type === '3rdParty' && this.modules.external.push(e),
            this
        );
    }
    setResolvedLanguage(e) {
        if (!(!e || !this.languages) && !(['cimode', 'dev'].indexOf(e) > -1)) {
            for (let t = 0; t < this.languages.length; t++) {
                const n = this.languages[t];
                if (
                    !(['cimode', 'dev'].indexOf(n) > -1) &&
                    this.store.hasLanguageSomeTranslations(n)
                ) {
                    this.resolvedLanguage = n;
                    break;
                }
            }
            !this.resolvedLanguage &&
                this.languages.indexOf(e) < 0 &&
                this.store.hasLanguageSomeTranslations(e) &&
                ((this.resolvedLanguage = e), this.languages.unshift(e));
        }
    }
    changeLanguage(e, t) {
        this.isLanguageChangingTo = e;
        const n = Vd();
        this.emit('languageChanging', e);
        const r = (l) => {
                (this.language = l),
                    (this.languages =
                        this.services.languageUtils.toResolveHierarchy(l)),
                    (this.resolvedLanguage = void 0),
                    this.setResolvedLanguage(l);
            },
            s = (l, c) => {
                c
                    ? this.isLanguageChangingTo === e &&
                      (r(c),
                      this.translator.changeLanguage(c),
                      (this.isLanguageChangingTo = void 0),
                      this.emit('languageChanged', c),
                      this.logger.log('languageChanged', c))
                    : (this.isLanguageChangingTo = void 0),
                    n.resolve((...d) => this.t(...d)),
                    t && t(l, (...d) => this.t(...d));
            },
            a = (l) => {
                var p, g;
                !e && !l && this.services.languageDetector && (l = []);
                const c = Bt(l) ? l : l && l[0],
                    d = this.store.hasLanguageSomeTranslations(c)
                        ? c
                        : this.services.languageUtils.getBestMatchFromCodes(
                              Bt(l) ? [l] : l
                          );
                d &&
                    (this.language || r(d),
                    this.translator.language ||
                        this.translator.changeLanguage(d),
                    (g =
                        (p = this.services.languageDetector) == null
                            ? void 0
                            : p.cacheUserLanguage) == null || g.call(p, d)),
                    this.loadResources(d, (y) => {
                        s(y, d);
                    });
            };
        return (
            !e &&
            this.services.languageDetector &&
            !this.services.languageDetector.async
                ? a(this.services.languageDetector.detect())
                : !e &&
                    this.services.languageDetector &&
                    this.services.languageDetector.async
                  ? this.services.languageDetector.detect.length === 0
                      ? this.services.languageDetector.detect().then(a)
                      : this.services.languageDetector.detect(a)
                  : a(e),
            n
        );
    }
    getFixedT(e, t, n) {
        const r = (s, a, ...l) => {
            let c;
            typeof a != 'object'
                ? (c = this.options.overloadTranslationOptionHandler(
                      [s, a].concat(l)
                  ))
                : (c = { ...a }),
                (c.lng = c.lng || r.lng),
                (c.lngs = c.lngs || r.lngs),
                (c.ns = c.ns || r.ns),
                c.keyPrefix !== '' &&
                    (c.keyPrefix = c.keyPrefix || n || r.keyPrefix);
            const d = this.options.keySeparator || '.';
            let p;
            return (
                c.keyPrefix && Array.isArray(s)
                    ? (p = s.map((g) => `${c.keyPrefix}${d}${g}`))
                    : (p = c.keyPrefix ? `${c.keyPrefix}${d}${s}` : s),
                this.t(p, c)
            );
        };
        return (
            Bt(e) ? (r.lng = e) : (r.lngs = e), (r.ns = t), (r.keyPrefix = n), r
        );
    }
    t(...e) {
        var t;
        return (t = this.translator) == null ? void 0 : t.translate(...e);
    }
    exists(...e) {
        var t;
        return (t = this.translator) == null ? void 0 : t.exists(...e);
    }
    setDefaultNamespace(e) {
        this.options.defaultNS = e;
    }
    hasLoadedNamespace(e, t = {}) {
        if (!this.isInitialized)
            return (
                this.logger.warn(
                    'hasLoadedNamespace: i18next was not initialized',
                    this.languages
                ),
                !1
            );
        if (!this.languages || !this.languages.length)
            return (
                this.logger.warn(
                    'hasLoadedNamespace: i18n.languages were undefined or empty',
                    this.languages
                ),
                !1
            );
        const n = t.lng || this.resolvedLanguage || this.languages[0],
            r = this.options ? this.options.fallbackLng : !1,
            s = this.languages[this.languages.length - 1];
        if (n.toLowerCase() === 'cimode') return !0;
        const a = (l, c) => {
            const d = this.services.backendConnector.state[`${l}|${c}`];
            return d === -1 || d === 0 || d === 2;
        };
        if (t.precheck) {
            const l = t.precheck(this, a);
            if (l !== void 0) return l;
        }
        return !!(
            this.hasResourceBundle(n, e) ||
            !this.services.backendConnector.backend ||
            (this.options.resources && !this.options.partialBundledLanguages) ||
            (a(n, e) && (!r || a(s, e)))
        );
    }
    loadNamespaces(e, t) {
        const n = Vd();
        return this.options.ns
            ? (Bt(e) && (e = [e]),
              e.forEach((r) => {
                  this.options.ns.indexOf(r) < 0 && this.options.ns.push(r);
              }),
              this.loadResources((r) => {
                  n.resolve(), t && t(r);
              }),
              n)
            : (t && t(), Promise.resolve());
    }
    loadLanguages(e, t) {
        const n = Vd();
        Bt(e) && (e = [e]);
        const r = this.options.preload || [],
            s = e.filter(
                (a) =>
                    r.indexOf(a) < 0 &&
                    this.services.languageUtils.isSupportedCode(a)
            );
        return s.length
            ? ((this.options.preload = r.concat(s)),
              this.loadResources((a) => {
                  n.resolve(), t && t(a);
              }),
              n)
            : (t && t(), Promise.resolve());
    }
    dir(e) {
        var r, s;
        if (
            (e ||
                (e =
                    this.resolvedLanguage ||
                    (((r = this.languages) == null ? void 0 : r.length) > 0
                        ? this.languages[0]
                        : this.language)),
            !e)
        )
            return 'rtl';
        const t = [
                'ar',
                'shu',
                'sqr',
                'ssh',
                'xaa',
                'yhd',
                'yud',
                'aao',
                'abh',
                'abv',
                'acm',
                'acq',
                'acw',
                'acx',
                'acy',
                'adf',
                'ads',
                'aeb',
                'aec',
                'afb',
                'ajp',
                'apc',
                'apd',
                'arb',
                'arq',
                'ars',
                'ary',
                'arz',
                'auz',
                'avl',
                'ayh',
                'ayl',
                'ayn',
                'ayp',
                'bbz',
                'pga',
                'he',
                'iw',
                'ps',
                'pbt',
                'pbu',
                'pst',
                'prp',
                'prd',
                'ug',
                'ur',
                'ydd',
                'yds',
                'yih',
                'ji',
                'yi',
                'hbo',
                'men',
                'xmn',
                'fa',
                'jpr',
                'peo',
                'pes',
                'prs',
                'dv',
                'sam',
                'ckb',
            ],
            n =
                ((s = this.services) == null ? void 0 : s.languageUtils) ||
                new BT(GT());
        return t.indexOf(n.getLanguagePartFromCode(e)) > -1 ||
            e.toLowerCase().indexOf('-arab') > 1
            ? 'rtl'
            : 'ltr';
    }
    static createInstance(e = {}, t) {
        return new Bp(e, t);
    }
    cloneInstance(e = {}, t = Qg) {
        const n = e.forkResourceStore;
        n && delete e.forkResourceStore;
        const r = { ...this.options, ...e, isClone: !0 },
            s = new Bp(r);
        if (
            ((e.debug !== void 0 || e.prefix !== void 0) &&
                (s.logger = s.logger.clone(e)),
            ['store', 'services', 'language'].forEach((l) => {
                s[l] = this[l];
            }),
            (s.services = { ...this.services }),
            (s.services.utils = {
                hasLoadedNamespace: s.hasLoadedNamespace.bind(s),
            }),
            n)
        ) {
            const l = Object.keys(this.store.data).reduce(
                (c, d) => (
                    (c[d] = { ...this.store.data[d] }),
                    (c[d] = Object.keys(c[d]).reduce(
                        (p, g) => ((p[g] = { ...c[d][g] }), p),
                        c[d]
                    )),
                    c
                ),
                {}
            );
            (s.store = new OT(l, r)), (s.services.resourceStore = s.store);
        }
        return (
            (s.translator = new Zy(s.services, r)),
            s.translator.on('*', (l, ...c) => {
                s.emit(l, ...c);
            }),
            s.init(r, t),
            (s.translator.options = r),
            (s.translator.backendConnector.services.utils = {
                hasLoadedNamespace: s.hasLoadedNamespace.bind(s),
            }),
            s
        );
    }
    toJSON() {
        return {
            options: this.options,
            store: this.store,
            language: this.language,
            languages: this.languages,
            resolvedLanguage: this.resolvedLanguage,
        };
    }
}
const ur = Bp.createInstance();
ur.createInstance = Bp.createInstance;
ur.createInstance;
ur.dir;
ur.init;
ur.loadResources;
ur.reloadResources;
ur.use;
ur.changeLanguage;
ur.getFixedT;
ur.t;
ur.exists;
ur.setDefaultNamespace;
ur.hasLoadedNamespace;
ur.loadNamespaces;
ur.loadLanguages;
const aW =
        /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g,
    lW = {
        '&amp;': '&',
        '&#38;': '&',
        '&lt;': '<',
        '&#60;': '<',
        '&gt;': '>',
        '&#62;': '>',
        '&apos;': "'",
        '&#39;': "'",
        '&quot;': '"',
        '&#34;': '"',
        '&nbsp;': ' ',
        '&#160;': ' ',
        '&copy;': '©',
        '&#169;': '©',
        '&reg;': '®',
        '&#174;': '®',
        '&hellip;': '…',
        '&#8230;': '…',
        '&#x2F;': '/',
        '&#47;': '/',
    },
    uW = (i) => lW[i],
    cW = (i) => i.replace(aW, uW);
let N_ = {
    bindI18n: 'languageChanged',
    bindI18nStore: '',
    transEmptyNodeValue: '',
    transSupportBasicHtmlNodes: !0,
    transWrapTextNodes: '',
    transKeepBasicHtmlNodesFor: ['br', 'strong', 'i', 'p'],
    useSuspense: !0,
    unescape: cW,
};
const fW = (i = {}) => {
        N_ = { ...N_, ...i };
    },
    m8 = () => N_;
let qP;
const hW = (i) => {
        qP = i;
    },
    g8 = () => qP,
    dW = {
        type: '3rdParty',
        init(i) {
            fW(i.options.react), hW(i);
        },
    };
function U_(i) {
    '@babel/helpers - typeof';
    return (
        (U_ =
            typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (e) {
                      return typeof e;
                  }
                : function (e) {
                      return e &&
                          typeof Symbol == 'function' &&
                          e.constructor === Symbol &&
                          e !== Symbol.prototype
                          ? 'symbol'
                          : typeof e;
                  }),
        U_(i)
    );
}
function $P() {
    return (
        typeof XMLHttpRequest == 'function' ||
        (typeof XMLHttpRequest > 'u' ? 'undefined' : U_(XMLHttpRequest)) ===
            'object'
    );
}
function pW(i) {
    return !!i && typeof i.then == 'function';
}
function mW(i) {
    return pW(i) ? i : Promise.resolve(i);
}
function XT(i, e) {
    var t = Object.keys(i);
    if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(i);
        e &&
            (n = n.filter(function (r) {
                return Object.getOwnPropertyDescriptor(i, r).enumerable;
            })),
            t.push.apply(t, n);
    }
    return t;
}
function jT(i) {
    for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e] != null ? arguments[e] : {};
        e % 2
            ? XT(Object(t), !0).forEach(function (n) {
                  gW(i, n, t[n]);
              })
            : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(i, Object.getOwnPropertyDescriptors(t))
              : XT(Object(t)).forEach(function (n) {
                    Object.defineProperty(
                        i,
                        n,
                        Object.getOwnPropertyDescriptor(t, n)
                    );
                });
    }
    return i;
}
function gW(i, e, t) {
    return (
        (e = yW(e)) in i
            ? Object.defineProperty(i, e, {
                  value: t,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
              })
            : (i[e] = t),
        i
    );
}
function yW(i) {
    var e = vW(i, 'string');
    return hc(e) == 'symbol' ? e : e + '';
}
function vW(i, e) {
    if (hc(i) != 'object' || !i) return i;
    var t = i[Symbol.toPrimitive];
    if (t !== void 0) {
        var n = t.call(i, e);
        if (hc(n) != 'object') return n;
        throw new TypeError('@@toPrimitive must return a primitive value.');
    }
    return (e === 'string' ? String : Number)(i);
}
function hc(i) {
    '@babel/helpers - typeof';
    return (
        (hc =
            typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (e) {
                      return typeof e;
                  }
                : function (e) {
                      return e &&
                          typeof Symbol == 'function' &&
                          e.constructor === Symbol &&
                          e !== Symbol.prototype
                          ? 'symbol'
                          : typeof e;
                  }),
        hc(i)
    );
}
var Ol = typeof fetch == 'function' ? fetch : void 0;
typeof global < 'u' && global.fetch
    ? (Ol = global.fetch)
    : typeof window < 'u' && window.fetch && (Ol = window.fetch);
var zp;
$P() &&
    (typeof global < 'u' && global.XMLHttpRequest
        ? (zp = global.XMLHttpRequest)
        : typeof window < 'u' &&
          window.XMLHttpRequest &&
          (zp = window.XMLHttpRequest));
var Jy;
typeof ActiveXObject == 'function' &&
    (typeof global < 'u' && global.ActiveXObject
        ? (Jy = global.ActiveXObject)
        : typeof window < 'u' &&
          window.ActiveXObject &&
          (Jy = window.ActiveXObject));
typeof Ol != 'function' && (Ol = void 0);
if (!Ol && !zp && !Jy)
    try {
        uo(() => import('./browser-ponyfill-DvhWOSoc.js').then((i) => i.b), [])
            .then(function (i) {
                Ol = i.default;
            })
            .catch(function () {});
    } catch {}
var O_ = function (e, t) {
        if (t && hc(t) === 'object') {
            var n = '';
            for (var r in t)
                n +=
                    '&' +
                    encodeURIComponent(r) +
                    '=' +
                    encodeURIComponent(t[r]);
            if (!n) return e;
            e = e + (e.indexOf('?') !== -1 ? '&' : '?') + n.slice(1);
        }
        return e;
    },
    qT = function (e, t, n, r) {
        var s = function (c) {
            if (!c.ok) return n(c.statusText || 'Error', { status: c.status });
            c.text()
                .then(function (d) {
                    n(null, { status: c.status, data: d });
                })
                .catch(n);
        };
        if (r) {
            var a = r(e, t);
            if (a instanceof Promise) {
                a.then(s).catch(n);
                return;
            }
        }
        typeof fetch == 'function'
            ? fetch(e, t).then(s).catch(n)
            : Ol(e, t).then(s).catch(n);
    },
    $T = !1,
    xW = function (e, t, n, r) {
        e.queryStringParams && (t = O_(t, e.queryStringParams));
        var s = jT(
            {},
            typeof e.customHeaders == 'function'
                ? e.customHeaders()
                : e.customHeaders
        );
        typeof window > 'u' &&
            typeof global < 'u' &&
            typeof global.process < 'u' &&
            global.process.versions &&
            global.process.versions.node &&
            (s['User-Agent'] = 'i18next-http-backend (node/'
                .concat(global.process.version, '; ')
                .concat(global.process.platform, ' ')
                .concat(global.process.arch, ')')),
            n && (s['Content-Type'] = 'application/json');
        var a =
                typeof e.requestOptions == 'function'
                    ? e.requestOptions(n)
                    : e.requestOptions,
            l = jT(
                {
                    method: n ? 'POST' : 'GET',
                    body: n ? e.stringify(n) : void 0,
                    headers: s,
                },
                $T ? {} : a
            ),
            c =
                typeof e.alternateFetch == 'function' &&
                e.alternateFetch.length >= 1
                    ? e.alternateFetch
                    : void 0;
        try {
            qT(t, l, r, c);
        } catch (d) {
            if (
                !a ||
                Object.keys(a).length === 0 ||
                !d.message ||
                d.message.indexOf('not implemented') < 0
            )
                return r(d);
            try {
                Object.keys(a).forEach(function (p) {
                    delete l[p];
                }),
                    qT(t, l, r, c),
                    ($T = !0);
            } catch (p) {
                r(p);
            }
        }
    },
    _W = function (e, t, n, r) {
        n && hc(n) === 'object' && (n = O_('', n).slice(1)),
            e.queryStringParams && (t = O_(t, e.queryStringParams));
        try {
            var s = zp ? new zp() : new Jy('MSXML2.XMLHTTP.3.0');
            s.open(n ? 'POST' : 'GET', t, 1),
                e.crossDomain ||
                    s.setRequestHeader('X-Requested-With', 'XMLHttpRequest'),
                (s.withCredentials = !!e.withCredentials),
                n &&
                    s.setRequestHeader(
                        'Content-Type',
                        'application/x-www-form-urlencoded'
                    ),
                s.overrideMimeType && s.overrideMimeType('application/json');
            var a = e.customHeaders;
            if (((a = typeof a == 'function' ? a() : a), a))
                for (var l in a) s.setRequestHeader(l, a[l]);
            (s.onreadystatechange = function () {
                s.readyState > 3 &&
                    r(s.status >= 400 ? s.statusText : null, {
                        status: s.status,
                        data: s.responseText,
                    });
            }),
                s.send(n);
        } catch (c) {
            console && console.log(c);
        }
    },
    SW = function (e, t, n, r) {
        if (
            (typeof n == 'function' && ((r = n), (n = void 0)),
            (r = r || function () {}),
            Ol && t.indexOf('file:') !== 0)
        )
            return xW(e, t, n, r);
        if ($P() || typeof ActiveXObject == 'function') return _W(e, t, n, r);
        r(new Error('No fetch and no xhr implementation found!'));
    };
function mh(i) {
    '@babel/helpers - typeof';
    return (
        (mh =
            typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (e) {
                      return typeof e;
                  }
                : function (e) {
                      return e &&
                          typeof Symbol == 'function' &&
                          e.constructor === Symbol &&
                          e !== Symbol.prototype
                          ? 'symbol'
                          : typeof e;
                  }),
        mh(i)
    );
}
function YT(i, e) {
    var t = Object.keys(i);
    if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(i);
        e &&
            (n = n.filter(function (r) {
                return Object.getOwnPropertyDescriptor(i, r).enumerable;
            })),
            t.push.apply(t, n);
    }
    return t;
}
function Hx(i) {
    for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e] != null ? arguments[e] : {};
        e % 2
            ? YT(Object(t), !0).forEach(function (n) {
                  YP(i, n, t[n]);
              })
            : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(i, Object.getOwnPropertyDescriptors(t))
              : YT(Object(t)).forEach(function (n) {
                    Object.defineProperty(
                        i,
                        n,
                        Object.getOwnPropertyDescriptor(t, n)
                    );
                });
    }
    return i;
}
function wW(i, e) {
    if (!(i instanceof e))
        throw new TypeError('Cannot call a class as a function');
}
function MW(i, e) {
    for (var t = 0; t < e.length; t++) {
        var n = e[t];
        (n.enumerable = n.enumerable || !1),
            (n.configurable = !0),
            'value' in n && (n.writable = !0),
            Object.defineProperty(i, KP(n.key), n);
    }
}
function EW(i, e, t) {
    return (
        e && MW(i.prototype, e),
        Object.defineProperty(i, 'prototype', { writable: !1 }),
        i
    );
}
function YP(i, e, t) {
    return (
        (e = KP(e)) in i
            ? Object.defineProperty(i, e, {
                  value: t,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
              })
            : (i[e] = t),
        i
    );
}
function KP(i) {
    var e = TW(i, 'string');
    return mh(e) == 'symbol' ? e : e + '';
}
function TW(i, e) {
    if (mh(i) != 'object' || !i) return i;
    var t = i[Symbol.toPrimitive];
    if (t !== void 0) {
        var n = t.call(i, e);
        if (mh(n) != 'object') return n;
        throw new TypeError('@@toPrimitive must return a primitive value.');
    }
    return String(i);
}
var AW = function () {
        return {
            loadPath: '/locales/{{lng}}/{{ns}}.json',
            addPath: '/locales/add/{{lng}}/{{ns}}',
            parse: function (t) {
                return JSON.parse(t);
            },
            stringify: JSON.stringify,
            parsePayload: function (t, n, r) {
                return YP({}, n, r || '');
            },
            parseLoadPayload: function (t, n) {},
            request: SW,
            reloadInterval: typeof window < 'u' ? !1 : 60 * 60 * 1e3,
            customHeaders: {},
            queryStringParams: {},
            crossDomain: !1,
            withCredentials: !1,
            overrideMimeType: !1,
            requestOptions: {
                mode: 'cors',
                credentials: 'same-origin',
                cache: 'default',
            },
        };
    },
    ZP = (function () {
        function i(e) {
            var t =
                    arguments.length > 1 && arguments[1] !== void 0
                        ? arguments[1]
                        : {},
                n =
                    arguments.length > 2 && arguments[2] !== void 0
                        ? arguments[2]
                        : {};
            wW(this, i),
                (this.services = e),
                (this.options = t),
                (this.allOptions = n),
                (this.type = 'backend'),
                this.init(e, t, n);
        }
        return EW(i, [
            {
                key: 'init',
                value: function (t) {
                    var n = this,
                        r =
                            arguments.length > 1 && arguments[1] !== void 0
                                ? arguments[1]
                                : {},
                        s =
                            arguments.length > 2 && arguments[2] !== void 0
                                ? arguments[2]
                                : {};
                    if (
                        ((this.services = t),
                        (this.options = Hx(
                            Hx(Hx({}, AW()), this.options || {}),
                            r
                        )),
                        (this.allOptions = s),
                        this.services && this.options.reloadInterval)
                    ) {
                        var a = setInterval(function () {
                            return n.reload();
                        }, this.options.reloadInterval);
                        mh(a) === 'object' &&
                            typeof a.unref == 'function' &&
                            a.unref();
                    }
                },
            },
            {
                key: 'readMulti',
                value: function (t, n, r) {
                    this._readAny(t, t, n, n, r);
                },
            },
            {
                key: 'read',
                value: function (t, n, r) {
                    this._readAny([t], t, [n], n, r);
                },
            },
            {
                key: '_readAny',
                value: function (t, n, r, s, a) {
                    var l = this,
                        c = this.options.loadPath;
                    typeof this.options.loadPath == 'function' &&
                        (c = this.options.loadPath(t, r)),
                        (c = mW(c)),
                        c.then(function (d) {
                            if (!d) return a(null, {});
                            var p = l.services.interpolator.interpolate(d, {
                                lng: t.join('+'),
                                ns: r.join('+'),
                            });
                            l.loadUrl(p, a, n, s);
                        });
                },
            },
            {
                key: 'loadUrl',
                value: function (t, n, r, s) {
                    var a = this,
                        l = typeof r == 'string' ? [r] : r,
                        c = typeof s == 'string' ? [s] : s,
                        d = this.options.parseLoadPayload(l, c);
                    this.options.request(this.options, t, d, function (p, g) {
                        if (
                            g &&
                            ((g.status >= 500 && g.status < 600) || !g.status)
                        )
                            return n(
                                'failed loading ' +
                                    t +
                                    '; status code: ' +
                                    g.status,
                                !0
                            );
                        if (g && g.status >= 400 && g.status < 500)
                            return n(
                                'failed loading ' +
                                    t +
                                    '; status code: ' +
                                    g.status,
                                !1
                            );
                        if (!g && p && p.message) {
                            var y = p.message.toLowerCase(),
                                v = ['failed', 'fetch', 'network', 'load'].find(
                                    function (M) {
                                        return y.indexOf(M) > -1;
                                    }
                                );
                            if (v)
                                return n(
                                    'failed loading ' + t + ': ' + p.message,
                                    !0
                                );
                        }
                        if (p) return n(p, !1);
                        var S, T;
                        try {
                            typeof g.data == 'string'
                                ? (S = a.options.parse(g.data, r, s))
                                : (S = g.data);
                        } catch {
                            T = 'failed parsing ' + t + ' to json';
                        }
                        if (T) return n(T, !1);
                        n(null, S);
                    });
                },
            },
            {
                key: 'create',
                value: function (t, n, r, s, a) {
                    var l = this;
                    if (this.options.addPath) {
                        typeof t == 'string' && (t = [t]);
                        var c = this.options.parsePayload(n, r, s),
                            d = 0,
                            p = [],
                            g = [];
                        t.forEach(function (y) {
                            var v = l.options.addPath;
                            typeof l.options.addPath == 'function' &&
                                (v = l.options.addPath(y, n));
                            var S = l.services.interpolator.interpolate(v, {
                                lng: y,
                                ns: n,
                            });
                            l.options.request(l.options, S, c, function (T, M) {
                                (d += 1),
                                    p.push(T),
                                    g.push(M),
                                    d === t.length &&
                                        typeof a == 'function' &&
                                        a(p, g);
                            });
                        });
                    }
                },
            },
            {
                key: 'reload',
                value: function () {
                    var t = this,
                        n = this.services,
                        r = n.backendConnector,
                        s = n.languageUtils,
                        a = n.logger,
                        l = r.language;
                    if (!(l && l.toLowerCase() === 'cimode')) {
                        var c = [],
                            d = function (g) {
                                var y = s.toResolveHierarchy(g);
                                y.forEach(function (v) {
                                    c.indexOf(v) < 0 && c.push(v);
                                });
                            };
                        d(l),
                            this.allOptions.preload &&
                                this.allOptions.preload.forEach(function (p) {
                                    return d(p);
                                }),
                            c.forEach(function (p) {
                                t.allOptions.ns.forEach(function (g) {
                                    r.read(
                                        p,
                                        g,
                                        'read',
                                        null,
                                        null,
                                        function (y, v) {
                                            y &&
                                                a.warn(
                                                    'loading namespace '
                                                        .concat(
                                                            g,
                                                            ' for language '
                                                        )
                                                        .concat(p, ' failed'),
                                                    y
                                                ),
                                                !y &&
                                                    v &&
                                                    a.log(
                                                        'loaded namespace '
                                                            .concat(
                                                                g,
                                                                ' for language '
                                                            )
                                                            .concat(p),
                                                        v
                                                    ),
                                                r.loaded(
                                                    ''.concat(p, '|').concat(g),
                                                    y,
                                                    v
                                                );
                                        }
                                    );
                                });
                            });
                    }
                },
            },
        ]);
    })();
ZP.type = 'backend';
const { slice: CW, forEach: RW } = [];
function bW(i) {
    return (
        RW.call(CW.call(arguments, 1), (e) => {
            if (e) for (const t in e) i[t] === void 0 && (i[t] = e[t]);
        }),
        i
    );
}
function PW(i) {
    return typeof i != 'string'
        ? !1
        : [
              /<\s*script.*?>/i,
              /<\s*\/\s*script\s*>/i,
              /<\s*img.*?on\w+\s*=/i,
              /<\s*\w+\s*on\w+\s*=.*?>/i,
              /javascript\s*:/i,
              /vbscript\s*:/i,
              /expression\s*\(/i,
              /eval\s*\(/i,
              /alert\s*\(/i,
              /document\.cookie/i,
              /document\.write\s*\(/i,
              /window\.location/i,
              /innerHTML/i,
          ].some((t) => t.test(i));
}
const KT = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/,
    LW = function (i, e) {
        const n =
                arguments.length > 2 && arguments[2] !== void 0
                    ? arguments[2]
                    : { path: '/' },
            r = encodeURIComponent(e);
        let s = `${i}=${r}`;
        if (n.maxAge > 0) {
            const a = n.maxAge - 0;
            if (Number.isNaN(a)) throw new Error('maxAge should be a Number');
            s += `; Max-Age=${Math.floor(a)}`;
        }
        if (n.domain) {
            if (!KT.test(n.domain))
                throw new TypeError('option domain is invalid');
            s += `; Domain=${n.domain}`;
        }
        if (n.path) {
            if (!KT.test(n.path)) throw new TypeError('option path is invalid');
            s += `; Path=${n.path}`;
        }
        if (n.expires) {
            if (typeof n.expires.toUTCString != 'function')
                throw new TypeError('option expires is invalid');
            s += `; Expires=${n.expires.toUTCString()}`;
        }
        if (
            (n.httpOnly && (s += '; HttpOnly'),
            n.secure && (s += '; Secure'),
            n.sameSite)
        )
            switch (
                typeof n.sameSite == 'string'
                    ? n.sameSite.toLowerCase()
                    : n.sameSite
            ) {
                case !0:
                    s += '; SameSite=Strict';
                    break;
                case 'lax':
                    s += '; SameSite=Lax';
                    break;
                case 'strict':
                    s += '; SameSite=Strict';
                    break;
                case 'none':
                    s += '; SameSite=None';
                    break;
                default:
                    throw new TypeError('option sameSite is invalid');
            }
        return n.partitioned && (s += '; Partitioned'), s;
    },
    ZT = {
        create(i, e, t, n) {
            let r =
                arguments.length > 4 && arguments[4] !== void 0
                    ? arguments[4]
                    : { path: '/', sameSite: 'strict' };
            t &&
                ((r.expires = new Date()),
                r.expires.setTime(r.expires.getTime() + t * 60 * 1e3)),
                n && (r.domain = n),
                (document.cookie = LW(i, encodeURIComponent(e), r));
        },
        read(i) {
            const e = `${i}=`,
                t = document.cookie.split(';');
            for (let n = 0; n < t.length; n++) {
                let r = t[n];
                for (; r.charAt(0) === ' '; ) r = r.substring(1, r.length);
                if (r.indexOf(e) === 0) return r.substring(e.length, r.length);
            }
            return null;
        },
        remove(i) {
            this.create(i, '', -1);
        },
    };
var IW = {
        name: 'cookie',
        lookup(i) {
            let { lookupCookie: e } = i;
            if (e && typeof document < 'u') return ZT.read(e) || void 0;
        },
        cacheUserLanguage(i, e) {
            let {
                lookupCookie: t,
                cookieMinutes: n,
                cookieDomain: r,
                cookieOptions: s,
            } = e;
            t && typeof document < 'u' && ZT.create(t, i, n, r, s);
        },
    },
    DW = {
        name: 'querystring',
        lookup(i) {
            var n;
            let { lookupQuerystring: e } = i,
                t;
            if (typeof window < 'u') {
                let { search: r } = window.location;
                !window.location.search &&
                    ((n = window.location.hash) == null
                        ? void 0
                        : n.indexOf('?')) > -1 &&
                    (r = window.location.hash.substring(
                        window.location.hash.indexOf('?')
                    ));
                const a = r.substring(1).split('&');
                for (let l = 0; l < a.length; l++) {
                    const c = a[l].indexOf('=');
                    c > 0 &&
                        a[l].substring(0, c) === e &&
                        (t = a[l].substring(c + 1));
                }
            }
            return t;
        },
    };
let Hf = null;
const JT = () => {
    if (Hf !== null) return Hf;
    try {
        if (((Hf = typeof window < 'u' && window.localStorage !== null), !Hf))
            return !1;
        const i = 'i18next.translate.boo';
        window.localStorage.setItem(i, 'foo'),
            window.localStorage.removeItem(i);
    } catch {
        Hf = !1;
    }
    return Hf;
};
var NW = {
    name: 'localStorage',
    lookup(i) {
        let { lookupLocalStorage: e } = i;
        if (e && JT()) return window.localStorage.getItem(e) || void 0;
    },
    cacheUserLanguage(i, e) {
        let { lookupLocalStorage: t } = e;
        t && JT() && window.localStorage.setItem(t, i);
    },
};
let Gf = null;
const QT = () => {
    if (Gf !== null) return Gf;
    try {
        if (((Gf = typeof window < 'u' && window.sessionStorage !== null), !Gf))
            return !1;
        const i = 'i18next.translate.boo';
        window.sessionStorage.setItem(i, 'foo'),
            window.sessionStorage.removeItem(i);
    } catch {
        Gf = !1;
    }
    return Gf;
};
var UW = {
        name: 'sessionStorage',
        lookup(i) {
            let { lookupSessionStorage: e } = i;
            if (e && QT()) return window.sessionStorage.getItem(e) || void 0;
        },
        cacheUserLanguage(i, e) {
            let { lookupSessionStorage: t } = e;
            t && QT() && window.sessionStorage.setItem(t, i);
        },
    },
    OW = {
        name: 'navigator',
        lookup(i) {
            const e = [];
            if (typeof navigator < 'u') {
                const {
                    languages: t,
                    userLanguage: n,
                    language: r,
                } = navigator;
                if (t) for (let s = 0; s < t.length; s++) e.push(t[s]);
                n && e.push(n), r && e.push(r);
            }
            return e.length > 0 ? e : void 0;
        },
    },
    kW = {
        name: 'htmlTag',
        lookup(i) {
            let { htmlTag: e } = i,
                t;
            const n =
                e || (typeof document < 'u' ? document.documentElement : null);
            return (
                n &&
                    typeof n.getAttribute == 'function' &&
                    (t = n.getAttribute('lang')),
                t
            );
        },
    },
    FW = {
        name: 'path',
        lookup(i) {
            var r;
            let { lookupFromPathIndex: e } = i;
            if (typeof window > 'u') return;
            const t = window.location.pathname.match(/\/([a-zA-Z-]*)/g);
            return Array.isArray(t)
                ? (r = t[typeof e == 'number' ? e : 0]) == null
                    ? void 0
                    : r.replace('/', '')
                : void 0;
        },
    },
    BW = {
        name: 'subdomain',
        lookup(i) {
            var r, s;
            let { lookupFromSubdomainIndex: e } = i;
            const t = typeof e == 'number' ? e + 1 : 1,
                n =
                    typeof window < 'u' &&
                    ((s =
                        (r = window.location) == null ? void 0 : r.hostname) ==
                    null
                        ? void 0
                        : s.match(
                              /^(\w{2,5})\.(([a-z0-9-]{1,63}\.[a-z]{2,6})|localhost)/i
                          ));
            if (n) return n[t];
        },
    };
let JP = !1;
try {
    document.cookie, (JP = !0);
} catch {}
const QP = [
    'querystring',
    'cookie',
    'localStorage',
    'sessionStorage',
    'navigator',
    'htmlTag',
];
JP || QP.splice(1, 1);
const zW = () => ({
    order: QP,
    lookupQuerystring: 'lng',
    lookupCookie: 'i18next',
    lookupLocalStorage: 'i18nextLng',
    lookupSessionStorage: 'i18nextLng',
    caches: ['localStorage'],
    excludeCacheFor: ['cimode'],
    convertDetectedLanguage: (i) => i,
});
class eL {
    constructor(e) {
        let t =
            arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        (this.type = 'languageDetector'),
            (this.detectors = {}),
            this.init(e, t);
    }
    init() {
        let e =
                arguments.length > 0 && arguments[0] !== void 0
                    ? arguments[0]
                    : { languageUtils: {} },
            t =
                arguments.length > 1 && arguments[1] !== void 0
                    ? arguments[1]
                    : {},
            n =
                arguments.length > 2 && arguments[2] !== void 0
                    ? arguments[2]
                    : {};
        (this.services = e),
            (this.options = bW(t, this.options || {}, zW())),
            typeof this.options.convertDetectedLanguage == 'string' &&
                this.options.convertDetectedLanguage.indexOf('15897') > -1 &&
                (this.options.convertDetectedLanguage = (r) =>
                    r.replace('-', '_')),
            this.options.lookupFromUrlIndex &&
                (this.options.lookupFromPathIndex =
                    this.options.lookupFromUrlIndex),
            (this.i18nOptions = n),
            this.addDetector(IW),
            this.addDetector(DW),
            this.addDetector(NW),
            this.addDetector(UW),
            this.addDetector(OW),
            this.addDetector(kW),
            this.addDetector(FW),
            this.addDetector(BW);
    }
    addDetector(e) {
        return (this.detectors[e.name] = e), this;
    }
    detect() {
        let e =
                arguments.length > 0 && arguments[0] !== void 0
                    ? arguments[0]
                    : this.options.order,
            t = [];
        return (
            e.forEach((n) => {
                if (this.detectors[n]) {
                    let r = this.detectors[n].lookup(this.options);
                    r && typeof r == 'string' && (r = [r]),
                        r && (t = t.concat(r));
                }
            }),
            (t = t
                .filter((n) => n != null && !PW(n))
                .map((n) => this.options.convertDetectedLanguage(n))),
            this.services &&
            this.services.languageUtils &&
            this.services.languageUtils.getBestMatchFromCodes
                ? t
                : t.length > 0
                  ? t[0]
                  : null
        );
    }
    cacheUserLanguage(e) {
        let t =
            arguments.length > 1 && arguments[1] !== void 0
                ? arguments[1]
                : this.options.caches;
        t &&
            ((this.options.excludeCacheFor &&
                this.options.excludeCacheFor.indexOf(e) > -1) ||
                t.forEach((n) => {
                    this.detectors[n] &&
                        this.detectors[n].cacheUserLanguage(e, this.options);
                }));
    }
}
eL.type = 'languageDetector';
ur.use(ZP)
    .use(eL)
    .use(dW)
    .init({
        debug: !0,
        fallbackLng: 'fr',
        backend: { loadPath: '/locales/{{lng}}/translation.json' },
    });
const tL = K.createContext(),
    VW = new URL('/assets/notification-wBGf4-Tp.mp3', import.meta.url).href,
    HW = ({ children: i }) => {
        const [e, t] = K.useState([]),
            [n, r] = K.useState(null);
        K.useEffect(() => {
            const c = new Audio(VW);
            return (
                r(c),
                c.load(),
                () => {
                    c && (c.pause(), (c.src = ''));
                }
            );
        }, []);
        const s = K.useCallback(async () => {
                if (n)
                    try {
                        (n.currentTime = 0), await n.play();
                    } catch (c) {
                        console.warn('Could not play notification sound:', c);
                    }
            }, [n]),
            a = K.useCallback(
                (c, d = 'info') => {
                    const p = Date.now().toString();
                    t((y) => [...y, { id: p, message: c, type: d }]), s();
                    const g = setTimeout(() => {
                        t((y) => y.filter((v) => v.id !== p));
                    }, 3e3);
                    return () => clearTimeout(g);
                },
                [s]
            ),
            l = K.useCallback((c) => {
                t((d) => d.filter((p) => p.id !== c));
            }, []);
        return rt.jsxs(tL.Provider, {
            value: { addToast: a, removeToast: l },
            children: [
                i,
                rt.jsx('div', {
                    className: 'fixed top-4 right-4 z-50 flex flex-col gap-2',
                    children: rt.jsx(XA, {
                        mode: 'popLayout',
                        children: e.map((c) =>
                            rt.jsx(XW, { ...c, onRemove: () => l(c.id) }, c.id)
                        ),
                    }),
                }),
            ],
        });
    },
    GW = {
        success: rt.jsx(Z5, { className: 'h-5 w-5 text-green-50' }),
        error: rt.jsx(iG, { className: 'h-5 w-5 text-red-50' }),
        warning: rt.jsx(Q5, { className: 'h-5 w-5 text-yellow-50' }),
        info: rt.jsx(tG, { className: 'h-5 w-5 text-blue-50' }),
    },
    WW = {
        success: 'bg-green-600/80  backdrop-blur-md text-green-50',
        error: 'bg-red-600/80  backdrop-blur-md text-red-50',
        warning: 'bg-yellow-600/80  backdrop-blur-md text-yellow-50',
        info: 'bg-blue-600/80  backdrop-blur-md text-blue-50',
    },
    XW = ({ id: i, message: e, type: t, onRemove: n }) =>
        rt.jsxs(MN.div, {
            layout: !0,
            initial: { opacity: 0, y: 50, scale: 0.3 },
            animate: { opacity: 1, y: 0, scale: 1 },
            exit: { opacity: 0, scale: 0.5, transition: { duration: 0.5 } },
            className: `flex w-[250px] items-center gap-3 rounded-2xl p-4 shadow-lg ${WW[t]} cursor-pointer`,
            onClick: n,
            id: `toast-${i}`,
            role: 'alert',
            'aria-live': 'polite',
            children: [
                GW[t],
                rt.jsx('span', {
                    className: 'text-sm font-medium',
                    children: e,
                }),
            ],
        }),
    y8 = () => {
        const i = K.useContext(tL);
        if (!i) throw new Error('useToast must be used within a ToastProvider');
        return i;
    },
    nL = K.createContext(null),
    jW = ({ children: i }) => {
        const e = {
                id: 'temp-' + Date.now().toString(),
                tone: null,
                elements: [],
                background: 'dramatic-bg',
                music: void 0,
            },
            [t, n] = K.useState(e),
            r = (S) => {
                switch (S) {
                    case 'dramatic':
                        return 'As the curtain falls on this digital chapter, I bid thee farewell...';
                    case 'ironic':
                        return 'Oh no... anyway';
                    case 'cringe':
                        return "OMG can't believe I'm actually leaving!! 😭😭😭";
                    case 'classy':
                        return 'With gratitude for our time together, I take my leave.';
                    case 'absurd':
                        return 'I have been ABDUCTED by ALIEN DUCKS and must depart this DIMENSION!!!';
                    default:
                        return 'Farewell, my friends...';
                }
            },
            s = (S) => {
                switch (S) {
                    case 'dramatic':
                        return 'handwritten';
                    case 'ironic':
                        return 'retro-font';
                    case 'cringe':
                        return 'comic-sans';
                    case 'classy':
                        return 'handwritten';
                    case 'absurd':
                        return 'pixel-font';
                    default:
                        return 'retro-font';
                }
            },
            a = (S) => {
                n((T) => {
                    let M = T.background;
                    return (
                        S === 'dramatic' && (M = 'dramatic-bg'),
                        S === 'ironic' && (M = 'ironic-bg'),
                        S === 'cringe' && (M = 'cringe-bg'),
                        S === 'classy' && (M = 'classy-bg'),
                        S === 'absurd' && (M = 'absurd-bg'),
                        {
                            ...T,
                            tone: S,
                            background: M,
                            elements: [
                                ...T.elements,
                                {
                                    id: 'default-text-' + Date.now(),
                                    type: 'text',
                                    content: r(S),
                                    style: {
                                        font: s(S),
                                        size: '2xl',
                                        color: 'white',
                                    },
                                    position: { x: 50, y: 50 },
                                },
                            ],
                        }
                    );
                });
            },
            l = (S) => {
                const T = {
                    ...S,
                    id: `${S.type}-${Date.now()}-${Math.floor(Math.random() * 1e3)}`,
                };
                n((M) => ({ ...M, elements: [...M.elements, T] })),
                    S.type === 'image' && console.log('Image added:', T);
            },
            c = (S, T) => {
                n((M) => ({
                    ...M,
                    elements: M.elements.map((w) =>
                        w.id === S ? { ...w, ...T } : w
                    ),
                }));
            },
            d = (S) => {
                n((T) => ({
                    ...T,
                    elements: T.elements.filter((M) => M.id !== S),
                }));
            },
            p = (S) => {
                n((T) => ({ ...T, background: S }));
            },
            g = (S) => {
                n((T) => ({ ...T, music: S }));
            },
            y = (S, T) => {
                n((M) => ({
                    ...M,
                    elements: M.elements.map((w) =>
                        w.id === S ? { ...w, position: T } : w
                    ),
                }));
            },
            v = () => {
                n(e);
            };
        return rt.jsx(nL.Provider, {
            value: {
                farewellPage: t,
                setTone: a,
                addElement: l,
                updateElement: c,
                removeElement: d,
                setBackground: p,
                setMusic: g,
                moveElement: y,
                resetPage: v,
            },
            children: i,
        });
    },
    v8 = () => {
        const i = K.useContext(nL);
        if (!i)
            throw new Error(
                'useFarewell must be used within a FarewellProvider'
            );
        return i;
    },
    qW = OL.createRoot(document.getElementById('root'));
qW.render(
    rt.jsx(K.StrictMode, {
        children: rt.jsx(jW, {
            children: rt.jsx(HW, { children: rt.jsx(HG, {}) }),
        }),
    })
);
export {
    Mh as $,
    XA as A,
    v8 as B,
    DL as C,
    ZW as D,
    Fb as E,
    j as F,
    Pt as G,
    gn as H,
    st as I,
    as as J,
    ov as K,
    XC as L,
    Ab as M,
    my as N,
    mU as O,
    sO as P,
    Hr as Q,
    yU as R,
    GH as S,
    di as T,
    Lv as U,
    Ce as V,
    Ts as W,
    iG as X,
    Lo as Y,
    hH as Z,
    uo as _,
    rs as a,
    Vr as a0,
    vk as a1,
    hi as a2,
    sr as a3,
    hv as a4,
    n8 as a5,
    hP as a6,
    dH as a7,
    Qn as a8,
    GR as a9,
    s8 as aA,
    Ff as aB,
    ZS as aC,
    wv as aD,
    sw as aE,
    ub as aF,
    dc as aG,
    HS as aH,
    vt as aI,
    QW as aJ,
    E5 as aK,
    Bv as aL,
    r8 as aM,
    o8 as aN,
    e8 as aO,
    T5 as aP,
    t8 as aQ,
    V5 as aR,
    oO as aS,
    aO as aT,
    Pi as aU,
    Eh as aV,
    Pl as aW,
    Ms as aa,
    YS as ab,
    Qp as ac,
    Th as ad,
    lo as ae,
    lv as af,
    sb as ag,
    Bo as ah,
    Fa as ai,
    zl as aj,
    uv as ak,
    bS as al,
    RS as am,
    Oa as an,
    ao,
    ka as ap,
    Gr as aq,
    uw as ar,
    hO as as,
    ws as at,
    Pa as au,
    Ua as av,
    vp as aw,
    fH as ax,
    w5 as ay,
    ZR as az,
    Qy as b,
    $W as c,
    FC as d,
    zv as e,
    nO as f,
    k_ as g,
    HU as h,
    i8 as i,
    rt as j,
    p8 as k,
    BL as l,
    MN as m,
    L2 as n,
    B_ as o,
    lh as p,
    uS as q,
    K as r,
    eA as s,
    Xn as t,
    y8 as u,
    Il as v,
    AM as w,
    YW as x,
    g8 as y,
    m8 as z,
};
